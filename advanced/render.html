<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>tf.advanced.render API documentation</title>
<meta name="description" content="Render â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<link rel="preconnect" href="https://www.google.com">
<script async src="https://cse.google.com/cse.js?cx=017837193012385208679:pey8ky8gdqw"></script>
<style>
.gsc-control-cse {padding:0 !important;margin-top:1em}
body.gsc-overflow-hidden #sidebar {overflow: visible;}
</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.advanced.render</code></h1>
</header>
<section id="section-intro">
<h1 id="render">Render</h1>
<p>Rendering is the process of generating HTML for a node, taking into account
display options (<code><a title="tf.advanced.options" href="options.html">tf.advanced.options</a></code>) and app settings (<code><a title="tf.advanced.settings" href="settings.html">tf.advanced.settings</a></code>).</p>
<p>It is organized as an <em>unravel</em> step (<code><a title="tf.advanced.unravel" href="unravel.html">tf.advanced.unravel</a></code>),
that generates a tree of node fragments
followed by an HTML generating step, that generates HTML for a tree in a recursive way.</p>
<p>The <em>unravel</em> step retrieves all relevant settings and options and stores them
in the tree in such a way that the essential information for rendering a subtree
is readily available at the top of that subtree.</p>
<h2 id="information-shielding">Information shielding</h2>
<p>The recursive render step does not have to consult the <code>app</code> object anymore,
because all information it needs from the <code>app</code> object is stored in the tree,
and all methods that need to be invoked on the <code>app</code> object are also accessible
directly from an attribute in the tree.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/916745547a850086a7d569a3b0c976b876f66a65/tf/advanced/render.py#L0-L493" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
.. include:: ../../docs/advanced/render.md
&#34;&#34;&#34;

from .helpers import htmlSafe, NB, dh
from .unravel import _unravel
from ..core.helpers import htmlEsc, flattenToSet


def render(app, isPretty, n, _inTuple, _asString, explain, **options):
    &#34;&#34;&#34;Renders a node, in plain or pretty mode.
    &#34;&#34;&#34;

    display = app.display

    if not display.check(&#34;pretty&#34; if isPretty else &#34;plain&#34;, options):
        return &#34;&#34;

    _browse = app._browse

    dContext = display.distill(options)
    if isPretty:
        tupleFeatures = dContext.tupleFeatures
        extraFeatures = dContext.extraFeatures

        dContext.set(
            &#34;features&#34;,
            sorted(flattenToSet(extraFeatures[0]) | flattenToSet(tupleFeatures)),
        )
        dContext.set(&#34;featuresIndirect&#34;, extraFeatures[1])

    tree = _unravel(app, isPretty, dContext, n, _inTuple=_inTuple, explain=explain)
    (chunk, info, subTrees) = tree
    settings = info.settings

    passage = _getPassage(isPretty, info, n)

    html = []

    for subTree in subTrees:
        _render(isPretty, subTree, True, True, 0, passage, html)

    rep = &#34;&#34;.join(html)
    ltr = settings.ltr

    elem = &#34;span&#34; if _inTuple else &#34;div&#34;
    ubd = &#34; ubd&#34; if _inTuple else &#34;&#34;
    result = (
        f&#34;&#34;&#34;{passage}&lt;{elem} class=&#34;{ltr} children&#34;&gt;{rep}&lt;/{elem}&gt;&#34;&#34;&#34;
        if isPretty
        else f&#34;&#34;&#34;&lt;{elem} class=&#34;{ltr}{ubd}&#34;&gt;{passage}{rep}&lt;/{elem}&gt;&#34;&#34;&#34;
    )

    if _browse or _asString:
        return result
    dh(result)


def _render(
    isPretty, tree, first, last, level, passage, html, switched=False, _asString=False
):
    outer = level == 0
    (chunk, info, children) = tree
    (n, (b, e)) = chunk
    settings = info.settings
    props = info.props
    boundaryCls = info.boundaryCls

    ltr = settings.ltr
    isBaseNonSlot = props.isBaseNonSlot
    plainCustom = props.plainCustom

    if isPretty:
        nodePlain = None
        if isBaseNonSlot:
            nodePlain = _render(
                False, tree, first, last, level, &#34;&#34;, [], switched=True, _asString=True
            )
        (label, featurePart) = _prettyTree(tree, outer, first, last, level, nodePlain)
        (containerB, containerE) = _prettyPre(
            tree, outer, label, featurePart, boundaryCls, html,
        )
        cls = props.cls
        childCls = cls[&#34;children&#34;]

        if children and not isBaseNonSlot:
            html.append(f&#39;&lt;div class=&#34;{childCls} {ltr}&#34;&gt;&#39;)
            after = props.after
    else:
        (contribB, contribE) = _plainPre(info, n, boundaryCls, outer, switched)
        contrib = _plainTree(tree, outer, first, last, level, boundaryCls, passage)
        if contribB:
            html.append(contribB)
        if contrib:
            html.append(contrib)

    lastCh = len(children) - 1

    if not ((isPretty and isBaseNonSlot) or (not isPretty and plainCustom)):
        for (i, subTree) in enumerate(children):
            thisFirst = first and i == 0
            thisLast = last and i == lastCh
            _render(isPretty, subTree, thisFirst, thisLast, level + 1, &#34;&#34;, html)
            if isPretty and after:
                html.append(after(subTree[0][0]))

    if isPretty:
        if children and not isBaseNonSlot:
            html.append(&#34;&lt;/div&gt;&#34;)
        _prettyPost(label, featurePart, html, containerB, containerE)
    else:
        _plainPost(contribE, html)

    return &#34;&#34;.join(html) if outer or _asString else None


# PLAIN LOW-LEVEL


def _plainPre(info, n, boundaryCls, outer, switched):
    isPretty = False
    options = info.options
    plainGaps = options.plainGaps

    settings = info.settings
    ltr = settings.ltr

    props = info.props
    hlCls = props.hlCls[isPretty]
    hlStyle = props.hlStyle[isPretty]

    nodePart = _getNodePart(False, info, n, outer, switched)

    boundary = boundaryCls if plainGaps else &#34;&#34;
    theHlCls = &#34;&#34; if switched else hlCls
    theHlStyle = &#34;&#34; if switched else hlStyle
    if boundary in {&#34;r&#34;, &#34;l&#34;} or theHlCls or theHlStyle or nodePart or switched:
        clses = f&#34;plain {ltr} {boundary} {theHlCls}&#34;
        contribB = f&#39;&lt;span class=&#34;{clses}&#34; {theHlStyle}&gt;&#39;
        contribE = &#34;&lt;/span&gt;&#34;
    else:
        contribB = &#34;&#34;
        contribE = &#34;&#34;
    if nodePart:
        contribB += nodePart
    return (contribB, contribE)


def _plainPost(contribE, html):
    if contribE:
        html.append(contribE)


def _plainTree(
    tree, outer, first, last, level, boundaryCls, passage,
):
    (chunk, info, subTrees) = tree

    options = info.options
    isHtml = options.isHtml
    fmt = options.fmt
    showGraphics = options.showGraphics

    settings = info.settings
    textMethod = settings.textMethod
    ltr = settings.ltr
    getText = settings.getText
    getGraphics = settings.getGraphics

    props = info.props
    hasGraphics = props.hasGraphics
    textCls = props.textCls
    nType = props.nType
    isSlotOrDescend = props.isSlotOrDescend
    descend = props.descend
    plainCustom = props.plainCustom

    chunk = tree[0]
    n = chunk[0]

    graphics = (
        getGraphics(False, n, nType, outer) if showGraphics and hasGraphics else &#34;&#34;
    )
    contrib = &#34;&#34;

    if plainCustom is not None:
        contrib = plainCustom(options, chunk, nType, outer)
        return contrib + graphics

    if isSlotOrDescend:
        text = textMethod(
            n,
            fmt=fmt,
            descend=descend,
            outer=outer,
            first=first,
            last=last,
            level=level,
        )
        if text:
            contrib = f&#39;&lt;span class=&#34;{textCls}&#34;&gt;{htmlSafe(text, isHtml)}&lt;/span&gt;&#39;
    else:
        tplFilled = getText(
            False,
            n,
            nType,
            outer,
            first,
            last,
            level,
            passage if outer else &#34;&#34;,
            descend,
            options=options,
        )
        if tplFilled:
            contrib = f&#39;&lt;span class=&#34;{textCls} {ltr}&#34;&gt;{tplFilled}&lt;/span&gt;&#39;

    return contrib + graphics


# PRETTY LOW-LEVEL


def _prettyPre(tree, outer, label, featurePart, boundaryCls, html):
    isPretty = True
    (chunk, info, subTrees) = tree
    n = chunk[0]

    options = info.options
    showGraphics = options.showGraphics

    settings = info.settings
    getGraphics = settings.getGraphics
    ltr = settings.ltr

    props = info.props
    hasGraphics = props.hasGraphics
    nType = props.nType
    cls = props.cls
    isBaseNonSlot = props.isBaseNonSlot
    hlCls = props.hlCls[isPretty]
    hlStyle = props.hlStyle[isPretty]

    contCls = cls[&#34;container&#34;]
    label0 = label.get(&#34;&#34;, None)
    labelB = label.get(&#34;b&#34;, None)

    n = tree[0][0]

    containerB = f&#39;&lt;div class=&#34;{contCls} {{}} {ltr} {boundaryCls} {hlCls}&#34; {hlStyle}&gt;&#39;
    containerE = &#34;&lt;/div&gt;&#34;

    terminalCls = &#34;trm&#34;
    material = featurePart
    if labelB is not None:
        trm = terminalCls
        html.append(f&#34;{containerB.format(trm)}{labelB}{material}{containerE}&#34;)
    if label0 is not None:
        trm = terminalCls if isBaseNonSlot or not subTrees else &#34;&#34;
        html.append(f&#34;{containerB.format(trm)}{label0}{material}&#34;)

    if showGraphics and hasGraphics:
        html.append(getGraphics(True, n, nType, outer))

    return (containerB, containerE)


def _prettyPost(label, featurePart, html, containerB, containerE):
    label0 = label.get(&#34;&#34;, None)
    labelE = label.get(&#34;e&#34;, None)

    if label0 is not None:
        html.append(containerE)
    if labelE is not None:
        html.append(f&#34;{containerB}{labelE} {featurePart}{containerE}&#34;)


def _prettyTree(tree, outer, first, last, level, nodePlain):
    isPretty = True
    (chunk, info, subTrees) = tree
    n = chunk[0]

    options = info.options

    settings = info.settings
    upMethod = settings.upMethod
    slotsMethod = settings.slotsMethod
    webLink = settings.webLink
    getText = settings.getText

    props = info.props
    nType = props.nType
    cls = props.cls
    hlCls = props.hlCls[isPretty]
    hlStyle = props.hlStyle[isPretty]
    descend = props.descend
    isBaseNonSlot = props.isBaseNonSlot
    isLexType = props.isLexType
    lexType = props.lexType
    textCls = props.textCls

    nodePart = _getNodePart(True, info, n, outer, False)
    labelHlCls = hlCls
    labelHlStyle = hlStyle

    if isBaseNonSlot:
        heading = nodePlain
    else:
        heading = getText(
            True, n, nType, outer, first, last, level, &#34;&#34;, descend, options=options
        )

    heading = f&#39;&lt;span class=&#34;{textCls}&#34;&gt;{heading}&lt;/span&gt;&#39; if heading else &#34;&#34;

    featurePart = _getFeatures(info, n, nType)

    if isLexType:
        slots = slotsMethod(n)
        extremeOccs = (slots[0],) if len(slots) == 1 else (slots[0], slots[-1])
        linkOccs = &#34; - &#34;.join(webLink(lo, _asString=True) for lo in extremeOccs)
        featurePart += f&#39;&lt;div class=&#34;occs&#34;&gt;{linkOccs}&lt;/div&gt;&#39;
    if lexType:
        lx = upMethod(n, otype=lexType)
        if lx:
            heading = webLink(lx[0], heading, _asString=True)

    label = {}
    for x in (&#34;&#34;, &#34;b&#34;, &#34;e&#34;):
        key = f&#34;label{x}&#34;
        if key in cls:
            val = cls[key]
            terminalCls = &#34;trm&#34; if x or isBaseNonSlot or not subTrees else &#34;&#34;
            sep = &#34; &#34; if nodePart and heading else &#34;&#34;
            material = f&#34;{nodePart}{sep}{heading}&#34; if nodePart or heading else &#34;&#34;
            label[x] = (
                f&#39;&lt;div class=&#34;{val} {terminalCls} {labelHlCls}&#34; {labelHlStyle}&gt;&#39;
                f&#34;{material}&lt;/div&gt;&#34;
                if material
                else &#34;&#34;
            )

    return (label, featurePart)


def _getPassage(isPretty, info, n):
    options = info.options
    withPassage = options.withPassage

    settings = info.settings
    webLink = settings.webLink

    if not withPassage:
        return &#34;&#34;

    ltr = settings.ltr

    passage = webLink(n, _asString=True)
    wrap = &#34;div&#34; if isPretty else &#34;span&#34;
    sep = &#34;&#34; if isPretty else NB * 2
    return f&#39;&lt;{wrap} class=&#34;tfsechead {ltr}&#34;&gt;{passage}&lt;/{wrap}&gt;{sep}&#39;


def _getNodePart(isPretty, info, n, outer, switched):
    options = info.options
    withNodes = options.withNodes and not switched
    withTypes = options.withTypes and not switched
    prettyTypes = options.prettyTypes and not switched
    lineNumbers = options.lineNumbers and not switched

    settings = info.settings
    browsing = settings.browsing
    lookupMethod = settings.lookupMethod

    props = info.props
    nType = props.nType
    isSlot = props.isSlot
    hlCls = props.hlCls[isPretty]
    lineNumberFeature = props.lineNumberFeature

    allowInfo = isPretty or (outer and not switched) or hlCls != &#34;&#34;

    num = &#34;&#34;
    if withNodes and allowInfo:
        num = n

    ntp = &#34;&#34;
    if (withTypes or isPretty and prettyTypes) and not isSlot and allowInfo:
        ntp = nType

    line = &#34;&#34;
    if lineNumbers and allowInfo:
        if lineNumberFeature:
            line = lookupMethod(lineNumberFeature).v(n)
        if line:
            line = f&#34;@{line}&#34; if line else &#34;&#34;

    elemb = &#39;a href=&#34;#&#34;&#39; if browsing else &#34;span&#34;
    eleme = &#34;a&#34; if browsing else &#34;span&#34;
    sep = &#34;:&#34; if ntp and num else &#34;&#34;

    return (
        f&#39;&lt;{elemb} class=&#34;nd&#34;&gt;{ntp}{sep}{num}{line}&lt;/{eleme}&gt;&#39;
        if ntp or num or line
        else &#34;&#34;
    )


def _getFeatures(info, n, nType):
    &#34;&#34;&#34;Feature fetcher.

    Helper for `pretty` that wraps the requested features and their values for
    *node* in HTML for pretty display.
    &#34;&#34;&#34;

    options = info.options
    dFeatures = options.features
    dFeaturesIndirect = options.featuresIndirect
    queryFeatures = options.queryFeatures
    standardFeatures = options.standardFeatures
    suppress = options.suppress
    noneValues = options.noneValues

    settings = info.settings
    upMethod = settings.upMethod
    lookupMethod = settings.lookupMethod

    props = info.props
    (features, indirect) = props.features
    (featuresBare, indirectBare) = props.featuresBare

    # a feature can be nType:feature
    # do a upMethod(n, otype=nType)[0] and take the feature from there

    givenFeatureSet = set(features) | set(featuresBare)
    xFeatures = tuple(
        f for f in dFeatures if not standardFeatures or f not in givenFeatureSet
    )
    featureList = tuple(featuresBare + features) + xFeatures
    bFeatures = len(featuresBare)
    nbFeatures = len(featuresBare) + len(features)

    featurePart = &#34;&#34;

    if standardFeatures or queryFeatures:
        for (i, name) in enumerate(featureList):
            if name not in suppress:
                fsName = lookupMethod(name)
                if fsName is None:
                    continue
                fsNamev = fsName.v

                value = None
                if (
                    name in dFeaturesIndirect
                    or name in indirectBare
                    or name in indirect
                ):
                    refType = (
                        dFeaturesIndirect[name]
                        if name in dFeaturesIndirect
                        else indirectBare[name]
                        if name in indirectBare
                        else indirect[name]
                    )
                    refNode = upMethod(n, otype=refType)
                    refNode = refNode[0] if refNode else None
                else:
                    refNode = n
                if refNode is not None:
                    value = fsNamev(refNode)

                value = None if value in noneValues else htmlEsc(value or &#34;&#34;)
                if value is not None:
                    value = value.replace(&#34;\n&#34;, &#34;&lt;br/&gt;&#34;)
                    isBare = i &lt; bFeatures
                    isExtra = i &gt;= nbFeatures
                    if (
                        isExtra
                        and not queryFeatures
                        or not isExtra
                        and not standardFeatures
                    ):
                        continue
                    nameRep = &#34;&#34; if isBare else f&#39;&lt;span class=&#34;f&#34;&gt;{name}=&lt;/span&gt;&#39;
                    titleRep = f&#39;title=&#34;{name}&#34;&#39; if isBare else &#34;&#34;
                    xCls = &#34;xft&#34; if isExtra else &#34;&#34;
                    featurePart += (
                        f&#39;&lt;span class=&#34;{name.lower()} {xCls}&#34; {titleRep}&gt;&#39;
                        f&#34;{nameRep}{value}&lt;/span&gt;&#34;
                    )
    if not featurePart:
        return &#34;&#34;

    return f&#34;&lt;div class=&#39;features&#39;&gt;{featurePart}&lt;/div&gt;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.advanced.render.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>app, isPretty, n, _inTuple, _asString, explain, **options)</span>
</code></dt>
<dd>
<div class="desc"><p>Renders a node, in plain or pretty mode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/916745547a850086a7d569a3b0c976b876f66a65/tf/advanced/render.py#L10-L56" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def render(app, isPretty, n, _inTuple, _asString, explain, **options):
    &#34;&#34;&#34;Renders a node, in plain or pretty mode.
    &#34;&#34;&#34;

    display = app.display

    if not display.check(&#34;pretty&#34; if isPretty else &#34;plain&#34;, options):
        return &#34;&#34;

    _browse = app._browse

    dContext = display.distill(options)
    if isPretty:
        tupleFeatures = dContext.tupleFeatures
        extraFeatures = dContext.extraFeatures

        dContext.set(
            &#34;features&#34;,
            sorted(flattenToSet(extraFeatures[0]) | flattenToSet(tupleFeatures)),
        )
        dContext.set(&#34;featuresIndirect&#34;, extraFeatures[1])

    tree = _unravel(app, isPretty, dContext, n, _inTuple=_inTuple, explain=explain)
    (chunk, info, subTrees) = tree
    settings = info.settings

    passage = _getPassage(isPretty, info, n)

    html = []

    for subTree in subTrees:
        _render(isPretty, subTree, True, True, 0, passage, html)

    rep = &#34;&#34;.join(html)
    ltr = settings.ltr

    elem = &#34;span&#34; if _inTuple else &#34;div&#34;
    ubd = &#34; ubd&#34; if _inTuple else &#34;&#34;
    result = (
        f&#34;&#34;&#34;{passage}&lt;{elem} class=&#34;{ltr} children&#34;&gt;{rep}&lt;/{elem}&gt;&#34;&#34;&#34;
        if isPretty
        else f&#34;&#34;&#34;&lt;{elem} class=&#34;{ltr}{ubd}&#34;&gt;{passage}{rep}&lt;/{elem}&gt;&#34;&#34;&#34;
    )

    if _browse or _asString:
        return result
    dh(result)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="/tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="/tf/index.html">tf home</a> -
<a href="/tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="/tf/images/GitHub_Logo.png" alt="GitHub"></a></p>
</p>
<div class="gcse-search" style="height: 70px"
data-as_oq="inurl:github.com/annotation site:annotation.github.io"
data-gaCategoryParameter="tf.advanced.render">
</div>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#render">Render</a><ul>
<li><a href="#information-shielding">Information shielding</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.advanced" href="index.html">tf.advanced</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tf.advanced.render.render" href="#tf.advanced.render.render">render</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://www.dans.knaw.nl"><img alt="DANS" src="/tf/images/DANS-logo.png" width="200" alt="DANS"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>