<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>tf.core.prepare API documentation</title>
<meta name="description" content="Functions that precompute data â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.core.prepare</code></h1>
</header>
<section id="section-intro">
<p>Functions that precompute data.</p>
<p>For Text-Fabric to work efficiently, some
derived data needs to be precomputed.
The precomputed data has a similar function as indexes in a database.</p>
<p>Precomputation is triggered when <a title="tf.fabric.Fabric" href="../fabric.html#tf.fabric.Fabric"><code>Fabric</code></a> loads features, and
the order and nature of the steps is configured in
<a title="tf.fabric.PRECOMPUTE" href="../fabric.html#tf.fabric.PRECOMPUTE"><code>PRECOMPUTE</code></a>.</p>
<p>The functions in this module implement those tasks.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Functions that precompute data.

For Text-Fabric to work efficiently, some  derived data needs to be precomputed.
The precomputed data has a similar function as indexes in a database.

Precomputation is triggered when `tf.fabric.Fabric` loads features, and
the order and nature of the steps is configured in
`tf.fabric.PRECOMPUTE`.

The functions in this module implement those tasks.
&#34;&#34;&#34;

from array import array
import collections
import functools
from .helpers import itemize


def levels(info, error, otype, oslots, otext):
    &#34;&#34;&#34;Computes level data.

    For each node type, compute the average number of slots occupied by its nodes,
    and order the node types on that.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    oslots: iterable
        The data of the *oslots* feature.
    otext: iterable
        The data of the *otext* feature.

    Returns
    -------
    tuple
        An ordered tuple, each member with the information of a node type:

        *   node type name
        *   average number of slots contained in the nodes of this type
        *   first node of this type
        *   last node of this type
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    levelOrder = otext.get(&#34;levels&#34;, None)
    if levelOrder is not None:
        levelRank = {level: i for (i, level) in enumerate(levelOrder.split(&#34;,&#34;))}
    otypeCount = collections.Counter()
    otypeMin = {}
    otypeMax = {}
    slotSetLengths = collections.Counter()
    info(&#34;get ranking of otypes&#34;)
    for k in range(len(oslots)):
        ntp = otype[k]
        otypeCount[ntp] += 1
        slotSetLengths[ntp] += len(oslots[k])
        tfn = k + maxSlot + 1
        if ntp not in otypeMin:
            otypeMin[ntp] = tfn
        if ntp not in otypeMax or otypeMax[ntp] &lt; tfn:
            otypeMax[ntp] = tfn
    sortKey = (lambda x: -x[1]) if levelOrder is None else (lambda x: levelRank[x[0]])
    result = tuple(
        sorted(
            (
                (
                    ntp,
                    slotSetLengths[ntp] / otypeCount[ntp],
                    otypeMin[ntp],
                    otypeMax[ntp],
                )
                for ntp in otypeCount
            ),
            key=sortKey,
        )
        + [(slotType, 1, 1, maxSlot)]
    )
    info(&#34;results:&#34;)
    for (otp, av, omin, omax) in result:
        info(f&#34;{otp:&lt;15}: {round(av, 2):&gt;8} {{{omin}-{omax}}}&#34;, tm=False)
    return result


def order(info, error, otype, oslots, levels):
    &#34;&#34;&#34;Computes order data.

    The canonical ordering between nodes is defined in terms of the slots that
    nodes contain.

    A node *A*  comes before a node *B* if, *A* contains the smallest slot
    that occurs in only one of *A* and *B*.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    oslots: iterable
        The data of the *oslots* feature.
    levels: tuple
        The data of the *levels* precompute step.

    Returns
    -------
    array
        All nodes, slot and nonslot, in canonical order.

    We store the result in an array because it saves a lot of memory, and access
    is still fast.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    info(&#34;assigning otype levels to nodes&#34;)
    otypeLevels = dict(((x[0], i) for (i, x) in enumerate(levels)))

    def otypeRank(n):
        return otypeLevels[slotType if n &lt; maxSlot + 1 else otype[n - maxSlot - 1]]

    def before(na, nb):
        if na &lt; maxSlot + 1:
            a = na
            sa = {a}
        else:
            a = na - maxSlot
            sa = set(oslots[a - 1])
        if nb &lt; maxSlot + 1:
            b = nb
            sb = {b}
        else:
            b = nb - maxSlot
            sb = set(oslots[b - 1])
        oa = otypeRank(na)
        ob = otypeRank(nb)
        if sa == sb:
            return 0 if oa == ob else -1 if oa &lt; ob else 1
        if sa &gt; sb:
            return -1
        if sa &lt; sb:
            return 1
        am = min(sa - sb)
        bm = min(sb - sa)
        return -1 if am &lt; bm else 1 if bm &lt; am else None

    canonKey = functools.cmp_to_key(before)
    info(&#34;sorting nodes&#34;)
    nodes = sorted(range(1, maxNode + 1), key=canonKey)
    return array(&#34;I&#34;, nodes)


def rank(info, error, otype, order):
    &#34;&#34;&#34;Computes rank data.

    The rank of a node is its place in among the other nodes in the
    canonical ordering (see `order`).

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    order: array
        The data of the *order* feature.

    Returns
    -------
    array
        The ranks of all nodes, slot and nonslot, with respect to the canonical order.

    We store the result in an array because it saves a lot of memory, and access
    is still fast.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    info(&#34;ranking nodes&#34;)
    nodesRank = dict(((n, i) for (i, n) in enumerate(order)))
    return array(&#34;I&#34;, (nodesRank[n] for n in range(1, maxNode + 1)))


def levUp(info, error, otype, oslots, rank):
    &#34;&#34;&#34;Computes level-up data.

    Level-up data is used by the API function `tf.core.locality.Locality.u`.

    This function computes the embedders of a node by looking them up from
    the level-up data.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    oslots: iterable
        The data of the *oslots* feature.
    rank: array
        The data of the *rank* precompute step.

    Returns
    -------
    tuple
        The n-th member is an array of the embedder nodes of n.
        Those arrays are sorted in canonical ordering.

    !!! hint &#34;Memory efficiency&#34;
        Many nodes have the same array of embedders.
        Those embedder arrays will be reused for those nodes.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    info(&#34;making inverse of edge feature oslots&#34;)
    oslotsInv = {}
    for (k, mList) in enumerate(oslots):
        for m in mList:
            oslotsInv.setdefault(m, set()).add(k + 1 + maxSlot)
    info(&#34;listing embedders of all nodes&#34;)
    embedders = []
    for n in range(1, maxSlot + 1):
        contentEmbedders = oslotsInv[n]
        embedders.append(
            tuple(
                sorted(
                    [m for m in contentEmbedders if m != n], key=lambda k: -rank[k - 1],
                )
            )
        )
    for n in range(maxSlot + 1, maxNode + 1):
        mList = oslots[n - maxSlot - 1]
        if len(mList) == 0:
            embedders.append(tuple())
        else:
            contentEmbedders = functools.reduce(
                lambda x, y: x &amp; oslotsInv[y], mList[1:], oslotsInv[mList[0]],
            )
            embedders.append(
                tuple(
                    sorted(
                        [m for m in contentEmbedders if m != n],
                        key=lambda k: -rank[k - 1],
                    )
                )
            )
    # reuse embedder tuples, because lots of nodes share embedders
    seen = {}
    embeddersx = []
    for t in embedders:
        if t not in seen:
            seen[t] = array(&#34;I&#34;, t)
        embeddersx.append(seen[t])
    return tuple(embeddersx)


def levDown(info, error, otype, levUp, rank):
    &#34;&#34;&#34;Computes level-down data.

    Level-down data is used by the API function `tf.core.locality.Locality.d`.

    This function computes the embedded nodes of a node by looking them up from
    the level-down data.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    levUp: iterable
        The data of the *levUp* precompute step.
    rank: array
        The data of the *rank* precompute step.

    Returns
    -------
    tuple
        The *n*-th member is an array of the embedded nodes of *n + maxSlot*.
        Those arrays are sorted in canonical ordering.

    !!! hint &#34;Memory efficiency&#34;
        Slot nodes do not have embedded nodes, so they do not have to occupy
        space in this tuple. Hence the first member are the embedded nodes
        of node *maxSlot + 1*.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    info(&#34;inverting embedders&#34;)
    inverse = {}
    for n in range(maxSlot + 1, maxNode + 1):
        for m in levUp[n - 1]:
            inverse.setdefault(m, set()).add(n)
    info(&#34;turning embeddees into list&#34;)
    embeddees = []
    for n in range(maxSlot + 1, maxNode + 1):
        embeddees.append(
            array(&#34;I&#34;, sorted(inverse.get(n, []), key=lambda m: rank[m - 1],))
        )
    return tuple(embeddees)


def boundary(info, error, otype, oslots, rank):
    &#34;&#34;&#34;Computes boundary data.

    For each slot, the nodes that start at that slot and the nodes that end
    at that slot are collected.

    Boundary data is used by the API functions
    `tf.core.locality.Locality.p`.
    and
    `tf.core.locality.Locality.n`.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    oslots: iterable
        The data of the *oslots* feature.
    rank: array
        The data of the *rank* precompute step.

    Returns
    -------
    tuple
        *   first: tuple of array
            The *n*-th member is the array of nodes that start at slot *n*,
            ordered in *reversed* canonical ordering;
        *   last: tuple of array
            The *n*-th member is the array of nodes that end at slot *n*,
            ordered in canonical ordering;

    !!! hint &#34;why  reversed canonical ordering&#34;
        Just for symmetry.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    firstSlotsD = {}
    lastSlotsD = {}
    for (k, mList) in enumerate(oslots):
        firstSlotsD.setdefault(mList[0], []).append(k + 1 + maxSlot)
        lastSlotsD.setdefault(mList[-1], []).append(k + 1 + maxSlot)
    firstSlots = []
    lastSlots = []
    for n in range(1, maxSlot + 1):
        firstSlots.append(
            array(&#34;I&#34;, sorted(firstSlotsD.get(n, []), key=lambda k: -rank[k - 1]))
        )
        lastSlots.append(
            array(&#34;I&#34;, sorted(lastSlotsD.get(n, []), key=lambda k: rank[k - 1]))
        )
    return (tuple(firstSlots), tuple(lastSlots))


def sections(info, error, otype, oslots, otext, levUp, levels, *sFeats):
    &#34;&#34;&#34;Computes section data.

    Text-Fabric datasets may define up to three section levels, roughly corresponding
    with a volume, a chapter, a paragraph.

    If the corpus has a richer section structure, it is also possible
    a different, more flexible and more extensive nest of structural sections.
    See `structure`.

    Text-Fabric must be able to go from sections at one level to the sections
    at one level lower. It must also be able to map section headings
    to nodes. For this, the section features are needed, since they
    contain the section headings.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    oslots: iterable
        The data of the *oslots* feature.
    otext: iterable
        The data of the *otext* feature.
    levUp: array
        The data of the *levUp* precompute step.
    levels: array
        The data of the *levels* precompute step.
    sFeats: iterable
        The names of section features.

    Returns
    -------
    tuple
        *   sec1
            Mapping from section-level-1 nodes to mappings from
            section-level-2 headings to section-level2 nodes.
        *   sec2
            Mapping from section-level-1 nodes to mappings from
            section-level-2 headings to mappings from
            section-level3 headings to section-level-3 nodes.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    support = dict(((o[0], (o[2], o[3])) for o in levels))
    sTypes = itemize(otext[&#34;sectionTypes&#34;], &#34;,&#34;)
    sec1 = {}
    sec2 = {}
    nestingProblems = collections.Counter()

    if len(sTypes) &lt; 2:
        pass

    elif len(sTypes) &lt; 3:
        c1 = 0
        support1 = support[sTypes[1]]
        for n1 in range(support1[0], support1[1] + 1):
            n0s = tuple(x for x in levUp[n1 - 1] if otype[x - maxSlot - 1] == sTypes[0])
            if not n0s:
                nestingProblems[
                    f&#34;section {sTypes[1]} without containing {sTypes[0]}&#34;
                ] += 1
                continue
            n0 = n0s[0]
            n1s = sFeats[1][n1]
            if n0 not in sec1:
                sec1[n0] = {}
            if n1s not in sec1[n0]:
                sec1[n0][n1s] = n1
                c1 += 1
        info(f&#34;{c1} {sTypes[1]}s indexed&#34;)

    else:
        c1 = 0
        c2 = 0
        support2 = support[sTypes[2]]
        for n2 in range(support2[0], support2[1] + 1):
            n0s = tuple(x for x in levUp[n2 - 1] if otype[x - maxSlot - 1] == sTypes[0])
            if not n0s:
                nestingProblems[
                    f&#34;section {sTypes[2]} without containing {sTypes[0]}&#34;
                ] += 1
                continue
            n0 = n0s[0]
            n1s = tuple(x for x in levUp[n2 - 1] if otype[x - maxSlot - 1] == sTypes[1])
            if not n1s:
                nestingProblems[
                    f&#34;section {sTypes[2]} without containing {sTypes[1]}&#34;
                ] += 1
                continue
            n1 = n1s[0]
            n1s = sFeats[1][n1]
            n2s = sFeats[2][n2]
            if n0 not in sec1:
                sec1[n0] = {}
            if n1s not in sec1[n0]:
                sec1[n0][n1s] = n1
                c1 += 1
            sec2.setdefault(n0, {}).setdefault(n1s, {})[n2s] = n2
            c2 += 1
        info(f&#34;{c1} {sTypes[1]}s and {c2} {sTypes[2]}s indexed&#34;)

    if nestingProblems:
        for (msg, amount) in sorted(nestingProblems.items()):
            error(f&#34;WARNING: {amount:&gt;4} x {msg}&#34;)

    return (sec1, sec2)


def structure(info, error, otype, oslots, otext, rank, levUp, *sFeats):
    &#34;&#34;&#34;Computes structure data.

    If the corpus has a rich section structure, it is possible to define
    a flexible and extensive nest of structural sections.

    Independent of this,
    Text-Fabric datasets may also define up to three section levels,
    roughly corresponding with a volume, a chapter, a paragraph.
    See `sections`.

    Text-Fabric must be able to go from sections at one level to the sections
    at one level lower. It must also be able to map section headings
    to nodes. For this, the section features are needed, since they
    contain the section headings.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    oslots: iterable
        The data of the *oslots* feature.
    otext: iterable
        The data of the *otext* feature.
    rank: array
        The data of the *rank* precompute step.
    levUp: array
        The data of the *levUp* precompute step.
    sFeats: iterable
        The names of structural features.

    Returns
    -------
    tuple
        *   headingFromNode
            Mapping from section keys to nodes
        *   nodeFromHeading
            Mapping from nodes to section keys
        *   multiple
        *   top
        *   up
        *   down

    A section key of a structural node is obtained by going a level up from
    that node, retrieving the heading of that structural node, then going up again,
    and so on till a top node is reached. The tuple of headings obtained in this way
    is the  section key.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    sTypeList = itemize(otext[&#34;structureTypes&#34;], &#34;,&#34;)
    nsTypes = len(sTypeList)
    nsFeats = len(sFeats)

    if nsTypes != nsFeats:
        error(
            f&#34;WARNING: {nsTypes} structure levels but {nsFeats} corresponding features&#34;
        )
        return ({}, {})

    sTypes = set(sTypeList)
    if len(sTypes) != nsTypes:
        error(f&#34;WARNING: duplicate structure levels&#34;)
        return ({}, {})

    higherTypes = collections.defaultdict(set)
    for (i, highType) in enumerate(sTypeList):
        for lowType in sTypeList[i:]:
            higherTypes[lowType].add(highType)

    featFromType = {sTypeList[i]: sFeats[i] for i in range(nsTypes)}

    multiple = collections.defaultdict(list)
    headingFromNode = {}
    nodeFromHeading = {}

    for n in range(maxSlot + 1, maxNode + 1):
        nType = otype[n - maxSlot - 1]
        if nType not in sTypes:
            continue
        ups = (u for u in levUp[n - 1] if otype[u - maxSlot - 1] in higherTypes[nType])
        sKey = tuple(
            reversed(
                tuple(
                    (
                        otype[x - maxSlot - 1],
                        featFromType[otype[x - maxSlot - 1]].get(x, None),
                    )
                    for x in (n, *ups)
                )
            )
        )

        if sKey in nodeFromHeading:
            if sKey not in multiple:
                multiple[sKey].append(nodeFromHeading[sKey])
            multiple[sKey].append(n)
        nodeFromHeading[sKey] = n
        headingFromNode[n] = sKey
    multiple = {
        sKey: tuple(sorted(ns, key=lambda n: rank[n - 1],))
        for (sKey, ns) in multiple.items()
    }

    top = tuple(
        sorted(
            (n for (n, h) in headingFromNode.items() if len(h) == 1),
            key=lambda n: rank[n - 1],
        )
    )

    up = {}
    for (n, heading) in headingFromNode.items():
        lHeading = len(heading)
        if lHeading == 1:
            continue
        upNode = None
        for i in range(lHeading - 1, 0, -1):
            upHeading = heading[0:i]
            upNode = nodeFromHeading.get(upHeading, None)
            if upNode is not None:
                up[n] = upNode
                break

    down = {}
    for (n, heading) in headingFromNode.items():
        if len(heading) == 1:
            continue
        down.setdefault(up[n], []).append(n)

    down = {n: tuple(sorted(ms, key=lambda m: rank[m - 1])) for (n, ms) in down.items()}

    return (headingFromNode, nodeFromHeading, multiple, top, up, down)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.core.prepare.boundary"><code class="name flex">
<span>def <span class="ident">boundary</span></span>(<span>info, error, otype, oslots, rank)</span>
</code></dt>
<dd>
<section class="desc"><p>Computes boundary data.</p>
<p>For each slot, the nodes that start at that slot and the nodes that end
at that slot are collected.</p>
<p>Boundary data is used by the API functions
<a title="tf.core.locality.Locality.p" href="locality.html#tf.core.locality.Locality.p"><code>Locality.p()</code></a>.
and
<a title="tf.core.locality.Locality.n" href="locality.html#tf.core.locality.Locality.n"><code>Locality.n()</code></a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otype</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>otype</em> feature.</dd>
<dt><strong><code>oslots</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>oslots</em> feature.</dd>
<dt><strong><a title="tf.core.prepare.rank" href="#tf.core.prepare.rank"><code>rank()</code></a></strong> :&ensp;<code>array</code></dt>
<dd>The data of the <em>rank</em> precompute step.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>
<ul>
<li>first: tuple of array
The <em>n</em>-th member is the array of nodes that start at slot <em>n</em>,
ordered in <em>reversed</em> canonical ordering;</li>
<li>last: tuple of array
The <em>n</em>-th member is the array of nodes that end at slot <em>n</em>,
ordered in canonical ordering;</li>
</ul>
</dd>
</dl>
<div class="admonition hint">
<p class="admonition-title">why
reversed canonical ordering</p>
<p>Just for symmetry.</p>
</div></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def boundary(info, error, otype, oslots, rank):
    &#34;&#34;&#34;Computes boundary data.

    For each slot, the nodes that start at that slot and the nodes that end
    at that slot are collected.

    Boundary data is used by the API functions
    `tf.core.locality.Locality.p`.
    and
    `tf.core.locality.Locality.n`.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    oslots: iterable
        The data of the *oslots* feature.
    rank: array
        The data of the *rank* precompute step.

    Returns
    -------
    tuple
        *   first: tuple of array
            The *n*-th member is the array of nodes that start at slot *n*,
            ordered in *reversed* canonical ordering;
        *   last: tuple of array
            The *n*-th member is the array of nodes that end at slot *n*,
            ordered in canonical ordering;

    !!! hint &#34;why  reversed canonical ordering&#34;
        Just for symmetry.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    firstSlotsD = {}
    lastSlotsD = {}
    for (k, mList) in enumerate(oslots):
        firstSlotsD.setdefault(mList[0], []).append(k + 1 + maxSlot)
        lastSlotsD.setdefault(mList[-1], []).append(k + 1 + maxSlot)
    firstSlots = []
    lastSlots = []
    for n in range(1, maxSlot + 1):
        firstSlots.append(
            array(&#34;I&#34;, sorted(firstSlotsD.get(n, []), key=lambda k: -rank[k - 1]))
        )
        lastSlots.append(
            array(&#34;I&#34;, sorted(lastSlotsD.get(n, []), key=lambda k: rank[k - 1]))
        )
    return (tuple(firstSlots), tuple(lastSlots))</code></pre>
</details>
</dd>
<dt id="tf.core.prepare.levDown"><code class="name flex">
<span>def <span class="ident">levDown</span></span>(<span>info, error, otype, levUp, rank)</span>
</code></dt>
<dd>
<section class="desc"><p>Computes level-down data.</p>
<p>Level-down data is used by the API function <a title="tf.core.locality.Locality.d" href="locality.html#tf.core.locality.Locality.d"><code>Locality.d()</code></a>.</p>
<p>This function computes the embedded nodes of a node by looking them up from
the level-down data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otype</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>otype</em> feature.</dd>
<dt><strong><a title="tf.core.prepare.levUp" href="#tf.core.prepare.levUp"><code>levUp()</code></a></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>levUp</em> precompute step.</dd>
<dt><strong><a title="tf.core.prepare.rank" href="#tf.core.prepare.rank"><code>rank()</code></a></strong> :&ensp;<code>array</code></dt>
<dd>The data of the <em>rank</em> precompute step.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>The <em>n</em>-th member is an array of the embedded nodes of <em>n + maxSlot</em>.
Those arrays are sorted in canonical ordering.</dd>
</dl>
<div class="admonition hint">
<p class="admonition-title">Memory efficiency</p>
<p>Slot nodes do not have embedded nodes, so they do not have to occupy
space in this tuple. Hence the first member are the embedded nodes
of node <em>maxSlot + 1</em>.</p>
</div></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def levDown(info, error, otype, levUp, rank):
    &#34;&#34;&#34;Computes level-down data.

    Level-down data is used by the API function `tf.core.locality.Locality.d`.

    This function computes the embedded nodes of a node by looking them up from
    the level-down data.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    levUp: iterable
        The data of the *levUp* precompute step.
    rank: array
        The data of the *rank* precompute step.

    Returns
    -------
    tuple
        The *n*-th member is an array of the embedded nodes of *n + maxSlot*.
        Those arrays are sorted in canonical ordering.

    !!! hint &#34;Memory efficiency&#34;
        Slot nodes do not have embedded nodes, so they do not have to occupy
        space in this tuple. Hence the first member are the embedded nodes
        of node *maxSlot + 1*.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    info(&#34;inverting embedders&#34;)
    inverse = {}
    for n in range(maxSlot + 1, maxNode + 1):
        for m in levUp[n - 1]:
            inverse.setdefault(m, set()).add(n)
    info(&#34;turning embeddees into list&#34;)
    embeddees = []
    for n in range(maxSlot + 1, maxNode + 1):
        embeddees.append(
            array(&#34;I&#34;, sorted(inverse.get(n, []), key=lambda m: rank[m - 1],))
        )
    return tuple(embeddees)</code></pre>
</details>
</dd>
<dt id="tf.core.prepare.levUp"><code class="name flex">
<span>def <span class="ident">levUp</span></span>(<span>info, error, otype, oslots, rank)</span>
</code></dt>
<dd>
<section class="desc"><p>Computes level-up data.</p>
<p>Level-up data is used by the API function <a title="tf.core.locality.Locality.u" href="locality.html#tf.core.locality.Locality.u"><code>Locality.u()</code></a>.</p>
<p>This function computes the embedders of a node by looking them up from
the level-up data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otype</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>otype</em> feature.</dd>
<dt><strong><code>oslots</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>oslots</em> feature.</dd>
<dt><strong><a title="tf.core.prepare.rank" href="#tf.core.prepare.rank"><code>rank()</code></a></strong> :&ensp;<code>array</code></dt>
<dd>The data of the <em>rank</em> precompute step.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>The n-th member is an array of the embedder nodes of n.
Those arrays are sorted in canonical ordering.</dd>
</dl>
<div class="admonition hint">
<p class="admonition-title">Memory efficiency</p>
<p>Many nodes have the same array of embedders.
Those embedder arrays will be reused for those nodes.</p>
</div></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def levUp(info, error, otype, oslots, rank):
    &#34;&#34;&#34;Computes level-up data.

    Level-up data is used by the API function `tf.core.locality.Locality.u`.

    This function computes the embedders of a node by looking them up from
    the level-up data.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    oslots: iterable
        The data of the *oslots* feature.
    rank: array
        The data of the *rank* precompute step.

    Returns
    -------
    tuple
        The n-th member is an array of the embedder nodes of n.
        Those arrays are sorted in canonical ordering.

    !!! hint &#34;Memory efficiency&#34;
        Many nodes have the same array of embedders.
        Those embedder arrays will be reused for those nodes.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    info(&#34;making inverse of edge feature oslots&#34;)
    oslotsInv = {}
    for (k, mList) in enumerate(oslots):
        for m in mList:
            oslotsInv.setdefault(m, set()).add(k + 1 + maxSlot)
    info(&#34;listing embedders of all nodes&#34;)
    embedders = []
    for n in range(1, maxSlot + 1):
        contentEmbedders = oslotsInv[n]
        embedders.append(
            tuple(
                sorted(
                    [m for m in contentEmbedders if m != n], key=lambda k: -rank[k - 1],
                )
            )
        )
    for n in range(maxSlot + 1, maxNode + 1):
        mList = oslots[n - maxSlot - 1]
        if len(mList) == 0:
            embedders.append(tuple())
        else:
            contentEmbedders = functools.reduce(
                lambda x, y: x &amp; oslotsInv[y], mList[1:], oslotsInv[mList[0]],
            )
            embedders.append(
                tuple(
                    sorted(
                        [m for m in contentEmbedders if m != n],
                        key=lambda k: -rank[k - 1],
                    )
                )
            )
    # reuse embedder tuples, because lots of nodes share embedders
    seen = {}
    embeddersx = []
    for t in embedders:
        if t not in seen:
            seen[t] = array(&#34;I&#34;, t)
        embeddersx.append(seen[t])
    return tuple(embeddersx)</code></pre>
</details>
</dd>
<dt id="tf.core.prepare.levels"><code class="name flex">
<span>def <span class="ident">levels</span></span>(<span>info, error, otype, oslots, otext)</span>
</code></dt>
<dd>
<section class="desc"><p>Computes level data.</p>
<p>For each node type, compute the average number of slots occupied by its nodes,
and order the node types on that.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otype</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>otype</em> feature.</dd>
<dt><strong><code>oslots</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>oslots</em> feature.</dd>
<dt><strong><code>otext</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>otext</em> feature.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>
<p>An ordered tuple, each member with the information of a node type:</p>
<ul>
<li>node type name</li>
<li>average number of slots contained in the nodes of this type</li>
<li>first node of this type</li>
<li>last node of this type</li>
</ul>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def levels(info, error, otype, oslots, otext):
    &#34;&#34;&#34;Computes level data.

    For each node type, compute the average number of slots occupied by its nodes,
    and order the node types on that.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    oslots: iterable
        The data of the *oslots* feature.
    otext: iterable
        The data of the *otext* feature.

    Returns
    -------
    tuple
        An ordered tuple, each member with the information of a node type:

        *   node type name
        *   average number of slots contained in the nodes of this type
        *   first node of this type
        *   last node of this type
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    levelOrder = otext.get(&#34;levels&#34;, None)
    if levelOrder is not None:
        levelRank = {level: i for (i, level) in enumerate(levelOrder.split(&#34;,&#34;))}
    otypeCount = collections.Counter()
    otypeMin = {}
    otypeMax = {}
    slotSetLengths = collections.Counter()
    info(&#34;get ranking of otypes&#34;)
    for k in range(len(oslots)):
        ntp = otype[k]
        otypeCount[ntp] += 1
        slotSetLengths[ntp] += len(oslots[k])
        tfn = k + maxSlot + 1
        if ntp not in otypeMin:
            otypeMin[ntp] = tfn
        if ntp not in otypeMax or otypeMax[ntp] &lt; tfn:
            otypeMax[ntp] = tfn
    sortKey = (lambda x: -x[1]) if levelOrder is None else (lambda x: levelRank[x[0]])
    result = tuple(
        sorted(
            (
                (
                    ntp,
                    slotSetLengths[ntp] / otypeCount[ntp],
                    otypeMin[ntp],
                    otypeMax[ntp],
                )
                for ntp in otypeCount
            ),
            key=sortKey,
        )
        + [(slotType, 1, 1, maxSlot)]
    )
    info(&#34;results:&#34;)
    for (otp, av, omin, omax) in result:
        info(f&#34;{otp:&lt;15}: {round(av, 2):&gt;8} {{{omin}-{omax}}}&#34;, tm=False)
    return result</code></pre>
</details>
</dd>
<dt id="tf.core.prepare.order"><code class="name flex">
<span>def <span class="ident">order</span></span>(<span>info, error, otype, oslots, levels)</span>
</code></dt>
<dd>
<section class="desc"><p>Computes order data.</p>
<p>The canonical ordering between nodes is defined in terms of the slots that
nodes contain.</p>
<p>A node <em>A</em>
comes before a node <em>B</em> if, <em>A</em> contains the smallest slot
that occurs in only one of <em>A</em> and <em>B</em>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otype</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>otype</em> feature.</dd>
<dt><strong><code>oslots</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>oslots</em> feature.</dd>
<dt><strong><a title="tf.core.prepare.levels" href="#tf.core.prepare.levels"><code>levels()</code></a></strong> :&ensp;<code>tuple</code></dt>
<dd>The data of the <em>levels</em> precompute step.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>array</code></dt>
<dd>All nodes, slot and nonslot, in canonical order.</dd>
<dt><code>We</code> <code>store</code> <code>the</code> <code>result</code> <code>in</code> <code>an</code> <code>array</code> <code>because</code> <code>it</code> <code>saves</code> <code>a</code> <code>lot</code> of <code>memory</code>, <code>and</code> <code>access</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>is still fast.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def order(info, error, otype, oslots, levels):
    &#34;&#34;&#34;Computes order data.

    The canonical ordering between nodes is defined in terms of the slots that
    nodes contain.

    A node *A*  comes before a node *B* if, *A* contains the smallest slot
    that occurs in only one of *A* and *B*.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    oslots: iterable
        The data of the *oslots* feature.
    levels: tuple
        The data of the *levels* precompute step.

    Returns
    -------
    array
        All nodes, slot and nonslot, in canonical order.

    We store the result in an array because it saves a lot of memory, and access
    is still fast.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    info(&#34;assigning otype levels to nodes&#34;)
    otypeLevels = dict(((x[0], i) for (i, x) in enumerate(levels)))

    def otypeRank(n):
        return otypeLevels[slotType if n &lt; maxSlot + 1 else otype[n - maxSlot - 1]]

    def before(na, nb):
        if na &lt; maxSlot + 1:
            a = na
            sa = {a}
        else:
            a = na - maxSlot
            sa = set(oslots[a - 1])
        if nb &lt; maxSlot + 1:
            b = nb
            sb = {b}
        else:
            b = nb - maxSlot
            sb = set(oslots[b - 1])
        oa = otypeRank(na)
        ob = otypeRank(nb)
        if sa == sb:
            return 0 if oa == ob else -1 if oa &lt; ob else 1
        if sa &gt; sb:
            return -1
        if sa &lt; sb:
            return 1
        am = min(sa - sb)
        bm = min(sb - sa)
        return -1 if am &lt; bm else 1 if bm &lt; am else None

    canonKey = functools.cmp_to_key(before)
    info(&#34;sorting nodes&#34;)
    nodes = sorted(range(1, maxNode + 1), key=canonKey)
    return array(&#34;I&#34;, nodes)</code></pre>
</details>
</dd>
<dt id="tf.core.prepare.rank"><code class="name flex">
<span>def <span class="ident">rank</span></span>(<span>info, error, otype, order)</span>
</code></dt>
<dd>
<section class="desc"><p>Computes rank data.</p>
<p>The rank of a node is its place in among the other nodes in the
canonical ordering (see <a title="tf.core.prepare.order" href="#tf.core.prepare.order"><code>order()</code></a>).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otype</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>otype</em> feature.</dd>
<dt><strong><a title="tf.core.prepare.order" href="#tf.core.prepare.order"><code>order()</code></a></strong> :&ensp;<code>array</code></dt>
<dd>The data of the <em>order</em> feature.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>array</code></dt>
<dd>The ranks of all nodes, slot and nonslot, with respect to the canonical order.</dd>
<dt><code>We</code> <code>store</code> <code>the</code> <code>result</code> <code>in</code> <code>an</code> <code>array</code> <code>because</code> <code>it</code> <code>saves</code> <code>a</code> <code>lot</code> of <code>memory</code>, <code>and</code> <code>access</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>is still fast.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rank(info, error, otype, order):
    &#34;&#34;&#34;Computes rank data.

    The rank of a node is its place in among the other nodes in the
    canonical ordering (see `order`).

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    order: array
        The data of the *order* feature.

    Returns
    -------
    array
        The ranks of all nodes, slot and nonslot, with respect to the canonical order.

    We store the result in an array because it saves a lot of memory, and access
    is still fast.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    info(&#34;ranking nodes&#34;)
    nodesRank = dict(((n, i) for (i, n) in enumerate(order)))
    return array(&#34;I&#34;, (nodesRank[n] for n in range(1, maxNode + 1)))</code></pre>
</details>
</dd>
<dt id="tf.core.prepare.sections"><code class="name flex">
<span>def <span class="ident">sections</span></span>(<span>info, error, otype, oslots, otext, levUp, levels, *sFeats)</span>
</code></dt>
<dd>
<section class="desc"><p>Computes section data.</p>
<p>Text-Fabric datasets may define up to three section levels, roughly corresponding
with a volume, a chapter, a paragraph.</p>
<p>If the corpus has a richer section structure, it is also possible
a different, more flexible and more extensive nest of structural sections.
See <a title="tf.core.prepare.structure" href="#tf.core.prepare.structure"><code>structure()</code></a>.</p>
<p>Text-Fabric must be able to go from sections at one level to the sections
at one level lower. It must also be able to map section headings
to nodes. For this, the section features are needed, since they
contain the section headings.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otype</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>otype</em> feature.</dd>
<dt><strong><code>oslots</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>oslots</em> feature.</dd>
<dt><strong><code>otext</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>otext</em> feature.</dd>
<dt><strong><a title="tf.core.prepare.levUp" href="#tf.core.prepare.levUp"><code>levUp()</code></a></strong> :&ensp;<code>array</code></dt>
<dd>The data of the <em>levUp</em> precompute step.</dd>
<dt><strong><a title="tf.core.prepare.levels" href="#tf.core.prepare.levels"><code>levels()</code></a></strong> :&ensp;<code>array</code></dt>
<dd>The data of the <em>levels</em> precompute step.</dd>
<dt><strong><code>sFeats</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The names of section features.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>
<ul>
<li>sec1
Mapping from section-level-1 nodes to mappings from
section-level-2 headings to section-level2 nodes.</li>
<li>sec2
Mapping from section-level-1 nodes to mappings from
section-level-2 headings to mappings from
section-level3 headings to section-level-3 nodes.</li>
</ul>
</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sections(info, error, otype, oslots, otext, levUp, levels, *sFeats):
    &#34;&#34;&#34;Computes section data.

    Text-Fabric datasets may define up to three section levels, roughly corresponding
    with a volume, a chapter, a paragraph.

    If the corpus has a richer section structure, it is also possible
    a different, more flexible and more extensive nest of structural sections.
    See `structure`.

    Text-Fabric must be able to go from sections at one level to the sections
    at one level lower. It must also be able to map section headings
    to nodes. For this, the section features are needed, since they
    contain the section headings.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    oslots: iterable
        The data of the *oslots* feature.
    otext: iterable
        The data of the *otext* feature.
    levUp: array
        The data of the *levUp* precompute step.
    levels: array
        The data of the *levels* precompute step.
    sFeats: iterable
        The names of section features.

    Returns
    -------
    tuple
        *   sec1
            Mapping from section-level-1 nodes to mappings from
            section-level-2 headings to section-level2 nodes.
        *   sec2
            Mapping from section-level-1 nodes to mappings from
            section-level-2 headings to mappings from
            section-level3 headings to section-level-3 nodes.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    support = dict(((o[0], (o[2], o[3])) for o in levels))
    sTypes = itemize(otext[&#34;sectionTypes&#34;], &#34;,&#34;)
    sec1 = {}
    sec2 = {}
    nestingProblems = collections.Counter()

    if len(sTypes) &lt; 2:
        pass

    elif len(sTypes) &lt; 3:
        c1 = 0
        support1 = support[sTypes[1]]
        for n1 in range(support1[0], support1[1] + 1):
            n0s = tuple(x for x in levUp[n1 - 1] if otype[x - maxSlot - 1] == sTypes[0])
            if not n0s:
                nestingProblems[
                    f&#34;section {sTypes[1]} without containing {sTypes[0]}&#34;
                ] += 1
                continue
            n0 = n0s[0]
            n1s = sFeats[1][n1]
            if n0 not in sec1:
                sec1[n0] = {}
            if n1s not in sec1[n0]:
                sec1[n0][n1s] = n1
                c1 += 1
        info(f&#34;{c1} {sTypes[1]}s indexed&#34;)

    else:
        c1 = 0
        c2 = 0
        support2 = support[sTypes[2]]
        for n2 in range(support2[0], support2[1] + 1):
            n0s = tuple(x for x in levUp[n2 - 1] if otype[x - maxSlot - 1] == sTypes[0])
            if not n0s:
                nestingProblems[
                    f&#34;section {sTypes[2]} without containing {sTypes[0]}&#34;
                ] += 1
                continue
            n0 = n0s[0]
            n1s = tuple(x for x in levUp[n2 - 1] if otype[x - maxSlot - 1] == sTypes[1])
            if not n1s:
                nestingProblems[
                    f&#34;section {sTypes[2]} without containing {sTypes[1]}&#34;
                ] += 1
                continue
            n1 = n1s[0]
            n1s = sFeats[1][n1]
            n2s = sFeats[2][n2]
            if n0 not in sec1:
                sec1[n0] = {}
            if n1s not in sec1[n0]:
                sec1[n0][n1s] = n1
                c1 += 1
            sec2.setdefault(n0, {}).setdefault(n1s, {})[n2s] = n2
            c2 += 1
        info(f&#34;{c1} {sTypes[1]}s and {c2} {sTypes[2]}s indexed&#34;)

    if nestingProblems:
        for (msg, amount) in sorted(nestingProblems.items()):
            error(f&#34;WARNING: {amount:&gt;4} x {msg}&#34;)

    return (sec1, sec2)</code></pre>
</details>
</dd>
<dt id="tf.core.prepare.structure"><code class="name flex">
<span>def <span class="ident">structure</span></span>(<span>info, error, otype, oslots, otext, rank, levUp, *sFeats)</span>
</code></dt>
<dd>
<section class="desc"><p>Computes structure data.</p>
<p>If the corpus has a rich section structure, it is possible to define
a flexible and extensive nest of structural sections.</p>
<p>Independent of this,
Text-Fabric datasets may also define up to three section levels,
roughly corresponding with a volume, a chapter, a paragraph.
See <a title="tf.core.prepare.sections" href="#tf.core.prepare.sections"><code>sections()</code></a>.</p>
<p>Text-Fabric must be able to go from sections at one level to the sections
at one level lower. It must also be able to map section headings
to nodes. For this, the section features are needed, since they
contain the section headings.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otype</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>otype</em> feature.</dd>
<dt><strong><code>oslots</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>oslots</em> feature.</dd>
<dt><strong><code>otext</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>otext</em> feature.</dd>
<dt><strong><a title="tf.core.prepare.rank" href="#tf.core.prepare.rank"><code>rank()</code></a></strong> :&ensp;<code>array</code></dt>
<dd>The data of the <em>rank</em> precompute step.</dd>
<dt><strong><a title="tf.core.prepare.levUp" href="#tf.core.prepare.levUp"><code>levUp()</code></a></strong> :&ensp;<code>array</code></dt>
<dd>The data of the <em>levUp</em> precompute step.</dd>
<dt><strong><code>sFeats</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The names of structural features.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>
<ul>
<li>headingFromNode
Mapping from section keys to nodes</li>
<li>nodeFromHeading
Mapping from nodes to section keys</li>
<li>multiple</li>
<li>top</li>
<li>up</li>
<li>down</li>
</ul>
</dd>
<dt><code>A</code> <code>section</code> <code>key</code> of <code>a</code> <code>structural</code> <code>node</code> <code>is</code> <code>obtained</code> <code>by</code> <code>going</code> <code>a</code> <code>level</code> <code>up</code> <code>from</code></dt>
<dd>&nbsp;</dd>
<dt><code>that</code> <code>node</code>, <code>retrieving</code> <code>the</code> <code>heading</code> of <code>that</code> <code>structural</code> <code>node</code>, <code>then</code> <code>going</code> <code>up</code> <code>again</code>,</dt>
<dd>&nbsp;</dd>
<dt><code>and</code> <code>so</code> <code>on</code> <code>till</code> <code>a</code> <code>top</code> <code>node</code> <code>is</code> <code>reached.</code> <code>The</code> <code>tuple</code> of <code>headings</code> <code>obtained</code> <code>in</code> <code>this</code> <code>way</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>is the
section key.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def structure(info, error, otype, oslots, otext, rank, levUp, *sFeats):
    &#34;&#34;&#34;Computes structure data.

    If the corpus has a rich section structure, it is possible to define
    a flexible and extensive nest of structural sections.

    Independent of this,
    Text-Fabric datasets may also define up to three section levels,
    roughly corresponding with a volume, a chapter, a paragraph.
    See `sections`.

    Text-Fabric must be able to go from sections at one level to the sections
    at one level lower. It must also be able to map section headings
    to nodes. For this, the section features are needed, since they
    contain the section headings.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    oslots: iterable
        The data of the *oslots* feature.
    otext: iterable
        The data of the *otext* feature.
    rank: array
        The data of the *rank* precompute step.
    levUp: array
        The data of the *levUp* precompute step.
    sFeats: iterable
        The names of structural features.

    Returns
    -------
    tuple
        *   headingFromNode
            Mapping from section keys to nodes
        *   nodeFromHeading
            Mapping from nodes to section keys
        *   multiple
        *   top
        *   up
        *   down

    A section key of a structural node is obtained by going a level up from
    that node, retrieving the heading of that structural node, then going up again,
    and so on till a top node is reached. The tuple of headings obtained in this way
    is the  section key.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    sTypeList = itemize(otext[&#34;structureTypes&#34;], &#34;,&#34;)
    nsTypes = len(sTypeList)
    nsFeats = len(sFeats)

    if nsTypes != nsFeats:
        error(
            f&#34;WARNING: {nsTypes} structure levels but {nsFeats} corresponding features&#34;
        )
        return ({}, {})

    sTypes = set(sTypeList)
    if len(sTypes) != nsTypes:
        error(f&#34;WARNING: duplicate structure levels&#34;)
        return ({}, {})

    higherTypes = collections.defaultdict(set)
    for (i, highType) in enumerate(sTypeList):
        for lowType in sTypeList[i:]:
            higherTypes[lowType].add(highType)

    featFromType = {sTypeList[i]: sFeats[i] for i in range(nsTypes)}

    multiple = collections.defaultdict(list)
    headingFromNode = {}
    nodeFromHeading = {}

    for n in range(maxSlot + 1, maxNode + 1):
        nType = otype[n - maxSlot - 1]
        if nType not in sTypes:
            continue
        ups = (u for u in levUp[n - 1] if otype[u - maxSlot - 1] in higherTypes[nType])
        sKey = tuple(
            reversed(
                tuple(
                    (
                        otype[x - maxSlot - 1],
                        featFromType[otype[x - maxSlot - 1]].get(x, None),
                    )
                    for x in (n, *ups)
                )
            )
        )

        if sKey in nodeFromHeading:
            if sKey not in multiple:
                multiple[sKey].append(nodeFromHeading[sKey])
            multiple[sKey].append(n)
        nodeFromHeading[sKey] = n
        headingFromNode[n] = sKey
    multiple = {
        sKey: tuple(sorted(ns, key=lambda n: rank[n - 1],))
        for (sKey, ns) in multiple.items()
    }

    top = tuple(
        sorted(
            (n for (n, h) in headingFromNode.items() if len(h) == 1),
            key=lambda n: rank[n - 1],
        )
    )

    up = {}
    for (n, heading) in headingFromNode.items():
        lHeading = len(heading)
        if lHeading == 1:
            continue
        upNode = None
        for i in range(lHeading - 1, 0, -1):
            upHeading = heading[0:i]
            upNode = nodeFromHeading.get(upHeading, None)
            if upNode is not None:
                up[n] = upNode
                break

    down = {}
    for (n, heading) in headingFromNode.items():
        if len(heading) == 1:
            continue
        down.setdefault(up[n], []).append(n)

    down = {n: tuple(sorted(ms, key=lambda m: rank[m - 1])) for (n, ms) in down.items()}

    return (headingFromNode, nodeFromHeading, multiple, top, up, down)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.core" href="index.html">tf.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="tf.core.prepare.boundary" href="#tf.core.prepare.boundary">boundary</a></code></li>
<li><code><a title="tf.core.prepare.levDown" href="#tf.core.prepare.levDown">levDown</a></code></li>
<li><code><a title="tf.core.prepare.levUp" href="#tf.core.prepare.levUp">levUp</a></code></li>
<li><code><a title="tf.core.prepare.levels" href="#tf.core.prepare.levels">levels</a></code></li>
<li><code><a title="tf.core.prepare.order" href="#tf.core.prepare.order">order</a></code></li>
<li><code><a title="tf.core.prepare.rank" href="#tf.core.prepare.rank">rank</a></code></li>
<li><code><a title="tf.core.prepare.sections" href="#tf.core.prepare.sections">sections</a></code></li>
<li><code><a title="tf.core.prepare.structure" href="#tf.core.prepare.structure">structure</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>