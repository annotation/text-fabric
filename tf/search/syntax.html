<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.search.syntax API documentation</title>
<meta name="description" content="Syntax of search templates" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.search.syntax</code></h1>
</header>
<section id="section-intro">
<h1 id="syntax-of-search-templates">Syntax of search templates</h1>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/20a11ec8c00eaa300322fdd0de11bdb896c605ed/tf/search/syntax.py#L1-L678" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# Syntax of search templates
&#34;&#34;&#34;

import re

# SYNTACTIC ANALYSIS OF SEARCH TEMPLATE ###

QWHERE = &#34;/where/&#34;
QHAVE = &#34;/have/&#34;
QWITHOUT = &#34;/without/&#34;
QWITH = &#34;/with/&#34;
QOR = &#34;/or/&#34;
QEND = &#34;/-/&#34;

QINIT = {QWHERE, QWITHOUT, QWITH}
QCONT = {QHAVE, QOR}
QTERM = {QEND}

PARENT_REF = &#34;..&#34;

ESCAPES = (
    &#34;\\\\&#34;,
    &#34;\\ &#34;,
    &#34;\\t&#34;,
    &#34;\\n&#34;,
    &#34;\\|&#34;,
    &#34;\\=&#34;,
)
VAL_ESCAPES = {
    &#34;\\|&#34;,
    &#34;\\=&#34;,
}

opPat = r&#34;(?:[.#&amp;|\[\]&lt;&gt;:=-]+\S*)&#34;

atomOpPat = r&#34;(\s*)({op})\s+([^ \t=#&lt;&gt;~*]+)(?:(?:\s*\Z)|(?:\s+(.*)))$&#34;.format(op=opPat)
atomPat = r&#34;(\s*)([^ \t=#&lt;&gt;~*]+)(?:(?:\s*\Z)|(?:\s+(.*)))$&#34;
compPat = r&#34;^([a-zA-Z0-9-@_]+)([&lt;&gt;])(.*)$&#34;
identPat = r&#34;^([a-zA-Z0-9-@_]+)([=#])(.+)$&#34;
indentLinePat = r&#34;^(\s*)(.*)&#34;
kPat = r&#34;^([^0-9]*)([0-9]+)([^0-9]+)$&#34;
namePat = r&#34;[A-Za-z0-9_.-]+&#34;
namesPat = r&#34;^\s*(?:{op}\s+)?([^ \t:=#&lt;&gt;~*]+):&#34;
nonePat = r&#34;^([a-zA-Z0-9-@_]+)(#?)\s*$&#34;
truePat = r&#34;^([a-zA-Z0-9-@_]+)[*]\s*$&#34;
numPat = r&#34;^-?[0-9]+$&#34;
opLinePat = r&#34;^(\s*)({op})\s*$&#34;.format(op=opPat)
opStripPat = r&#34;^\s*{op}\s+(.*)$&#34;.format(op=opPat)
quPat = f&#34;(?:{QWHERE}|{QHAVE}|{QWITHOUT}|{QWITH}|{QOR}|{QEND})&#34;
quLinePat = r&#34;^(\s*)({qu})\s*$&#34;.format(qu=quPat)
relPat = r&#34;^(\s*)({nm})\s+({op})\s+({nm})\s*$&#34;.format(nm=namePat, op=opPat)
rePat = r&#34;^([a-zA-Z0-9-@_]+)~(.*)$&#34;

atomOpRe = re.compile(atomOpPat)
atomRe = re.compile(atomPat)
compRe = re.compile(compPat)
identRe = re.compile(identPat)
indentLineRe = re.compile(indentLinePat)
kRe = re.compile(kPat)
nameRe = re.compile(f&#34;^{namePat}$&#34;)
namesRe = re.compile(namesPat)
numRe = re.compile(numPat)
noneRe = re.compile(nonePat)
trueRe = re.compile(truePat)
opLineRe = re.compile(opLinePat)
opStripRe = re.compile(opStripPat)
quLineRe = re.compile(quLinePat)
relRe = re.compile(relPat)
reRe = re.compile(rePat)
whiteRe = re.compile(r&#34;^\s*(%|$)&#34;)

reTp = type(reRe)


def syntax(searchExe):
    error = searchExe.api.TF.error
    _msgCache = searchExe._msgCache
    searchExe.good = True
    searchExe.badSyntax = []
    searchExe.searchLines = searchExe.searchTemplate.split(&#34;\n&#34;)
    offset = searchExe.offset

    _tokenize(searchExe)

    if not searchExe.good:
        searchExe.showOuterTemplate(_msgCache)
        for (i, line) in enumerate(searchExe.searchLines):
            error(f&#34;{i + offset:&gt;2} {line}&#34;, tm=False, cache=_msgCache)
        for (ln, eline) in searchExe.badSyntax:
            txt = eline if ln is None else f&#34;line {ln + offset}: {eline}&#34;
            error(txt, tm=False, cache=_msgCache)


def _tokenize(searchExe):

    tokens = []

    def lastAtomToken():
        for token in reversed(tokens):
            kind = token[&#34;kind&#34;]
            if kind == &#34;feat&#34;:
                continue
            if kind == &#34;atom&#34; and &#34;otype&#34; in token:
                return token
            return None
        return None

    def readFeatures(x, i):
        features = {}
        featureString = x.replace(&#34;\\ &#34;, chr(1)) if x is not None else &#34;&#34;
        featureList = featureString.split()
        good = True
        for featStr in featureList:
            if not parseFeatureVals(searchExe, featStr, features, i):
                good = False
        return features if good else None

    searchLines = searchExe.searchLines
    allGood = True

    # the template may contain nested quantifiers
    # However, we detect only the outer level of quantifiers.
    # Everything contained in a quantifiers is collected in
    # a new search template, verbatim, without interpretion,
    # because it will be fed to search() on another instance.
    # We only strip the quantified lines of the outermost quantifiers.

    # We can maintain the current quantifier, None if there is none.
    # We also remember the current indentation of the current quantifier
    # We collect the templates within the quantifier in a list of strings.
    # We add all the material into a quantifier token of the shape
    #
    # Because indentation is not indicative of quantifier nesting
    # we need to maintain a stack of inner quantifiers,
    # just to be able to determine wich quantifier words
    # belong to the outerlevel quantifiers.

    curQu = []
    curQuTemplates = None

    for (i, line) in enumerate(searchLines):
        if whiteRe.match(line):
            continue
        opFeatures = {}

        # first check whether we have a line with a quantifier
        # and what the indent on the line is

        match = quLineRe.match(line)
        if match:
            (indent, lineQuKind) = match.groups()
        else:
            lineQuKind = None
            match = indentLineRe.match(line)
            indent = match.group(1)

        lineIndent = len(indent)

        # QUANTIFIER FILTERING
        #
        # now check whether we are in a quantifier or not
        # and determine whether a quantifier starts or ends here

        # we have the following possible situations:
        #
        # UUO no outer              - no q-keyword
        #
        # UBO no outer              - q-keyword
        #     * ES no start keyword
        #     * ET no preceding token
        #     * EA no preceding atom
        #     * EI preceding atom not the same indentation
        #
        # PBI outer                 - q-keyword init
        #
        # PPO outer                 - no q-keyword
        #
        # PPI inner                 - no q-keyword
        #
        # PCO outer                 - q-keyword continue
        #     * EP wrong precursor
        #     * EK preceding keyword not the same indentation
        #
        # PCI inner                 - q-keyword continue
        #     * EP wrong precursor
        #     * EK preceding keyword not the same indentation
        #
        # PEO outer                 - q-keyword end
        #     * EP wrong precursor
        #     * EK preceding keyword not the same indentation
        #
        # PEI inner                 - q-keyword end
        #     * EP wrong precursor
        #     * EK preceding keyword not the same indentation
        #
        # at the end we may have a non-empty quantifier stack:
        #     * generate an unterminated quantifier error for each member
        #       of the stack

        # first we determine what is the case and we store it in booleans

        curQuLine = None
        curQuKind = None
        curQuIndent = None
        curQuDepth = len(curQu)
        if curQuDepth:
            (curQuLine, curQuKind, curQuIndent) = curQu[-1]

        UUO = not curQuDepth and not lineQuKind
        UBO = not curQuDepth and lineQuKind
        PBI = curQuDepth and lineQuKind in QINIT
        PPO = curQuDepth == 1 and not lineQuKind
        PPI = curQuDepth &gt; 1 and not lineQuKind
        PCO = curQuDepth == 1 and lineQuKind in QCONT
        PCI = curQuDepth &gt; 1 and lineQuKind in QCONT
        PEO = curQuDepth == 1 and lineQuKind in QTERM
        PEI = curQuDepth &gt; 1 and lineQuKind in QTERM

        (ES, ET, EA, EI, EP, EK) = (False,) * 6

        if UBO:
            ES = lineQuKind not in QINIT
            ET = len(tokens) == 0
            lastAtom = lastAtomToken()
            EA = len(tokens) and not lastAtom
            # EA = len(tokens) and not lastAtomToken
            EI = len(tokens) and lastAtom and lastAtom[&#34;indent&#34;] != lineIndent
            # EA = (len(tokens) and tokens[-1][&#39;kind&#39;] != &#39;atom&#39; and &#39;otype&#39; not in tokens[-1])
            # EI = (len(tokens) and tokens[-1][&#39;indent&#39;] != lineIndent)

        if PCO or PCI:
            EP = (lineQuKind == QHAVE and curQuKind != QWHERE) or (
                lineQuKind == QOR and curQuKind not in {QWITH, QOR}
            )
            EK = curQu[-1][2] != lineIndent

        if PEO or PEI:
            EP = curQuKind in {QWHERE}
            EK = curQu[-1][2] != lineIndent

        # QUANTIFIER HANDLING
        #
        # Based on what is the case, we take actions.
        # * we swallow quantified templates
        # * we handle quantifier lines
        # * we let all other lines pass through

        good = True

        for x in [True]:
            if UUO:
                # no quantifier business
                continue
            if UBO:
                # start new quantifier from nothing
                if ES:
                    searchExe.badSyntax.append(
                        (i, f&#39;Quantifier: Can not start with &#34;{lineQuKind}:&#34;&#39;)
                    )
                    good = False
                if ET:
                    searchExe.badSyntax.append((i, &#34;Quantifier: No preceding tokens&#34;))
                    good = False
                if EA or EI:
                    searchExe.badSyntax.append(
                        (
                            i,
                            &#34;Quantifier: Does not immediately follow an atom at the same level&#34;,
                        )
                    )
                    good = False
                if not good:
                    continue
                # prevAtom = tokens[-1]
                prevAtom = lastAtomToken()
                curQu.append((i, lineQuKind, lineIndent))
                curQuTemplates = [[]]
                quantifiers = prevAtom.setdefault(&#34;quantifiers&#34;, [])
                quantifiers.append((lineQuKind, curQuTemplates, i))
                continue
            if PBI:
                # start inner quantifier
                # lines are passed with stripped indentation
                # based on the outermost quantifier level
                outerIndent = curQu[0][2]
                strippedLine = line[outerIndent:]
                curQuTemplates[-1].append(strippedLine)
                curQu.append((i, lineQuKind, lineIndent))
            if PPO:
                # inside an outer quantifier
                # lines are passed with stripped indentation
                strippedLine = line[curQuIndent:]
                curQuTemplates[-1].append(strippedLine)
                continue
            if PPI:
                # inside an inner quantifier
                # lines are passed with stripped indentation
                # based on the outermost quantifier level
                outerIndent = curQu[0][2]
                strippedLine = line[outerIndent:]
                curQuTemplates[-1].append(strippedLine)
            if PCO or PCI:
                if EP:
                    searchExe.badSyntax.append(
                        (
                            i,
                            f&#39;Quantifier: &#34;{lineQuKind}&#34; can not follow &#34;{curQuKind}&#34; on line {curQuLine}&#39;,
                        )
                    )
                    good = False
                if EK:
                    searchExe.badSyntax.append(
                        (
                            i,
                            (
                                f&#39;Quantifier &#34;{lineQuKind}&#34;&#39;
                                f&#39; has not same indentation as &#34;{curQuKind}&#34; on line {curQuLine}&#39;
                            ),
                        )
                    )
                    good = False
                if PCO:
                    curQuTemplates.append([])
                else:
                    outerIndent = curQu[0][2]
                    strippedLine = line[outerIndent:]
                    curQuTemplates[-1].append(strippedLine)
                curQu[-1] = (i, lineQuKind, lineIndent)
                continue
            if PEO or PEI:
                if EP:
                    searchExe.badSyntax.append(
                        (
                            i,
                            (
                                f&#39;Quantifier: &#34;{lineQuKind}&#34;&#39;
                                f&#39; : premature end of &#34;{curQuKind}&#34; on line {curQuLine}&#39;
                            ),
                        )
                    )
                    good = False
                if EK:
                    searchExe.badSyntax.append(
                        (
                            i,
                            (
                                f&#39;Quantifier &#34;{lineQuKind}&#34;&#39;
                                f&#39; has not same indentation as &#34;{curQuKind}&#34; on line {curQuLine}&#39;
                            ),
                        )
                    )
                    good = False
                if PEO:
                    curQuTemplates = None
                else:
                    outerIndent = curQu[0][2]
                    strippedLine = line[outerIndent:]
                    curQuTemplates[-1].append(strippedLine)
                curQu.pop()
                continue

        if not good:
            allGood = False

        if UUO:
            # go on with normal template tokenization
            pass
        else:
            # quantifiers stuff has been dealt with
            continue

        # QUANTIFIER FREE HANDLING

        good = False

        for x in [True]:
            (kind, data) = parseLine(line)

            if kind == &#34;op&#34;:
                (indent, op) = data
                if not parseFeatureVals(searchExe, op, opFeatures, i, asEdge=True):
                    good = False
                else:
                    if opFeatures:
                        op = (op, opFeatures)
                    tokens.append(dict(ln=i, kind=&#34;atom&#34;, indent=len(indent), op=op))
                    good = True
                break

            if kind == &#34;rel&#34;:
                (indent, f, op, t) = data
                if not parseFeatureVals(searchExe, op, opFeatures, i, asEdge=True):
                    good = False
                else:
                    if opFeatures:
                        op = (op, opFeatures)
                    tokens.append(dict(ln=i, kind=&#34;rel&#34;, f=f, op=op, t=t))
                    good = True
                break

            if kind == &#34;atom&#34;:
                (indent, op, name, otype, features) = data
                good = True
                if name != &#34;&#34;:
                    mt = nameRe.match(name)
                    if not mt:
                        searchExe.badSyntax.append((i, f&#39;Illegal name: &#34;{name}&#34;&#39;))
                        good = False
                features = readFeatures(features, i)
                if features is None:
                    good = False
                else:
                    if op is not None:
                        if not parseFeatureVals(
                            searchExe, op, opFeatures, i, asEdge=True
                        ):
                            good = False
                    if good:
                        if opFeatures:
                            op = (op, opFeatures)
                        tokens.append(
                            dict(
                                ln=i,
                                kind=&#34;atom&#34;,
                                indent=len(indent),
                                op=op,
                                name=name,
                                otype=otype,
                                src=line.lstrip(),
                                features=features,
                            )
                        )
                break

            if kind == &#34;feat&#34;:
                features = data[0]
                features = readFeatures(features, i)
                if features is None:
                    good = False
                else:
                    tokens.append(dict(ln=i, kind=&#34;feat&#34;, features=features))
                    good = True
                break

            good = False
            searchExe.badSyntax.append((i, f&#34;Unrecognized line: {line}&#34;))

        if not good:
            allGood = False

    if curQu:
        for (curQuLine, curQuKind, curQuIndent) in curQu:
            searchExe.badSyntax.append(
                (curQuLine, f&#39;Quantifier: Unterminated &#34;{curQuKind}&#34;&#39;)
            )
        good = False
        allGood = False
    if allGood:
        searchExe.tokens = tokens
    else:
        searchExe.good = False


def parseLine(line):
    for x in [True]:
        escLine = _esc(line)

        match = opLineRe.match(escLine)
        if match:
            (indent, op) = match.groups()
            kind = &#34;op&#34;
            data = (indent, op)
            break

        match = relRe.match(escLine)
        if match:
            (indent, f, op, t) = match.groups()
            kind = &#34;rel&#34;
            data = (indent, f, op, t)
            break

        matchOp = atomOpRe.match(escLine)
        if matchOp:
            (indent, op, atom, features) = matchOp.groups()
        else:
            match = atomRe.match(escLine)
            if match:
                op = None
                (indent, atom, features) = match.groups()
        if matchOp or match:
            atomComps = atom.split(&#34;:&#34;, 1)
            if len(atomComps) == 1:
                name = &#34;&#34;
                otype = atomComps[0]
            else:
                name = atomComps[0]
                otype = atomComps[1]
            kind = &#34;atom&#34;
            if features is None:
                features = &#34;&#34;
            data = (indent, op, name, otype, features)
            break

        kind = &#34;feat&#34;
        data = (escLine,)

    return (kind, data)


def parseFeatureVals(searchExe, featStr, features, i, asEdge=False):
    if asEdge:
        if not (
            (featStr[0] == &#34;-&#34; and featStr[-1] == &#34;&gt;&#34;)
            or (featStr[0] == &#34;&lt;&#34; and featStr[-1] == &#34;-&#34;)
            or (featStr[0] == &#34;&lt;&#34; and featStr[-1] == &#34;&gt;&#34;)
        ):
            return True
        feat = featStr[1:-1]
    else:
        feat = featStr.replace(chr(1), &#34; &#34;)
    good = True
    for x in [True]:
        match = trueRe.match(feat)
        if match:
            (featN,) = match.groups()
            featName = _unesc(featN)
            featVals = (None, True)
            break
        match = noneRe.match(feat)
        if match:
            (featN, unequal) = match.groups()
            featName = _unesc(featN)
            featVals = None if unequal else True
            break
        match = identRe.match(feat)
        if match:
            (featN, comp, featValStr) = match.groups()
            featName = _unesc(featN)
            featValSet = frozenset(_unesc(featVal) for featVal in featValStr.split(&#34;|&#34;))
            featVals = (comp == &#34;=&#34;, featValSet)
            break
        match = compRe.match(feat)
        if match:
            (featN, comp, limit) = match.groups()
            featName = _unesc(featN)
            if not numRe.match(limit):
                searchExe.badSyntax.append((i, f&#39;Limit is non numeric &#34;{limit}&#34;&#39;))
                good = False
                featVals = None
            else:
                featVals = _makeLimit(int(limit), comp == &#34;&gt;&#34;)
            break
        match = reRe.match(feat)
        if match:
            (featN, valRe) = match.groups()
            featName = _unesc(featN)
            valRe = _unesc(valRe, inRe=True)
            try:
                featVals = re.compile(valRe)
            except Exception as err:
                searchExe.badSyntax.append(
                    (i, f&#39;Wrong regular expression &#34;{valRe}&#34;: &#34;{err}&#34;&#39;)
                )
                good = False
                featVals = None
            break
        searchExe.badSyntax.append((i, f&#39;Unrecognized feature condition &#34;{feat}&#34;&#39;))
        good = False
        featVals = None
    if good:
        features[featName] = featVals
    return good


def _genLine(kind, data):
    result = None

    for x in [True]:
        if kind == &#34;op&#34;:
            (indent, op) = data
            result = f&#34;{indent}{_unesc(op)}&#34;
            break

        if kind == &#34;rel&#34;:
            (indent, f, op, t) = data
            result = f&#34;{indent}{f} {_unesc(op)} {t}&#34;
            break

        if kind == &#34;atom&#34;:
            (indent, op, name, otype, features) = data
            opRep = &#34;&#34; if op is None else f&#34;{_unesc(op)} &#34;
            nameRep = &#34;&#34; if name == &#34;&#34; else f&#34;{name}:&#34;
            featRep = _unesc(features)
            if featRep:
                featRep = f&#34; {featRep}&#34;
            result = f&#34;{indent}{opRep}{nameRep}{otype}{featRep}&#34;
            break

        features = data[0]
        result = _unesc(features)

    return result


def cleanParent(atom, parentName):
    (kind, data) = parseLine(atom)
    (indent, op, name, otype, features) = data
    if name == &#34;&#34;:
        name = parentName
    return _genLine(kind, (indent, None, name, otype, features))


def deContext(quantifier, parentName):
    (quKind, quTemplates, ln) = quantifier

    # choose a name for the parent
    # either the given name
    if not parentName:
        # or make a new name
        # collect all used names
        # to avoid choosing a name that is already used
        usedNames = set()
        for template in quTemplates:
            for line in template:
                for name in namesRe.findall(line):
                    usedNames.add(name)
        parentName = &#34;parent&#34;
        while parentName in usedNames:
            parentName += &#34;x&#34;

    newQuTemplates = []
    newQuantifier = (quKind, newQuTemplates, parentName, ln)

    # replace .. (PARENT_REF) by parentName
    # wherever it is applicable
    for template in quTemplates:
        newLines = []
        for line in template:
            (kind, data) = parseLine(line)
            newLine = line
            if kind == &#34;rel&#34;:
                (indent, f, op, t) = data
                if f == PARENT_REF or t == PARENT_REF:
                    newF = parentName if f == PARENT_REF else f
                    newT = parentName if t == PARENT_REF else t
                    newData = (indent, newF, op, newT)
                    newLine = _genLine(kind, newData)
            elif kind == &#34;atom&#34;:
                (indent, op, name, otype, features) = data
                if name == &#34;&#34; and otype == PARENT_REF:
                    newData = (indent, op, name, parentName, features)
                    newLine = _genLine(kind, newData)
            newLines.append(newLine)
        templateStr = &#34;\n&#34;.join(newLines)
        newQuTemplates.append(templateStr)
    return newQuantifier


def _makeLimit(n, isLower):
    if isLower:
        return lambda x: x is not None and x &gt; n
    return lambda x: x is not None and x &lt; n


def _esc(x):
    for (i, c) in enumerate(ESCAPES):
        x = x.replace(c, chr(i))
    return x


def _unesc(x, inRe=False):
    for (i, c) in enumerate(ESCAPES):
        if inRe and c in VAL_ESCAPES:
            x = x.replace(chr(i), f&#34;\\{c[1]}&#34;)
        else:
            x = x.replace(chr(i), c[1])
    return x</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.search.syntax.cleanParent"><code class="name flex">
<span>def <span class="ident">cleanParent</span></span>(<span>atom, parentName)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/20a11ec8c00eaa300322fdd0de11bdb896c605ed/tf/search/syntax.py#L606-L611" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def cleanParent(atom, parentName):
    (kind, data) = parseLine(atom)
    (indent, op, name, otype, features) = data
    if name == &#34;&#34;:
        name = parentName
    return _genLine(kind, (indent, None, name, otype, features))</code></pre>
</details>
</dd>
<dt id="tf.search.syntax.deContext"><code class="name flex">
<span>def <span class="ident">deContext</span></span>(<span>quantifier, parentName)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/20a11ec8c00eaa300322fdd0de11bdb896c605ed/tf/search/syntax.py#L614-L657" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def deContext(quantifier, parentName):
    (quKind, quTemplates, ln) = quantifier

    # choose a name for the parent
    # either the given name
    if not parentName:
        # or make a new name
        # collect all used names
        # to avoid choosing a name that is already used
        usedNames = set()
        for template in quTemplates:
            for line in template:
                for name in namesRe.findall(line):
                    usedNames.add(name)
        parentName = &#34;parent&#34;
        while parentName in usedNames:
            parentName += &#34;x&#34;

    newQuTemplates = []
    newQuantifier = (quKind, newQuTemplates, parentName, ln)

    # replace .. (PARENT_REF) by parentName
    # wherever it is applicable
    for template in quTemplates:
        newLines = []
        for line in template:
            (kind, data) = parseLine(line)
            newLine = line
            if kind == &#34;rel&#34;:
                (indent, f, op, t) = data
                if f == PARENT_REF or t == PARENT_REF:
                    newF = parentName if f == PARENT_REF else f
                    newT = parentName if t == PARENT_REF else t
                    newData = (indent, newF, op, newT)
                    newLine = _genLine(kind, newData)
            elif kind == &#34;atom&#34;:
                (indent, op, name, otype, features) = data
                if name == &#34;&#34; and otype == PARENT_REF:
                    newData = (indent, op, name, parentName, features)
                    newLine = _genLine(kind, newData)
            newLines.append(newLine)
        templateStr = &#34;\n&#34;.join(newLines)
        newQuTemplates.append(templateStr)
    return newQuantifier</code></pre>
</details>
</dd>
<dt id="tf.search.syntax.parseFeatureVals"><code class="name flex">
<span>def <span class="ident">parseFeatureVals</span></span>(<span>searchExe, featStr, features, i, asEdge=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/20a11ec8c00eaa300322fdd0de11bdb896c605ed/tf/search/syntax.py#L511-L573" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parseFeatureVals(searchExe, featStr, features, i, asEdge=False):
    if asEdge:
        if not (
            (featStr[0] == &#34;-&#34; and featStr[-1] == &#34;&gt;&#34;)
            or (featStr[0] == &#34;&lt;&#34; and featStr[-1] == &#34;-&#34;)
            or (featStr[0] == &#34;&lt;&#34; and featStr[-1] == &#34;&gt;&#34;)
        ):
            return True
        feat = featStr[1:-1]
    else:
        feat = featStr.replace(chr(1), &#34; &#34;)
    good = True
    for x in [True]:
        match = trueRe.match(feat)
        if match:
            (featN,) = match.groups()
            featName = _unesc(featN)
            featVals = (None, True)
            break
        match = noneRe.match(feat)
        if match:
            (featN, unequal) = match.groups()
            featName = _unesc(featN)
            featVals = None if unequal else True
            break
        match = identRe.match(feat)
        if match:
            (featN, comp, featValStr) = match.groups()
            featName = _unesc(featN)
            featValSet = frozenset(_unesc(featVal) for featVal in featValStr.split(&#34;|&#34;))
            featVals = (comp == &#34;=&#34;, featValSet)
            break
        match = compRe.match(feat)
        if match:
            (featN, comp, limit) = match.groups()
            featName = _unesc(featN)
            if not numRe.match(limit):
                searchExe.badSyntax.append((i, f&#39;Limit is non numeric &#34;{limit}&#34;&#39;))
                good = False
                featVals = None
            else:
                featVals = _makeLimit(int(limit), comp == &#34;&gt;&#34;)
            break
        match = reRe.match(feat)
        if match:
            (featN, valRe) = match.groups()
            featName = _unesc(featN)
            valRe = _unesc(valRe, inRe=True)
            try:
                featVals = re.compile(valRe)
            except Exception as err:
                searchExe.badSyntax.append(
                    (i, f&#39;Wrong regular expression &#34;{valRe}&#34;: &#34;{err}&#34;&#39;)
                )
                good = False
                featVals = None
            break
        searchExe.badSyntax.append((i, f&#39;Unrecognized feature condition &#34;{feat}&#34;&#39;))
        good = False
        featVals = None
    if good:
        features[featName] = featVals
    return good</code></pre>
</details>
</dd>
<dt id="tf.search.syntax.parseLine"><code class="name flex">
<span>def <span class="ident">parseLine</span></span>(<span>line)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/20a11ec8c00eaa300322fdd0de11bdb896c605ed/tf/search/syntax.py#L465-L508" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parseLine(line):
    for x in [True]:
        escLine = _esc(line)

        match = opLineRe.match(escLine)
        if match:
            (indent, op) = match.groups()
            kind = &#34;op&#34;
            data = (indent, op)
            break

        match = relRe.match(escLine)
        if match:
            (indent, f, op, t) = match.groups()
            kind = &#34;rel&#34;
            data = (indent, f, op, t)
            break

        matchOp = atomOpRe.match(escLine)
        if matchOp:
            (indent, op, atom, features) = matchOp.groups()
        else:
            match = atomRe.match(escLine)
            if match:
                op = None
                (indent, atom, features) = match.groups()
        if matchOp or match:
            atomComps = atom.split(&#34;:&#34;, 1)
            if len(atomComps) == 1:
                name = &#34;&#34;
                otype = atomComps[0]
            else:
                name = atomComps[0]
                otype = atomComps[1]
            kind = &#34;atom&#34;
            if features is None:
                features = &#34;&#34;
            data = (indent, op, name, otype, features)
            break

        kind = &#34;feat&#34;
        data = (escLine,)

    return (kind, data)</code></pre>
</details>
</dd>
<dt id="tf.search.syntax.syntax"><code class="name flex">
<span>def <span class="ident">syntax</span></span>(<span>searchExe)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/20a11ec8c00eaa300322fdd0de11bdb896c605ed/tf/search/syntax.py#L76-L92" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def syntax(searchExe):
    error = searchExe.api.TF.error
    _msgCache = searchExe._msgCache
    searchExe.good = True
    searchExe.badSyntax = []
    searchExe.searchLines = searchExe.searchTemplate.split(&#34;\n&#34;)
    offset = searchExe.offset

    _tokenize(searchExe)

    if not searchExe.good:
        searchExe.showOuterTemplate(_msgCache)
        for (i, line) in enumerate(searchExe.searchLines):
            error(f&#34;{i + offset:&gt;2} {line}&#34;, tm=False, cache=_msgCache)
        for (ln, eline) in searchExe.badSyntax:
            txt = eline if ln is None else f&#34;line {ln + offset}: {eline}&#34;
            error(txt, tm=False, cache=_msgCache)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#syntax-of-search-templates">Syntax of search templates</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.search" href="index.html">tf.search</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tf.search.syntax.cleanParent" href="#tf.search.syntax.cleanParent">cleanParent</a></code></li>
<li><code><a title="tf.search.syntax.deContext" href="#tf.search.syntax.deContext">deContext</a></code></li>
<li><code><a title="tf.search.syntax.parseFeatureVals" href="#tf.search.syntax.parseFeatureVals">parseFeatureVals</a></code></li>
<li><code><a title="tf.search.syntax.parseLine" href="#tf.search.syntax.parseLine">parseLine</a></code></li>
<li><code><a title="tf.search.syntax.syntax" href="#tf.search.syntax.syntax">syntax</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>