<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.search.searchexe API documentation</title>
<meta name="description" content="Search execution management" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.search.searchexe</code></h1>
</header>
<section id="section-intro">
<h1 id="search-execution-management">Search execution management</h1>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/3f12ed87f6209ca93e7ae1b2399ded7bd1f6c212/tf/search/searchexe.py#L1-L246" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# Search execution management
&#34;&#34;&#34;

from .relations import basicRelations
from .syntax import syntax
from .semantics import semantics
from .graph import connectedness, displayPlan
from .spin import spinAtoms, spinEdges
from .stitch import setStrategy, stitch
from ..parameters import SEARCH_FAIL_FACTOR, YARN_RATIO, TRY_LIMIT_FROM, TRY_LIMIT_TO
from ..core.timestamp import DEEP


PROGRESS = 100


class SearchExe:
    perfDefaults = dict(
        yarnRatio=YARN_RATIO,
        tryLimitFrom=TRY_LIMIT_FROM,
        tryLimitTo=TRY_LIMIT_TO,
    )
    perfParams = dict(**perfDefaults)

    @classmethod
    def setPerfParams(cls, params):
        cls.perfParams = params

    def __init__(
        self,
        api,
        searchTemplate,
        outerTemplate=None,
        quKind=None,
        offset=0,
        level=0,
        sets=None,
        shallow=False,
        silent=DEEP,
        showQuantifiers=False,
        _msgCache=False,
        setInfo={},
    ):
        self.api = api
        TF = api.TF
        setSilent = TF.setSilent

        self.searchTemplate = searchTemplate
        self.outerTemplate = outerTemplate
        self.quKind = quKind
        self.level = level
        self.offset = offset
        self.sets = sets
        self.shallow = 0 if not shallow else 1 if shallow is True else shallow
        self.silent = silent
        setSilent(silent)
        self.showQuantifiers = showQuantifiers
        self._msgCache = (
            _msgCache if type(_msgCache) is list else -1 if _msgCache else 0
        )
        self.good = True
        self.setInfo = setInfo
        basicRelations(self, api)

    # API METHODS ###

    def search(self, limit=None):
        api = self.api
        TF = api.TF
        setSilent = TF.setSilent
        setSilent(True)
        self.study()
        setSilent(self.silent)
        return self.fetch(limit=limit)

    def study(self, strategy=None):
        api = self.api
        TF = api.TF
        info = TF.info
        indent = TF.indent
        isSilent = TF.isSilent
        setSilent = TF.setSilent
        _msgCache = self._msgCache

        indent(level=0, reset=True)
        self.good = True

        wasSilent = isSilent()

        setStrategy(self, strategy)
        if not self.good:
            return

        info(&#34;Checking search template ...&#34;, cache=_msgCache)

        self._parse()
        self._prepare()
        if not self.good:
            return
        info(
            f&#34;Setting up search space for {len(self.qnodes)} objects ...&#34;,
            cache=_msgCache,
        )
        spinAtoms(self)
        # in spinAtoms an inner call to study may have happened due to quantifiers
        # That will restore the silent level to what we had outside
        # study(). So we have to make it deep again.
        setSilent(wasSilent)
        info(
            f&#34;Constraining search space with {len(self.qedges)} relations ...&#34;,
            cache=_msgCache,
        )
        spinEdges(self)
        info(f&#34;\t{len(self.thinned)} edges thinned&#34;, cache=_msgCache)
        info(
            f&#34;Setting up retrieval plan with strategy {self.strategyName} ...&#34;,
            cache=_msgCache,
        )
        stitch(self)
        if self.good:
            yarnContent = sum(len(y) for y in self.yarns.values())
            info(f&#34;Ready to deliver results from {yarnContent} nodes&#34;, cache=_msgCache)
            info(&#34;Iterate over S.fetch() to get the results&#34;, tm=False, cache=_msgCache)
            info(&#34;See S.showPlan() to interpret the results&#34;, tm=False, cache=_msgCache)

    def fetch(self, limit=None):
        api = self.api
        TF = api.TF
        F = api.F
        error = TF.error
        _msgCache = self._msgCache

        if limit and limit &lt; 0:
            limit = 0

        if not self.good:
            queryResults = set() if self.shallow else []
        elif self.shallow:
            queryResults = self.results
        else:
            failLimit = limit if limit else SEARCH_FAIL_FACTOR * F.otype.maxNode

            def limitedResults():
                for (i, result) in enumerate(self.results()):
                    if i &lt; failLimit:
                        yield result
                    else:
                        if not limit:
                            error(
                                f&#34;cut off at {failLimit} results. There are more ...&#34;,
                                cache=_msgCache,
                            )
                        return

            queryResults = (
                limitedResults() if limit is None else tuple(limitedResults())
            )

        return queryResults

    def count(self, progress=None, limit=None):
        TF = self.api.TF
        info = TF.info
        error = TF.error
        _msgCache = self._msgCache
        indent = TF.indent
        indent(level=0, reset=True)

        if limit and limit &lt; 0:
            limit = 0

        if not self.good:
            error(
                &#34;This search has problems. No results to count.&#34;,
                tm=False,
                cache=_msgCache,
            )
            return

        if progress is None:
            progress = PROGRESS

        if limit:
            failLimit = limit
            msg = f&#34; up to {failLimit}&#34;
        else:
            failLimit = SEARCH_FAIL_FACTOR * self.api.F.otype.maxNode
            msg = &#34;&#34;

        info(
            f&#34;Counting results per {progress}{msg} ...&#34;,
            cache=_msgCache,
        )
        indent(level=1, reset=True)

        j = 0
        good = True
        for (i, r) in enumerate(self.results(remap=False)):
            if i &gt;= failLimit:
                if not limit:
                    good = False
                break
            j += 1
            if j == progress:
                j = 0
                info(i + 1, cache=_msgCache)

        indent(level=0)
        if good:
            info(f&#34;Done: {i + 1} results&#34;, cache=_msgCache)
        else:
            error(
                f&#34;cut off at {failLimit} results. There are more ...&#34;, cache=_msgCache
            )

    # SHOWING WITH THE SEARCH GRAPH ###

    def showPlan(self, details=False):
        displayPlan(self, details=details)

    def showOuterTemplate(self, _msgCache):
        error = self.api.TF.error
        offset = self.offset
        outerTemplate = self.outerTemplate
        quKind = self.quKind
        if offset and outerTemplate is not None:
            for (i, line) in enumerate(outerTemplate.split(&#34;\n&#34;)):
                error(f&#34;{i:&gt;2} {line}&#34;, tm=False, cache=_msgCache)
            error(f&#34;line {offset:&gt;2}: Error under {quKind}:&#34;, tm=False, cache=_msgCache)

    # TOP-LEVEL IMPLEMENTATION METHODS

    def _parse(self):
        syntax(self)
        semantics(self)

    def _prepare(self):
        if not self.good:
            return
        self.yarns = {}
        self.spreads = {}
        self.spreadsC = {}
        self.uptodate = {}
        self.results = None
        connectedness(self)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.search.searchexe.SearchExe"><code class="flex name class">
<span>class <span class="ident">SearchExe</span></span>
<span>(</span><span>api, searchTemplate, outerTemplate=None, quKind=None, offset=0, level=0, sets=None, shallow=False, silent='deep', showQuantifiers=False, setInfo={})</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/3f12ed87f6209ca93e7ae1b2399ded7bd1f6c212/tf/search/searchexe.py#L18-L246" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SearchExe:
    perfDefaults = dict(
        yarnRatio=YARN_RATIO,
        tryLimitFrom=TRY_LIMIT_FROM,
        tryLimitTo=TRY_LIMIT_TO,
    )
    perfParams = dict(**perfDefaults)

    @classmethod
    def setPerfParams(cls, params):
        cls.perfParams = params

    def __init__(
        self,
        api,
        searchTemplate,
        outerTemplate=None,
        quKind=None,
        offset=0,
        level=0,
        sets=None,
        shallow=False,
        silent=DEEP,
        showQuantifiers=False,
        _msgCache=False,
        setInfo={},
    ):
        self.api = api
        TF = api.TF
        setSilent = TF.setSilent

        self.searchTemplate = searchTemplate
        self.outerTemplate = outerTemplate
        self.quKind = quKind
        self.level = level
        self.offset = offset
        self.sets = sets
        self.shallow = 0 if not shallow else 1 if shallow is True else shallow
        self.silent = silent
        setSilent(silent)
        self.showQuantifiers = showQuantifiers
        self._msgCache = (
            _msgCache if type(_msgCache) is list else -1 if _msgCache else 0
        )
        self.good = True
        self.setInfo = setInfo
        basicRelations(self, api)

    # API METHODS ###

    def search(self, limit=None):
        api = self.api
        TF = api.TF
        setSilent = TF.setSilent
        setSilent(True)
        self.study()
        setSilent(self.silent)
        return self.fetch(limit=limit)

    def study(self, strategy=None):
        api = self.api
        TF = api.TF
        info = TF.info
        indent = TF.indent
        isSilent = TF.isSilent
        setSilent = TF.setSilent
        _msgCache = self._msgCache

        indent(level=0, reset=True)
        self.good = True

        wasSilent = isSilent()

        setStrategy(self, strategy)
        if not self.good:
            return

        info(&#34;Checking search template ...&#34;, cache=_msgCache)

        self._parse()
        self._prepare()
        if not self.good:
            return
        info(
            f&#34;Setting up search space for {len(self.qnodes)} objects ...&#34;,
            cache=_msgCache,
        )
        spinAtoms(self)
        # in spinAtoms an inner call to study may have happened due to quantifiers
        # That will restore the silent level to what we had outside
        # study(). So we have to make it deep again.
        setSilent(wasSilent)
        info(
            f&#34;Constraining search space with {len(self.qedges)} relations ...&#34;,
            cache=_msgCache,
        )
        spinEdges(self)
        info(f&#34;\t{len(self.thinned)} edges thinned&#34;, cache=_msgCache)
        info(
            f&#34;Setting up retrieval plan with strategy {self.strategyName} ...&#34;,
            cache=_msgCache,
        )
        stitch(self)
        if self.good:
            yarnContent = sum(len(y) for y in self.yarns.values())
            info(f&#34;Ready to deliver results from {yarnContent} nodes&#34;, cache=_msgCache)
            info(&#34;Iterate over S.fetch() to get the results&#34;, tm=False, cache=_msgCache)
            info(&#34;See S.showPlan() to interpret the results&#34;, tm=False, cache=_msgCache)

    def fetch(self, limit=None):
        api = self.api
        TF = api.TF
        F = api.F
        error = TF.error
        _msgCache = self._msgCache

        if limit and limit &lt; 0:
            limit = 0

        if not self.good:
            queryResults = set() if self.shallow else []
        elif self.shallow:
            queryResults = self.results
        else:
            failLimit = limit if limit else SEARCH_FAIL_FACTOR * F.otype.maxNode

            def limitedResults():
                for (i, result) in enumerate(self.results()):
                    if i &lt; failLimit:
                        yield result
                    else:
                        if not limit:
                            error(
                                f&#34;cut off at {failLimit} results. There are more ...&#34;,
                                cache=_msgCache,
                            )
                        return

            queryResults = (
                limitedResults() if limit is None else tuple(limitedResults())
            )

        return queryResults

    def count(self, progress=None, limit=None):
        TF = self.api.TF
        info = TF.info
        error = TF.error
        _msgCache = self._msgCache
        indent = TF.indent
        indent(level=0, reset=True)

        if limit and limit &lt; 0:
            limit = 0

        if not self.good:
            error(
                &#34;This search has problems. No results to count.&#34;,
                tm=False,
                cache=_msgCache,
            )
            return

        if progress is None:
            progress = PROGRESS

        if limit:
            failLimit = limit
            msg = f&#34; up to {failLimit}&#34;
        else:
            failLimit = SEARCH_FAIL_FACTOR * self.api.F.otype.maxNode
            msg = &#34;&#34;

        info(
            f&#34;Counting results per {progress}{msg} ...&#34;,
            cache=_msgCache,
        )
        indent(level=1, reset=True)

        j = 0
        good = True
        for (i, r) in enumerate(self.results(remap=False)):
            if i &gt;= failLimit:
                if not limit:
                    good = False
                break
            j += 1
            if j == progress:
                j = 0
                info(i + 1, cache=_msgCache)

        indent(level=0)
        if good:
            info(f&#34;Done: {i + 1} results&#34;, cache=_msgCache)
        else:
            error(
                f&#34;cut off at {failLimit} results. There are more ...&#34;, cache=_msgCache
            )

    # SHOWING WITH THE SEARCH GRAPH ###

    def showPlan(self, details=False):
        displayPlan(self, details=details)

    def showOuterTemplate(self, _msgCache):
        error = self.api.TF.error
        offset = self.offset
        outerTemplate = self.outerTemplate
        quKind = self.quKind
        if offset and outerTemplate is not None:
            for (i, line) in enumerate(outerTemplate.split(&#34;\n&#34;)):
                error(f&#34;{i:&gt;2} {line}&#34;, tm=False, cache=_msgCache)
            error(f&#34;line {offset:&gt;2}: Error under {quKind}:&#34;, tm=False, cache=_msgCache)

    # TOP-LEVEL IMPLEMENTATION METHODS

    def _parse(self):
        syntax(self)
        semantics(self)

    def _prepare(self):
        if not self.good:
            return
        self.yarns = {}
        self.spreads = {}
        self.spreadsC = {}
        self.uptodate = {}
        self.results = None
        connectedness(self)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="tf.search.searchexe.SearchExe.perfDefaults"><code class="name">var <span class="ident">perfDefaults</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tf.search.searchexe.SearchExe.perfParams"><code class="name">var <span class="ident">perfParams</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="tf.search.searchexe.SearchExe.setPerfParams"><code class="name flex">
<span>def <span class="ident">setPerfParams</span></span>(<span>params)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/3f12ed87f6209ca93e7ae1b2399ded7bd1f6c212/tf/search/searchexe.py#L26-L28" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def setPerfParams(cls, params):
    cls.perfParams = params</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tf.search.searchexe.SearchExe.count"><code class="name flex">
<span>def <span class="ident">count</span></span>(<span>self, progress=None, limit=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/3f12ed87f6209ca93e7ae1b2399ded7bd1f6c212/tf/search/searchexe.py#L162-L215" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def count(self, progress=None, limit=None):
    TF = self.api.TF
    info = TF.info
    error = TF.error
    _msgCache = self._msgCache
    indent = TF.indent
    indent(level=0, reset=True)

    if limit and limit &lt; 0:
        limit = 0

    if not self.good:
        error(
            &#34;This search has problems. No results to count.&#34;,
            tm=False,
            cache=_msgCache,
        )
        return

    if progress is None:
        progress = PROGRESS

    if limit:
        failLimit = limit
        msg = f&#34; up to {failLimit}&#34;
    else:
        failLimit = SEARCH_FAIL_FACTOR * self.api.F.otype.maxNode
        msg = &#34;&#34;

    info(
        f&#34;Counting results per {progress}{msg} ...&#34;,
        cache=_msgCache,
    )
    indent(level=1, reset=True)

    j = 0
    good = True
    for (i, r) in enumerate(self.results(remap=False)):
        if i &gt;= failLimit:
            if not limit:
                good = False
            break
        j += 1
        if j == progress:
            j = 0
            info(i + 1, cache=_msgCache)

    indent(level=0)
    if good:
        info(f&#34;Done: {i + 1} results&#34;, cache=_msgCache)
    else:
        error(
            f&#34;cut off at {failLimit} results. There are more ...&#34;, cache=_msgCache
        )</code></pre>
</details>
</dd>
<dt id="tf.search.searchexe.SearchExe.fetch"><code class="name flex">
<span>def <span class="ident">fetch</span></span>(<span>self, limit=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/3f12ed87f6209ca93e7ae1b2399ded7bd1f6c212/tf/search/searchexe.py#L127-L160" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fetch(self, limit=None):
    api = self.api
    TF = api.TF
    F = api.F
    error = TF.error
    _msgCache = self._msgCache

    if limit and limit &lt; 0:
        limit = 0

    if not self.good:
        queryResults = set() if self.shallow else []
    elif self.shallow:
        queryResults = self.results
    else:
        failLimit = limit if limit else SEARCH_FAIL_FACTOR * F.otype.maxNode

        def limitedResults():
            for (i, result) in enumerate(self.results()):
                if i &lt; failLimit:
                    yield result
                else:
                    if not limit:
                        error(
                            f&#34;cut off at {failLimit} results. There are more ...&#34;,
                            cache=_msgCache,
                        )
                    return

        queryResults = (
            limitedResults() if limit is None else tuple(limitedResults())
        )

    return queryResults</code></pre>
</details>
</dd>
<dt id="tf.search.searchexe.SearchExe.search"><code class="name flex">
<span>def <span class="ident">search</span></span>(<span>self, limit=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/3f12ed87f6209ca93e7ae1b2399ded7bd1f6c212/tf/search/searchexe.py#L68-L75" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def search(self, limit=None):
    api = self.api
    TF = api.TF
    setSilent = TF.setSilent
    setSilent(True)
    self.study()
    setSilent(self.silent)
    return self.fetch(limit=limit)</code></pre>
</details>
</dd>
<dt id="tf.search.searchexe.SearchExe.showOuterTemplate"><code class="name flex">
<span>def <span class="ident">showOuterTemplate</span></span>(<span>self, _msgCache)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/3f12ed87f6209ca93e7ae1b2399ded7bd1f6c212/tf/search/searchexe.py#L222-L230" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def showOuterTemplate(self, _msgCache):
    error = self.api.TF.error
    offset = self.offset
    outerTemplate = self.outerTemplate
    quKind = self.quKind
    if offset and outerTemplate is not None:
        for (i, line) in enumerate(outerTemplate.split(&#34;\n&#34;)):
            error(f&#34;{i:&gt;2} {line}&#34;, tm=False, cache=_msgCache)
        error(f&#34;line {offset:&gt;2}: Error under {quKind}:&#34;, tm=False, cache=_msgCache)</code></pre>
</details>
</dd>
<dt id="tf.search.searchexe.SearchExe.showPlan"><code class="name flex">
<span>def <span class="ident">showPlan</span></span>(<span>self, details=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/3f12ed87f6209ca93e7ae1b2399ded7bd1f6c212/tf/search/searchexe.py#L219-L220" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def showPlan(self, details=False):
    displayPlan(self, details=details)</code></pre>
</details>
</dd>
<dt id="tf.search.searchexe.SearchExe.study"><code class="name flex">
<span>def <span class="ident">study</span></span>(<span>self, strategy=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/3f12ed87f6209ca93e7ae1b2399ded7bd1f6c212/tf/search/searchexe.py#L77-L125" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def study(self, strategy=None):
    api = self.api
    TF = api.TF
    info = TF.info
    indent = TF.indent
    isSilent = TF.isSilent
    setSilent = TF.setSilent
    _msgCache = self._msgCache

    indent(level=0, reset=True)
    self.good = True

    wasSilent = isSilent()

    setStrategy(self, strategy)
    if not self.good:
        return

    info(&#34;Checking search template ...&#34;, cache=_msgCache)

    self._parse()
    self._prepare()
    if not self.good:
        return
    info(
        f&#34;Setting up search space for {len(self.qnodes)} objects ...&#34;,
        cache=_msgCache,
    )
    spinAtoms(self)
    # in spinAtoms an inner call to study may have happened due to quantifiers
    # That will restore the silent level to what we had outside
    # study(). So we have to make it deep again.
    setSilent(wasSilent)
    info(
        f&#34;Constraining search space with {len(self.qedges)} relations ...&#34;,
        cache=_msgCache,
    )
    spinEdges(self)
    info(f&#34;\t{len(self.thinned)} edges thinned&#34;, cache=_msgCache)
    info(
        f&#34;Setting up retrieval plan with strategy {self.strategyName} ...&#34;,
        cache=_msgCache,
    )
    stitch(self)
    if self.good:
        yarnContent = sum(len(y) for y in self.yarns.values())
        info(f&#34;Ready to deliver results from {yarnContent} nodes&#34;, cache=_msgCache)
        info(&#34;Iterate over S.fetch() to get the results&#34;, tm=False, cache=_msgCache)
        info(&#34;See S.showPlan() to interpret the results&#34;, tm=False, cache=_msgCache)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#search-execution-management">Search execution management</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.search" href="index.html">tf.search</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.search.searchexe.SearchExe" href="#tf.search.searchexe.SearchExe">SearchExe</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.search.searchexe.SearchExe.count" href="#tf.search.searchexe.SearchExe.count">count</a></code></li>
<li><code><a title="tf.search.searchexe.SearchExe.fetch" href="#tf.search.searchexe.SearchExe.fetch">fetch</a></code></li>
<li><code><a title="tf.search.searchexe.SearchExe.perfDefaults" href="#tf.search.searchexe.SearchExe.perfDefaults">perfDefaults</a></code></li>
<li><code><a title="tf.search.searchexe.SearchExe.perfParams" href="#tf.search.searchexe.SearchExe.perfParams">perfParams</a></code></li>
<li><code><a title="tf.search.searchexe.SearchExe.search" href="#tf.search.searchexe.SearchExe.search">search</a></code></li>
<li><code><a title="tf.search.searchexe.SearchExe.setPerfParams" href="#tf.search.searchexe.SearchExe.setPerfParams">setPerfParams</a></code></li>
<li><code><a title="tf.search.searchexe.SearchExe.showOuterTemplate" href="#tf.search.searchexe.SearchExe.showOuterTemplate">showOuterTemplate</a></code></li>
<li><code><a title="tf.search.searchexe.SearchExe.showPlan" href="#tf.search.searchexe.SearchExe.showPlan">showPlan</a></code></li>
<li><code><a title="tf.search.searchexe.SearchExe.study" href="#tf.search.searchexe.SearchExe.study">study</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>