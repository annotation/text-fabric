<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.browser.ner.servelib API documentation</title>
<meta name="description" content="Auxiliary functions for managing request data â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-GjqubOlYA6/wOZV7F31o2t4ogk4JGDGFa6XmL+BfAG0=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-qDPJ4nH38AgHyK3U6cvI6DBifA+7hPBo8mVoH6pyN9c=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.browser.ner.servelib</code></h1>
</header>
<section id="section-intro">
<p>Auxiliary functions for managing request data.</p>
<p>To see how this fits among all the modules of this package, see
<code><a title="tf.browser.ner.annotate" href="annotate.html">tf.browser.ner.annotate</a></code> .</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/23cf5da9dec27afb7a27c0b45bb902eec9f4bfcf/tf/browser/ner/servelib.py#L1-L252" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Auxiliary functions for managing request data.

To see how this fits among all the modules of this package, see
`tf.browser.ner.annotate` .
&#34;&#34;&#34;

import json
from urllib.parse import unquote

from flask import request

from ...core.generic import AttrDict, deepAttrDict
from .settings import TOOLKEY, EMPTY, NONE, SORTKEY_DEFAULT, SORTDIR_DEFAULT, SC_ALL
from .helpers import findCompile


def getFormData(self):
    &#34;&#34;&#34;Get form data.

    The TF browser user interacts with the app by clicking and typing,
    as a result of which a HTML form gets filled in.
    This form as regularly submitted to the server with a request
    for a new incarnation of the page: a response.

    The values that come with a request, must be peeled out of the form,
    and stored as logical values.

    Parameters
    ----------
    self: object
        A `tf.browser.ner.annotate.Annotate` object is expected.
    &#34;&#34;&#34;
    settings = self.settings
    features = settings.features

    fget = request.form.get

    form = {}

    form[&#34;resetForm&#34;] = fget(&#34;resetForm&#34;, &#34;&#34;)
    submitter = fget(&#34;submitter&#34;, &#34;&#34;)
    form[&#34;submitter&#34;] = submitter

    form[&#34;sec0&#34;] = fget(&#34;sec0&#34;, &#34;&#34;)
    form[&#34;sec1&#34;] = fget(&#34;sec1&#34;, &#34;&#34;)
    form[&#34;sec2&#34;] = fget(&#34;sec2&#34;, &#34;&#34;)
    form[&#34;annoset&#34;] = fget(&#34;annoset&#34;, &#34;&#34;)
    form[&#34;duannoset&#34;] = fget(&#34;duannoset&#34;, &#34;&#34;)
    form[&#34;rannoset&#34;] = fget(&#34;rannoset&#34;, &#34;&#34;)
    form[&#34;dannoset&#34;] = fget(&#34;dannoset&#34;, &#34;&#34;)
    form[&#34;sortkey&#34;] = fget(&#34;sortkey&#34;, &#34;&#34;) or SORTKEY_DEFAULT
    form[&#34;sortdir&#34;] = fget(&#34;sortdir&#34;, &#34;&#34;) or SORTDIR_DEFAULT
    form[&#34;sortkey&#34;] = fget(&#34;sortkey&#34;, &#34;&#34;) or SORTKEY_DEFAULT
    form[&#34;sortdir&#34;] = fget(&#34;sortdir&#34;, &#34;&#34;) or SORTDIR_DEFAULT
    form[&#34;formattingdo&#34;] = fget(&#34;formattingdo&#34;, &#34;x&#34;) == &#34;v&#34;
    form[&#34;formattingstate&#34;] = {
        feat: fget(f&#34;{feat}_appearance&#34;, &#34;v&#34;) == &#34;v&#34;
        for feat in features + (&#34;_stat_&#34;, &#34;_entity_&#34;)
    }
    form[&#34;bfind&#34;] = fget(&#34;bfind&#34;, &#34;&#34;)
    form[&#34;bfindc&#34;] = fget(&#34;bfindc&#34;, &#34;x&#34;) == &#34;v&#34;
    form[&#34;bfinderror&#34;] = fget(&#34;bfinderror&#34;, &#34;&#34;)

    anyEnt = fget(&#34;anyent&#34;, &#34;&#34;)
    form[&#34;anyent&#34;] = True if anyEnt == &#34;v&#34; else False if anyEnt == &#34;x&#34; else None

    form[&#34;freestate&#34;] = fget(&#34;freestate&#34;, &#34;all&#34;)
    activeEntity = fget(&#34;activeentity&#34;, None)
    form[&#34;activeentity&#34;] = tuple(activeEntity.split(&#34;âŠ™&#34;)) if activeEntity else None
    form[&#34;efind&#34;] = fget(&#34;efind&#34;, &#34;&#34;)
    tokenStart = fget(&#34;tokenstart&#34;, &#34;&#34;)
    form[&#34;tokenstart&#34;] = int(tokenStart) if tokenStart else None
    tokenEnd = fget(&#34;tokenend&#34;, &#34;&#34;)
    form[&#34;tokenend&#34;] = int(tokenEnd) if tokenEnd else None
    form[&#34;activeval&#34;] = tuple((feat, fget(f&#34;{feat}_active&#34;, &#34;&#34;)) for feat in features)
    makeValSelect(self, form)

    form[&#34;scope&#34;] = fget(&#34;scope&#34;, SC_ALL)
    excludedTokens = fget(&#34;excludedtokens&#34;, &#34;&#34;)
    form[&#34;excludedtokens&#34;] = (
        {int(t) for t in excludedTokens.split(&#34;,&#34;)} if excludedTokens else set()
    )
    addData = fget(&#34;adddata&#34;, &#34;&#34;)
    form[&#34;adddata&#34;] = (
        AttrDict() if addData == &#34;&#34; else deepAttrDict(json.loads(unquote(addData)))
    )
    delData = fget(&#34;deldata&#34;, &#34;&#34;)
    form[&#34;deldata&#34;] = (
        AttrDict() if delData == &#34;&#34; else deepAttrDict(json.loads(unquote(delData)))
    )
    form[&#34;reportdel&#34;] = fget(&#34;reportdel&#34;, &#34;&#34;)
    form[&#34;reportadd&#34;] = fget(&#34;reportadd&#34;, &#34;&#34;)
    form[&#34;modwidgetstate&#34;] = fget(&#34;modwidgetstate&#34;, &#34;add&#34;)

    return form


def makeValSelect(self, form):
    &#34;&#34;&#34;Set values for the entity features, based on the request.

    On the web page, there are hidden input fields for these values.
    These values are picked up and put in the form, under key `valselect`.
    Depending on which button caused the submit, the NONE value is added
    to each feature.

    The idea is that when the user is still engaged in filtering buckets,
    and there is an occurrence selected, the user should have the option
    to sub-select occurrences that do not yet have an entity assigned.

    Parameters
    ----------
    self: object
        A `tf.browser.ner.annotate.Annotate` object is expected.
    form: dict
        Contains the fields of the request data, in logical form.
    &#34;&#34;&#34;
    settings = self.settings
    features = settings.features

    fget = request.form.get

    submitter = form[&#34;submitter&#34;]
    valSelectProto = {feat: fget(f&#34;{feat}_select&#34;, &#34;&#34;) for feat in features}
    valSelect = {}

    startSearch = submitter in {&#34;lookupq&#34;, &#34;lookupn&#34;, &#34;freebutton&#34;}

    for feat in features:
        valProto = valSelectProto[feat]
        valSelect[feat] = (
            set(&#34;&#34; if x == EMPTY else x for x in valProto.split(&#34;,&#34;))
            if valProto
            else set()
        )
        if startSearch:
            valSelect[feat].add(NONE)

    form[&#34;valselect&#34;] = valSelect


def adaptValSelect(self, templateData):
    &#34;&#34;&#34;Adapts the values contained in `valSelect` after a modification action.

    After the addition or deletion of an entity, the values contained in `valSelect`
    may have become obsolete or inconvenient for further actions.

    This function adapts those values before having them rendered on the page.

    Parameters
    ----------
    self: object
        A `tf.browser.ner.annotate.Annotate` object is expected.
    templateData: dict
        Contains the intermediate results of computing the new page.
    &#34;&#34;&#34;
    settings = self.settings
    features = settings.features

    submitter = templateData.submitter
    valSelect = templateData.valselect

    if submitter == &#34;addgo&#34;:
        addData = templateData.adddata
        additions = addData.additions
        freeVals = addData.freeVals

        freeState = templateData.freestate

        for i, (feat, values) in enumerate(zip(features, additions)):
            for val in values:
                valSelect.setdefault(feat, set()).add(val)
                if val == freeVals[i]:
                    freeVals[i] = None

        if freeState == &#34;free&#34;:
            templateData.freestate = &#34;all&#34;

    elif submitter == &#34;delgo&#34;:
        for feat in features:
            valSelect.setdefault(feat, set()).add(NONE)

    templateData.submitter = &#34;&#34;


def initTemplate(self, app):
    &#34;&#34;&#34;Initializes the computation of the new page.

    It collects the request data, gleans some info from the configuration
    settings and the TF app, and initializes some data structures that
    will collect further information for the page.

    All bits and pieces that are needed during processing
    the request and filling in the final HTML template find a place under
    some key in the `templateData` dict which is stored in `self`.

    Parameters
    ----------
    self: object
        A `tf.browser.ner.annotate.Annotate` object is expected.
    app: object
        The TF app that represents the loaded corpus.
    &#34;&#34;&#34;
    settings = self.settings
    bucketType = settings.bucketType
    features = settings.features

    aContext = app.context
    appName = aContext.appName.replace(&#34;/&#34;, &#34; / &#34;)
    api = app.api
    F = api.F
    slotType = F.otype.slotType

    form = getFormData(self)
    resetForm = form[&#34;resetForm&#34;]

    templateData = AttrDict()
    templateData.toolkey = TOOLKEY
    templateData.buckettype = bucketType
    templateData.featurelist = &#34;,&#34;.join(features)

    for k, v in form.items():
        if not resetForm or k not in templateData:
            templateData[k] = v

    templateData.appname = appName
    templateData.slottype = slotType
    templateData.resetform = &#34;&#34;

    self.templateData = templateData


def findSetup(templateData):
    &#34;&#34;&#34;Compiles the filter pattern into a regular expression.

    When the user enters a search pattern in the box meant to filter the buckets,
    the pattern will be interpreted as a regular expression.

    We do the compilation here.
    If there are errors in the pattern they will be reported.
    Whether or not the search is case sensitive or not is under user control,
    and it will influence the compilation of the pattern.

    All input and output data is in `templateData` .
    &#34;&#34;&#34;
    bFind = templateData.bfind
    bFindC = templateData.bfindc

    (bFind, bFindRe, errorMsg) = findCompile(bFind, bFindC)

    templateData.bfind = bFind
    templateData.bfindre = bFindRe
    templateData.errormsg = errorMsg</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.browser.ner.servelib.adaptValSelect"><code class="name flex">
<span>def <span class="ident">adaptValSelect</span></span>(<span>self, templateData)</span>
</code></dt>
<dd>
<div class="desc"><p>Adapts the values contained in <code>valSelect</code> after a modification action.</p>
<p>After the addition or deletion of an entity, the values contained in <code>valSelect</code>
may have become obsolete or inconvenient for further actions.</p>
<p>This function adapts those values before having them rendered on the page.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>self</code></strong> :&ensp;<code>object</code></dt>
<dd>A <code><a title="tf.browser.ner.annotate.Annotate" href="annotate.html#tf.browser.ner.annotate.Annotate">Annotate</a></code> object is expected.</dd>
<dt><strong><code>templateData</code></strong> :&ensp;<code>dict</code></dt>
<dd>Contains the intermediate results of computing the new page.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/23cf5da9dec27afb7a27c0b45bb902eec9f4bfcf/tf/browser/ner/servelib.py#L141-L182" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def adaptValSelect(self, templateData):
    &#34;&#34;&#34;Adapts the values contained in `valSelect` after a modification action.

    After the addition or deletion of an entity, the values contained in `valSelect`
    may have become obsolete or inconvenient for further actions.

    This function adapts those values before having them rendered on the page.

    Parameters
    ----------
    self: object
        A `tf.browser.ner.annotate.Annotate` object is expected.
    templateData: dict
        Contains the intermediate results of computing the new page.
    &#34;&#34;&#34;
    settings = self.settings
    features = settings.features

    submitter = templateData.submitter
    valSelect = templateData.valselect

    if submitter == &#34;addgo&#34;:
        addData = templateData.adddata
        additions = addData.additions
        freeVals = addData.freeVals

        freeState = templateData.freestate

        for i, (feat, values) in enumerate(zip(features, additions)):
            for val in values:
                valSelect.setdefault(feat, set()).add(val)
                if val == freeVals[i]:
                    freeVals[i] = None

        if freeState == &#34;free&#34;:
            templateData.freestate = &#34;all&#34;

    elif submitter == &#34;delgo&#34;:
        for feat in features:
            valSelect.setdefault(feat, set()).add(NONE)

    templateData.submitter = &#34;&#34;</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.servelib.findSetup"><code class="name flex">
<span>def <span class="ident">findSetup</span></span>(<span>templateData)</span>
</code></dt>
<dd>
<div class="desc"><p>Compiles the filter pattern into a regular expression.</p>
<p>When the user enters a search pattern in the box meant to filter the buckets,
the pattern will be interpreted as a regular expression.</p>
<p>We do the compilation here.
If there are errors in the pattern they will be reported.
Whether or not the search is case sensitive or not is under user control,
and it will influence the compilation of the pattern.</p>
<p>All input and output data is in <code>templateData</code> .</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/23cf5da9dec27afb7a27c0b45bb902eec9f4bfcf/tf/browser/ner/servelib.py#L232-L252" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def findSetup(templateData):
    &#34;&#34;&#34;Compiles the filter pattern into a regular expression.

    When the user enters a search pattern in the box meant to filter the buckets,
    the pattern will be interpreted as a regular expression.

    We do the compilation here.
    If there are errors in the pattern they will be reported.
    Whether or not the search is case sensitive or not is under user control,
    and it will influence the compilation of the pattern.

    All input and output data is in `templateData` .
    &#34;&#34;&#34;
    bFind = templateData.bfind
    bFindC = templateData.bfindc

    (bFind, bFindRe, errorMsg) = findCompile(bFind, bFindC)

    templateData.bfind = bFind
    templateData.bfindre = bFindRe
    templateData.errormsg = errorMsg</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.servelib.getFormData"><code class="name flex">
<span>def <span class="ident">getFormData</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get form data.</p>
<p>The TF browser user interacts with the app by clicking and typing,
as a result of which a HTML form gets filled in.
This form as regularly submitted to the server with a request
for a new incarnation of the page: a response.</p>
<p>The values that come with a request, must be peeled out of the form,
and stored as logical values.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>self</code></strong> :&ensp;<code>object</code></dt>
<dd>A <code><a title="tf.browser.ner.annotate.Annotate" href="annotate.html#tf.browser.ner.annotate.Annotate">Annotate</a></code> object is expected.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/23cf5da9dec27afb7a27c0b45bb902eec9f4bfcf/tf/browser/ner/servelib.py#L17-L95" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getFormData(self):
    &#34;&#34;&#34;Get form data.

    The TF browser user interacts with the app by clicking and typing,
    as a result of which a HTML form gets filled in.
    This form as regularly submitted to the server with a request
    for a new incarnation of the page: a response.

    The values that come with a request, must be peeled out of the form,
    and stored as logical values.

    Parameters
    ----------
    self: object
        A `tf.browser.ner.annotate.Annotate` object is expected.
    &#34;&#34;&#34;
    settings = self.settings
    features = settings.features

    fget = request.form.get

    form = {}

    form[&#34;resetForm&#34;] = fget(&#34;resetForm&#34;, &#34;&#34;)
    submitter = fget(&#34;submitter&#34;, &#34;&#34;)
    form[&#34;submitter&#34;] = submitter

    form[&#34;sec0&#34;] = fget(&#34;sec0&#34;, &#34;&#34;)
    form[&#34;sec1&#34;] = fget(&#34;sec1&#34;, &#34;&#34;)
    form[&#34;sec2&#34;] = fget(&#34;sec2&#34;, &#34;&#34;)
    form[&#34;annoset&#34;] = fget(&#34;annoset&#34;, &#34;&#34;)
    form[&#34;duannoset&#34;] = fget(&#34;duannoset&#34;, &#34;&#34;)
    form[&#34;rannoset&#34;] = fget(&#34;rannoset&#34;, &#34;&#34;)
    form[&#34;dannoset&#34;] = fget(&#34;dannoset&#34;, &#34;&#34;)
    form[&#34;sortkey&#34;] = fget(&#34;sortkey&#34;, &#34;&#34;) or SORTKEY_DEFAULT
    form[&#34;sortdir&#34;] = fget(&#34;sortdir&#34;, &#34;&#34;) or SORTDIR_DEFAULT
    form[&#34;sortkey&#34;] = fget(&#34;sortkey&#34;, &#34;&#34;) or SORTKEY_DEFAULT
    form[&#34;sortdir&#34;] = fget(&#34;sortdir&#34;, &#34;&#34;) or SORTDIR_DEFAULT
    form[&#34;formattingdo&#34;] = fget(&#34;formattingdo&#34;, &#34;x&#34;) == &#34;v&#34;
    form[&#34;formattingstate&#34;] = {
        feat: fget(f&#34;{feat}_appearance&#34;, &#34;v&#34;) == &#34;v&#34;
        for feat in features + (&#34;_stat_&#34;, &#34;_entity_&#34;)
    }
    form[&#34;bfind&#34;] = fget(&#34;bfind&#34;, &#34;&#34;)
    form[&#34;bfindc&#34;] = fget(&#34;bfindc&#34;, &#34;x&#34;) == &#34;v&#34;
    form[&#34;bfinderror&#34;] = fget(&#34;bfinderror&#34;, &#34;&#34;)

    anyEnt = fget(&#34;anyent&#34;, &#34;&#34;)
    form[&#34;anyent&#34;] = True if anyEnt == &#34;v&#34; else False if anyEnt == &#34;x&#34; else None

    form[&#34;freestate&#34;] = fget(&#34;freestate&#34;, &#34;all&#34;)
    activeEntity = fget(&#34;activeentity&#34;, None)
    form[&#34;activeentity&#34;] = tuple(activeEntity.split(&#34;âŠ™&#34;)) if activeEntity else None
    form[&#34;efind&#34;] = fget(&#34;efind&#34;, &#34;&#34;)
    tokenStart = fget(&#34;tokenstart&#34;, &#34;&#34;)
    form[&#34;tokenstart&#34;] = int(tokenStart) if tokenStart else None
    tokenEnd = fget(&#34;tokenend&#34;, &#34;&#34;)
    form[&#34;tokenend&#34;] = int(tokenEnd) if tokenEnd else None
    form[&#34;activeval&#34;] = tuple((feat, fget(f&#34;{feat}_active&#34;, &#34;&#34;)) for feat in features)
    makeValSelect(self, form)

    form[&#34;scope&#34;] = fget(&#34;scope&#34;, SC_ALL)
    excludedTokens = fget(&#34;excludedtokens&#34;, &#34;&#34;)
    form[&#34;excludedtokens&#34;] = (
        {int(t) for t in excludedTokens.split(&#34;,&#34;)} if excludedTokens else set()
    )
    addData = fget(&#34;adddata&#34;, &#34;&#34;)
    form[&#34;adddata&#34;] = (
        AttrDict() if addData == &#34;&#34; else deepAttrDict(json.loads(unquote(addData)))
    )
    delData = fget(&#34;deldata&#34;, &#34;&#34;)
    form[&#34;deldata&#34;] = (
        AttrDict() if delData == &#34;&#34; else deepAttrDict(json.loads(unquote(delData)))
    )
    form[&#34;reportdel&#34;] = fget(&#34;reportdel&#34;, &#34;&#34;)
    form[&#34;reportadd&#34;] = fget(&#34;reportadd&#34;, &#34;&#34;)
    form[&#34;modwidgetstate&#34;] = fget(&#34;modwidgetstate&#34;, &#34;add&#34;)

    return form</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.servelib.initTemplate"><code class="name flex">
<span>def <span class="ident">initTemplate</span></span>(<span>self, app)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes the computation of the new page.</p>
<p>It collects the request data, gleans some info from the configuration
settings and the TF app, and initializes some data structures that
will collect further information for the page.</p>
<p>All bits and pieces that are needed during processing
the request and filling in the final HTML template find a place under
some key in the <code>templateData</code> dict which is stored in <code>self</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>self</code></strong> :&ensp;<code>object</code></dt>
<dd>A <code><a title="tf.browser.ner.annotate.Annotate" href="annotate.html#tf.browser.ner.annotate.Annotate">Annotate</a></code> object is expected.</dd>
<dt><strong><code>app</code></strong> :&ensp;<code>object</code></dt>
<dd>The TF app that represents the loaded corpus.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/23cf5da9dec27afb7a27c0b45bb902eec9f4bfcf/tf/browser/ner/servelib.py#L185-L229" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def initTemplate(self, app):
    &#34;&#34;&#34;Initializes the computation of the new page.

    It collects the request data, gleans some info from the configuration
    settings and the TF app, and initializes some data structures that
    will collect further information for the page.

    All bits and pieces that are needed during processing
    the request and filling in the final HTML template find a place under
    some key in the `templateData` dict which is stored in `self`.

    Parameters
    ----------
    self: object
        A `tf.browser.ner.annotate.Annotate` object is expected.
    app: object
        The TF app that represents the loaded corpus.
    &#34;&#34;&#34;
    settings = self.settings
    bucketType = settings.bucketType
    features = settings.features

    aContext = app.context
    appName = aContext.appName.replace(&#34;/&#34;, &#34; / &#34;)
    api = app.api
    F = api.F
    slotType = F.otype.slotType

    form = getFormData(self)
    resetForm = form[&#34;resetForm&#34;]

    templateData = AttrDict()
    templateData.toolkey = TOOLKEY
    templateData.buckettype = bucketType
    templateData.featurelist = &#34;,&#34;.join(features)

    for k, v in form.items():
        if not resetForm or k not in templateData:
            templateData[k] = v

    templateData.appname = appName
    templateData.slottype = slotType
    templateData.resetform = &#34;&#34;

    self.templateData = templateData</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.servelib.makeValSelect"><code class="name flex">
<span>def <span class="ident">makeValSelect</span></span>(<span>self, form)</span>
</code></dt>
<dd>
<div class="desc"><p>Set values for the entity features, based on the request.</p>
<p>On the web page, there are hidden input fields for these values.
These values are picked up and put in the form, under key <code>valselect</code>.
Depending on which button caused the submit, the NONE value is added
to each feature.</p>
<p>The idea is that when the user is still engaged in filtering buckets,
and there is an occurrence selected, the user should have the option
to sub-select occurrences that do not yet have an entity assigned.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>self</code></strong> :&ensp;<code>object</code></dt>
<dd>A <code><a title="tf.browser.ner.annotate.Annotate" href="annotate.html#tf.browser.ner.annotate.Annotate">Annotate</a></code> object is expected.</dd>
<dt><strong><code>form</code></strong> :&ensp;<code>dict</code></dt>
<dd>Contains the fields of the request data, in logical form.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/23cf5da9dec27afb7a27c0b45bb902eec9f4bfcf/tf/browser/ner/servelib.py#L98-L138" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeValSelect(self, form):
    &#34;&#34;&#34;Set values for the entity features, based on the request.

    On the web page, there are hidden input fields for these values.
    These values are picked up and put in the form, under key `valselect`.
    Depending on which button caused the submit, the NONE value is added
    to each feature.

    The idea is that when the user is still engaged in filtering buckets,
    and there is an occurrence selected, the user should have the option
    to sub-select occurrences that do not yet have an entity assigned.

    Parameters
    ----------
    self: object
        A `tf.browser.ner.annotate.Annotate` object is expected.
    form: dict
        Contains the fields of the request data, in logical form.
    &#34;&#34;&#34;
    settings = self.settings
    features = settings.features

    fget = request.form.get

    submitter = form[&#34;submitter&#34;]
    valSelectProto = {feat: fget(f&#34;{feat}_select&#34;, &#34;&#34;) for feat in features}
    valSelect = {}

    startSearch = submitter in {&#34;lookupq&#34;, &#34;lookupn&#34;, &#34;freebutton&#34;}

    for feat in features:
        valProto = valSelectProto[feat]
        valSelect[feat] = (
            set(&#34;&#34; if x == EMPTY else x for x in valProto.split(&#34;,&#34;))
            if valProto
            else set()
        )
        if startSearch:
            valSelect[feat].add(NONE)

    form[&#34;valselect&#34;] = valSelect</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../../tf/index.html">tf home</a> -
<a href="../../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.browser.ner" href="index.html">tf.browser.ner</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tf.browser.ner.servelib.adaptValSelect" href="#tf.browser.ner.servelib.adaptValSelect">adaptValSelect</a></code></li>
<li><code><a title="tf.browser.ner.servelib.findSetup" href="#tf.browser.ner.servelib.findSetup">findSetup</a></code></li>
<li><code><a title="tf.browser.ner.servelib.getFormData" href="#tf.browser.ner.servelib.getFormData">getFormData</a></code></li>
<li><code><a title="tf.browser.ner.servelib.initTemplate" href="#tf.browser.ner.servelib.initTemplate">initTemplate</a></code></li>
<li><code><a title="tf.browser.ner.servelib.makeValSelect" href="#tf.browser.ner.servelib.makeValSelect">makeValSelect</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>