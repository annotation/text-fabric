<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.browser.ner.ner API documentation</title>
<meta name="description" content="API for rule-based entity marking …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-GjqubOlYA6/wOZV7F31o2t4ogk4JGDGFa6XmL+BfAG0=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-qDPJ4nH38AgHyK3U6cvI6DBifA+7hPBo8mVoH6pyN9c=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.browser.ner.ner</code></h1>
</header>
<section id="section-intro">
<p>API for rule-based entity marking.</p>
<p>This module contains the top-level methods for applying annotation rules to a corpus.</p>
<p>To see how this fits among all the modules of this package, see
<code><a title="tf.browser.ner.annotate" href="annotate.html">tf.browser.ner.annotate</a></code> .</p>
<h1 id="programmatic-annotation-done-in-a-jupyter-notebook">Programmatic annotation done in a Jupyter Notebook</h1>
<p>If you have a spreadsheet with named entities, and for each entity a list of surface forms,
then this module takes care to read that spreadsheet, translate it to YAML,
and then use the YAML as instructions to add entity annotations to the corpus.</p>
<p>See this
<a href="https://nbviewer.jupyter.org/github/HuygensING/suriano/blob/main/programs/ner.ipynb">example notebook</a>.</p>
<p>Here are more details.</p>
<h2 id="starting-up">Starting up</h2>
<p>Load the relevant Python modules:</p>
<pre><code class="language-python">from tf.app import use
</code></pre>
<p>Load your corpus. There are two ways:</p>
<ul>
<li>
<p>Work with a local GitHub clone of the corpus in <code>~/HuygensING/suriano</code>:</p>
<p><code>A = use("HuygensING/suriano:clone", checkout="clone")</code></p>
</li>
<li>
<p>Or let TF auto-download the latest version and work with that:</p>
<p><code>A = use("HuygensING/suriano")</code></p>
</li>
</ul>
<p>Load the <code>Ner</code> module:</p>
<pre><code class="language-python">NE = A.makeNer()
</code></pre>
<p>The tool expects some input data to be present: configuration and spreadsheets with
instructions. They can be found in the <code>ner</code> directory.
If you work with a local GitHub clone, that data resides in
<code>~/github/HuygensING/suriano</code>
and if you work with an auto-downloaded copy of the data, it is in
<code>~/text-fabric-data/github/HuygensING/suriano</code>.</p>
<p>The output data of the tool ends up in the <code>_temp</code> directory, which ends up next
to the <code>ner</code> directory.</p>
<h2 id="the-entity-spreadsheets">The entity spreadsheets</h2>
<p>Here is an example:</p>
<p><img alt="browser" src="../../images/Annotate/spreadsheet.png"></p>
<p>In our example, the name of the spreadsheet containing this information is
<code>people.xlsx</code> and it can be found as <code>ner/sheets/people.xlsx</code></p>
<p>The spreadsheet will be read as follows:</p>
<ul>
<li>the first two rows will be skipped</li>
<li>after that, each row is taken to describe exactly one entity</li>
<li>the first column has the full and unique name for that entity</li>
<li>the second column contains the kind of the entity (you may choose your
keywords freely for this)</li>
<li>the third column contains a number of surface forms for this entity,
separated by <code>;</code></li>
<li>when the surface forms are peeled out, leading and trailing white-space will be
stripped</li>
<li>all other columns will be ignored for the moment; in later versions we may use
the information in those columns to fill in extra data about the entities;
but probably that information will not end up in TF features.</li>
</ul>
<p>During translation from XLSX to YAML the following happens:</p>
<ul>
<li>An identifier is distilled from the name of the entity;</li>
<li>Missing kind fields are filled with the default kind.</li>
</ul>
<p>These steps need some configuration information from the <code>ner/config.yaml</code> file.</p>
<p>Translation is done by</p>
<pre><code class="language-python">NE.readInstructions(&quot;people&quot;)
</code></pre>
<p>The resulting YAML ends up next to the
spreadsheet, and it looks like this:</p>
<pre><code class="language-yaml">christoffel.sticke:
  kind: PER
  name: Christoffel Sticke
  occSpecs: []
diederik.sticke:
  kind: PER
  name: Diederik Sticke
  occSpecs:
  - Dierck
  - Dirk
dirck.hartog:
  kind: PER
  name: Dirck Hartog
  occSpecs:
  - Dirich Hartocson
  - Hertocson
jan.baptist.roelants:
  kind: PER
  name: Jan-Baptist Roelants
  occSpecs:
  - Roelans
  - Rolans
</code></pre>
<h2 id="inventory">Inventory</h2>
<p>A first step is to find out how many occurrences we find in the corpus for these
surface forms:</p>
<pre><code class="language-python">NE.makeInventory()
NE.showInventory()
</code></pre>
<p>and the output looks like this</p>
<pre><code>...

cornelis.adriaensz       PER   Pach                     7 x Cornelis Adriaensz. Pack
david.marlot             PER   Morlot                   1 x David de Marlot
erick.dimmer             PER   Dimer                   11 x Erick Dimmer
erycius.puteanus         PER   Potiano                  2 x Erycius Puteanus
francesco.giustiniani    PER   Giustiniano             11 x Francesco Giustiniani
francois.doubleth        PER   Doublet                  2 x François Doubleth

...

Total 150
</code></pre>
<p>Entities that are in the spreadsheet, but not in the corpus are skipped.</p>
<h2 id="marking-up">Marking up</h2>
<p>In order to create annotations for these entities, we have to switch to an
annotation set. Let's start a new set and give it the name <code>power</code>.</p>
<pre><code class="language-python">NE.setSet(&quot;power&quot;)
</code></pre>
<p>If it turns out that <code>power</code> has already annotations, and you want to clear them, say</p>
<pre><code class="language-python">NE.resetSet(&quot;power&quot;)
</code></pre>
<p>Now we are ready for the big thing: creating the annotations:</p>
<pre><code class="language-python">NE.markEntities()
</code></pre>
<p>It outputs this message:</p>
<pre><code>Already present:     0 x
Added:             150 x
</code></pre>
<h2 id="inspection">Inspection</h2>
<p>We now revert to lower-level methods from the <code><a title="tf.browser.ner.annotate" href="annotate.html">tf.browser.ner.annotate</a></code> class to
inspect some of the results.</p>
<pre><code class="language-python">results = NE.filterContent(bFind=&quot;pach&quot;, bFindC=False, anyEnt=True, showStats=None)
</code></pre>
<p>Here we filtered the chunks (paragraphs) to those that contain the string <code>pach</code>,
in a case-insensitive way, and that contain at least one entity.</p>
<p>There 6 of them, and we can show them:</p>
<pre><code class="language-python">NE.showContent(results)
</code></pre>
<p><img alt="browser" src="../../images/Annotate/pach.png"></p>
<p>The resulting entities are in <code>_temp/power/entities.tsv</code> and look like this:</p>
<pre><code>erick.dimmer    PER     160196
isabella.clara.eugenia  PER     142613
gaspar.iii.coligny      PER     7877
isabella.clara.eugenia  PER     210499
john.vere       PER     94659
antonio.lando   PER     267755
isabella.clara.eugenia  PER     107069
isabella.clara.eugenia  PER     9162
michiel.pagani  PER     94366
isabella.clara.eugenia  PER     179208
isabella.clara.eugenia  PER     258933
hans.meinhard   PER     75039

...
</code></pre>
<p>Each line corresponds to a marked entity occurrence.
Lines consist of tab separated fields:</p>
<ul>
<li>entity identifier</li>
<li>entity kind</li>
<li>remaining fields: slots, i.e. the textual positions occupied by the occurrence.
Some entity occurrences consist of multiple words / tokens, hence have multiple
slots.</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/69c3f8c35133bfdd1e62af1d1705bac20abb14d0/tf/browser/ner/ner.py#L1-L525" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;API for rule-based entity marking.

This module contains the top-level methods for applying annotation rules to a corpus.

To see how this fits among all the modules of this package, see
`tf.browser.ner.annotate` .

# Programmatic annotation done in a Jupyter Notebook

If you have a spreadsheet with named entities, and for each entity a list of surface forms,
then this module takes care to read that spreadsheet, translate it to YAML,
and then use the YAML as instructions to add entity annotations to the corpus.

See this
[example notebook](https://nbviewer.jupyter.org/github/HuygensING/suriano/blob/main/programs/ner.ipynb).

Here are more details.

## Starting up

Load the relevant Python modules:

``` python
from tf.app import use
```

Load your corpus. There are two ways:

*   Work with a local GitHub clone of the corpus in `~/HuygensING/suriano`:

    ```
    A = use(&#34;HuygensING/suriano:clone&#34;, checkout=&#34;clone&#34;)
    ```

*   Or let TF auto-download the latest version and work with that:

    ```
    A = use(&#34;HuygensING/suriano&#34;)
    ```

Load the `Ner` module:

``` python
NE = A.makeNer()
```

The tool expects some input data to be present: configuration and spreadsheets with
instructions. They can be found in the `ner` directory.
If you work with a local GitHub clone, that data resides in
`~/github/HuygensING/suriano`
and if you work with an auto-downloaded copy of the data, it is in
`~/text-fabric-data/github/HuygensING/suriano`.

The output data of the tool ends up in the `_temp` directory, which ends up next
to the `ner` directory.

## The entity spreadsheets

Here is an example:

![browser](../../images/Annotate/spreadsheet.png)

In our example, the name of the spreadsheet containing this information is
`people.xlsx` and it can be found as `ner/sheets/people.xlsx`

The spreadsheet will be read as follows:

*   the first two rows will be skipped
*   after that, each row is taken to describe exactly one entity
*   the first column has the full and unique name for that entity
*   the second column contains the kind of the entity (you may choose your
    keywords freely for this)
*   the third column contains a number of surface forms for this entity,
    separated by `;`
*   when the surface forms are peeled out, leading and trailing white-space will be
    stripped
*   all other columns will be ignored for the moment; in later versions we may use
    the information in those columns to fill in extra data about the entities;
    but probably that information will not end up in TF features.

During translation from XLSX to YAML the following happens:

*   An identifier is distilled from the name of the entity;
*   Missing kind fields are filled with the default kind.

These steps need some configuration information from the `ner/config.yaml` file.

Translation is done by

``` python
NE.readInstructions(&#34;people&#34;)
```

The resulting YAML ends up next to the
spreadsheet, and it looks like this:

``` yaml
christoffel.sticke:
  kind: PER
  name: Christoffel Sticke
  occSpecs: []
diederik.sticke:
  kind: PER
  name: Diederik Sticke
  occSpecs:
  - Dierck
  - Dirk
dirck.hartog:
  kind: PER
  name: Dirck Hartog
  occSpecs:
  - Dirich Hartocson
  - Hertocson
jan.baptist.roelants:
  kind: PER
  name: Jan-Baptist Roelants
  occSpecs:
  - Roelans
  - Rolans
```

## Inventory

A first step is to find out how many occurrences we find in the corpus for these
surface forms:

``` python
NE.makeInventory()
NE.showInventory()
```

and the output looks like this

```
...

cornelis.adriaensz       PER   Pach                     7 x Cornelis Adriaensz. Pack
david.marlot             PER   Morlot                   1 x David de Marlot
erick.dimmer             PER   Dimer                   11 x Erick Dimmer
erycius.puteanus         PER   Potiano                  2 x Erycius Puteanus
francesco.giustiniani    PER   Giustiniano             11 x Francesco Giustiniani
francois.doubleth        PER   Doublet                  2 x François Doubleth

...

Total 150
```

Entities that are in the spreadsheet, but not in the corpus are skipped.

## Marking up

In order to create annotations for these entities, we have to switch to an
annotation set. Let&#39;s start a new set and give it the name `power`.

``` python
NE.setSet(&#34;power&#34;)
```

If it turns out that `power` has already annotations, and you want to clear them, say

``` python
NE.resetSet(&#34;power&#34;)
```

Now we are ready for the big thing: creating the annotations:

``` python
NE.markEntities()
```

It outputs this message:

```
Already present:     0 x
Added:             150 x
```

## Inspection

We now revert to lower-level methods from the `tf.browser.ner.annotate` class to
inspect some of the results.

``` python
results = NE.filterContent(bFind=&#34;pach&#34;, bFindC=False, anyEnt=True, showStats=None)
```

Here we filtered the chunks (paragraphs) to those that contain the string `pach`,
in a case-insensitive way, and that contain at least one entity.

There 6 of them, and we can show them:

``` python
NE.showContent(results)
```

![browser](../../images/Annotate/pach.png)

The resulting entities are in `_temp/power/entities.tsv` and look like this:

```
erick.dimmer    PER     160196
isabella.clara.eugenia  PER     142613
gaspar.iii.coligny      PER     7877
isabella.clara.eugenia  PER     210499
john.vere       PER     94659
antonio.lando   PER     267755
isabella.clara.eugenia  PER     107069
isabella.clara.eugenia  PER     9162
michiel.pagani  PER     94366
isabella.clara.eugenia  PER     179208
isabella.clara.eugenia  PER     258933
hans.meinhard   PER     75039

...
```

Each line corresponds to a marked entity occurrence.
Lines consist of tab separated fields:

*   entity identifier
*   entity kind
*   remaining fields: slots, i.e. the textual positions occupied by the occurrence.
    Some entity occurrences consist of multiple words / tokens, hence have multiple
    slots.

&#34;&#34;&#34;

from ...capable import CheckImport
from ...core.files import mTime, fileExists, readYaml, writeYaml
from ...core.helpers import console
from .helpers import normalize, toSmallId, toTokens
from .annotate import Annotate


class NER(Annotate):
    def __init__(self, app):
        &#34;&#34;&#34;Bulk entity annotation.

        Contains methods to translate spreadsheets to YAML files with markup
        instructions; to locate all relevant occurrences; and to mark them up
        properly.

        It is a high-level class, building on the lower-level tools provided
        by the Annotate class on which it is based.

        Parameters
        ----------
        app: object
            The object that corresponds to a loaded TF app for a corpus.
        &#34;&#34;&#34;
        super().__init__(app)
        if not self.properlySetup:
            return

        self.instructions = None
        &#34;&#34;&#34;Will contain the information in a spreadsheet for marking up entities.&#34;&#34;&#34;

        self.inventory = None
        &#34;&#34;&#34;Will contain the locations of all surface forms in the current instructions.
        &#34;&#34;&#34;

    def readInstructions(self, sheetName, force=False):
        &#34;&#34;&#34;Reads an Excel or YAML file with entity recognition instructions.

        If an Excel spreadsheet is present and no corresponding YAML file is present,
        or if the corresponding YAML file is out of data, the spreadsheet will be
        converted to YAML.

        The info in the resulting YAML file is stored as attribute
        `instructions` in this object.

        A report of the instructions will be shown in the output.

        Reading instructions will invalidate the `inventory` member of this object,
        which is the result of looking up all entities in the corpus on the basis
        of the instructions.

        Parameters
        ----------
        sheetName: string
            The file name without extension of the spreadsheet.
            The spreadsheet is expected in the `ner/sheets` directory.
            The YAML file ends up in the same directory, with the same name and
            extension `.yaml`
        force: boolean, optional False
            If True, the conversion from Excel to YAML will take place anyhow, provided
            the Excel sheet exists.
        &#34;&#34;&#34;
        CI = CheckImport(&#34;openpyxl&#34;)
        if CI.importOK(hint=True):
            openpyxl = CI.importGet()
            load_workbook = openpyxl.load_workbook
        else:
            return

        if not self.properlySetup:
            return

        sheetDir = self.sheetDir

        xlsFile = f&#34;{sheetDir}/{sheetName}.xlsx&#34;
        yamlFile = f&#34;{sheetDir}/{sheetName}.yaml&#34;

        doConvert = False

        if not fileExists(yamlFile):
            if not fileExists(xlsFile):
                console(f&#34;no instructions found: {yamlFile} and {xlsFile} don&#39;t exist&#34;)
                return

            doConvert = True
        else:
            if fileExists(xlsFile) and force or (mTime(yamlFile) &lt; mTime(xlsFile)):
                doConvert = True

        if doConvert:
            settings = self.settings
            transform = settings.transform
            keywordFeatures = settings.keywordFeatures
            kindFeature = keywordFeatures[0]
            defaultValues = settings.defaultValues

            wb = load_workbook(xlsFile, data_only=True)
            ws = wb.active

            (headRow, subHeadRow, *rows) = list(ws.rows)
            rows = [row for row in rows if any(c.value for c in row)]

            defaultKind = defaultValues.get(kindFeature, &#34;&#34;)

            info = {}
            namesByOrigEid = {}
            eidByName = {}

            for r, row in enumerate(ws.rows):
                if r in {0, 1}:
                    continue
                if not any(c.value for c in row):
                    continue

                (name, kind, synonymStr) = (
                    normalize(row[i].value or &#34;&#34;) for i in range(3)
                )
                synonyms = sorted(
                    set()
                    if not synonymStr
                    else {normalize(x) for x in synonymStr.split(&#34;;&#34;)}
                )
                if not name:
                    name = synonyms[0] if synonyms else &#34;&#34;
                    if name == &#34;&#34;:
                        console(f&#34;Row {r + 1:&gt;3}: no entity name and no synonyms&#34;)
                        continue
                    else:
                        console(f&#34;Row {r + 1:&gt;3}: no entity name, supplied {name}&#34;)

                if not kind:
                    kind = defaultKind

                i = 0
                while name in eidByName:
                    i += 1
                    name = f&#34;{name} ({i})&#34;

                eid = toSmallId(name, transform=transform)
                namesByOrigEid.setdefault(eid, []).append(name)

                i = 0
                while eid in info:
                    i += 1
                    eid = f&#34;{eid}.{i}&#34;

                eidByName[name] = eid

                occSpecs = sorted(synonyms, key=lambda x: -len(x))
                info[eid] = {&#34;name&#34;: name, kindFeature: kind, &#34;occSpecs&#34;: occSpecs}

            for origEid, names in sorted(namesByOrigEid.items()):
                if len(names) == 1:
                    continue
                console(f&#34;Multiple names for candidate identifier {origEid}:&#34;)
                for name in names:
                    newEid = eidByName[name]
                    console(f&#34;&#34;&#34;\tIdentifier {newEid} assigned to name &#34;{name}&#34; &#34;&#34;&#34;)
            writeYaml(info, asFile=yamlFile)

        else:
            info = readYaml(asFile=yamlFile)

        namesByOcc = {}

        for eInfo in info.values():
            name = eInfo[&#34;name&#34;]
            occSpecs = eInfo[&#34;occSpecs&#34;]
            for occSpec in occSpecs:
                namesByOcc.setdefault(occSpec, []).append(name)

        nEid = len(info)
        nOcc = sum(len(x[&#34;occSpecs&#34;]) for x in info.values())
        noOccs = sum(1 for x in info.values() if len(x[&#34;occSpecs&#34;]) == 0)
        console(f&#34;{nEid} entities with {nOcc} occurrence specs&#34;)
        console(f&#34;{noOccs} entities do not have occurrence specifiers&#34;)

        nm = 0

        for occSpec, names in sorted(namesByOcc.items()):
            if len(names) == 1:
                continue

            console(f&#34;&#34;&#34;&#34;{occSpec}&#34; used for:&#34;&#34;&#34;)
            for name in names:
                console(f&#34;\t{name}&#34;)
            nm += 1

        if nm == 0:
            console(&#34;All occurrence specifiers are unambiguous&#34;)
        else:
            console(f&#34;{nm} occurrence specifiers are ambiguous&#34;)

        self.instructions = readYaml(asFile=yamlFile)
        self.inventory = None

    def makeInventory(self):
        &#34;&#34;&#34;Explores the corpus for the surface forms mentioned in the instructions.

        The instructions are present in the `instructions` attribute of the object.

        The resulting inventory is stored in the `inventory` member of
        the object.

        It is a dictionary, keyed by sequences of tokens, whose values are the
        slot sequences where those token sequences occur in the corpus.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        instructions = self.instructions
        settings = self.settings
        spaceEscaped = settings.spaceEscaped

        qSets = set()

        for info in instructions.values():
            for occSpec in info.occSpecs:
                qSets.add(toTokens(occSpec, spaceEscaped=spaceEscaped))

        self.inventory = self.findOccs(qSets)

    def showInventory(self):
        &#34;&#34;&#34;Shows the inventory.

        The surface forms in the inventory are put into the context of the entities
        of which they are surface forms.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        instructions = self.instructions
        inventory = self.inventory
        settings = self.settings
        spaceEscaped = settings.spaceEscaped

        total = 0

        for eid, info in instructions.items():
            name = info.name
            kind = info.kind
            occSpecs = info.occSpecs

            for occSpec in occSpecs:
                matches = inventory.get(toTokens(occSpec, spaceEscaped=spaceEscaped), None)
                if matches is None:
                    continue
                n = len(matches)
                total += n
                console(f&#34;{eid:&lt;24} {kind:&lt;5} {occSpec:&lt;20} {n:&gt;5} x {name}&#34;)

        console(f&#34;Total {total}&#34;)

    def markEntities(self):
        &#34;&#34;&#34;Marks up the members of the inventory as entities.

        The instructions contain the entity identifier and the entity kind that
        have to be assigned to the surface forms.

        The inventory knows where the occurrences of the surface forms are.
        If there is no inventory yet, it will be created.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        inventory = self.inventory
        instructions = self.instructions
        settings = self.settings
        spaceEscaped = settings.spaceEscaped
        keywordFeatures = settings.keywordFeatures
        kindFeature = keywordFeatures[0]

        newEntities = []

        qSets = set()
        fValsByQTokens = {}

        for eid, info in instructions.items():
            kind = info[kindFeature]

            occSpecs = info.occSpecs
            if not len(occSpecs):
                continue

            for occSpec in info.occSpecs:
                qTokens = toTokens(occSpec, spaceEscaped=spaceEscaped)
                fValsByQTokens.setdefault(qTokens, set()).add((eid, kind))
                qSets.add(qTokens)

        if inventory is None:
            inventory = self.findOccs(qSets)
            self.inventory = inventory

        for qTokens, matches in inventory.items():
            for fVals in fValsByQTokens[qTokens]:
                newEntities.append((fVals, matches))

        self.addEntities(newEntities, silent=False)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.browser.ner.ner.NER"><code class="flex name class">
<span>class <span class="ident">NER</span></span>
<span>(</span><span>app)</span>
</code></dt>
<dd>
<div class="desc"><p>Bulk entity annotation.</p>
<p>Contains methods to translate spreadsheets to YAML files with markup
instructions; to locate all relevant occurrences; and to mark them up
properly.</p>
<p>It is a high-level class, building on the lower-level tools provided
by the Annotate class on which it is based.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>app</code></strong> :&ensp;<code>object</code></dt>
<dd>The object that corresponds to a loaded TF app for a corpus.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/69c3f8c35133bfdd1e62af1d1705bac20abb14d0/tf/browser/ner/ner.py#L236-L525" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class NER(Annotate):
    def __init__(self, app):
        &#34;&#34;&#34;Bulk entity annotation.

        Contains methods to translate spreadsheets to YAML files with markup
        instructions; to locate all relevant occurrences; and to mark them up
        properly.

        It is a high-level class, building on the lower-level tools provided
        by the Annotate class on which it is based.

        Parameters
        ----------
        app: object
            The object that corresponds to a loaded TF app for a corpus.
        &#34;&#34;&#34;
        super().__init__(app)
        if not self.properlySetup:
            return

        self.instructions = None
        &#34;&#34;&#34;Will contain the information in a spreadsheet for marking up entities.&#34;&#34;&#34;

        self.inventory = None
        &#34;&#34;&#34;Will contain the locations of all surface forms in the current instructions.
        &#34;&#34;&#34;

    def readInstructions(self, sheetName, force=False):
        &#34;&#34;&#34;Reads an Excel or YAML file with entity recognition instructions.

        If an Excel spreadsheet is present and no corresponding YAML file is present,
        or if the corresponding YAML file is out of data, the spreadsheet will be
        converted to YAML.

        The info in the resulting YAML file is stored as attribute
        `instructions` in this object.

        A report of the instructions will be shown in the output.

        Reading instructions will invalidate the `inventory` member of this object,
        which is the result of looking up all entities in the corpus on the basis
        of the instructions.

        Parameters
        ----------
        sheetName: string
            The file name without extension of the spreadsheet.
            The spreadsheet is expected in the `ner/sheets` directory.
            The YAML file ends up in the same directory, with the same name and
            extension `.yaml`
        force: boolean, optional False
            If True, the conversion from Excel to YAML will take place anyhow, provided
            the Excel sheet exists.
        &#34;&#34;&#34;
        CI = CheckImport(&#34;openpyxl&#34;)
        if CI.importOK(hint=True):
            openpyxl = CI.importGet()
            load_workbook = openpyxl.load_workbook
        else:
            return

        if not self.properlySetup:
            return

        sheetDir = self.sheetDir

        xlsFile = f&#34;{sheetDir}/{sheetName}.xlsx&#34;
        yamlFile = f&#34;{sheetDir}/{sheetName}.yaml&#34;

        doConvert = False

        if not fileExists(yamlFile):
            if not fileExists(xlsFile):
                console(f&#34;no instructions found: {yamlFile} and {xlsFile} don&#39;t exist&#34;)
                return

            doConvert = True
        else:
            if fileExists(xlsFile) and force or (mTime(yamlFile) &lt; mTime(xlsFile)):
                doConvert = True

        if doConvert:
            settings = self.settings
            transform = settings.transform
            keywordFeatures = settings.keywordFeatures
            kindFeature = keywordFeatures[0]
            defaultValues = settings.defaultValues

            wb = load_workbook(xlsFile, data_only=True)
            ws = wb.active

            (headRow, subHeadRow, *rows) = list(ws.rows)
            rows = [row for row in rows if any(c.value for c in row)]

            defaultKind = defaultValues.get(kindFeature, &#34;&#34;)

            info = {}
            namesByOrigEid = {}
            eidByName = {}

            for r, row in enumerate(ws.rows):
                if r in {0, 1}:
                    continue
                if not any(c.value for c in row):
                    continue

                (name, kind, synonymStr) = (
                    normalize(row[i].value or &#34;&#34;) for i in range(3)
                )
                synonyms = sorted(
                    set()
                    if not synonymStr
                    else {normalize(x) for x in synonymStr.split(&#34;;&#34;)}
                )
                if not name:
                    name = synonyms[0] if synonyms else &#34;&#34;
                    if name == &#34;&#34;:
                        console(f&#34;Row {r + 1:&gt;3}: no entity name and no synonyms&#34;)
                        continue
                    else:
                        console(f&#34;Row {r + 1:&gt;3}: no entity name, supplied {name}&#34;)

                if not kind:
                    kind = defaultKind

                i = 0
                while name in eidByName:
                    i += 1
                    name = f&#34;{name} ({i})&#34;

                eid = toSmallId(name, transform=transform)
                namesByOrigEid.setdefault(eid, []).append(name)

                i = 0
                while eid in info:
                    i += 1
                    eid = f&#34;{eid}.{i}&#34;

                eidByName[name] = eid

                occSpecs = sorted(synonyms, key=lambda x: -len(x))
                info[eid] = {&#34;name&#34;: name, kindFeature: kind, &#34;occSpecs&#34;: occSpecs}

            for origEid, names in sorted(namesByOrigEid.items()):
                if len(names) == 1:
                    continue
                console(f&#34;Multiple names for candidate identifier {origEid}:&#34;)
                for name in names:
                    newEid = eidByName[name]
                    console(f&#34;&#34;&#34;\tIdentifier {newEid} assigned to name &#34;{name}&#34; &#34;&#34;&#34;)
            writeYaml(info, asFile=yamlFile)

        else:
            info = readYaml(asFile=yamlFile)

        namesByOcc = {}

        for eInfo in info.values():
            name = eInfo[&#34;name&#34;]
            occSpecs = eInfo[&#34;occSpecs&#34;]
            for occSpec in occSpecs:
                namesByOcc.setdefault(occSpec, []).append(name)

        nEid = len(info)
        nOcc = sum(len(x[&#34;occSpecs&#34;]) for x in info.values())
        noOccs = sum(1 for x in info.values() if len(x[&#34;occSpecs&#34;]) == 0)
        console(f&#34;{nEid} entities with {nOcc} occurrence specs&#34;)
        console(f&#34;{noOccs} entities do not have occurrence specifiers&#34;)

        nm = 0

        for occSpec, names in sorted(namesByOcc.items()):
            if len(names) == 1:
                continue

            console(f&#34;&#34;&#34;&#34;{occSpec}&#34; used for:&#34;&#34;&#34;)
            for name in names:
                console(f&#34;\t{name}&#34;)
            nm += 1

        if nm == 0:
            console(&#34;All occurrence specifiers are unambiguous&#34;)
        else:
            console(f&#34;{nm} occurrence specifiers are ambiguous&#34;)

        self.instructions = readYaml(asFile=yamlFile)
        self.inventory = None

    def makeInventory(self):
        &#34;&#34;&#34;Explores the corpus for the surface forms mentioned in the instructions.

        The instructions are present in the `instructions` attribute of the object.

        The resulting inventory is stored in the `inventory` member of
        the object.

        It is a dictionary, keyed by sequences of tokens, whose values are the
        slot sequences where those token sequences occur in the corpus.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        instructions = self.instructions
        settings = self.settings
        spaceEscaped = settings.spaceEscaped

        qSets = set()

        for info in instructions.values():
            for occSpec in info.occSpecs:
                qSets.add(toTokens(occSpec, spaceEscaped=spaceEscaped))

        self.inventory = self.findOccs(qSets)

    def showInventory(self):
        &#34;&#34;&#34;Shows the inventory.

        The surface forms in the inventory are put into the context of the entities
        of which they are surface forms.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        instructions = self.instructions
        inventory = self.inventory
        settings = self.settings
        spaceEscaped = settings.spaceEscaped

        total = 0

        for eid, info in instructions.items():
            name = info.name
            kind = info.kind
            occSpecs = info.occSpecs

            for occSpec in occSpecs:
                matches = inventory.get(toTokens(occSpec, spaceEscaped=spaceEscaped), None)
                if matches is None:
                    continue
                n = len(matches)
                total += n
                console(f&#34;{eid:&lt;24} {kind:&lt;5} {occSpec:&lt;20} {n:&gt;5} x {name}&#34;)

        console(f&#34;Total {total}&#34;)

    def markEntities(self):
        &#34;&#34;&#34;Marks up the members of the inventory as entities.

        The instructions contain the entity identifier and the entity kind that
        have to be assigned to the surface forms.

        The inventory knows where the occurrences of the surface forms are.
        If there is no inventory yet, it will be created.
        &#34;&#34;&#34;
        if not self.properlySetup:
            return

        inventory = self.inventory
        instructions = self.instructions
        settings = self.settings
        spaceEscaped = settings.spaceEscaped
        keywordFeatures = settings.keywordFeatures
        kindFeature = keywordFeatures[0]

        newEntities = []

        qSets = set()
        fValsByQTokens = {}

        for eid, info in instructions.items():
            kind = info[kindFeature]

            occSpecs = info.occSpecs
            if not len(occSpecs):
                continue

            for occSpec in info.occSpecs:
                qTokens = toTokens(occSpec, spaceEscaped=spaceEscaped)
                fValsByQTokens.setdefault(qTokens, set()).add((eid, kind))
                qSets.add(qTokens)

        if inventory is None:
            inventory = self.findOccs(qSets)
            self.inventory = inventory

        for qTokens, matches in inventory.items():
            for fVals in fValsByQTokens[qTokens]:
                newEntities.append((fVals, matches))

        self.addEntities(newEntities, silent=False)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tf.browser.ner.annotate.Annotate" href="annotate.html#tf.browser.ner.annotate.Annotate">Annotate</a></li>
<li><a title="tf.browser.ner.sets.Sets" href="sets.html#tf.browser.ner.sets.Sets">Sets</a></li>
<li><a title="tf.browser.ner.data.Data" href="data.html#tf.browser.ner.data.Data">Data</a></li>
<li><a title="tf.browser.ner.corpus.Corpus" href="corpus.html#tf.browser.ner.corpus.Corpus">Corpus</a></li>
<li><a title="tf.browser.ner.settings.Settings" href="settings.html#tf.browser.ner.settings.Settings">Settings</a></li>
<li><a title="tf.browser.ner.show.Show" href="show.html#tf.browser.ner.show.Show">Show</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="tf.browser.ner.ner.NER.instructions"><code class="name">var <span class="ident">instructions</span></code></dt>
<dd>
<div class="desc"><p>Will contain the information in a spreadsheet for marking up entities.</p></div>
</dd>
<dt id="tf.browser.ner.ner.NER.inventory"><code class="name">var <span class="ident">inventory</span></code></dt>
<dd>
<div class="desc"><p>Will contain the locations of all surface forms in the current instructions.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tf.browser.ner.ner.NER.makeInventory"><code class="name flex">
<span>def <span class="ident">makeInventory</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Explores the corpus for the surface forms mentioned in the instructions.</p>
<p>The instructions are present in the <code>instructions</code> attribute of the object.</p>
<p>The resulting inventory is stored in the <code>inventory</code> member of
the object.</p>
<p>It is a dictionary, keyed by sequences of tokens, whose values are the
slot sequences where those token sequences occur in the corpus.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/69c3f8c35133bfdd1e62af1d1705bac20abb14d0/tf/browser/ner/ner.py#L424-L448" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeInventory(self):
    &#34;&#34;&#34;Explores the corpus for the surface forms mentioned in the instructions.

    The instructions are present in the `instructions` attribute of the object.

    The resulting inventory is stored in the `inventory` member of
    the object.

    It is a dictionary, keyed by sequences of tokens, whose values are the
    slot sequences where those token sequences occur in the corpus.
    &#34;&#34;&#34;
    if not self.properlySetup:
        return

    instructions = self.instructions
    settings = self.settings
    spaceEscaped = settings.spaceEscaped

    qSets = set()

    for info in instructions.values():
        for occSpec in info.occSpecs:
            qSets.add(toTokens(occSpec, spaceEscaped=spaceEscaped))

    self.inventory = self.findOccs(qSets)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.ner.NER.markEntities"><code class="name flex">
<span>def <span class="ident">markEntities</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Marks up the members of the inventory as entities.</p>
<p>The instructions contain the entity identifier and the entity kind that
have to be assigned to the surface forms.</p>
<p>The inventory knows where the occurrences of the surface forms are.
If there is no inventory yet, it will be created.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/69c3f8c35133bfdd1e62af1d1705bac20abb14d0/tf/browser/ner/ner.py#L481-L525" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def markEntities(self):
    &#34;&#34;&#34;Marks up the members of the inventory as entities.

    The instructions contain the entity identifier and the entity kind that
    have to be assigned to the surface forms.

    The inventory knows where the occurrences of the surface forms are.
    If there is no inventory yet, it will be created.
    &#34;&#34;&#34;
    if not self.properlySetup:
        return

    inventory = self.inventory
    instructions = self.instructions
    settings = self.settings
    spaceEscaped = settings.spaceEscaped
    keywordFeatures = settings.keywordFeatures
    kindFeature = keywordFeatures[0]

    newEntities = []

    qSets = set()
    fValsByQTokens = {}

    for eid, info in instructions.items():
        kind = info[kindFeature]

        occSpecs = info.occSpecs
        if not len(occSpecs):
            continue

        for occSpec in info.occSpecs:
            qTokens = toTokens(occSpec, spaceEscaped=spaceEscaped)
            fValsByQTokens.setdefault(qTokens, set()).add((eid, kind))
            qSets.add(qTokens)

    if inventory is None:
        inventory = self.findOccs(qSets)
        self.inventory = inventory

    for qTokens, matches in inventory.items():
        for fVals in fValsByQTokens[qTokens]:
            newEntities.append((fVals, matches))

    self.addEntities(newEntities, silent=False)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.ner.NER.readInstructions"><code class="name flex">
<span>def <span class="ident">readInstructions</span></span>(<span>self, sheetName, force=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads an Excel or YAML file with entity recognition instructions.</p>
<p>If an Excel spreadsheet is present and no corresponding YAML file is present,
or if the corresponding YAML file is out of data, the spreadsheet will be
converted to YAML.</p>
<p>The info in the resulting YAML file is stored as attribute
<code>instructions</code> in this object.</p>
<p>A report of the instructions will be shown in the output.</p>
<p>Reading instructions will invalidate the <code>inventory</code> member of this object,
which is the result of looking up all entities in the corpus on the basis
of the instructions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sheetName</code></strong> :&ensp;<code>string</code></dt>
<dd>The file name without extension of the spreadsheet.
The spreadsheet is expected in the <code>ner/sheets</code> directory.
The YAML file ends up in the same directory, with the same name and
extension <code>.yaml</code></dd>
<dt><strong><code>force</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If True, the conversion from Excel to YAML will take place anyhow, provided
the Excel sheet exists.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/69c3f8c35133bfdd1e62af1d1705bac20abb14d0/tf/browser/ner/ner.py#L263-L422" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readInstructions(self, sheetName, force=False):
    &#34;&#34;&#34;Reads an Excel or YAML file with entity recognition instructions.

    If an Excel spreadsheet is present and no corresponding YAML file is present,
    or if the corresponding YAML file is out of data, the spreadsheet will be
    converted to YAML.

    The info in the resulting YAML file is stored as attribute
    `instructions` in this object.

    A report of the instructions will be shown in the output.

    Reading instructions will invalidate the `inventory` member of this object,
    which is the result of looking up all entities in the corpus on the basis
    of the instructions.

    Parameters
    ----------
    sheetName: string
        The file name without extension of the spreadsheet.
        The spreadsheet is expected in the `ner/sheets` directory.
        The YAML file ends up in the same directory, with the same name and
        extension `.yaml`
    force: boolean, optional False
        If True, the conversion from Excel to YAML will take place anyhow, provided
        the Excel sheet exists.
    &#34;&#34;&#34;
    CI = CheckImport(&#34;openpyxl&#34;)
    if CI.importOK(hint=True):
        openpyxl = CI.importGet()
        load_workbook = openpyxl.load_workbook
    else:
        return

    if not self.properlySetup:
        return

    sheetDir = self.sheetDir

    xlsFile = f&#34;{sheetDir}/{sheetName}.xlsx&#34;
    yamlFile = f&#34;{sheetDir}/{sheetName}.yaml&#34;

    doConvert = False

    if not fileExists(yamlFile):
        if not fileExists(xlsFile):
            console(f&#34;no instructions found: {yamlFile} and {xlsFile} don&#39;t exist&#34;)
            return

        doConvert = True
    else:
        if fileExists(xlsFile) and force or (mTime(yamlFile) &lt; mTime(xlsFile)):
            doConvert = True

    if doConvert:
        settings = self.settings
        transform = settings.transform
        keywordFeatures = settings.keywordFeatures
        kindFeature = keywordFeatures[0]
        defaultValues = settings.defaultValues

        wb = load_workbook(xlsFile, data_only=True)
        ws = wb.active

        (headRow, subHeadRow, *rows) = list(ws.rows)
        rows = [row for row in rows if any(c.value for c in row)]

        defaultKind = defaultValues.get(kindFeature, &#34;&#34;)

        info = {}
        namesByOrigEid = {}
        eidByName = {}

        for r, row in enumerate(ws.rows):
            if r in {0, 1}:
                continue
            if not any(c.value for c in row):
                continue

            (name, kind, synonymStr) = (
                normalize(row[i].value or &#34;&#34;) for i in range(3)
            )
            synonyms = sorted(
                set()
                if not synonymStr
                else {normalize(x) for x in synonymStr.split(&#34;;&#34;)}
            )
            if not name:
                name = synonyms[0] if synonyms else &#34;&#34;
                if name == &#34;&#34;:
                    console(f&#34;Row {r + 1:&gt;3}: no entity name and no synonyms&#34;)
                    continue
                else:
                    console(f&#34;Row {r + 1:&gt;3}: no entity name, supplied {name}&#34;)

            if not kind:
                kind = defaultKind

            i = 0
            while name in eidByName:
                i += 1
                name = f&#34;{name} ({i})&#34;

            eid = toSmallId(name, transform=transform)
            namesByOrigEid.setdefault(eid, []).append(name)

            i = 0
            while eid in info:
                i += 1
                eid = f&#34;{eid}.{i}&#34;

            eidByName[name] = eid

            occSpecs = sorted(synonyms, key=lambda x: -len(x))
            info[eid] = {&#34;name&#34;: name, kindFeature: kind, &#34;occSpecs&#34;: occSpecs}

        for origEid, names in sorted(namesByOrigEid.items()):
            if len(names) == 1:
                continue
            console(f&#34;Multiple names for candidate identifier {origEid}:&#34;)
            for name in names:
                newEid = eidByName[name]
                console(f&#34;&#34;&#34;\tIdentifier {newEid} assigned to name &#34;{name}&#34; &#34;&#34;&#34;)
        writeYaml(info, asFile=yamlFile)

    else:
        info = readYaml(asFile=yamlFile)

    namesByOcc = {}

    for eInfo in info.values():
        name = eInfo[&#34;name&#34;]
        occSpecs = eInfo[&#34;occSpecs&#34;]
        for occSpec in occSpecs:
            namesByOcc.setdefault(occSpec, []).append(name)

    nEid = len(info)
    nOcc = sum(len(x[&#34;occSpecs&#34;]) for x in info.values())
    noOccs = sum(1 for x in info.values() if len(x[&#34;occSpecs&#34;]) == 0)
    console(f&#34;{nEid} entities with {nOcc} occurrence specs&#34;)
    console(f&#34;{noOccs} entities do not have occurrence specifiers&#34;)

    nm = 0

    for occSpec, names in sorted(namesByOcc.items()):
        if len(names) == 1:
            continue

        console(f&#34;&#34;&#34;&#34;{occSpec}&#34; used for:&#34;&#34;&#34;)
        for name in names:
            console(f&#34;\t{name}&#34;)
        nm += 1

    if nm == 0:
        console(&#34;All occurrence specifiers are unambiguous&#34;)
    else:
        console(f&#34;{nm} occurrence specifiers are ambiguous&#34;)

    self.instructions = readYaml(asFile=yamlFile)
    self.inventory = None</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.ner.NER.showInventory"><code class="name flex">
<span>def <span class="ident">showInventory</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Shows the inventory.</p>
<p>The surface forms in the inventory are put into the context of the entities
of which they are surface forms.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/69c3f8c35133bfdd1e62af1d1705bac20abb14d0/tf/browser/ner/ner.py#L450-L479" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def showInventory(self):
    &#34;&#34;&#34;Shows the inventory.

    The surface forms in the inventory are put into the context of the entities
    of which they are surface forms.
    &#34;&#34;&#34;
    if not self.properlySetup:
        return

    instructions = self.instructions
    inventory = self.inventory
    settings = self.settings
    spaceEscaped = settings.spaceEscaped

    total = 0

    for eid, info in instructions.items():
        name = info.name
        kind = info.kind
        occSpecs = info.occSpecs

        for occSpec in occSpecs:
            matches = inventory.get(toTokens(occSpec, spaceEscaped=spaceEscaped), None)
            if matches is None:
                continue
            n = len(matches)
            total += n
            console(f&#34;{eid:&lt;24} {kind:&lt;5} {occSpec:&lt;20} {n:&gt;5} x {name}&#34;)

    console(f&#34;Total {total}&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tf.browser.ner.annotate.Annotate" href="annotate.html#tf.browser.ner.annotate.Annotate">Annotate</a></b></code>:
<ul class="hlist">
<li><code><a title="tf.browser.ner.annotate.Annotate.addEntities" href="data.html#tf.browser.ner.data.Data.addEntities">addEntities</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.addEntity" href="data.html#tf.browser.ner.data.Data.addEntity">addEntity</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.addEntityRich" href="data.html#tf.browser.ner.data.Data.addEntityRich">addEntityRich</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.annoSet" href="sets.html#tf.browser.ner.sets.Sets.annoSet">annoSet</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.annoSetRep" href="sets.html#tf.browser.ner.sets.Sets.annoSetRep">annoSetRep</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.checkBuckets" href="corpus.html#tf.browser.ner.corpus.Corpus.checkBuckets">checkBuckets</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.checkFeature" href="corpus.html#tf.browser.ner.corpus.Corpus.checkFeature">checkFeature</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.console" href="settings.html#tf.browser.ner.settings.Settings.console">console</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.delEntity" href="data.html#tf.browser.ner.data.Data.delEntity">delEntity</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.delEntityRich" href="data.html#tf.browser.ner.data.Data.delEntityRich">delEntityRich</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.featureDefault" href="corpus.html#tf.browser.ner.corpus.Corpus.featureDefault">featureDefault</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.filterContent" href="annotate.html#tf.browser.ner.annotate.Annotate.filterContent">filterContent</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.findOccs" href="annotate.html#tf.browser.ner.annotate.Annotate.findOccs">findOccs</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.fromSource" href="data.html#tf.browser.ner.data.Data.fromSource">fromSource</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.get0" href="corpus.html#tf.browser.ner.corpus.Corpus.get0">get0</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.get1" href="corpus.html#tf.browser.ner.corpus.Corpus.get1">get1</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.getAfter" href="corpus.html#tf.browser.ner.corpus.Corpus.getAfter">getAfter</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.getBucketNodes" href="corpus.html#tf.browser.ner.corpus.Corpus.getBucketNodes">getBucketNodes</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.getContext" href="corpus.html#tf.browser.ner.corpus.Corpus.getContext">getContext</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.getEntityNodes" href="corpus.html#tf.browser.ner.corpus.Corpus.getEntityNodes">getEntityNodes</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.getFVal" href="corpus.html#tf.browser.ner.corpus.Corpus.getFVal">getFVal</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.getSetData" href="sets.html#tf.browser.ner.sets.Sets.getSetData">getSetData</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.getSlots" href="corpus.html#tf.browser.ner.corpus.Corpus.getSlots">getSlots</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.getStr" href="corpus.html#tf.browser.ner.corpus.Corpus.getStr">getStr</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.getStrings" href="corpus.html#tf.browser.ner.corpus.Corpus.getStrings">getStrings</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.getText" href="corpus.html#tf.browser.ner.corpus.Corpus.getText">getText</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.getTextR" href="corpus.html#tf.browser.ner.corpus.Corpus.getTextR">getTextR</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.getTokens" href="corpus.html#tf.browser.ner.corpus.Corpus.getTokens">getTokens</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.loadData" href="data.html#tf.browser.ner.data.Data.loadData">loadData</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.mergeEntities" href="data.html#tf.browser.ner.data.Data.mergeEntities">mergeEntities</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.process" href="data.html#tf.browser.ner.data.Data.process">process</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.properlySetup" href="corpus.html#tf.browser.ner.corpus.Corpus.properlySetup">properlySetup</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.resetSet" href="sets.html#tf.browser.ner.sets.Sets.resetSet">resetSet</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.saveEntitiesAs" href="data.html#tf.browser.ner.data.Data.saveEntitiesAs">saveEntitiesAs</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.sectionHead" href="corpus.html#tf.browser.ner.corpus.Corpus.sectionHead">sectionHead</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.setDel" href="sets.html#tf.browser.ner.sets.Sets.setDel">setDel</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.setDup" href="sets.html#tf.browser.ner.sets.Sets.setDup">setDup</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.setMove" href="sets.html#tf.browser.ner.sets.Sets.setMove">setMove</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.setNames" href="sets.html#tf.browser.ner.sets.Sets.setNames">setNames</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.setSet" href="sets.html#tf.browser.ner.sets.Sets.setSet">setSet</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.showContent" href="show.html#tf.browser.ner.show.Show.showContent">showContent</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.showEntities" href="show.html#tf.browser.ner.show.Show.showEntities">showEntities</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.showEntityOverview" href="show.html#tf.browser.ner.show.Show.showEntityOverview">showEntityOverview</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.slotType" href="corpus.html#tf.browser.ner.corpus.Corpus.slotType">slotType</a></code></li>
<li><code><a title="tf.browser.ner.annotate.Annotate.weedEntities" href="data.html#tf.browser.ner.data.Data.weedEntities">weedEntities</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../../tf/index.html">tf home</a> -
<a href="../../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#programmatic-annotation-done-in-a-jupyter-notebook">Programmatic annotation done in a Jupyter Notebook</a><ul>
<li><a href="#starting-up">Starting up</a></li>
<li><a href="#the-entity-spreadsheets">The entity spreadsheets</a></li>
<li><a href="#inventory">Inventory</a></li>
<li><a href="#marking-up">Marking up</a></li>
<li><a href="#inspection">Inspection</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.browser.ner" href="index.html">tf.browser.ner</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.browser.ner.ner.NER" href="#tf.browser.ner.ner.NER">NER</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.browser.ner.ner.NER.instructions" href="#tf.browser.ner.ner.NER.instructions">instructions</a></code></li>
<li><code><a title="tf.browser.ner.ner.NER.inventory" href="#tf.browser.ner.ner.NER.inventory">inventory</a></code></li>
<li><code><a title="tf.browser.ner.ner.NER.makeInventory" href="#tf.browser.ner.ner.NER.makeInventory">makeInventory</a></code></li>
<li><code><a title="tf.browser.ner.ner.NER.markEntities" href="#tf.browser.ner.ner.NER.markEntities">markEntities</a></code></li>
<li><code><a title="tf.browser.ner.ner.NER.readInstructions" href="#tf.browser.ner.ner.NER.readInstructions">readInstructions</a></code></li>
<li><code><a title="tf.browser.ner.ner.NER.showInventory" href="#tf.browser.ner.ner.NER.showInventory">showInventory</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>