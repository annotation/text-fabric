<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.browser.ner.fragments API documentation</title>
<meta name="description" content="Wraps various pieces into HTML ‚Ä¶" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-GjqubOlYA6/wOZV7F31o2t4ogk4JGDGFa6XmL+BfAG0=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-qDPJ4nH38AgHyK3U6cvI6DBifA+7hPBo8mVoH6pyN9c=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.browser.ner.fragments</code></h1>
</header>
<section id="section-intro">
<p>Wraps various pieces into HTML.</p>
<p>This module generates HTML for various controls that appear in the TF browser.</p>
<p>To see how this fits among all the modules of this package, see
<code><a title="tf.browser.ner.annotate" href="annotate.html">tf.browser.ner.annotate</a></code> .</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/369e52fe19b197bfd6b085594fe9184ecf0cc02e/tf/browser/ner/fragments.py#L1-L891" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Wraps various pieces into HTML.

This module generates HTML for various controls that appear in the TF browser.

To see how this fits among all the modules of this package, see
`tf.browser.ner.annotate` .
&#34;&#34;&#34;

from .settings import EMPTY, NONE, SORTDIR_ASC
from ..html import H
from .helpers import repIdent, valRep


class Fragments:
    def wrapMessages(self):
        &#34;&#34;&#34;HTML for messages.&#34;&#34;&#34;
        v = self.v
        messageSrc = v.messagesrc

        v.messages = H.p((H.span(text, cls=lev) + H.br() for (lev, text) in messageSrc))

    def wrapAnnoSets(self):
        &#34;&#34;&#34;HTML for the annotation set chooser.

        It is a list of buttons, each corresponding to an existing annotation set.
        A click on the button selects that set.
        There is also a control to delete the set.

        Apart from these buttons there is a button to switch to the entities that are
        present in the TF dataset as nodes of the entity type specified
        in the YAML file with corresponding
        features.

        Finally, it is possible to create a new, empty annotation set.
        &#34;&#34;&#34;
        annotate = self.annotate
        setNames = annotate.setNames
        settings = annotate.settings
        entitySet = settings.entitySet

        v = self.v
        chosenAnnoSet = v.annoset

        content1 = [
            H.input(
                type=&#34;hidden&#34;,
                name=&#34;annoset&#34;,
                value=chosenAnnoSet,
                id=&#34;annoseth&#34;,
            ),
            H.input(
                type=&#34;hidden&#34;,
                name=&#34;duannoset&#34;,
                value=&#34;&#34;,
                id=&#34;duannoseth&#34;,
            ),
            H.input(
                type=&#34;hidden&#34;,
                name=&#34;rannoset&#34;,
                value=&#34;&#34;,
                id=&#34;rannoseth&#34;,
            ),
            H.button(
                &#34;+&#34;,
                type=&#34;submit&#34;,
                id=&#34;anew&#34;,
                title=&#34;create a new annotation set&#34;,
                cls=&#34;mono&#34;,
            ),
            &#34; &#34;,
            H.button(
                &#34;++&#34;,
                type=&#34;submit&#34;,
                id=&#34;adup&#34;,
                title=&#34;duplicate this annotation set&#34;,
                cls=&#34;mono&#34;,
            ),
            &#34; &#34;,
            H.select(
                (
                    H.option(
                        entitySet if annoSet == &#34;&#34; else annoSet,
                        value=annoSet,
                        selected=annoSet == chosenAnnoSet,
                    )
                    for annoSet in [&#34;&#34;] + sorted(setNames)
                ),
                cls=&#34;selinp&#34;,
                id=&#34;achange&#34;,
            ),
        ]

        content2 = (
            [
                H.input(
                    type=&#34;hidden&#34;,
                    name=&#34;dannoset&#34;,
                    value=&#34;&#34;,
                    id=&#34;dannoseth&#34;,
                ),
                H.button(
                    &#34;‚Üí&#34;,
                    type=&#34;submit&#34;,
                    id=&#34;arename&#34;,
                    title=&#34;rename current annotation set&#34;,
                    cls=&#34;mono&#34;,
                ),
                &#34; &#34;,
                H.button(
                    &#34;-&#34;,
                    type=&#34;submit&#34;,
                    id=&#34;adelete&#34;,
                    title=&#34;delete current annotation set&#34;,
                    cls=&#34;mono&#34;,
                ),
            ]
            if chosenAnnoSet
            else []
        )

        v.annosets = H.p(content1, content2)

    def wrapQuery(self):
        &#34;&#34;&#34;HTML for all control widgets on the page.&#34;&#34;&#34;
        self.wrapAppearance()
        self.wrapFilter()
        self.wrapEntity()
        self.wrapEntityText()
        self.wrapScope()
        self.wrapEntityFeats()
        self.wrapEntityModReport()
        self.wrapEntityModify()

    def wrapAppearance(self):
        &#34;&#34;&#34;HTML for the appearance widget.

        The appearance widget lets the user choose how inline entities should
        appear: with or without underlining, identifier, kind, frequency.
        &#34;&#34;&#34;
        v = self.v
        annotate = self.annotate
        settings = annotate.settings
        features = settings.features

        formattingDo = v.formattingdo
        formattingState = v.formattingstate
        v.formattingbuttons = H.join(
            H.span(
                H.input(
                    type=&#34;hidden&#34;,
                    name=&#34;formattingdo&#34;,
                    value=&#34;v&#34; if formattingDo else &#34;x&#34;,
                ),
                H.button(
                    &#34;decorated&#34; if formattingDo else &#34;plain&#34;,
                    type=&#34;button&#34;,
                    main=&#34;v&#34;,
                    title=&#34;toggle plain or decorated formatting of entities&#34;,
                    cls=&#34;mono&#34;,
                ),
            ),
            H.span(
                [
                    H.span(
                        H.input(
                            type=&#34;hidden&#34;,
                            name=f&#34;{feat}_appearance&#34;,
                            value=&#34;v&#34; if formattingState[feat] else &#34;x&#34;,
                        ),
                        H.button(
                            &#34;stats&#34;
                            if feat == &#34;_stat_&#34;
                            else &#34;underlining&#34;
                            if feat == &#34;_entity_&#34;
                            else feat,
                            feat=feat,
                            type=&#34;button&#34;,
                            title=&#34;toggle display of statistics&#34;
                            if feat == &#34;_stat_&#34;
                            else &#34;toggle formatting of entities&#34;
                            if feat == &#34;_entity&#34;
                            else f&#34;toggle formatting for feature {feat}&#34;,
                            cls=&#34;active&#34; if formattingState[feat] else &#34;&#34;,
                        ),
                    )
                    for feat in features + (&#34;_stat_&#34;, &#34;_entity_&#34;)
                ],
                id=&#34;decoratewidget&#34;,
            ),
            sep=&#34; &#34;,
        )

    def wrapFilter(self):
        &#34;&#34;&#34;HTML for the filter widget.

        The filter widget lets the user filter the buckets by a search pattern
        or the condition that the buckets contains entities (and the even more useful
        condition that the buckets do *not* contain entities).
        &#34;&#34;&#34;
        v = self.v
        annotate = self.annotate
        setData = annotate.getSetData()

        bFind = v.bfind
        bFindC = v.bfindc
        bFindRe = v.bfindre
        bFindError = v.bfinderror
        anyEnt = v.anyent

        v.hasfilter = bFindRe is not None or anyEnt is not None
        v.nbuckets = len(setData.buckets or [])

        v.filterwidget = H.join(
            H.span(
                H.input(type=&#34;text&#34;, name=&#34;bfind&#34;, id=&#34;bfind&#34;, value=bFind),
                H.input(
                    type=&#34;hidden&#34;,
                    name=&#34;bfindc&#34;,
                    id=&#34;bfindc&#34;,
                    value=&#34;v&#34; if bFindC else &#34;x&#34;,
                ),
                H.button(
                    &#34;C&#34; if bFindC else &#34;¬¢&#34;,
                    type=&#34;submit&#34;,
                    id=&#34;bfindb&#34;,
                    title=&#34;using case SENSITIVE search&#34;
                    if bFindC
                    else &#34;using case INSENSITIVE search&#34;,
                    cls=&#34;mono&#34;,
                ),
                &#34; &#34;,
                H.button(&#34;‚ùå&#34;, type=&#34;submit&#34;, id=&#34;findclear&#34;, cls=&#34;icon&#34;),
                &#34; &#34;,
                H.span(bFindError, id=&#34;bfinderror&#34;, cls=&#34;error&#34;),
                cls=&#34;filtercomponent&#34;,
            ),
            H.span(
                H.input(
                    type=&#34;hidden&#34;,
                    name=&#34;anyent&#34;,
                    id=&#34;anyent&#34;,
                    value=&#34;&#34; if anyEnt is None else &#34;v&#34; if anyEnt else &#34;x&#34;,
                ),
                H.button(
                    &#34;with or without&#34;
                    if anyEnt is None
                    else &#34;with&#34;
                    if anyEnt
                    else &#34;without&#34;,
                    type=&#34;submit&#34;,
                    id=&#34;anyentbutton&#34;,
                    cls=&#34;mono&#34;,
                ),
                H.span(&#34; marked entities&#34;),
                cls=&#34;filtercomponent&#34;,
            ),
            H.span(
                H.button(&#34;üîé&#34;, type=&#34;submit&#34;, id=&#34;lookupf&#34;, cls=&#34;alt&#34;),
                cls=&#34;filtercomponent&#34;,
            ),
            H.span(
                self.wrapFindStat(),
                cls=&#34;filtercomponent&#34;,
            ),
        )

    def wrapEntity(self):
        &#34;&#34;&#34;Basic data for the selected entity widget.

        The entity widget shows the occurrence or entity that is selected.
        This function computed the relevant values and stores them in
        hidden input elements.
        &#34;&#34;&#34;
        v = self.v
        annotate = self.annotate
        settings = annotate.settings
        features = settings.features

        activeEntity = v.activeentity
        tokenStart = v.tokenstart
        tokenEnd = v.tokenend

        hasEnt = activeEntity is not None
        hasOcc = tokenStart is not None and tokenEnd is not None

        if hasEnt:
            v.tokenstart = None
            v.tokenend = None
            txt = &#34;&#34;
            eTxt = repIdent(features, activeEntity, active=&#34;active&#34;)
        elif hasOcc:
            v.activeentity = None
            txt = (
                annotate.getText(range(tokenStart, tokenEnd + 1))
                if tokenStart and tokenEnd
                else &#34;&#34;
            )
            eTxt = &#34;&#34;
        else:
            v.activeentity = None
            v.tokenstart = None
            v.tokenend = None
            txt = &#34;&#34;
            eTxt = &#34;&#34;

        v.activeentityrep = &#34;‚äô&#34;.join(activeEntity) if activeEntity else &#34;&#34;
        tokenStart = v.tokenstart
        tokenEnd = v.tokenend

        startRep = H.input(
            type=&#34;hidden&#34;, name=&#34;tokenstart&#34;, id=&#34;tokenstart&#34;, value=tokenStart or &#34;&#34;
        )
        endRep = H.input(
            type=&#34;hidden&#34;, name=&#34;tokenend&#34;, id=&#34;tokenend&#34;, value=tokenEnd or &#34;&#34;
        )
        v.entityinit = startRep + endRep

        v.txt = txt
        v.etxt = eTxt

    def wrapEntityHeaders(self):
        &#34;&#34;&#34;HTML for the header of the entity table, dependent on the state of sorting.&#34;&#34;&#34;
        v = self.v
        sortKey = v.sortkey
        sortDir = v.sortdir
        annotate = self.annotate
        settings = annotate.settings
        features = settings.features

        sortKeys = ((feat, f&#34;sort_{i}&#34;) for (i, feat) in enumerate(features))

        content = [
            H.input(type=&#34;hidden&#34;, name=&#34;sortkey&#34;, id=&#34;sortkey&#34;, value=sortKey),
            H.input(type=&#34;hidden&#34;, name=&#34;sortdir&#34;, id=&#34;sortdir&#34;, value=sortDir),
        ]

        for label, key in ((&#34;frequency&#34;, &#34;freqsort&#34;), *sortKeys):
            hl = &#34; active &#34; if key == sortKey else &#34;&#34;
            theDir = sortDir if key == sortKey else SORTDIR_ASC
            theArrow = &#34;‚Üë&#34; if theDir == SORTDIR_ASC else &#34;‚Üì&#34;
            content.extend(
                [
                    H.button(
                        f&#34;{label} {theArrow}&#34;,
                        type=&#34;button&#34;,
                        tp=&#34;sort&#34;,
                        sk=key,
                        sd=theDir,
                        cls=f&#34;alt{hl}&#34;,
                    ),
                    &#34; &#34;,
                ]
            )

        return H.p(content)

    def wrapEntityText(self):
        &#34;&#34;&#34;HTML for the selected entity widget.&#34;&#34;&#34;
        v = self.v

        freeState = v.freestate
        txt = v.txt
        eTxt = v.etxt

        title = &#34;choose: free, intersecting with other entities, or all&#34;
        v.entitytext = H.join(
            H.span(txt if txt else eTxt or &#34;&#34;, id=&#34;qtextentshow&#34;),
            &#34; &#34;,
            H.button(&#34;‚ùå&#34;, type=&#34;submit&#34;, id=&#34;queryclear&#34;, cls=&#34;icon&#34;),
            &#34; &#34;,
            H.button(
                &#34;‚úÖ&#34;,
                type=&#34;submit&#34;,
                id=&#34;lookupq&#34;,
                cls=&#34;icon&#34;,
                title=&#34;look up and fill in green fields&#34;,
            ),
            H.button(
                &#34;‚ùé&#34;,
                type=&#34;submit&#34;,
                id=&#34;lookupn&#34;,
                cls=&#34;icon&#34;,
                title=&#34;look up and keep green fields as is&#34;,
            ),
            H.input(type=&#34;hidden&#34;, name=&#34;freestate&#34;, id=&#34;freestate&#34;, value=freeState),
            H.button(
                &#34;‚ö≠ intersecting&#34;
                if freeState == &#34;bound&#34;
                else &#34;‚öØ free&#34;
                if freeState == &#34;free&#34;
                else &#34;‚ö¨ all&#34;,
                type=&#34;submit&#34;,
                id=&#34;freebutton&#34;,
                cls=&#34;mono&#34;,
                title=title,
            ),
        )

    def wrapEntityFeats(self):
        &#34;&#34;&#34;HTML for the entity feature value selection.

        All feature values of entities that occupy the selected occurrences are
        shown, with the possibility that the user selects some of these values,
        thereby selecting a subset of the original set of occurrences.
        &#34;&#34;&#34;
        v = self.v
        annotate = self.annotate
        settings = annotate.settings
        bucketType = settings.bucketType
        features = settings.features

        setData = annotate.getSetData()

        txt = v.txt
        eTxt = v.etxt
        valSelect = v.valselect
        scopeInit = v.scopeinit
        scopeFilter = v.scopefilter

        hasOcc = txt != &#34;&#34;
        hasEnt = eTxt != &#34;&#34;

        featuresW = {
            feat: valSelect[feat]
            if hasEnt
            else setData.entityTextVal[feat].get(txt, set())
            for feat in features
        }
        content = []
        inputContent = []

        for feat, theseVals in featuresW.items():
            thisValSelect = valSelect[feat]

            valuesContent = []

            inputContent.append(
                H.input(
                    type=&#34;hidden&#34;,
                    name=f&#34;{feat}_select&#34;,
                    id=f&#34;{feat}_select&#34;,
                    value=&#34;,&#34;.join(thisValSelect),
                )
            )

            if hasEnt or hasOcc:
                for val in [NONE] + sorted(theseVals):
                    valuesContent.append(
                        H.button(
                            val,
                            self.wrapEntityStat(val, feat),
                            type=&#34;button&#34;,
                            name=val or EMPTY,
                            cls=f&#34;{feat}_sel alt&#34;,
                            st=&#34;v&#34; if val in thisValSelect else &#34;x&#34;,
                            title=f&#34;{feat} not marked&#34;
                            if val == NONE
                            else f&#34;{feat} marked as {val}&#34;,
                        )
                    )
                titleContent = H.div(H.i(f&#34;{feat}:&#34;), cls=&#34;feattitle&#34;)
            else:
                titleContent = &#34;&#34;

            content.append(H.div(titleContent, valuesContent, cls=&#34;featwidget&#34;))

        total = self.wrapEntityStat(None, &#34;&#34;)
        v.selectentities = (
            H.div(
                H.join(inputContent),
                H.div(
                    H.span(H.b(&#34;Select&#34;), scopeInit, scopeFilter),
                    H.span(H.span(f&#34;{total} {bucketType}(s)&#34;)),
                )
                if hasEnt
                else H.join(
                    H.div(
                        H.p(H.b(&#34;Select&#34;), scopeInit, scopeFilter),
                        H.p(H.span(f&#34;{total} {bucketType}(s)&#34;)),
                    ),
                    H.div(content, id=&#34;selectsubwidget&#34;),
                ),
                id=&#34;selectwidget&#34;,
            )
            if hasEnt or hasOcc
            else H.join(inputContent)
        )

    def wrapScope(self):
        &#34;&#34;&#34;HTML for the scope widget.

        The scope widget lets the user choose whether the add / del actions should
        be applied to all relevant buckets, or only to the filtered buckets.
        &#34;&#34;&#34;
        v = self.v
        annotate = self.annotate
        annoSet = annotate.annoSet
        scope = v.scope
        hasFilter = v.hasfilter
        txt = v.txt
        eTxt = v.etxt
        hasOcc = txt != &#34;&#34;
        hasEnt = eTxt != &#34;&#34;

        scopeInit = H.input(type=&#34;hidden&#34;, id=&#34;scope&#34;, name=&#34;scope&#34;, value=scope)
        scopeFilter = &#34;&#34;

        if annoSet and (hasOcc or hasEnt):
            # Scope of modification

            scopeFilter = (
                H.span(
                    H.button(&#34;&#34;, type=&#34;button&#34;, id=&#34;scopebutton&#34;, title=&#34;&#34;, cls=&#34;alt&#34;)
                )
                if hasFilter
                else &#34;&#34;
            )

        v.scopeinit = scopeInit
        v.scopefilter = scopeFilter

    def wrapExceptions(self):
        &#34;&#34;&#34;HTML for the select / deselect buttons.

        These buttons appear at the end of selected occurrences in the text displayed
        in the buckets.
        The user can select or deselect individual entities for the application of
        the add / del operations.
        &#34;&#34;&#34;
        v = self.v
        txt = v.txt
        eTxt = v.etxt
        annotate = self.annotate
        settings = annotate.settings
        bucketType = settings.bucketType
        annoSet = annotate.annoSet
        hasOcc = txt != &#34;&#34;
        hasEnt = eTxt != &#34;&#34;

        scopeExceptions = &#34;&#34;

        if annoSet and (hasOcc or hasEnt):
            scopeExceptions = H.span(
                H.nb,
                H.button(
                    &#34;‚úÖ&#34;,
                    type=&#34;button&#34;,
                    id=&#34;selectall&#34;,
                    title=f&#34;select all occurrences in filtered {bucketType}s&#34;,
                    cls=&#34;icon&#34;,
                ),
                &#34; &#34;,
                H.button(
                    &#34;‚ùå&#34;,
                    type=&#34;button&#34;,
                    id=&#34;selectnone&#34;,
                    title=f&#34;deselect all occurrences in filtered {bucketType}s&#34;,
                    cls=&#34;icon&#34;,
                ),
            )

        return scopeExceptions

    def wrapEntityModify(self):
        &#34;&#34;&#34;HTML for the add / del widget.

        This widget contains controls to specify which entity feature values
        should be added or deleted.

        Considerable effort is made to prefill these components with ergonomic
        values.
        &#34;&#34;&#34;
        v = self.v
        annotate = self.annotate
        settings = annotate.settings
        features = settings.features
        keywordFeatures = settings.keywordFeatures

        featureDefault = annotate.featureDefault

        setData = annotate.getSetData()
        annoSet = annotate.annoSet

        txt = v.txt
        eTxt = v.etxt
        submitter = v.submitter
        activeEntity = v.activeentity
        tokenStart = v.tokenstart
        tokenEnd = v.tokenend
        delData = v.adddata
        addData = v.adddata
        modWidgetState = v.modwidgetstate
        excludedTokens = v.excludedtokens

        deletions = delData.deletions
        additions = addData.additions
        freeVals = addData.freeVals

        hasOcc = txt != &#34;&#34;
        hasEnt = eTxt != &#34;&#34;

        delButtonHtml = &#34;&#34;
        addButtonHtml = &#34;&#34;
        delContentHtml = []
        addContentHtml = []

        # Assigment of feature values

        somethingToDelete = True

        if annoSet and (hasOcc or hasEnt):
            instances = self.wrapExceptions()

            for i, feat in enumerate(features):
                isKeyword = feat in keywordFeatures
                theseVals = (
                    {activeEntity[i]}
                    if hasEnt
                    else sorted(setData.entityTextVal[feat].get(txt, set()))
                )
                allVals = (
                    sorted(x[0] for x in setData.entityFreq[feat])
                    if isKeyword
                    else theseVals
                )
                addVals = (
                    additions[i]
                    if additions is not None and len(additions) &gt; i
                    else set()
                )
                delVals = (
                    deletions[i]
                    if deletions is not None and len(deletions) &gt; i
                    else set()
                )
                freeVal = (
                    freeVals[i] if freeVals is not None and len(freeVals) &gt; i else None
                )
                default = (
                    activeEntity[i]
                    if hasEnt
                    else featureDefault[feat](range(tokenStart, tokenEnd + 1))
                    if hasOcc
                    else {}
                )

                titleContent = H.div(
                    H.i(f&#34;{feat}:&#34;),
                    cls=&#34;feattitle&#34;,
                )

                delValuesContent = []
                addValuesContent = []

                hasSomeVals = False

                for val in allVals:
                    occurs = val in theseVals
                    delSt = &#34;minus&#34; if hasEnt or val in delVals else &#34;x&#34;
                    addSt = (
                        &#34;plus&#34;
                        if val in addVals
                        else &#34;plus&#34;
                        if val == default and freeVal != default
                        else &#34;x&#34;
                    )

                    if occurs:
                        delValuesContent.append(
                            H.div(
                                [
                                    H.span(
                                        val or H.nb,
                                        cls=f&#34;{feat}_sel&#34;,
                                        st=delSt,
                                        val=val,
                                    ),
                                ],
                                cls=f&#34;{feat}_w modval&#34;,
                            )
                        )
                        hasSomeVals = True

                    addValuesContent.append(
                        H.div(
                            [
                                H.span(
                                    val or H.nb, cls=f&#34;{feat}_sel&#34;, st=addSt, val=val
                                ),
                            ],
                            cls=f&#34;{feat}_w modval&#34;,
                        )
                    )

                if not hasSomeVals:
                    somethingToDelete = False

                init = &#34;&#34; if default in theseVals else default
                val = (
                    addVals[0]
                    if len(addVals) and submitter in {&#34;lookupn&#34;, &#34;freebutton&#34;}
                    else init
                    if submitter == &#34;lookupq&#34;
                    else freeVal
                    if freeVal is not None
                    else init
                )
                addSt = (
                    &#34;plus&#34;
                    if val and len(addVals) and submitter in {&#34;lookupn&#34;, &#34;freebutton&#34;}
                    else &#34;plus&#34;
                    if submitter == &#34;lookupq&#34; and val
                    else &#34;plus&#34;
                    if val == freeVal
                    else &#34;plus&#34;
                    if init and len(theseVals) == 0
                    else &#34;x&#34;
                )
                if (isKeyword and val in allVals) or val is None:
                    val = &#34;&#34;
                    addSt = &#34;x&#34;

                addValuesContent.append(
                    H.div(
                        [H.input(type=&#34;text&#34;, st=addSt, value=val, origval=val)],
                        cls=&#34;modval&#34;,
                    )
                )

                delContentHtml.append(
                    H.div(
                        titleContent,
                        H.div(delValuesContent, cls=&#34;modifyvalues&#34;),
                        cls=&#34;delfeat&#34;,
                        feat=feat,
                    )
                )
                addContentHtml.append(
                    H.div(
                        titleContent,
                        H.div(addValuesContent, cls=&#34;modifyvalues&#34;),
                        cls=&#34;addfeat&#34;,
                        feat=feat,
                    )
                )

            delButtonHtml = H.span(
                H.button(&#34;Delete&#34;, type=&#34;button&#34;, id=&#34;delgo&#34;, value=&#34;v&#34;, cls=&#34;special&#34;),
                H.input(type=&#34;hidden&#34;, id=&#34;deldata&#34;, name=&#34;deldata&#34;, value=&#34;&#34;),
            )
            addButtonHtml = H.span(
                H.button(&#34;Add&#34;, type=&#34;button&#34;, id=&#34;addgo&#34;, value=&#34;v&#34;, cls=&#34;special&#34;),
                H.input(type=&#34;hidden&#34;, id=&#34;adddata&#34;, name=&#34;adddata&#34;, value=&#34;&#34;),
            )
            delResetHtml = H.button(
                &#34;‚å´&#34;,
                type=&#34;button&#34;,
                id=&#34;delresetbutton&#34;,
                title=&#34;clear values in form&#34;,
                cls=&#34;icon&#34;,
            )
            addResetHtml = H.button(
                &#34;‚å´&#34;,
                type=&#34;button&#34;,
                id=&#34;addresetbutton&#34;,
                title=&#34;clear values in form&#34;,
                cls=&#34;icon&#34;,
            )

            delWidgetContent = (
                H.div(
                    H.span(
                        H.span(delButtonHtml, delResetHtml, id=&#34;modifyhead&#34;),
                        H.span(delContentHtml, cls=&#34;assignwidget&#34;),
                    ),
                    H.span(&#34;&#34;, id=&#34;delfeedback&#34;, cls=&#34;feedback&#34;),
                    id=&#34;delwidget&#34;,
                )
                if somethingToDelete
                else &#34;&#34;
            )
            v.modifyentity = H.div(
                H.input(
                    type=&#34;hidden&#34;,
                    id=&#34;modwidgetstate&#34;,
                    name=&#34;modwidgetstate&#34;,
                    value=modWidgetState,
                ),
                H.input(
                    type=&#34;hidden&#34;,
                    id=&#34;excludedtokens&#34;,
                    name=&#34;excludedtokens&#34;,
                    value=&#34;,&#34;.join(str(t) for t in excludedTokens),
                ),
                H.b(&#34;Modify&#34;),
                instances,
                delWidgetContent,
                H.div(
                    H.span(
                        H.span(addButtonHtml, addResetHtml, id=&#34;modifyhead&#34;),
                        H.span(addContentHtml, cls=&#34;assignwidget&#34;),
                    ),
                    H.span(&#34;&#34;, id=&#34;addfeedback&#34;, cls=&#34;feedback&#34;),
                    id=&#34;addwidget&#34;,
                ),
                id=&#34;modwidget&#34;,
            )

    def wrapFindStat(self):
        &#34;&#34;&#34;HTML for statistics.

        This is about totals of occurrences in all buckets versus in filtered
        buckets.
        &#34;&#34;&#34;
        v = self.v
        nBuckets = v.nbuckets
        nFind = v.nfind
        hasFilter = v.hasfilter

        n = f&#34;{nFind} of {nBuckets}&#34; if hasFilter else nBuckets
        return H.span(n, cls=&#34;stat&#34;)

    def wrapEntityStat(self, val, feat):
        &#34;&#34;&#34;HTML for statistics of feature values.

        This is about totals of occurrences of feature values in all buckets
        versus in filtered buckets.
        &#34;&#34;&#34;
        v = self.v
        nVisible = v.nvisible
        nEnt = v.nent
        hasFilter = v.hasfilter

        thisNVisible = nVisible[feat]
        thisNEnt = nEnt[feat]

        na = thisNEnt[val]
        n = (
            (H.span(f&#34;{thisNVisible[val]} of &#34;, cls=&#34;filted&#34;) + f&#34;{na}&#34;)
            if hasFilter
            else f&#34;{na}&#34;
        )
        return H.span(n, cls=&#34;stat&#34;)

    def wrapActive(self):
        &#34;&#34;&#34;HTML for the active entity.&#34;&#34;&#34;
        v = self.v

        activeVal = v.activeval

        v.activevalrep = H.join(
            H.input(
                type=&#34;hidden&#34;,
                id=f&#34;{feat}_active&#34;,
                name=f&#34;{feat}_active&#34;,
                value=val or &#34;&#34;,
            )
            for (feat, val) in activeVal.items()
        )

    def wrapEntityModReport(self):
        &#34;&#34;&#34;HTML for the combined report of add / del actions.&#34;&#34;&#34;
        v = self.v
        reportDel = v.reportdel
        reportAdd = v.reportadd
        v.modifyreport = H.join(
            H.div(reportDel, id=&#34;delreport&#34;, cls=&#34;report&#34;),
            H.div(reportAdd, id=&#34;addreport&#34;, cls=&#34;report&#34;),
        )

    def wrapReport(self, report, kind):
        &#34;&#34;&#34;HTML for the report of add / del actions.&#34;&#34;&#34;
        v = self.v
        annotate = self.annotate
        settings = annotate.settings
        features = settings.features

        label = &#34;Deletion&#34; if kind == &#34;del&#34; else &#34;Addition&#34; if kind == &#34;add&#34; else &#34;&#34;
        v[f&#34;report{kind}&#34;] = H.join(
            H.div(
                H.join(
                    H.div(f&#34;{label}: {n} x {valRep(features, fVals)}&#34;)
                    for (fVals, n) in line
                )
                if type(line) is tuple
                else line,
                cls=&#34;report&#34;,
            )
            for line in report
        )
        report.clear()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.browser.ner.fragments.Fragments"><code class="flex name class">
<span>class <span class="ident">Fragments</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/369e52fe19b197bfd6b085594fe9184ecf0cc02e/tf/browser/ner/fragments.py#L14-L891" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Fragments:
    def wrapMessages(self):
        &#34;&#34;&#34;HTML for messages.&#34;&#34;&#34;
        v = self.v
        messageSrc = v.messagesrc

        v.messages = H.p((H.span(text, cls=lev) + H.br() for (lev, text) in messageSrc))

    def wrapAnnoSets(self):
        &#34;&#34;&#34;HTML for the annotation set chooser.

        It is a list of buttons, each corresponding to an existing annotation set.
        A click on the button selects that set.
        There is also a control to delete the set.

        Apart from these buttons there is a button to switch to the entities that are
        present in the TF dataset as nodes of the entity type specified
        in the YAML file with corresponding
        features.

        Finally, it is possible to create a new, empty annotation set.
        &#34;&#34;&#34;
        annotate = self.annotate
        setNames = annotate.setNames
        settings = annotate.settings
        entitySet = settings.entitySet

        v = self.v
        chosenAnnoSet = v.annoset

        content1 = [
            H.input(
                type=&#34;hidden&#34;,
                name=&#34;annoset&#34;,
                value=chosenAnnoSet,
                id=&#34;annoseth&#34;,
            ),
            H.input(
                type=&#34;hidden&#34;,
                name=&#34;duannoset&#34;,
                value=&#34;&#34;,
                id=&#34;duannoseth&#34;,
            ),
            H.input(
                type=&#34;hidden&#34;,
                name=&#34;rannoset&#34;,
                value=&#34;&#34;,
                id=&#34;rannoseth&#34;,
            ),
            H.button(
                &#34;+&#34;,
                type=&#34;submit&#34;,
                id=&#34;anew&#34;,
                title=&#34;create a new annotation set&#34;,
                cls=&#34;mono&#34;,
            ),
            &#34; &#34;,
            H.button(
                &#34;++&#34;,
                type=&#34;submit&#34;,
                id=&#34;adup&#34;,
                title=&#34;duplicate this annotation set&#34;,
                cls=&#34;mono&#34;,
            ),
            &#34; &#34;,
            H.select(
                (
                    H.option(
                        entitySet if annoSet == &#34;&#34; else annoSet,
                        value=annoSet,
                        selected=annoSet == chosenAnnoSet,
                    )
                    for annoSet in [&#34;&#34;] + sorted(setNames)
                ),
                cls=&#34;selinp&#34;,
                id=&#34;achange&#34;,
            ),
        ]

        content2 = (
            [
                H.input(
                    type=&#34;hidden&#34;,
                    name=&#34;dannoset&#34;,
                    value=&#34;&#34;,
                    id=&#34;dannoseth&#34;,
                ),
                H.button(
                    &#34;‚Üí&#34;,
                    type=&#34;submit&#34;,
                    id=&#34;arename&#34;,
                    title=&#34;rename current annotation set&#34;,
                    cls=&#34;mono&#34;,
                ),
                &#34; &#34;,
                H.button(
                    &#34;-&#34;,
                    type=&#34;submit&#34;,
                    id=&#34;adelete&#34;,
                    title=&#34;delete current annotation set&#34;,
                    cls=&#34;mono&#34;,
                ),
            ]
            if chosenAnnoSet
            else []
        )

        v.annosets = H.p(content1, content2)

    def wrapQuery(self):
        &#34;&#34;&#34;HTML for all control widgets on the page.&#34;&#34;&#34;
        self.wrapAppearance()
        self.wrapFilter()
        self.wrapEntity()
        self.wrapEntityText()
        self.wrapScope()
        self.wrapEntityFeats()
        self.wrapEntityModReport()
        self.wrapEntityModify()

    def wrapAppearance(self):
        &#34;&#34;&#34;HTML for the appearance widget.

        The appearance widget lets the user choose how inline entities should
        appear: with or without underlining, identifier, kind, frequency.
        &#34;&#34;&#34;
        v = self.v
        annotate = self.annotate
        settings = annotate.settings
        features = settings.features

        formattingDo = v.formattingdo
        formattingState = v.formattingstate
        v.formattingbuttons = H.join(
            H.span(
                H.input(
                    type=&#34;hidden&#34;,
                    name=&#34;formattingdo&#34;,
                    value=&#34;v&#34; if formattingDo else &#34;x&#34;,
                ),
                H.button(
                    &#34;decorated&#34; if formattingDo else &#34;plain&#34;,
                    type=&#34;button&#34;,
                    main=&#34;v&#34;,
                    title=&#34;toggle plain or decorated formatting of entities&#34;,
                    cls=&#34;mono&#34;,
                ),
            ),
            H.span(
                [
                    H.span(
                        H.input(
                            type=&#34;hidden&#34;,
                            name=f&#34;{feat}_appearance&#34;,
                            value=&#34;v&#34; if formattingState[feat] else &#34;x&#34;,
                        ),
                        H.button(
                            &#34;stats&#34;
                            if feat == &#34;_stat_&#34;
                            else &#34;underlining&#34;
                            if feat == &#34;_entity_&#34;
                            else feat,
                            feat=feat,
                            type=&#34;button&#34;,
                            title=&#34;toggle display of statistics&#34;
                            if feat == &#34;_stat_&#34;
                            else &#34;toggle formatting of entities&#34;
                            if feat == &#34;_entity&#34;
                            else f&#34;toggle formatting for feature {feat}&#34;,
                            cls=&#34;active&#34; if formattingState[feat] else &#34;&#34;,
                        ),
                    )
                    for feat in features + (&#34;_stat_&#34;, &#34;_entity_&#34;)
                ],
                id=&#34;decoratewidget&#34;,
            ),
            sep=&#34; &#34;,
        )

    def wrapFilter(self):
        &#34;&#34;&#34;HTML for the filter widget.

        The filter widget lets the user filter the buckets by a search pattern
        or the condition that the buckets contains entities (and the even more useful
        condition that the buckets do *not* contain entities).
        &#34;&#34;&#34;
        v = self.v
        annotate = self.annotate
        setData = annotate.getSetData()

        bFind = v.bfind
        bFindC = v.bfindc
        bFindRe = v.bfindre
        bFindError = v.bfinderror
        anyEnt = v.anyent

        v.hasfilter = bFindRe is not None or anyEnt is not None
        v.nbuckets = len(setData.buckets or [])

        v.filterwidget = H.join(
            H.span(
                H.input(type=&#34;text&#34;, name=&#34;bfind&#34;, id=&#34;bfind&#34;, value=bFind),
                H.input(
                    type=&#34;hidden&#34;,
                    name=&#34;bfindc&#34;,
                    id=&#34;bfindc&#34;,
                    value=&#34;v&#34; if bFindC else &#34;x&#34;,
                ),
                H.button(
                    &#34;C&#34; if bFindC else &#34;¬¢&#34;,
                    type=&#34;submit&#34;,
                    id=&#34;bfindb&#34;,
                    title=&#34;using case SENSITIVE search&#34;
                    if bFindC
                    else &#34;using case INSENSITIVE search&#34;,
                    cls=&#34;mono&#34;,
                ),
                &#34; &#34;,
                H.button(&#34;‚ùå&#34;, type=&#34;submit&#34;, id=&#34;findclear&#34;, cls=&#34;icon&#34;),
                &#34; &#34;,
                H.span(bFindError, id=&#34;bfinderror&#34;, cls=&#34;error&#34;),
                cls=&#34;filtercomponent&#34;,
            ),
            H.span(
                H.input(
                    type=&#34;hidden&#34;,
                    name=&#34;anyent&#34;,
                    id=&#34;anyent&#34;,
                    value=&#34;&#34; if anyEnt is None else &#34;v&#34; if anyEnt else &#34;x&#34;,
                ),
                H.button(
                    &#34;with or without&#34;
                    if anyEnt is None
                    else &#34;with&#34;
                    if anyEnt
                    else &#34;without&#34;,
                    type=&#34;submit&#34;,
                    id=&#34;anyentbutton&#34;,
                    cls=&#34;mono&#34;,
                ),
                H.span(&#34; marked entities&#34;),
                cls=&#34;filtercomponent&#34;,
            ),
            H.span(
                H.button(&#34;üîé&#34;, type=&#34;submit&#34;, id=&#34;lookupf&#34;, cls=&#34;alt&#34;),
                cls=&#34;filtercomponent&#34;,
            ),
            H.span(
                self.wrapFindStat(),
                cls=&#34;filtercomponent&#34;,
            ),
        )

    def wrapEntity(self):
        &#34;&#34;&#34;Basic data for the selected entity widget.

        The entity widget shows the occurrence or entity that is selected.
        This function computed the relevant values and stores them in
        hidden input elements.
        &#34;&#34;&#34;
        v = self.v
        annotate = self.annotate
        settings = annotate.settings
        features = settings.features

        activeEntity = v.activeentity
        tokenStart = v.tokenstart
        tokenEnd = v.tokenend

        hasEnt = activeEntity is not None
        hasOcc = tokenStart is not None and tokenEnd is not None

        if hasEnt:
            v.tokenstart = None
            v.tokenend = None
            txt = &#34;&#34;
            eTxt = repIdent(features, activeEntity, active=&#34;active&#34;)
        elif hasOcc:
            v.activeentity = None
            txt = (
                annotate.getText(range(tokenStart, tokenEnd + 1))
                if tokenStart and tokenEnd
                else &#34;&#34;
            )
            eTxt = &#34;&#34;
        else:
            v.activeentity = None
            v.tokenstart = None
            v.tokenend = None
            txt = &#34;&#34;
            eTxt = &#34;&#34;

        v.activeentityrep = &#34;‚äô&#34;.join(activeEntity) if activeEntity else &#34;&#34;
        tokenStart = v.tokenstart
        tokenEnd = v.tokenend

        startRep = H.input(
            type=&#34;hidden&#34;, name=&#34;tokenstart&#34;, id=&#34;tokenstart&#34;, value=tokenStart or &#34;&#34;
        )
        endRep = H.input(
            type=&#34;hidden&#34;, name=&#34;tokenend&#34;, id=&#34;tokenend&#34;, value=tokenEnd or &#34;&#34;
        )
        v.entityinit = startRep + endRep

        v.txt = txt
        v.etxt = eTxt

    def wrapEntityHeaders(self):
        &#34;&#34;&#34;HTML for the header of the entity table, dependent on the state of sorting.&#34;&#34;&#34;
        v = self.v
        sortKey = v.sortkey
        sortDir = v.sortdir
        annotate = self.annotate
        settings = annotate.settings
        features = settings.features

        sortKeys = ((feat, f&#34;sort_{i}&#34;) for (i, feat) in enumerate(features))

        content = [
            H.input(type=&#34;hidden&#34;, name=&#34;sortkey&#34;, id=&#34;sortkey&#34;, value=sortKey),
            H.input(type=&#34;hidden&#34;, name=&#34;sortdir&#34;, id=&#34;sortdir&#34;, value=sortDir),
        ]

        for label, key in ((&#34;frequency&#34;, &#34;freqsort&#34;), *sortKeys):
            hl = &#34; active &#34; if key == sortKey else &#34;&#34;
            theDir = sortDir if key == sortKey else SORTDIR_ASC
            theArrow = &#34;‚Üë&#34; if theDir == SORTDIR_ASC else &#34;‚Üì&#34;
            content.extend(
                [
                    H.button(
                        f&#34;{label} {theArrow}&#34;,
                        type=&#34;button&#34;,
                        tp=&#34;sort&#34;,
                        sk=key,
                        sd=theDir,
                        cls=f&#34;alt{hl}&#34;,
                    ),
                    &#34; &#34;,
                ]
            )

        return H.p(content)

    def wrapEntityText(self):
        &#34;&#34;&#34;HTML for the selected entity widget.&#34;&#34;&#34;
        v = self.v

        freeState = v.freestate
        txt = v.txt
        eTxt = v.etxt

        title = &#34;choose: free, intersecting with other entities, or all&#34;
        v.entitytext = H.join(
            H.span(txt if txt else eTxt or &#34;&#34;, id=&#34;qtextentshow&#34;),
            &#34; &#34;,
            H.button(&#34;‚ùå&#34;, type=&#34;submit&#34;, id=&#34;queryclear&#34;, cls=&#34;icon&#34;),
            &#34; &#34;,
            H.button(
                &#34;‚úÖ&#34;,
                type=&#34;submit&#34;,
                id=&#34;lookupq&#34;,
                cls=&#34;icon&#34;,
                title=&#34;look up and fill in green fields&#34;,
            ),
            H.button(
                &#34;‚ùé&#34;,
                type=&#34;submit&#34;,
                id=&#34;lookupn&#34;,
                cls=&#34;icon&#34;,
                title=&#34;look up and keep green fields as is&#34;,
            ),
            H.input(type=&#34;hidden&#34;, name=&#34;freestate&#34;, id=&#34;freestate&#34;, value=freeState),
            H.button(
                &#34;‚ö≠ intersecting&#34;
                if freeState == &#34;bound&#34;
                else &#34;‚öØ free&#34;
                if freeState == &#34;free&#34;
                else &#34;‚ö¨ all&#34;,
                type=&#34;submit&#34;,
                id=&#34;freebutton&#34;,
                cls=&#34;mono&#34;,
                title=title,
            ),
        )

    def wrapEntityFeats(self):
        &#34;&#34;&#34;HTML for the entity feature value selection.

        All feature values of entities that occupy the selected occurrences are
        shown, with the possibility that the user selects some of these values,
        thereby selecting a subset of the original set of occurrences.
        &#34;&#34;&#34;
        v = self.v
        annotate = self.annotate
        settings = annotate.settings
        bucketType = settings.bucketType
        features = settings.features

        setData = annotate.getSetData()

        txt = v.txt
        eTxt = v.etxt
        valSelect = v.valselect
        scopeInit = v.scopeinit
        scopeFilter = v.scopefilter

        hasOcc = txt != &#34;&#34;
        hasEnt = eTxt != &#34;&#34;

        featuresW = {
            feat: valSelect[feat]
            if hasEnt
            else setData.entityTextVal[feat].get(txt, set())
            for feat in features
        }
        content = []
        inputContent = []

        for feat, theseVals in featuresW.items():
            thisValSelect = valSelect[feat]

            valuesContent = []

            inputContent.append(
                H.input(
                    type=&#34;hidden&#34;,
                    name=f&#34;{feat}_select&#34;,
                    id=f&#34;{feat}_select&#34;,
                    value=&#34;,&#34;.join(thisValSelect),
                )
            )

            if hasEnt or hasOcc:
                for val in [NONE] + sorted(theseVals):
                    valuesContent.append(
                        H.button(
                            val,
                            self.wrapEntityStat(val, feat),
                            type=&#34;button&#34;,
                            name=val or EMPTY,
                            cls=f&#34;{feat}_sel alt&#34;,
                            st=&#34;v&#34; if val in thisValSelect else &#34;x&#34;,
                            title=f&#34;{feat} not marked&#34;
                            if val == NONE
                            else f&#34;{feat} marked as {val}&#34;,
                        )
                    )
                titleContent = H.div(H.i(f&#34;{feat}:&#34;), cls=&#34;feattitle&#34;)
            else:
                titleContent = &#34;&#34;

            content.append(H.div(titleContent, valuesContent, cls=&#34;featwidget&#34;))

        total = self.wrapEntityStat(None, &#34;&#34;)
        v.selectentities = (
            H.div(
                H.join(inputContent),
                H.div(
                    H.span(H.b(&#34;Select&#34;), scopeInit, scopeFilter),
                    H.span(H.span(f&#34;{total} {bucketType}(s)&#34;)),
                )
                if hasEnt
                else H.join(
                    H.div(
                        H.p(H.b(&#34;Select&#34;), scopeInit, scopeFilter),
                        H.p(H.span(f&#34;{total} {bucketType}(s)&#34;)),
                    ),
                    H.div(content, id=&#34;selectsubwidget&#34;),
                ),
                id=&#34;selectwidget&#34;,
            )
            if hasEnt or hasOcc
            else H.join(inputContent)
        )

    def wrapScope(self):
        &#34;&#34;&#34;HTML for the scope widget.

        The scope widget lets the user choose whether the add / del actions should
        be applied to all relevant buckets, or only to the filtered buckets.
        &#34;&#34;&#34;
        v = self.v
        annotate = self.annotate
        annoSet = annotate.annoSet
        scope = v.scope
        hasFilter = v.hasfilter
        txt = v.txt
        eTxt = v.etxt
        hasOcc = txt != &#34;&#34;
        hasEnt = eTxt != &#34;&#34;

        scopeInit = H.input(type=&#34;hidden&#34;, id=&#34;scope&#34;, name=&#34;scope&#34;, value=scope)
        scopeFilter = &#34;&#34;

        if annoSet and (hasOcc or hasEnt):
            # Scope of modification

            scopeFilter = (
                H.span(
                    H.button(&#34;&#34;, type=&#34;button&#34;, id=&#34;scopebutton&#34;, title=&#34;&#34;, cls=&#34;alt&#34;)
                )
                if hasFilter
                else &#34;&#34;
            )

        v.scopeinit = scopeInit
        v.scopefilter = scopeFilter

    def wrapExceptions(self):
        &#34;&#34;&#34;HTML for the select / deselect buttons.

        These buttons appear at the end of selected occurrences in the text displayed
        in the buckets.
        The user can select or deselect individual entities for the application of
        the add / del operations.
        &#34;&#34;&#34;
        v = self.v
        txt = v.txt
        eTxt = v.etxt
        annotate = self.annotate
        settings = annotate.settings
        bucketType = settings.bucketType
        annoSet = annotate.annoSet
        hasOcc = txt != &#34;&#34;
        hasEnt = eTxt != &#34;&#34;

        scopeExceptions = &#34;&#34;

        if annoSet and (hasOcc or hasEnt):
            scopeExceptions = H.span(
                H.nb,
                H.button(
                    &#34;‚úÖ&#34;,
                    type=&#34;button&#34;,
                    id=&#34;selectall&#34;,
                    title=f&#34;select all occurrences in filtered {bucketType}s&#34;,
                    cls=&#34;icon&#34;,
                ),
                &#34; &#34;,
                H.button(
                    &#34;‚ùå&#34;,
                    type=&#34;button&#34;,
                    id=&#34;selectnone&#34;,
                    title=f&#34;deselect all occurrences in filtered {bucketType}s&#34;,
                    cls=&#34;icon&#34;,
                ),
            )

        return scopeExceptions

    def wrapEntityModify(self):
        &#34;&#34;&#34;HTML for the add / del widget.

        This widget contains controls to specify which entity feature values
        should be added or deleted.

        Considerable effort is made to prefill these components with ergonomic
        values.
        &#34;&#34;&#34;
        v = self.v
        annotate = self.annotate
        settings = annotate.settings
        features = settings.features
        keywordFeatures = settings.keywordFeatures

        featureDefault = annotate.featureDefault

        setData = annotate.getSetData()
        annoSet = annotate.annoSet

        txt = v.txt
        eTxt = v.etxt
        submitter = v.submitter
        activeEntity = v.activeentity
        tokenStart = v.tokenstart
        tokenEnd = v.tokenend
        delData = v.adddata
        addData = v.adddata
        modWidgetState = v.modwidgetstate
        excludedTokens = v.excludedtokens

        deletions = delData.deletions
        additions = addData.additions
        freeVals = addData.freeVals

        hasOcc = txt != &#34;&#34;
        hasEnt = eTxt != &#34;&#34;

        delButtonHtml = &#34;&#34;
        addButtonHtml = &#34;&#34;
        delContentHtml = []
        addContentHtml = []

        # Assigment of feature values

        somethingToDelete = True

        if annoSet and (hasOcc or hasEnt):
            instances = self.wrapExceptions()

            for i, feat in enumerate(features):
                isKeyword = feat in keywordFeatures
                theseVals = (
                    {activeEntity[i]}
                    if hasEnt
                    else sorted(setData.entityTextVal[feat].get(txt, set()))
                )
                allVals = (
                    sorted(x[0] for x in setData.entityFreq[feat])
                    if isKeyword
                    else theseVals
                )
                addVals = (
                    additions[i]
                    if additions is not None and len(additions) &gt; i
                    else set()
                )
                delVals = (
                    deletions[i]
                    if deletions is not None and len(deletions) &gt; i
                    else set()
                )
                freeVal = (
                    freeVals[i] if freeVals is not None and len(freeVals) &gt; i else None
                )
                default = (
                    activeEntity[i]
                    if hasEnt
                    else featureDefault[feat](range(tokenStart, tokenEnd + 1))
                    if hasOcc
                    else {}
                )

                titleContent = H.div(
                    H.i(f&#34;{feat}:&#34;),
                    cls=&#34;feattitle&#34;,
                )

                delValuesContent = []
                addValuesContent = []

                hasSomeVals = False

                for val in allVals:
                    occurs = val in theseVals
                    delSt = &#34;minus&#34; if hasEnt or val in delVals else &#34;x&#34;
                    addSt = (
                        &#34;plus&#34;
                        if val in addVals
                        else &#34;plus&#34;
                        if val == default and freeVal != default
                        else &#34;x&#34;
                    )

                    if occurs:
                        delValuesContent.append(
                            H.div(
                                [
                                    H.span(
                                        val or H.nb,
                                        cls=f&#34;{feat}_sel&#34;,
                                        st=delSt,
                                        val=val,
                                    ),
                                ],
                                cls=f&#34;{feat}_w modval&#34;,
                            )
                        )
                        hasSomeVals = True

                    addValuesContent.append(
                        H.div(
                            [
                                H.span(
                                    val or H.nb, cls=f&#34;{feat}_sel&#34;, st=addSt, val=val
                                ),
                            ],
                            cls=f&#34;{feat}_w modval&#34;,
                        )
                    )

                if not hasSomeVals:
                    somethingToDelete = False

                init = &#34;&#34; if default in theseVals else default
                val = (
                    addVals[0]
                    if len(addVals) and submitter in {&#34;lookupn&#34;, &#34;freebutton&#34;}
                    else init
                    if submitter == &#34;lookupq&#34;
                    else freeVal
                    if freeVal is not None
                    else init
                )
                addSt = (
                    &#34;plus&#34;
                    if val and len(addVals) and submitter in {&#34;lookupn&#34;, &#34;freebutton&#34;}
                    else &#34;plus&#34;
                    if submitter == &#34;lookupq&#34; and val
                    else &#34;plus&#34;
                    if val == freeVal
                    else &#34;plus&#34;
                    if init and len(theseVals) == 0
                    else &#34;x&#34;
                )
                if (isKeyword and val in allVals) or val is None:
                    val = &#34;&#34;
                    addSt = &#34;x&#34;

                addValuesContent.append(
                    H.div(
                        [H.input(type=&#34;text&#34;, st=addSt, value=val, origval=val)],
                        cls=&#34;modval&#34;,
                    )
                )

                delContentHtml.append(
                    H.div(
                        titleContent,
                        H.div(delValuesContent, cls=&#34;modifyvalues&#34;),
                        cls=&#34;delfeat&#34;,
                        feat=feat,
                    )
                )
                addContentHtml.append(
                    H.div(
                        titleContent,
                        H.div(addValuesContent, cls=&#34;modifyvalues&#34;),
                        cls=&#34;addfeat&#34;,
                        feat=feat,
                    )
                )

            delButtonHtml = H.span(
                H.button(&#34;Delete&#34;, type=&#34;button&#34;, id=&#34;delgo&#34;, value=&#34;v&#34;, cls=&#34;special&#34;),
                H.input(type=&#34;hidden&#34;, id=&#34;deldata&#34;, name=&#34;deldata&#34;, value=&#34;&#34;),
            )
            addButtonHtml = H.span(
                H.button(&#34;Add&#34;, type=&#34;button&#34;, id=&#34;addgo&#34;, value=&#34;v&#34;, cls=&#34;special&#34;),
                H.input(type=&#34;hidden&#34;, id=&#34;adddata&#34;, name=&#34;adddata&#34;, value=&#34;&#34;),
            )
            delResetHtml = H.button(
                &#34;‚å´&#34;,
                type=&#34;button&#34;,
                id=&#34;delresetbutton&#34;,
                title=&#34;clear values in form&#34;,
                cls=&#34;icon&#34;,
            )
            addResetHtml = H.button(
                &#34;‚å´&#34;,
                type=&#34;button&#34;,
                id=&#34;addresetbutton&#34;,
                title=&#34;clear values in form&#34;,
                cls=&#34;icon&#34;,
            )

            delWidgetContent = (
                H.div(
                    H.span(
                        H.span(delButtonHtml, delResetHtml, id=&#34;modifyhead&#34;),
                        H.span(delContentHtml, cls=&#34;assignwidget&#34;),
                    ),
                    H.span(&#34;&#34;, id=&#34;delfeedback&#34;, cls=&#34;feedback&#34;),
                    id=&#34;delwidget&#34;,
                )
                if somethingToDelete
                else &#34;&#34;
            )
            v.modifyentity = H.div(
                H.input(
                    type=&#34;hidden&#34;,
                    id=&#34;modwidgetstate&#34;,
                    name=&#34;modwidgetstate&#34;,
                    value=modWidgetState,
                ),
                H.input(
                    type=&#34;hidden&#34;,
                    id=&#34;excludedtokens&#34;,
                    name=&#34;excludedtokens&#34;,
                    value=&#34;,&#34;.join(str(t) for t in excludedTokens),
                ),
                H.b(&#34;Modify&#34;),
                instances,
                delWidgetContent,
                H.div(
                    H.span(
                        H.span(addButtonHtml, addResetHtml, id=&#34;modifyhead&#34;),
                        H.span(addContentHtml, cls=&#34;assignwidget&#34;),
                    ),
                    H.span(&#34;&#34;, id=&#34;addfeedback&#34;, cls=&#34;feedback&#34;),
                    id=&#34;addwidget&#34;,
                ),
                id=&#34;modwidget&#34;,
            )

    def wrapFindStat(self):
        &#34;&#34;&#34;HTML for statistics.

        This is about totals of occurrences in all buckets versus in filtered
        buckets.
        &#34;&#34;&#34;
        v = self.v
        nBuckets = v.nbuckets
        nFind = v.nfind
        hasFilter = v.hasfilter

        n = f&#34;{nFind} of {nBuckets}&#34; if hasFilter else nBuckets
        return H.span(n, cls=&#34;stat&#34;)

    def wrapEntityStat(self, val, feat):
        &#34;&#34;&#34;HTML for statistics of feature values.

        This is about totals of occurrences of feature values in all buckets
        versus in filtered buckets.
        &#34;&#34;&#34;
        v = self.v
        nVisible = v.nvisible
        nEnt = v.nent
        hasFilter = v.hasfilter

        thisNVisible = nVisible[feat]
        thisNEnt = nEnt[feat]

        na = thisNEnt[val]
        n = (
            (H.span(f&#34;{thisNVisible[val]} of &#34;, cls=&#34;filted&#34;) + f&#34;{na}&#34;)
            if hasFilter
            else f&#34;{na}&#34;
        )
        return H.span(n, cls=&#34;stat&#34;)

    def wrapActive(self):
        &#34;&#34;&#34;HTML for the active entity.&#34;&#34;&#34;
        v = self.v

        activeVal = v.activeval

        v.activevalrep = H.join(
            H.input(
                type=&#34;hidden&#34;,
                id=f&#34;{feat}_active&#34;,
                name=f&#34;{feat}_active&#34;,
                value=val or &#34;&#34;,
            )
            for (feat, val) in activeVal.items()
        )

    def wrapEntityModReport(self):
        &#34;&#34;&#34;HTML for the combined report of add / del actions.&#34;&#34;&#34;
        v = self.v
        reportDel = v.reportdel
        reportAdd = v.reportadd
        v.modifyreport = H.join(
            H.div(reportDel, id=&#34;delreport&#34;, cls=&#34;report&#34;),
            H.div(reportAdd, id=&#34;addreport&#34;, cls=&#34;report&#34;),
        )

    def wrapReport(self, report, kind):
        &#34;&#34;&#34;HTML for the report of add / del actions.&#34;&#34;&#34;
        v = self.v
        annotate = self.annotate
        settings = annotate.settings
        features = settings.features

        label = &#34;Deletion&#34; if kind == &#34;del&#34; else &#34;Addition&#34; if kind == &#34;add&#34; else &#34;&#34;
        v[f&#34;report{kind}&#34;] = H.join(
            H.div(
                H.join(
                    H.div(f&#34;{label}: {n} x {valRep(features, fVals)}&#34;)
                    for (fVals, n) in line
                )
                if type(line) is tuple
                else line,
                cls=&#34;report&#34;,
            )
            for line in report
        )
        report.clear()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="tf.browser.ner.serve.Serve" href="serve.html#tf.browser.ner.serve.Serve">Serve</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tf.browser.ner.fragments.Fragments.wrapActive"><code class="name flex">
<span>def <span class="ident">wrapActive</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>HTML for the active entity.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/369e52fe19b197bfd6b085594fe9184ecf0cc02e/tf/browser/ner/fragments.py#L845-L859" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrapActive(self):
    &#34;&#34;&#34;HTML for the active entity.&#34;&#34;&#34;
    v = self.v

    activeVal = v.activeval

    v.activevalrep = H.join(
        H.input(
            type=&#34;hidden&#34;,
            id=f&#34;{feat}_active&#34;,
            name=f&#34;{feat}_active&#34;,
            value=val or &#34;&#34;,
        )
        for (feat, val) in activeVal.items()
    )</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.fragments.Fragments.wrapAnnoSets"><code class="name flex">
<span>def <span class="ident">wrapAnnoSets</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>HTML for the annotation set chooser.</p>
<p>It is a list of buttons, each corresponding to an existing annotation set.
A click on the button selects that set.
There is also a control to delete the set.</p>
<p>Apart from these buttons there is a button to switch to the entities that are
present in the TF dataset as nodes of the entity type specified
in the YAML file with corresponding
features.</p>
<p>Finally, it is possible to create a new, empty annotation set.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/369e52fe19b197bfd6b085594fe9184ecf0cc02e/tf/browser/ner/fragments.py#L22-L121" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrapAnnoSets(self):
    &#34;&#34;&#34;HTML for the annotation set chooser.

    It is a list of buttons, each corresponding to an existing annotation set.
    A click on the button selects that set.
    There is also a control to delete the set.

    Apart from these buttons there is a button to switch to the entities that are
    present in the TF dataset as nodes of the entity type specified
    in the YAML file with corresponding
    features.

    Finally, it is possible to create a new, empty annotation set.
    &#34;&#34;&#34;
    annotate = self.annotate
    setNames = annotate.setNames
    settings = annotate.settings
    entitySet = settings.entitySet

    v = self.v
    chosenAnnoSet = v.annoset

    content1 = [
        H.input(
            type=&#34;hidden&#34;,
            name=&#34;annoset&#34;,
            value=chosenAnnoSet,
            id=&#34;annoseth&#34;,
        ),
        H.input(
            type=&#34;hidden&#34;,
            name=&#34;duannoset&#34;,
            value=&#34;&#34;,
            id=&#34;duannoseth&#34;,
        ),
        H.input(
            type=&#34;hidden&#34;,
            name=&#34;rannoset&#34;,
            value=&#34;&#34;,
            id=&#34;rannoseth&#34;,
        ),
        H.button(
            &#34;+&#34;,
            type=&#34;submit&#34;,
            id=&#34;anew&#34;,
            title=&#34;create a new annotation set&#34;,
            cls=&#34;mono&#34;,
        ),
        &#34; &#34;,
        H.button(
            &#34;++&#34;,
            type=&#34;submit&#34;,
            id=&#34;adup&#34;,
            title=&#34;duplicate this annotation set&#34;,
            cls=&#34;mono&#34;,
        ),
        &#34; &#34;,
        H.select(
            (
                H.option(
                    entitySet if annoSet == &#34;&#34; else annoSet,
                    value=annoSet,
                    selected=annoSet == chosenAnnoSet,
                )
                for annoSet in [&#34;&#34;] + sorted(setNames)
            ),
            cls=&#34;selinp&#34;,
            id=&#34;achange&#34;,
        ),
    ]

    content2 = (
        [
            H.input(
                type=&#34;hidden&#34;,
                name=&#34;dannoset&#34;,
                value=&#34;&#34;,
                id=&#34;dannoseth&#34;,
            ),
            H.button(
                &#34;‚Üí&#34;,
                type=&#34;submit&#34;,
                id=&#34;arename&#34;,
                title=&#34;rename current annotation set&#34;,
                cls=&#34;mono&#34;,
            ),
            &#34; &#34;,
            H.button(
                &#34;-&#34;,
                type=&#34;submit&#34;,
                id=&#34;adelete&#34;,
                title=&#34;delete current annotation set&#34;,
                cls=&#34;mono&#34;,
            ),
        ]
        if chosenAnnoSet
        else []
    )

    v.annosets = H.p(content1, content2)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.fragments.Fragments.wrapAppearance"><code class="name flex">
<span>def <span class="ident">wrapAppearance</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>HTML for the appearance widget.</p>
<p>The appearance widget lets the user choose how inline entities should
appear: with or without underlining, identifier, kind, frequency.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/369e52fe19b197bfd6b085594fe9184ecf0cc02e/tf/browser/ner/fragments.py#L134-L191" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrapAppearance(self):
    &#34;&#34;&#34;HTML for the appearance widget.

    The appearance widget lets the user choose how inline entities should
    appear: with or without underlining, identifier, kind, frequency.
    &#34;&#34;&#34;
    v = self.v
    annotate = self.annotate
    settings = annotate.settings
    features = settings.features

    formattingDo = v.formattingdo
    formattingState = v.formattingstate
    v.formattingbuttons = H.join(
        H.span(
            H.input(
                type=&#34;hidden&#34;,
                name=&#34;formattingdo&#34;,
                value=&#34;v&#34; if formattingDo else &#34;x&#34;,
            ),
            H.button(
                &#34;decorated&#34; if formattingDo else &#34;plain&#34;,
                type=&#34;button&#34;,
                main=&#34;v&#34;,
                title=&#34;toggle plain or decorated formatting of entities&#34;,
                cls=&#34;mono&#34;,
            ),
        ),
        H.span(
            [
                H.span(
                    H.input(
                        type=&#34;hidden&#34;,
                        name=f&#34;{feat}_appearance&#34;,
                        value=&#34;v&#34; if formattingState[feat] else &#34;x&#34;,
                    ),
                    H.button(
                        &#34;stats&#34;
                        if feat == &#34;_stat_&#34;
                        else &#34;underlining&#34;
                        if feat == &#34;_entity_&#34;
                        else feat,
                        feat=feat,
                        type=&#34;button&#34;,
                        title=&#34;toggle display of statistics&#34;
                        if feat == &#34;_stat_&#34;
                        else &#34;toggle formatting of entities&#34;
                        if feat == &#34;_entity&#34;
                        else f&#34;toggle formatting for feature {feat}&#34;,
                        cls=&#34;active&#34; if formattingState[feat] else &#34;&#34;,
                    ),
                )
                for feat in features + (&#34;_stat_&#34;, &#34;_entity_&#34;)
            ],
            id=&#34;decoratewidget&#34;,
        ),
        sep=&#34; &#34;,
    )</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.fragments.Fragments.wrapEntity"><code class="name flex">
<span>def <span class="ident">wrapEntity</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Basic data for the selected entity widget.</p>
<p>The entity widget shows the occurrence or entity that is selected.
This function computed the relevant values and stores them in
hidden input elements.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/369e52fe19b197bfd6b085594fe9184ecf0cc02e/tf/browser/ner/fragments.py#L267-L319" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrapEntity(self):
    &#34;&#34;&#34;Basic data for the selected entity widget.

    The entity widget shows the occurrence or entity that is selected.
    This function computed the relevant values and stores them in
    hidden input elements.
    &#34;&#34;&#34;
    v = self.v
    annotate = self.annotate
    settings = annotate.settings
    features = settings.features

    activeEntity = v.activeentity
    tokenStart = v.tokenstart
    tokenEnd = v.tokenend

    hasEnt = activeEntity is not None
    hasOcc = tokenStart is not None and tokenEnd is not None

    if hasEnt:
        v.tokenstart = None
        v.tokenend = None
        txt = &#34;&#34;
        eTxt = repIdent(features, activeEntity, active=&#34;active&#34;)
    elif hasOcc:
        v.activeentity = None
        txt = (
            annotate.getText(range(tokenStart, tokenEnd + 1))
            if tokenStart and tokenEnd
            else &#34;&#34;
        )
        eTxt = &#34;&#34;
    else:
        v.activeentity = None
        v.tokenstart = None
        v.tokenend = None
        txt = &#34;&#34;
        eTxt = &#34;&#34;

    v.activeentityrep = &#34;‚äô&#34;.join(activeEntity) if activeEntity else &#34;&#34;
    tokenStart = v.tokenstart
    tokenEnd = v.tokenend

    startRep = H.input(
        type=&#34;hidden&#34;, name=&#34;tokenstart&#34;, id=&#34;tokenstart&#34;, value=tokenStart or &#34;&#34;
    )
    endRep = H.input(
        type=&#34;hidden&#34;, name=&#34;tokenend&#34;, id=&#34;tokenend&#34;, value=tokenEnd or &#34;&#34;
    )
    v.entityinit = startRep + endRep

    v.txt = txt
    v.etxt = eTxt</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.fragments.Fragments.wrapEntityFeats"><code class="name flex">
<span>def <span class="ident">wrapEntityFeats</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>HTML for the entity feature value selection.</p>
<p>All feature values of entities that occupy the selected occurrences are
shown, with the possibility that the user selects some of these values,
thereby selecting a subset of the original set of occurrences.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/369e52fe19b197bfd6b085594fe9184ecf0cc02e/tf/browser/ner/fragments.py#L399-L487" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrapEntityFeats(self):
    &#34;&#34;&#34;HTML for the entity feature value selection.

    All feature values of entities that occupy the selected occurrences are
    shown, with the possibility that the user selects some of these values,
    thereby selecting a subset of the original set of occurrences.
    &#34;&#34;&#34;
    v = self.v
    annotate = self.annotate
    settings = annotate.settings
    bucketType = settings.bucketType
    features = settings.features

    setData = annotate.getSetData()

    txt = v.txt
    eTxt = v.etxt
    valSelect = v.valselect
    scopeInit = v.scopeinit
    scopeFilter = v.scopefilter

    hasOcc = txt != &#34;&#34;
    hasEnt = eTxt != &#34;&#34;

    featuresW = {
        feat: valSelect[feat]
        if hasEnt
        else setData.entityTextVal[feat].get(txt, set())
        for feat in features
    }
    content = []
    inputContent = []

    for feat, theseVals in featuresW.items():
        thisValSelect = valSelect[feat]

        valuesContent = []

        inputContent.append(
            H.input(
                type=&#34;hidden&#34;,
                name=f&#34;{feat}_select&#34;,
                id=f&#34;{feat}_select&#34;,
                value=&#34;,&#34;.join(thisValSelect),
            )
        )

        if hasEnt or hasOcc:
            for val in [NONE] + sorted(theseVals):
                valuesContent.append(
                    H.button(
                        val,
                        self.wrapEntityStat(val, feat),
                        type=&#34;button&#34;,
                        name=val or EMPTY,
                        cls=f&#34;{feat}_sel alt&#34;,
                        st=&#34;v&#34; if val in thisValSelect else &#34;x&#34;,
                        title=f&#34;{feat} not marked&#34;
                        if val == NONE
                        else f&#34;{feat} marked as {val}&#34;,
                    )
                )
            titleContent = H.div(H.i(f&#34;{feat}:&#34;), cls=&#34;feattitle&#34;)
        else:
            titleContent = &#34;&#34;

        content.append(H.div(titleContent, valuesContent, cls=&#34;featwidget&#34;))

    total = self.wrapEntityStat(None, &#34;&#34;)
    v.selectentities = (
        H.div(
            H.join(inputContent),
            H.div(
                H.span(H.b(&#34;Select&#34;), scopeInit, scopeFilter),
                H.span(H.span(f&#34;{total} {bucketType}(s)&#34;)),
            )
            if hasEnt
            else H.join(
                H.div(
                    H.p(H.b(&#34;Select&#34;), scopeInit, scopeFilter),
                    H.p(H.span(f&#34;{total} {bucketType}(s)&#34;)),
                ),
                H.div(content, id=&#34;selectsubwidget&#34;),
            ),
            id=&#34;selectwidget&#34;,
        )
        if hasEnt or hasOcc
        else H.join(inputContent)
    )</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.fragments.Fragments.wrapEntityHeaders"><code class="name flex">
<span>def <span class="ident">wrapEntityHeaders</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>HTML for the header of the entity table, dependent on the state of sorting.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/369e52fe19b197bfd6b085594fe9184ecf0cc02e/tf/browser/ner/fragments.py#L321-L355" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrapEntityHeaders(self):
    &#34;&#34;&#34;HTML for the header of the entity table, dependent on the state of sorting.&#34;&#34;&#34;
    v = self.v
    sortKey = v.sortkey
    sortDir = v.sortdir
    annotate = self.annotate
    settings = annotate.settings
    features = settings.features

    sortKeys = ((feat, f&#34;sort_{i}&#34;) for (i, feat) in enumerate(features))

    content = [
        H.input(type=&#34;hidden&#34;, name=&#34;sortkey&#34;, id=&#34;sortkey&#34;, value=sortKey),
        H.input(type=&#34;hidden&#34;, name=&#34;sortdir&#34;, id=&#34;sortdir&#34;, value=sortDir),
    ]

    for label, key in ((&#34;frequency&#34;, &#34;freqsort&#34;), *sortKeys):
        hl = &#34; active &#34; if key == sortKey else &#34;&#34;
        theDir = sortDir if key == sortKey else SORTDIR_ASC
        theArrow = &#34;‚Üë&#34; if theDir == SORTDIR_ASC else &#34;‚Üì&#34;
        content.extend(
            [
                H.button(
                    f&#34;{label} {theArrow}&#34;,
                    type=&#34;button&#34;,
                    tp=&#34;sort&#34;,
                    sk=key,
                    sd=theDir,
                    cls=f&#34;alt{hl}&#34;,
                ),
                &#34; &#34;,
            ]
        )

    return H.p(content)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.fragments.Fragments.wrapEntityModReport"><code class="name flex">
<span>def <span class="ident">wrapEntityModReport</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>HTML for the combined report of add / del actions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/369e52fe19b197bfd6b085594fe9184ecf0cc02e/tf/browser/ner/fragments.py#L861-L869" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrapEntityModReport(self):
    &#34;&#34;&#34;HTML for the combined report of add / del actions.&#34;&#34;&#34;
    v = self.v
    reportDel = v.reportdel
    reportAdd = v.reportadd
    v.modifyreport = H.join(
        H.div(reportDel, id=&#34;delreport&#34;, cls=&#34;report&#34;),
        H.div(reportAdd, id=&#34;addreport&#34;, cls=&#34;report&#34;),
    )</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.fragments.Fragments.wrapEntityModify"><code class="name flex">
<span>def <span class="ident">wrapEntityModify</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>HTML for the add / del widget.</p>
<p>This widget contains controls to specify which entity feature values
should be added or deleted.</p>
<p>Considerable effort is made to prefill these components with ergonomic
values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/369e52fe19b197bfd6b085594fe9184ecf0cc02e/tf/browser/ner/fragments.py#L564-L807" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrapEntityModify(self):
    &#34;&#34;&#34;HTML for the add / del widget.

    This widget contains controls to specify which entity feature values
    should be added or deleted.

    Considerable effort is made to prefill these components with ergonomic
    values.
    &#34;&#34;&#34;
    v = self.v
    annotate = self.annotate
    settings = annotate.settings
    features = settings.features
    keywordFeatures = settings.keywordFeatures

    featureDefault = annotate.featureDefault

    setData = annotate.getSetData()
    annoSet = annotate.annoSet

    txt = v.txt
    eTxt = v.etxt
    submitter = v.submitter
    activeEntity = v.activeentity
    tokenStart = v.tokenstart
    tokenEnd = v.tokenend
    delData = v.adddata
    addData = v.adddata
    modWidgetState = v.modwidgetstate
    excludedTokens = v.excludedtokens

    deletions = delData.deletions
    additions = addData.additions
    freeVals = addData.freeVals

    hasOcc = txt != &#34;&#34;
    hasEnt = eTxt != &#34;&#34;

    delButtonHtml = &#34;&#34;
    addButtonHtml = &#34;&#34;
    delContentHtml = []
    addContentHtml = []

    # Assigment of feature values

    somethingToDelete = True

    if annoSet and (hasOcc or hasEnt):
        instances = self.wrapExceptions()

        for i, feat in enumerate(features):
            isKeyword = feat in keywordFeatures
            theseVals = (
                {activeEntity[i]}
                if hasEnt
                else sorted(setData.entityTextVal[feat].get(txt, set()))
            )
            allVals = (
                sorted(x[0] for x in setData.entityFreq[feat])
                if isKeyword
                else theseVals
            )
            addVals = (
                additions[i]
                if additions is not None and len(additions) &gt; i
                else set()
            )
            delVals = (
                deletions[i]
                if deletions is not None and len(deletions) &gt; i
                else set()
            )
            freeVal = (
                freeVals[i] if freeVals is not None and len(freeVals) &gt; i else None
            )
            default = (
                activeEntity[i]
                if hasEnt
                else featureDefault[feat](range(tokenStart, tokenEnd + 1))
                if hasOcc
                else {}
            )

            titleContent = H.div(
                H.i(f&#34;{feat}:&#34;),
                cls=&#34;feattitle&#34;,
            )

            delValuesContent = []
            addValuesContent = []

            hasSomeVals = False

            for val in allVals:
                occurs = val in theseVals
                delSt = &#34;minus&#34; if hasEnt or val in delVals else &#34;x&#34;
                addSt = (
                    &#34;plus&#34;
                    if val in addVals
                    else &#34;plus&#34;
                    if val == default and freeVal != default
                    else &#34;x&#34;
                )

                if occurs:
                    delValuesContent.append(
                        H.div(
                            [
                                H.span(
                                    val or H.nb,
                                    cls=f&#34;{feat}_sel&#34;,
                                    st=delSt,
                                    val=val,
                                ),
                            ],
                            cls=f&#34;{feat}_w modval&#34;,
                        )
                    )
                    hasSomeVals = True

                addValuesContent.append(
                    H.div(
                        [
                            H.span(
                                val or H.nb, cls=f&#34;{feat}_sel&#34;, st=addSt, val=val
                            ),
                        ],
                        cls=f&#34;{feat}_w modval&#34;,
                    )
                )

            if not hasSomeVals:
                somethingToDelete = False

            init = &#34;&#34; if default in theseVals else default
            val = (
                addVals[0]
                if len(addVals) and submitter in {&#34;lookupn&#34;, &#34;freebutton&#34;}
                else init
                if submitter == &#34;lookupq&#34;
                else freeVal
                if freeVal is not None
                else init
            )
            addSt = (
                &#34;plus&#34;
                if val and len(addVals) and submitter in {&#34;lookupn&#34;, &#34;freebutton&#34;}
                else &#34;plus&#34;
                if submitter == &#34;lookupq&#34; and val
                else &#34;plus&#34;
                if val == freeVal
                else &#34;plus&#34;
                if init and len(theseVals) == 0
                else &#34;x&#34;
            )
            if (isKeyword and val in allVals) or val is None:
                val = &#34;&#34;
                addSt = &#34;x&#34;

            addValuesContent.append(
                H.div(
                    [H.input(type=&#34;text&#34;, st=addSt, value=val, origval=val)],
                    cls=&#34;modval&#34;,
                )
            )

            delContentHtml.append(
                H.div(
                    titleContent,
                    H.div(delValuesContent, cls=&#34;modifyvalues&#34;),
                    cls=&#34;delfeat&#34;,
                    feat=feat,
                )
            )
            addContentHtml.append(
                H.div(
                    titleContent,
                    H.div(addValuesContent, cls=&#34;modifyvalues&#34;),
                    cls=&#34;addfeat&#34;,
                    feat=feat,
                )
            )

        delButtonHtml = H.span(
            H.button(&#34;Delete&#34;, type=&#34;button&#34;, id=&#34;delgo&#34;, value=&#34;v&#34;, cls=&#34;special&#34;),
            H.input(type=&#34;hidden&#34;, id=&#34;deldata&#34;, name=&#34;deldata&#34;, value=&#34;&#34;),
        )
        addButtonHtml = H.span(
            H.button(&#34;Add&#34;, type=&#34;button&#34;, id=&#34;addgo&#34;, value=&#34;v&#34;, cls=&#34;special&#34;),
            H.input(type=&#34;hidden&#34;, id=&#34;adddata&#34;, name=&#34;adddata&#34;, value=&#34;&#34;),
        )
        delResetHtml = H.button(
            &#34;‚å´&#34;,
            type=&#34;button&#34;,
            id=&#34;delresetbutton&#34;,
            title=&#34;clear values in form&#34;,
            cls=&#34;icon&#34;,
        )
        addResetHtml = H.button(
            &#34;‚å´&#34;,
            type=&#34;button&#34;,
            id=&#34;addresetbutton&#34;,
            title=&#34;clear values in form&#34;,
            cls=&#34;icon&#34;,
        )

        delWidgetContent = (
            H.div(
                H.span(
                    H.span(delButtonHtml, delResetHtml, id=&#34;modifyhead&#34;),
                    H.span(delContentHtml, cls=&#34;assignwidget&#34;),
                ),
                H.span(&#34;&#34;, id=&#34;delfeedback&#34;, cls=&#34;feedback&#34;),
                id=&#34;delwidget&#34;,
            )
            if somethingToDelete
            else &#34;&#34;
        )
        v.modifyentity = H.div(
            H.input(
                type=&#34;hidden&#34;,
                id=&#34;modwidgetstate&#34;,
                name=&#34;modwidgetstate&#34;,
                value=modWidgetState,
            ),
            H.input(
                type=&#34;hidden&#34;,
                id=&#34;excludedtokens&#34;,
                name=&#34;excludedtokens&#34;,
                value=&#34;,&#34;.join(str(t) for t in excludedTokens),
            ),
            H.b(&#34;Modify&#34;),
            instances,
            delWidgetContent,
            H.div(
                H.span(
                    H.span(addButtonHtml, addResetHtml, id=&#34;modifyhead&#34;),
                    H.span(addContentHtml, cls=&#34;assignwidget&#34;),
                ),
                H.span(&#34;&#34;, id=&#34;addfeedback&#34;, cls=&#34;feedback&#34;),
                id=&#34;addwidget&#34;,
            ),
            id=&#34;modwidget&#34;,
        )</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.fragments.Fragments.wrapEntityStat"><code class="name flex">
<span>def <span class="ident">wrapEntityStat</span></span>(<span>self, val, feat)</span>
</code></dt>
<dd>
<div class="desc"><p>HTML for statistics of feature values.</p>
<p>This is about totals of occurrences of feature values in all buckets
versus in filtered buckets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/369e52fe19b197bfd6b085594fe9184ecf0cc02e/tf/browser/ner/fragments.py#L823-L843" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrapEntityStat(self, val, feat):
    &#34;&#34;&#34;HTML for statistics of feature values.

    This is about totals of occurrences of feature values in all buckets
    versus in filtered buckets.
    &#34;&#34;&#34;
    v = self.v
    nVisible = v.nvisible
    nEnt = v.nent
    hasFilter = v.hasfilter

    thisNVisible = nVisible[feat]
    thisNEnt = nEnt[feat]

    na = thisNEnt[val]
    n = (
        (H.span(f&#34;{thisNVisible[val]} of &#34;, cls=&#34;filted&#34;) + f&#34;{na}&#34;)
        if hasFilter
        else f&#34;{na}&#34;
    )
    return H.span(n, cls=&#34;stat&#34;)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.fragments.Fragments.wrapEntityText"><code class="name flex">
<span>def <span class="ident">wrapEntityText</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>HTML for the selected entity widget.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/369e52fe19b197bfd6b085594fe9184ecf0cc02e/tf/browser/ner/fragments.py#L357-L397" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrapEntityText(self):
    &#34;&#34;&#34;HTML for the selected entity widget.&#34;&#34;&#34;
    v = self.v

    freeState = v.freestate
    txt = v.txt
    eTxt = v.etxt

    title = &#34;choose: free, intersecting with other entities, or all&#34;
    v.entitytext = H.join(
        H.span(txt if txt else eTxt or &#34;&#34;, id=&#34;qtextentshow&#34;),
        &#34; &#34;,
        H.button(&#34;‚ùå&#34;, type=&#34;submit&#34;, id=&#34;queryclear&#34;, cls=&#34;icon&#34;),
        &#34; &#34;,
        H.button(
            &#34;‚úÖ&#34;,
            type=&#34;submit&#34;,
            id=&#34;lookupq&#34;,
            cls=&#34;icon&#34;,
            title=&#34;look up and fill in green fields&#34;,
        ),
        H.button(
            &#34;‚ùé&#34;,
            type=&#34;submit&#34;,
            id=&#34;lookupn&#34;,
            cls=&#34;icon&#34;,
            title=&#34;look up and keep green fields as is&#34;,
        ),
        H.input(type=&#34;hidden&#34;, name=&#34;freestate&#34;, id=&#34;freestate&#34;, value=freeState),
        H.button(
            &#34;‚ö≠ intersecting&#34;
            if freeState == &#34;bound&#34;
            else &#34;‚öØ free&#34;
            if freeState == &#34;free&#34;
            else &#34;‚ö¨ all&#34;,
            type=&#34;submit&#34;,
            id=&#34;freebutton&#34;,
            cls=&#34;mono&#34;,
            title=title,
        ),
    )</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.fragments.Fragments.wrapExceptions"><code class="name flex">
<span>def <span class="ident">wrapExceptions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>HTML for the select / deselect buttons.</p>
<p>These buttons appear at the end of selected occurrences in the text displayed
in the buckets.
The user can select or deselect individual entities for the application of
the add / del operations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/369e52fe19b197bfd6b085594fe9184ecf0cc02e/tf/browser/ner/fragments.py#L522-L562" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrapExceptions(self):
    &#34;&#34;&#34;HTML for the select / deselect buttons.

    These buttons appear at the end of selected occurrences in the text displayed
    in the buckets.
    The user can select or deselect individual entities for the application of
    the add / del operations.
    &#34;&#34;&#34;
    v = self.v
    txt = v.txt
    eTxt = v.etxt
    annotate = self.annotate
    settings = annotate.settings
    bucketType = settings.bucketType
    annoSet = annotate.annoSet
    hasOcc = txt != &#34;&#34;
    hasEnt = eTxt != &#34;&#34;

    scopeExceptions = &#34;&#34;

    if annoSet and (hasOcc or hasEnt):
        scopeExceptions = H.span(
            H.nb,
            H.button(
                &#34;‚úÖ&#34;,
                type=&#34;button&#34;,
                id=&#34;selectall&#34;,
                title=f&#34;select all occurrences in filtered {bucketType}s&#34;,
                cls=&#34;icon&#34;,
            ),
            &#34; &#34;,
            H.button(
                &#34;‚ùå&#34;,
                type=&#34;button&#34;,
                id=&#34;selectnone&#34;,
                title=f&#34;deselect all occurrences in filtered {bucketType}s&#34;,
                cls=&#34;icon&#34;,
            ),
        )

    return scopeExceptions</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.fragments.Fragments.wrapFilter"><code class="name flex">
<span>def <span class="ident">wrapFilter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>HTML for the filter widget.</p>
<p>The filter widget lets the user filter the buckets by a search pattern
or the condition that the buckets contains entities (and the even more useful
condition that the buckets do <em>not</em> contain entities).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/369e52fe19b197bfd6b085594fe9184ecf0cc02e/tf/browser/ner/fragments.py#L193-L265" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrapFilter(self):
    &#34;&#34;&#34;HTML for the filter widget.

    The filter widget lets the user filter the buckets by a search pattern
    or the condition that the buckets contains entities (and the even more useful
    condition that the buckets do *not* contain entities).
    &#34;&#34;&#34;
    v = self.v
    annotate = self.annotate
    setData = annotate.getSetData()

    bFind = v.bfind
    bFindC = v.bfindc
    bFindRe = v.bfindre
    bFindError = v.bfinderror
    anyEnt = v.anyent

    v.hasfilter = bFindRe is not None or anyEnt is not None
    v.nbuckets = len(setData.buckets or [])

    v.filterwidget = H.join(
        H.span(
            H.input(type=&#34;text&#34;, name=&#34;bfind&#34;, id=&#34;bfind&#34;, value=bFind),
            H.input(
                type=&#34;hidden&#34;,
                name=&#34;bfindc&#34;,
                id=&#34;bfindc&#34;,
                value=&#34;v&#34; if bFindC else &#34;x&#34;,
            ),
            H.button(
                &#34;C&#34; if bFindC else &#34;¬¢&#34;,
                type=&#34;submit&#34;,
                id=&#34;bfindb&#34;,
                title=&#34;using case SENSITIVE search&#34;
                if bFindC
                else &#34;using case INSENSITIVE search&#34;,
                cls=&#34;mono&#34;,
            ),
            &#34; &#34;,
            H.button(&#34;‚ùå&#34;, type=&#34;submit&#34;, id=&#34;findclear&#34;, cls=&#34;icon&#34;),
            &#34; &#34;,
            H.span(bFindError, id=&#34;bfinderror&#34;, cls=&#34;error&#34;),
            cls=&#34;filtercomponent&#34;,
        ),
        H.span(
            H.input(
                type=&#34;hidden&#34;,
                name=&#34;anyent&#34;,
                id=&#34;anyent&#34;,
                value=&#34;&#34; if anyEnt is None else &#34;v&#34; if anyEnt else &#34;x&#34;,
            ),
            H.button(
                &#34;with or without&#34;
                if anyEnt is None
                else &#34;with&#34;
                if anyEnt
                else &#34;without&#34;,
                type=&#34;submit&#34;,
                id=&#34;anyentbutton&#34;,
                cls=&#34;mono&#34;,
            ),
            H.span(&#34; marked entities&#34;),
            cls=&#34;filtercomponent&#34;,
        ),
        H.span(
            H.button(&#34;üîé&#34;, type=&#34;submit&#34;, id=&#34;lookupf&#34;, cls=&#34;alt&#34;),
            cls=&#34;filtercomponent&#34;,
        ),
        H.span(
            self.wrapFindStat(),
            cls=&#34;filtercomponent&#34;,
        ),
    )</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.fragments.Fragments.wrapFindStat"><code class="name flex">
<span>def <span class="ident">wrapFindStat</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>HTML for statistics.</p>
<p>This is about totals of occurrences in all buckets versus in filtered
buckets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/369e52fe19b197bfd6b085594fe9184ecf0cc02e/tf/browser/ner/fragments.py#L809-L821" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrapFindStat(self):
    &#34;&#34;&#34;HTML for statistics.

    This is about totals of occurrences in all buckets versus in filtered
    buckets.
    &#34;&#34;&#34;
    v = self.v
    nBuckets = v.nbuckets
    nFind = v.nfind
    hasFilter = v.hasfilter

    n = f&#34;{nFind} of {nBuckets}&#34; if hasFilter else nBuckets
    return H.span(n, cls=&#34;stat&#34;)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.fragments.Fragments.wrapMessages"><code class="name flex">
<span>def <span class="ident">wrapMessages</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>HTML for messages.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/369e52fe19b197bfd6b085594fe9184ecf0cc02e/tf/browser/ner/fragments.py#L15-L20" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrapMessages(self):
    &#34;&#34;&#34;HTML for messages.&#34;&#34;&#34;
    v = self.v
    messageSrc = v.messagesrc

    v.messages = H.p((H.span(text, cls=lev) + H.br() for (lev, text) in messageSrc))</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.fragments.Fragments.wrapQuery"><code class="name flex">
<span>def <span class="ident">wrapQuery</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>HTML for all control widgets on the page.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/369e52fe19b197bfd6b085594fe9184ecf0cc02e/tf/browser/ner/fragments.py#L123-L132" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrapQuery(self):
    &#34;&#34;&#34;HTML for all control widgets on the page.&#34;&#34;&#34;
    self.wrapAppearance()
    self.wrapFilter()
    self.wrapEntity()
    self.wrapEntityText()
    self.wrapScope()
    self.wrapEntityFeats()
    self.wrapEntityModReport()
    self.wrapEntityModify()</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.fragments.Fragments.wrapReport"><code class="name flex">
<span>def <span class="ident">wrapReport</span></span>(<span>self, report, kind)</span>
</code></dt>
<dd>
<div class="desc"><p>HTML for the report of add / del actions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/369e52fe19b197bfd6b085594fe9184ecf0cc02e/tf/browser/ner/fragments.py#L871-L891" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrapReport(self, report, kind):
    &#34;&#34;&#34;HTML for the report of add / del actions.&#34;&#34;&#34;
    v = self.v
    annotate = self.annotate
    settings = annotate.settings
    features = settings.features

    label = &#34;Deletion&#34; if kind == &#34;del&#34; else &#34;Addition&#34; if kind == &#34;add&#34; else &#34;&#34;
    v[f&#34;report{kind}&#34;] = H.join(
        H.div(
            H.join(
                H.div(f&#34;{label}: {n} x {valRep(features, fVals)}&#34;)
                for (fVals, n) in line
            )
            if type(line) is tuple
            else line,
            cls=&#34;report&#34;,
        )
        for line in report
    )
    report.clear()</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.fragments.Fragments.wrapScope"><code class="name flex">
<span>def <span class="ident">wrapScope</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>HTML for the scope widget.</p>
<p>The scope widget lets the user choose whether the add / del actions should
be applied to all relevant buckets, or only to the filtered buckets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/369e52fe19b197bfd6b085594fe9184ecf0cc02e/tf/browser/ner/fragments.py#L489-L520" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def wrapScope(self):
    &#34;&#34;&#34;HTML for the scope widget.

    The scope widget lets the user choose whether the add / del actions should
    be applied to all relevant buckets, or only to the filtered buckets.
    &#34;&#34;&#34;
    v = self.v
    annotate = self.annotate
    annoSet = annotate.annoSet
    scope = v.scope
    hasFilter = v.hasfilter
    txt = v.txt
    eTxt = v.etxt
    hasOcc = txt != &#34;&#34;
    hasEnt = eTxt != &#34;&#34;

    scopeInit = H.input(type=&#34;hidden&#34;, id=&#34;scope&#34;, name=&#34;scope&#34;, value=scope)
    scopeFilter = &#34;&#34;

    if annoSet and (hasOcc or hasEnt):
        # Scope of modification

        scopeFilter = (
            H.span(
                H.button(&#34;&#34;, type=&#34;button&#34;, id=&#34;scopebutton&#34;, title=&#34;&#34;, cls=&#34;alt&#34;)
            )
            if hasFilter
            else &#34;&#34;
        )

    v.scopeinit = scopeInit
    v.scopefilter = scopeFilter</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../../tf/index.html">tf home</a> -
<a href="../../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="üîé Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.browser.ner" href="index.html">tf.browser.ner</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.browser.ner.fragments.Fragments" href="#tf.browser.ner.fragments.Fragments">Fragments</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.browser.ner.fragments.Fragments.wrapActive" href="#tf.browser.ner.fragments.Fragments.wrapActive">wrapActive</a></code></li>
<li><code><a title="tf.browser.ner.fragments.Fragments.wrapAnnoSets" href="#tf.browser.ner.fragments.Fragments.wrapAnnoSets">wrapAnnoSets</a></code></li>
<li><code><a title="tf.browser.ner.fragments.Fragments.wrapAppearance" href="#tf.browser.ner.fragments.Fragments.wrapAppearance">wrapAppearance</a></code></li>
<li><code><a title="tf.browser.ner.fragments.Fragments.wrapEntity" href="#tf.browser.ner.fragments.Fragments.wrapEntity">wrapEntity</a></code></li>
<li><code><a title="tf.browser.ner.fragments.Fragments.wrapEntityFeats" href="#tf.browser.ner.fragments.Fragments.wrapEntityFeats">wrapEntityFeats</a></code></li>
<li><code><a title="tf.browser.ner.fragments.Fragments.wrapEntityHeaders" href="#tf.browser.ner.fragments.Fragments.wrapEntityHeaders">wrapEntityHeaders</a></code></li>
<li><code><a title="tf.browser.ner.fragments.Fragments.wrapEntityModReport" href="#tf.browser.ner.fragments.Fragments.wrapEntityModReport">wrapEntityModReport</a></code></li>
<li><code><a title="tf.browser.ner.fragments.Fragments.wrapEntityModify" href="#tf.browser.ner.fragments.Fragments.wrapEntityModify">wrapEntityModify</a></code></li>
<li><code><a title="tf.browser.ner.fragments.Fragments.wrapEntityStat" href="#tf.browser.ner.fragments.Fragments.wrapEntityStat">wrapEntityStat</a></code></li>
<li><code><a title="tf.browser.ner.fragments.Fragments.wrapEntityText" href="#tf.browser.ner.fragments.Fragments.wrapEntityText">wrapEntityText</a></code></li>
<li><code><a title="tf.browser.ner.fragments.Fragments.wrapExceptions" href="#tf.browser.ner.fragments.Fragments.wrapExceptions">wrapExceptions</a></code></li>
<li><code><a title="tf.browser.ner.fragments.Fragments.wrapFilter" href="#tf.browser.ner.fragments.Fragments.wrapFilter">wrapFilter</a></code></li>
<li><code><a title="tf.browser.ner.fragments.Fragments.wrapFindStat" href="#tf.browser.ner.fragments.Fragments.wrapFindStat">wrapFindStat</a></code></li>
<li><code><a title="tf.browser.ner.fragments.Fragments.wrapMessages" href="#tf.browser.ner.fragments.Fragments.wrapMessages">wrapMessages</a></code></li>
<li><code><a title="tf.browser.ner.fragments.Fragments.wrapQuery" href="#tf.browser.ner.fragments.Fragments.wrapQuery">wrapQuery</a></code></li>
<li><code><a title="tf.browser.ner.fragments.Fragments.wrapReport" href="#tf.browser.ner.fragments.Fragments.wrapReport">wrapReport</a></code></li>
<li><code><a title="tf.browser.ner.fragments.Fragments.wrapScope" href="#tf.browser.ner.fragments.Fragments.wrapScope">wrapScope</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>