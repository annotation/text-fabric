<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.browser.ner.request API documentation</title>
<meta name="description" content="Auxiliary functions for managing request data â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-GjqubOlYA6/wOZV7F31o2t4ogk4JGDGFa6XmL+BfAG0=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-qDPJ4nH38AgHyK3U6cvI6DBifA+7hPBo8mVoH6pyN9c=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.browser.ner.request</code></h1>
</header>
<section id="section-intro">
<p>Auxiliary functions for managing request data.</p>
<p>To see how this fits among all the modules of this package, see
<code><a title="tf.browser.ner.annotate" href="annotate.html">tf.browser.ner.annotate</a></code> .</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/7fdf25fed954698d7bcf1c0099489ed4c8456fe6/tf/browser/ner/request.py#L1-L302" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Auxiliary functions for managing request data.

To see how this fits among all the modules of this package, see
`tf.browser.ner.annotate` .
&#34;&#34;&#34;


from ...core.generic import AttrDict
from .settings import TOOLKEY, EMPTY, NONE, SORTKEY_DEFAULT, SORTDIR_DEFAULT, SC_ALL
from .form import Form
from .helpers import findCompile


class Request(Form):
    def __init__(self):
        &#34;&#34;&#34;Calculate important values based on form data.

        We define specifications as to how to read form values and which defaults
        should be supplied.

        We categorize the keys in the request form into categories based on their
        interpreted type and organization.

        We provide appropriate empty values as defaults, but it is possible to specify
        other defaults.

        The categories are:

        *   `Str` values are strings;
        *   `Bool` values are booleans (2 possible values);
        *   `Tri` values are booleans (3 possible values, a none value is included);
        *   `Int` values are positive integers;
        *   `Tup` values are tuples of strings;
        *   `SetInt` values are sets of integers;
        *   `Json` values are arbitrary structures encoded in json strings;

        We also define a few composed values, where we store the values of
        several related keys in the form as a dictionary value under a new key.
        &#34;&#34;&#34;
        annotate = self.annotate
        settings = annotate.settings
        features = settings.features

        keysStr = &#34;&#34;&#34;
            resetForm
            submitter
            sec0
            sec1
            sec2
            annoset
            duannoset
            rannoset
            dannoset
            sortkey
            sortdir
            bfind
            bfinderror
            freestate
            efind
            scope
            reportdel
            reportadd
            modwidgetstate
        &#34;&#34;&#34;.strip().split()

        keysBool = &#34;&#34;&#34;
            formattingdo
            bfindc
        &#34;&#34;&#34;.strip().split()

        keysTri = &#34;&#34;&#34;
            anyent
        &#34;&#34;&#34;.strip().split()

        keysInt = &#34;&#34;&#34;
            tokenstart
            tokenend
        &#34;&#34;&#34;.strip().split()

        keysTup = &#34;&#34;&#34;
            activeentity
        &#34;&#34;&#34;.strip().split()

        keysSetInt = &#34;&#34;&#34;
            excludedtokens
        &#34;&#34;&#34;.strip().split()

        keysJson = &#34;&#34;&#34;
            adddata
            deldata
        &#34;&#34;&#34;.strip().split()

        defaults = dict(
            sortkey=SORTKEY_DEFAULT,
            sortdir=SORTDIR_DEFAULT,
            freestate=&#34;all&#34;,
            scope=SC_ALL,
            modwidgetstate=&#34;add&#34;,
        )

        formattingState = {
            feat: f&#34;{feat}_appearance&#34; for feat in features + (&#34;_stat_&#34;, &#34;_entity_&#34;)
        }
        self.formattingState = formattingState

        for feat, featStr in formattingState.items():
            keysBool.append(featStr)
            defaults[featStr] = &#34;v&#34;

        activeVal = {feat: f&#34;{feat}_active&#34; for feat in features}
        self.activeVal = activeVal

        for feat, featStr in activeVal.items():
            keysStr.append(featStr)

        valSelectProto = {feat: f&#34;{feat}_select&#34; for feat in features}
        self.valSelectProto = valSelectProto

        for feat, featStr in valSelectProto.items():
            keysStr.append(featStr)

        super().__init__(
            features,
            defaults,
            keysStr=keysStr,
            keysBool=keysBool,
            keysTri=keysTri,
            keysInt=keysInt,
            keysTup=keysTup,
            keysSetInt=keysSetInt,
            keysJson=keysJson,
        )

    def getFormData(self):
        &#34;&#34;&#34;Get form data.

        The TF browser user interacts with the app by clicking and typing,
        as a result of which a HTML form gets filled in.
        This form as regularly submitted to the server with a request
        for a new incarnation of the page: a response.

        The values that come with a request, must be peeled out of the form,
        and stored as logical values.

        Additionally, some business logic is carried out:
        we set values for the entity features, based on the form, especially the
        keys ending in `_active`. We build a value under key `valselect`
        based on the value for key `submitter`.
        Depending on which button caused the submit, the NONE value is added
        to each feature.

        The idea is that when the user is still engaged in filtering buckets,
        and there is an occurrence selected, the user should have the option
        to sub-select occurrences that do not yet have an entity assigned.
        &#34;&#34;&#34;
        annotate = self.annotate
        settings = annotate.settings
        features = settings.features
        formattingState = self.formattingState
        activeVal = self.activeVal
        valSelectProto = self.valSelectProto

        form = self.fill()

        form[&#34;formattingstate&#34;] = {
            feat: self.fget2(featStr) for (feat, featStr) in formattingState.items()
        }

        form[&#34;activeval&#34;] = {
            feat: self.fgets(featStr) for (feat, featStr) in activeVal.items()
        }

        valSelectProto = {
            feat: self.fgets(featStr) for (feat, featStr) in valSelectProto.items()
        }

        submitter = form[&#34;submitter&#34;]

        valSelect = {}

        startSearch = submitter in {&#34;lookupq&#34;, &#34;lookupn&#34;, &#34;freebutton&#34;}

        for feat in features:
            valProto = valSelectProto[feat]
            valSelect[feat] = (
                set(&#34;&#34; if x == EMPTY else x for x in valProto.split(&#34;,&#34;))
                if valProto
                else set()
            )
            if startSearch:
                valSelect[feat].add(NONE)

        form[&#34;valselect&#34;] = valSelect

        return form

    def initVars(self):
        &#34;&#34;&#34;Initializes the computation of the new page.

        It collects the request data, gleans some info from the configuration
        settings and the TF app, and initializes some data structures that
        will collect further information for the page.

        All bits and pieces that are needed during processing
        the request and filling in the final HTML template find a place under
        some key in the `v` dict which is stored in `self`.

        So, this function makes the transition from information that is in the
        `form` dictionary to values that are stored in the `v` dictionary.
        &#34;&#34;&#34;
        annotate = self.annotate
        settings = annotate.settings
        bucketType = settings.bucketType
        features = settings.features

        appName = annotate.appName
        appName = appName.replace(&#34;/&#34;, &#34; / &#34;)
        slotType = annotate.slotType

        form = self.getFormData()
        resetForm = form[&#34;resetForm&#34;]

        v = AttrDict()
        v.toolkey = TOOLKEY
        v.buckettype = bucketType
        v.featurelist = &#34;,&#34;.join(features)

        for k, vl in form.items():
            if not resetForm or k not in v:
                v[k] = vl

        v.appname = appName
        v.slottype = slotType
        v.resetform = &#34;&#34;

        self.v = v

    def adaptValSelect(self):
        &#34;&#34;&#34;Adapts the values contained in `valSelect` after a modification action.

        After the addition or deletion of an entity, the values contained in `valSelect`
        may have become obsolete or inconvenient for further actions.

        This function adapts those values before having them rendered on the page.

        Parameters
        ----------
        v: dict
            Contains the intermediate results of computing the new page.
        &#34;&#34;&#34;
        v = self.v
        annotate = self.annotate
        settings = annotate.settings
        features = settings.features

        submitter = v.submitter
        valSelect = v.valselect

        if submitter == &#34;addgo&#34;:
            addData = v.adddata
            additions = addData.additions
            freeVals = addData.freeVals

            freeState = v.freestate

            for i, (feat, values) in enumerate(zip(features, additions)):
                for val in values:
                    valSelect.setdefault(feat, set()).add(val)
                    if val == freeVals[i]:
                        freeVals[i] = None

            if freeState == &#34;free&#34;:
                v.freestate = &#34;all&#34;

        elif submitter == &#34;delgo&#34;:
            for feat in features:
                valSelect.setdefault(feat, set()).add(NONE)

        v.submitter = &#34;&#34;

    def findSetup(self):
        &#34;&#34;&#34;Compiles the filter pattern into a regular expression.

        When the user enters a search pattern in the box meant to filter the buckets,
        the pattern will be interpreted as a regular expression.

        We do the compilation here.
        If there are errors in the pattern they will be reported.
        Whether or not the search is case sensitive or not is under user control,
        and it will influence the compilation of the pattern.

        All input and output data is in `v` .
        &#34;&#34;&#34;
        v = self.v
        bFind = v.bfind
        bFindC = v.bfindc

        (bFind, bFindRe, errorMsg) = findCompile(bFind, bFindC)

        v.bfind = bFind
        v.bfindre = bFindRe
        v.errormsg = errorMsg</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.browser.ner.request.Request"><code class="flex name class">
<span>class <span class="ident">Request</span></span>
</code></dt>
<dd>
<div class="desc"><p>Calculate important values based on form data.</p>
<p>We define specifications as to how to read form values and which defaults
should be supplied.</p>
<p>We categorize the keys in the request form into categories based on their
interpreted type and organization.</p>
<p>We provide appropriate empty values as defaults, but it is possible to specify
other defaults.</p>
<p>The categories are:</p>
<ul>
<li><code>Str</code> values are strings;</li>
<li><code>Bool</code> values are booleans (2 possible values);</li>
<li><code>Tri</code> values are booleans (3 possible values, a none value is included);</li>
<li><code>Int</code> values are positive integers;</li>
<li><code>Tup</code> values are tuples of strings;</li>
<li><code>SetInt</code> values are sets of integers;</li>
<li><code>Json</code> values are arbitrary structures encoded in json strings;</li>
</ul>
<p>We also define a few composed values, where we store the values of
several related keys in the form as a dictionary value under a new key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/7fdf25fed954698d7bcf1c0099489ed4c8456fe6/tf/browser/ner/request.py#L14-L302" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Request(Form):
    def __init__(self):
        &#34;&#34;&#34;Calculate important values based on form data.

        We define specifications as to how to read form values and which defaults
        should be supplied.

        We categorize the keys in the request form into categories based on their
        interpreted type and organization.

        We provide appropriate empty values as defaults, but it is possible to specify
        other defaults.

        The categories are:

        *   `Str` values are strings;
        *   `Bool` values are booleans (2 possible values);
        *   `Tri` values are booleans (3 possible values, a none value is included);
        *   `Int` values are positive integers;
        *   `Tup` values are tuples of strings;
        *   `SetInt` values are sets of integers;
        *   `Json` values are arbitrary structures encoded in json strings;

        We also define a few composed values, where we store the values of
        several related keys in the form as a dictionary value under a new key.
        &#34;&#34;&#34;
        annotate = self.annotate
        settings = annotate.settings
        features = settings.features

        keysStr = &#34;&#34;&#34;
            resetForm
            submitter
            sec0
            sec1
            sec2
            annoset
            duannoset
            rannoset
            dannoset
            sortkey
            sortdir
            bfind
            bfinderror
            freestate
            efind
            scope
            reportdel
            reportadd
            modwidgetstate
        &#34;&#34;&#34;.strip().split()

        keysBool = &#34;&#34;&#34;
            formattingdo
            bfindc
        &#34;&#34;&#34;.strip().split()

        keysTri = &#34;&#34;&#34;
            anyent
        &#34;&#34;&#34;.strip().split()

        keysInt = &#34;&#34;&#34;
            tokenstart
            tokenend
        &#34;&#34;&#34;.strip().split()

        keysTup = &#34;&#34;&#34;
            activeentity
        &#34;&#34;&#34;.strip().split()

        keysSetInt = &#34;&#34;&#34;
            excludedtokens
        &#34;&#34;&#34;.strip().split()

        keysJson = &#34;&#34;&#34;
            adddata
            deldata
        &#34;&#34;&#34;.strip().split()

        defaults = dict(
            sortkey=SORTKEY_DEFAULT,
            sortdir=SORTDIR_DEFAULT,
            freestate=&#34;all&#34;,
            scope=SC_ALL,
            modwidgetstate=&#34;add&#34;,
        )

        formattingState = {
            feat: f&#34;{feat}_appearance&#34; for feat in features + (&#34;_stat_&#34;, &#34;_entity_&#34;)
        }
        self.formattingState = formattingState

        for feat, featStr in formattingState.items():
            keysBool.append(featStr)
            defaults[featStr] = &#34;v&#34;

        activeVal = {feat: f&#34;{feat}_active&#34; for feat in features}
        self.activeVal = activeVal

        for feat, featStr in activeVal.items():
            keysStr.append(featStr)

        valSelectProto = {feat: f&#34;{feat}_select&#34; for feat in features}
        self.valSelectProto = valSelectProto

        for feat, featStr in valSelectProto.items():
            keysStr.append(featStr)

        super().__init__(
            features,
            defaults,
            keysStr=keysStr,
            keysBool=keysBool,
            keysTri=keysTri,
            keysInt=keysInt,
            keysTup=keysTup,
            keysSetInt=keysSetInt,
            keysJson=keysJson,
        )

    def getFormData(self):
        &#34;&#34;&#34;Get form data.

        The TF browser user interacts with the app by clicking and typing,
        as a result of which a HTML form gets filled in.
        This form as regularly submitted to the server with a request
        for a new incarnation of the page: a response.

        The values that come with a request, must be peeled out of the form,
        and stored as logical values.

        Additionally, some business logic is carried out:
        we set values for the entity features, based on the form, especially the
        keys ending in `_active`. We build a value under key `valselect`
        based on the value for key `submitter`.
        Depending on which button caused the submit, the NONE value is added
        to each feature.

        The idea is that when the user is still engaged in filtering buckets,
        and there is an occurrence selected, the user should have the option
        to sub-select occurrences that do not yet have an entity assigned.
        &#34;&#34;&#34;
        annotate = self.annotate
        settings = annotate.settings
        features = settings.features
        formattingState = self.formattingState
        activeVal = self.activeVal
        valSelectProto = self.valSelectProto

        form = self.fill()

        form[&#34;formattingstate&#34;] = {
            feat: self.fget2(featStr) for (feat, featStr) in formattingState.items()
        }

        form[&#34;activeval&#34;] = {
            feat: self.fgets(featStr) for (feat, featStr) in activeVal.items()
        }

        valSelectProto = {
            feat: self.fgets(featStr) for (feat, featStr) in valSelectProto.items()
        }

        submitter = form[&#34;submitter&#34;]

        valSelect = {}

        startSearch = submitter in {&#34;lookupq&#34;, &#34;lookupn&#34;, &#34;freebutton&#34;}

        for feat in features:
            valProto = valSelectProto[feat]
            valSelect[feat] = (
                set(&#34;&#34; if x == EMPTY else x for x in valProto.split(&#34;,&#34;))
                if valProto
                else set()
            )
            if startSearch:
                valSelect[feat].add(NONE)

        form[&#34;valselect&#34;] = valSelect

        return form

    def initVars(self):
        &#34;&#34;&#34;Initializes the computation of the new page.

        It collects the request data, gleans some info from the configuration
        settings and the TF app, and initializes some data structures that
        will collect further information for the page.

        All bits and pieces that are needed during processing
        the request and filling in the final HTML template find a place under
        some key in the `v` dict which is stored in `self`.

        So, this function makes the transition from information that is in the
        `form` dictionary to values that are stored in the `v` dictionary.
        &#34;&#34;&#34;
        annotate = self.annotate
        settings = annotate.settings
        bucketType = settings.bucketType
        features = settings.features

        appName = annotate.appName
        appName = appName.replace(&#34;/&#34;, &#34; / &#34;)
        slotType = annotate.slotType

        form = self.getFormData()
        resetForm = form[&#34;resetForm&#34;]

        v = AttrDict()
        v.toolkey = TOOLKEY
        v.buckettype = bucketType
        v.featurelist = &#34;,&#34;.join(features)

        for k, vl in form.items():
            if not resetForm or k not in v:
                v[k] = vl

        v.appname = appName
        v.slottype = slotType
        v.resetform = &#34;&#34;

        self.v = v

    def adaptValSelect(self):
        &#34;&#34;&#34;Adapts the values contained in `valSelect` after a modification action.

        After the addition or deletion of an entity, the values contained in `valSelect`
        may have become obsolete or inconvenient for further actions.

        This function adapts those values before having them rendered on the page.

        Parameters
        ----------
        v: dict
            Contains the intermediate results of computing the new page.
        &#34;&#34;&#34;
        v = self.v
        annotate = self.annotate
        settings = annotate.settings
        features = settings.features

        submitter = v.submitter
        valSelect = v.valselect

        if submitter == &#34;addgo&#34;:
            addData = v.adddata
            additions = addData.additions
            freeVals = addData.freeVals

            freeState = v.freestate

            for i, (feat, values) in enumerate(zip(features, additions)):
                for val in values:
                    valSelect.setdefault(feat, set()).add(val)
                    if val == freeVals[i]:
                        freeVals[i] = None

            if freeState == &#34;free&#34;:
                v.freestate = &#34;all&#34;

        elif submitter == &#34;delgo&#34;:
            for feat in features:
                valSelect.setdefault(feat, set()).add(NONE)

        v.submitter = &#34;&#34;

    def findSetup(self):
        &#34;&#34;&#34;Compiles the filter pattern into a regular expression.

        When the user enters a search pattern in the box meant to filter the buckets,
        the pattern will be interpreted as a regular expression.

        We do the compilation here.
        If there are errors in the pattern they will be reported.
        Whether or not the search is case sensitive or not is under user control,
        and it will influence the compilation of the pattern.

        All input and output data is in `v` .
        &#34;&#34;&#34;
        v = self.v
        bFind = v.bfind
        bFindC = v.bfindc

        (bFind, bFindRe, errorMsg) = findCompile(bFind, bFindC)

        v.bfind = bFind
        v.bfindre = bFindRe
        v.errormsg = errorMsg</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tf.browser.ner.form.Form" href="form.html#tf.browser.ner.form.Form">Form</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="tf.browser.ner.serve.Serve" href="serve.html#tf.browser.ner.serve.Serve">Serve</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tf.browser.ner.request.Request.adaptValSelect"><code class="name flex">
<span>def <span class="ident">adaptValSelect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Adapts the values contained in <code>valSelect</code> after a modification action.</p>
<p>After the addition or deletion of an entity, the values contained in <code>valSelect</code>
may have become obsolete or inconvenient for further actions.</p>
<p>This function adapts those values before having them rendered on the page.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>v</code></strong> :&ensp;<code>dict</code></dt>
<dd>Contains the intermediate results of computing the new page.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/7fdf25fed954698d7bcf1c0099489ed4c8456fe6/tf/browser/ner/request.py#L238-L279" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def adaptValSelect(self):
    &#34;&#34;&#34;Adapts the values contained in `valSelect` after a modification action.

    After the addition or deletion of an entity, the values contained in `valSelect`
    may have become obsolete or inconvenient for further actions.

    This function adapts those values before having them rendered on the page.

    Parameters
    ----------
    v: dict
        Contains the intermediate results of computing the new page.
    &#34;&#34;&#34;
    v = self.v
    annotate = self.annotate
    settings = annotate.settings
    features = settings.features

    submitter = v.submitter
    valSelect = v.valselect

    if submitter == &#34;addgo&#34;:
        addData = v.adddata
        additions = addData.additions
        freeVals = addData.freeVals

        freeState = v.freestate

        for i, (feat, values) in enumerate(zip(features, additions)):
            for val in values:
                valSelect.setdefault(feat, set()).add(val)
                if val == freeVals[i]:
                    freeVals[i] = None

        if freeState == &#34;free&#34;:
            v.freestate = &#34;all&#34;

    elif submitter == &#34;delgo&#34;:
        for feat in features:
            valSelect.setdefault(feat, set()).add(NONE)

    v.submitter = &#34;&#34;</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.request.Request.findSetup"><code class="name flex">
<span>def <span class="ident">findSetup</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Compiles the filter pattern into a regular expression.</p>
<p>When the user enters a search pattern in the box meant to filter the buckets,
the pattern will be interpreted as a regular expression.</p>
<p>We do the compilation here.
If there are errors in the pattern they will be reported.
Whether or not the search is case sensitive or not is under user control,
and it will influence the compilation of the pattern.</p>
<p>All input and output data is in <code>v</code> .</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/7fdf25fed954698d7bcf1c0099489ed4c8456fe6/tf/browser/ner/request.py#L281-L302" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def findSetup(self):
    &#34;&#34;&#34;Compiles the filter pattern into a regular expression.

    When the user enters a search pattern in the box meant to filter the buckets,
    the pattern will be interpreted as a regular expression.

    We do the compilation here.
    If there are errors in the pattern they will be reported.
    Whether or not the search is case sensitive or not is under user control,
    and it will influence the compilation of the pattern.

    All input and output data is in `v` .
    &#34;&#34;&#34;
    v = self.v
    bFind = v.bfind
    bFindC = v.bfindc

    (bFind, bFindRe, errorMsg) = findCompile(bFind, bFindC)

    v.bfind = bFind
    v.bfindre = bFindRe
    v.errormsg = errorMsg</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.request.Request.getFormData"><code class="name flex">
<span>def <span class="ident">getFormData</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get form data.</p>
<p>The TF browser user interacts with the app by clicking and typing,
as a result of which a HTML form gets filled in.
This form as regularly submitted to the server with a request
for a new incarnation of the page: a response.</p>
<p>The values that come with a request, must be peeled out of the form,
and stored as logical values.</p>
<p>Additionally, some business logic is carried out:
we set values for the entity features, based on the form, especially the
keys ending in <code>_active</code>. We build a value under key <code>valselect</code>
based on the value for key <code>submitter</code>.
Depending on which button caused the submit, the NONE value is added
to each feature.</p>
<p>The idea is that when the user is still engaged in filtering buckets,
and there is an occurrence selected, the user should have the option
to sub-select occurrences that do not yet have an entity assigned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/7fdf25fed954698d7bcf1c0099489ed4c8456fe6/tf/browser/ner/request.py#L134-L195" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getFormData(self):
    &#34;&#34;&#34;Get form data.

    The TF browser user interacts with the app by clicking and typing,
    as a result of which a HTML form gets filled in.
    This form as regularly submitted to the server with a request
    for a new incarnation of the page: a response.

    The values that come with a request, must be peeled out of the form,
    and stored as logical values.

    Additionally, some business logic is carried out:
    we set values for the entity features, based on the form, especially the
    keys ending in `_active`. We build a value under key `valselect`
    based on the value for key `submitter`.
    Depending on which button caused the submit, the NONE value is added
    to each feature.

    The idea is that when the user is still engaged in filtering buckets,
    and there is an occurrence selected, the user should have the option
    to sub-select occurrences that do not yet have an entity assigned.
    &#34;&#34;&#34;
    annotate = self.annotate
    settings = annotate.settings
    features = settings.features
    formattingState = self.formattingState
    activeVal = self.activeVal
    valSelectProto = self.valSelectProto

    form = self.fill()

    form[&#34;formattingstate&#34;] = {
        feat: self.fget2(featStr) for (feat, featStr) in formattingState.items()
    }

    form[&#34;activeval&#34;] = {
        feat: self.fgets(featStr) for (feat, featStr) in activeVal.items()
    }

    valSelectProto = {
        feat: self.fgets(featStr) for (feat, featStr) in valSelectProto.items()
    }

    submitter = form[&#34;submitter&#34;]

    valSelect = {}

    startSearch = submitter in {&#34;lookupq&#34;, &#34;lookupn&#34;, &#34;freebutton&#34;}

    for feat in features:
        valProto = valSelectProto[feat]
        valSelect[feat] = (
            set(&#34;&#34; if x == EMPTY else x for x in valProto.split(&#34;,&#34;))
            if valProto
            else set()
        )
        if startSearch:
            valSelect[feat].add(NONE)

    form[&#34;valselect&#34;] = valSelect

    return form</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.request.Request.initVars"><code class="name flex">
<span>def <span class="ident">initVars</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes the computation of the new page.</p>
<p>It collects the request data, gleans some info from the configuration
settings and the TF app, and initializes some data structures that
will collect further information for the page.</p>
<p>All bits and pieces that are needed during processing
the request and filling in the final HTML template find a place under
some key in the <code>v</code> dict which is stored in <code>self</code>.</p>
<p>So, this function makes the transition from information that is in the
<code>form</code> dictionary to values that are stored in the <code>v</code> dictionary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/7fdf25fed954698d7bcf1c0099489ed4c8456fe6/tf/browser/ner/request.py#L197-L236" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def initVars(self):
    &#34;&#34;&#34;Initializes the computation of the new page.

    It collects the request data, gleans some info from the configuration
    settings and the TF app, and initializes some data structures that
    will collect further information for the page.

    All bits and pieces that are needed during processing
    the request and filling in the final HTML template find a place under
    some key in the `v` dict which is stored in `self`.

    So, this function makes the transition from information that is in the
    `form` dictionary to values that are stored in the `v` dictionary.
    &#34;&#34;&#34;
    annotate = self.annotate
    settings = annotate.settings
    bucketType = settings.bucketType
    features = settings.features

    appName = annotate.appName
    appName = appName.replace(&#34;/&#34;, &#34; / &#34;)
    slotType = annotate.slotType

    form = self.getFormData()
    resetForm = form[&#34;resetForm&#34;]

    v = AttrDict()
    v.toolkey = TOOLKEY
    v.buckettype = bucketType
    v.featurelist = &#34;,&#34;.join(features)

    for k, vl in form.items():
        if not resetForm or k not in v:
            v[k] = vl

    v.appname = appName
    v.slottype = slotType
    v.resetform = &#34;&#34;

    self.v = v</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tf.browser.ner.form.Form" href="form.html#tf.browser.ner.form.Form">Form</a></b></code>:
<ul class="hlist">
<li><code><a title="tf.browser.ner.form.Form.fget2" href="form.html#tf.browser.ner.form.Form.fget2">fget2</a></code></li>
<li><code><a title="tf.browser.ner.form.Form.fget3" href="form.html#tf.browser.ner.form.Form.fget3">fget3</a></code></li>
<li><code><a title="tf.browser.ner.form.Form.fgeti" href="form.html#tf.browser.ner.form.Form.fgeti">fgeti</a></code></li>
<li><code><a title="tf.browser.ner.form.Form.fgetj" href="form.html#tf.browser.ner.form.Form.fgetj">fgetj</a></code></li>
<li><code><a title="tf.browser.ner.form.Form.fgets" href="form.html#tf.browser.ner.form.Form.fgets">fgets</a></code></li>
<li><code><a title="tf.browser.ner.form.Form.fgetsi" href="form.html#tf.browser.ner.form.Form.fgetsi">fgetsi</a></code></li>
<li><code><a title="tf.browser.ner.form.Form.fgettu" href="form.html#tf.browser.ner.form.Form.fgettu">fgettu</a></code></li>
<li><code><a title="tf.browser.ner.form.Form.fill" href="form.html#tf.browser.ner.form.Form.fill">fill</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../../tf/index.html">tf home</a> -
<a href="../../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.browser.ner" href="index.html">tf.browser.ner</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.browser.ner.request.Request" href="#tf.browser.ner.request.Request">Request</a></code></h4>
<ul class="">
<li><code><a title="tf.browser.ner.request.Request.adaptValSelect" href="#tf.browser.ner.request.Request.adaptValSelect">adaptValSelect</a></code></li>
<li><code><a title="tf.browser.ner.request.Request.findSetup" href="#tf.browser.ner.request.Request.findSetup">findSetup</a></code></li>
<li><code><a title="tf.browser.ner.request.Request.getFormData" href="#tf.browser.ner.request.Request.getFormData">getFormData</a></code></li>
<li><code><a title="tf.browser.ner.request.Request.initVars" href="#tf.browser.ner.request.Request.initVars">initVars</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>