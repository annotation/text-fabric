<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.browser.ner.tables API documentation</title>
<meta name="description" content="Module to compose tables of result data." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.browser.ner.tables</code></h1>
</header>
<section id="section-intro">
<p>Module to compose tables of result data.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ce3eadd9c62d7871af2a4eb6bf9dfc3118886de7/tf/browser/ner/tables.py#L1-L248" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Module to compose tables of result data.
&#34;&#34;&#34;

from textwrap import dedent


def composeE(app, setData, sortKey, sortDir):
    &#34;&#34;&#34;Compose a table of entities with selection and sort controls.

    Parameters
    ----------
    app: object
        The TF app of the corpus in question.
    setData: dict
        The entity data of the chosen set.
        We only need the `entitiesByKind` member.
    sortKey: string
        Indicates how to sort the table:

        *   `freqsort`: by the frequency of the entities
        *   `kindsort`: by the kind of the entities
        *   `etxtsort`: by the text of the entities

    sortDir: string
        Indicates the direction of the sort:

        *   `u`: up, i.e. ascending
        *   `d`: down, i.e. descending

    Returns
    -------
    html string
        The finished HTML of the table, ready to put into the Flask template.
    &#34;&#34;&#34;

    html = []

    entries = setData.entitiesByKind.items()
    if sortKey == &#34;freqsort&#34;:
        if sortDir == &#34;u&#34;:
            entries = sorted(entries, key=lambda x: (len(x[1]), x[0][1], x[0][0]))
        else:
            entries = sorted(entries, key=lambda x: (-len(x[1]), x[0][1], x[0][0]))
    elif sortKey == &#34;kindsort&#34;:
        entries = sorted(entries, key=lambda x: (x[0][0], x[0][1], -len(x[1])))
        if sortDir == &#34;d&#34;:
            entries = reversed(entries)
    elif sortKey == &#34;etxtsort&#34;:
        entries = sorted(entries, key=lambda x: (x[0][1], x[0][0], -len(x[1])))
        if sortDir == &#34;d&#34;:
            entries = reversed(entries)

    for ((kind, txt), es) in entries:
        x = len(es)
        item = (
            f&#34;&#34;&#34;&lt;span&gt;&lt;code class=&#34;w&#34;&gt;{x:&gt;5}&lt;/code&gt; x &lt;b&gt;{kind}&lt;/b&gt; {txt}&lt;/span&gt;&lt;br&gt;&#34;&#34;&#34;
        )
        html.append(item)

    return &#34;\n&#34;.join(html)


def tokenMatch(L, F, s, words):
    nWords = len(words)

    sTokens = {t: F.str.v(t) or &#34;&#34; for t in L.d(s, otype=&#34;t&#34;)}
    matches = set()

    if nWords:
        sWords = set(sTokens.values())

        if any(w not in sWords for w in words):
            return None

        nSTokens = len(sTokens)

        for (i, (t, w)) in enumerate(sTokens.items()):
            if w != words[0]:
                continue
            if nSTokens &lt; i + nWords:
                return None

            match = True

            for (j, w) in enumerate(words[1:]):
                if sTokens[t + j + 1] != w:
                    match = False
                    break

            if match:
                matches |= set(range(t, t + nWords))

        if len(matches) == 0:
            return None

    return (sTokens, matches)


def composeS(app, setData, tokenStart, tokenEnd):
    &#34;&#34;&#34;Compose a table of sentences.

    Will filter the sentences by tokens if the `tokens` parameter is not None.
    In that case, `tokens` should be an array of slots.
    All sentences that contain the words of those slots will show up,
    all other sentences will be left out.
    The matching slots will be highlighted.

    Parameters
    ----------
    app: object
        The TF app of the corpus in question.

    setData: dict
        The entity data of the chosen set.

    tokenStart, tokenEnd: int or None
        Specify the start slot number and the end slot number of a sequence of tokens.
        Only sentences that contain this token sentence will be passed through,
        all other sentences will be filtered out.

    Returns
    -------
    html string
        The finished HTML of the table, ready to put into the Flask template.
    &#34;&#34;&#34;

    api = app.api
    L = api.L
    F = api.F

    html = []
    words = []

    if tokenStart and tokenEnd:
        for t in range(tokenStart, tokenEnd + 1):
            words.append(F.str.v(t) or &#34;&#34;)

    entitiesSlotIndex = setData.entitiesSlotIndex

    for s in setData.sentences:
        result = tokenMatch(L, F, s, words)
        if result is None:
            continue

        (sTokens, matches) = result
        ht = []

        for (t, w) in sTokens.items():
            queried = &#39;class=&#34;queried&#34;&#39; if t in matches else &#34;&#34;
            after = F.after.v(t) or &#34;&#34;
            info = entitiesSlotIndex.get(t, None)
            inEntity = False

            if info is not None:
                inEntity = True
                for item in info:
                    if item is not None:
                        (status, kind, freq) = item
                        if status:
                            ht.append(
                                dedent(
                                    f&#34;&#34;&#34;
                                    &lt;span class=&#34;es&#34;
                                    &gt;{kind} &lt;span class=&#34;n&#34;&gt;{freq}&lt;/span
                                    &gt;&lt;/span&gt;&#34;&#34;&#34;
                                )
                            )
            inside = &#39;class=&#34;ei&#34;&#39; if inEntity else &#34;&#34;
            ht.append(f&#34;&#34;&#34;&lt;span {queried} {inside} t=&#34;{t}&#34;&gt;{w}&lt;/span&gt;{after}&#34;&#34;&#34;)

            if info is not None:
                for item in info:
                    if item is not None:
                        (status, kind, freq) = item
                        if not status:
                            ht.append(
                                dedent(
                                    f&#34;&#34;&#34;&lt;span class=&#34;ee&#34;&gt;{kind}&lt;/span&gt;&lt;/span&gt;&#34;&#34;&#34;
                                )
                            )

        ht = &#34;&#34;.join(ht)
        html.append(f&#34;&#34;&#34;&lt;div class=&#34;s&#34;&gt;{ht}&lt;/div&gt;&#34;&#34;&#34;)

    return &#34;&#34;.join(html)


def composeQ(app, tokenStart, tokenEnd):
    &#34;&#34;&#34;HTML for the query tokens.

    Parameters
    ----------
    app: object
        The TF app of the corpus in question.

    tokenStart, tokenEnd: int or None
        Specify the start slot number and the end slot number of a sequence of tokens.
        Only sentences that contain this token sentence will be passed through,
        all other sentences will be filtered out.

    Returns
    -------
    html string
        The finished HTML of the query parameters
    &#34;&#34;&#34;

    api = app.api
    F = api.F

    html = []

    wordHtml = (
        &#34; &#34;.join(
            f&#34;&#34;&#34;&lt;span&gt;{F.str.v(t) or &#34;&#34;}&lt;/span&gt; &#34;&#34;&#34;
            for t in range(tokenStart, tokenEnd + 1)
        )
        if tokenStart and tokenEnd
        else &#34;&#34;
    )

    html.append(
        dedent(
            f&#34;&#34;&#34;
            &lt;input type=&#34;hidden&#34;
                name=&#34;tselectstart&#34;
                id=&#34;tSelectStart&#34;
                value=&#34;{tokenStart or &#34;&#34;}&#34;
            &gt;
            &lt;input type=&#34;hidden&#34;
                name=&#34;tselectend&#34;
                id=&#34;tSelectEnd&#34;
                value=&#34;{tokenEnd or &#34;&#34;}&#34;
            &gt;
            &lt;span id=&#34;qWordShow&#34;&gt;{wordHtml}&lt;/span&gt;
            &#34;&#34;&#34;
        )
    )

    html.append(
        dedent(
            &#34;&#34;&#34;
            &lt;button type=&#34;submit&#34; id=&#34;queryFilter&#34;&gt;filter&lt;/button&gt;
            &lt;button type=&#34;submit&#34; id=&#34;queryClear&#34;&gt;clear&lt;/button&gt;
            &#34;&#34;&#34;
        )
    )

    return &#34;\n&#34;.join(html)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.browser.ner.tables.composeE"><code class="name flex">
<span>def <span class="ident">composeE</span></span>(<span>app, setData, sortKey, sortDir)</span>
</code></dt>
<dd>
<div class="desc"><p>Compose a table of entities with selection and sort controls.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>app</code></strong> :&ensp;<code>object</code></dt>
<dd>The TF app of the corpus in question.</dd>
<dt><strong><code>setData</code></strong> :&ensp;<code>dict</code></dt>
<dd>The entity data of the chosen set.
We only need the <code>entitiesByKind</code> member.</dd>
<dt><strong><code>sortKey</code></strong> :&ensp;<code>string</code></dt>
<dd>
<p>Indicates how to sort the table:</p>
<ul>
<li><code>freqsort</code>: by the frequency of the entities</li>
<li><code>kindsort</code>: by the kind of the entities</li>
<li><code>etxtsort</code>: by the text of the entities</li>
</ul>
</dd>
<dt><strong><code>sortDir</code></strong> :&ensp;<code>string</code></dt>
<dd>
<p>Indicates the direction of the sort:</p>
<ul>
<li><code>u</code>: up, i.e. ascending</li>
<li><code>d</code>: down, i.e. descending</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>html string</code></dt>
<dd>The finished HTML of the table, ready to put into the Flask template.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ce3eadd9c62d7871af2a4eb6bf9dfc3118886de7/tf/browser/ner/tables.py#L7-L60" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def composeE(app, setData, sortKey, sortDir):
    &#34;&#34;&#34;Compose a table of entities with selection and sort controls.

    Parameters
    ----------
    app: object
        The TF app of the corpus in question.
    setData: dict
        The entity data of the chosen set.
        We only need the `entitiesByKind` member.
    sortKey: string
        Indicates how to sort the table:

        *   `freqsort`: by the frequency of the entities
        *   `kindsort`: by the kind of the entities
        *   `etxtsort`: by the text of the entities

    sortDir: string
        Indicates the direction of the sort:

        *   `u`: up, i.e. ascending
        *   `d`: down, i.e. descending

    Returns
    -------
    html string
        The finished HTML of the table, ready to put into the Flask template.
    &#34;&#34;&#34;

    html = []

    entries = setData.entitiesByKind.items()
    if sortKey == &#34;freqsort&#34;:
        if sortDir == &#34;u&#34;:
            entries = sorted(entries, key=lambda x: (len(x[1]), x[0][1], x[0][0]))
        else:
            entries = sorted(entries, key=lambda x: (-len(x[1]), x[0][1], x[0][0]))
    elif sortKey == &#34;kindsort&#34;:
        entries = sorted(entries, key=lambda x: (x[0][0], x[0][1], -len(x[1])))
        if sortDir == &#34;d&#34;:
            entries = reversed(entries)
    elif sortKey == &#34;etxtsort&#34;:
        entries = sorted(entries, key=lambda x: (x[0][1], x[0][0], -len(x[1])))
        if sortDir == &#34;d&#34;:
            entries = reversed(entries)

    for ((kind, txt), es) in entries:
        x = len(es)
        item = (
            f&#34;&#34;&#34;&lt;span&gt;&lt;code class=&#34;w&#34;&gt;{x:&gt;5}&lt;/code&gt; x &lt;b&gt;{kind}&lt;/b&gt; {txt}&lt;/span&gt;&lt;br&gt;&#34;&#34;&#34;
        )
        html.append(item)

    return &#34;\n&#34;.join(html)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.tables.composeQ"><code class="name flex">
<span>def <span class="ident">composeQ</span></span>(<span>app, tokenStart, tokenEnd)</span>
</code></dt>
<dd>
<div class="desc"><p>HTML for the query tokens.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>app</code></strong> :&ensp;<code>object</code></dt>
<dd>The TF app of the corpus in question.</dd>
<dt><strong><code>tokenStart</code></strong>, <strong><code>tokenEnd</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>Specify the start slot number and the end slot number of a sequence of tokens.
Only sentences that contain this token sentence will be passed through,
all other sentences will be filtered out.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>html string</code></dt>
<dd>The finished HTML of the query parameters</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ce3eadd9c62d7871af2a4eb6bf9dfc3118886de7/tf/browser/ner/tables.py#L188-L248" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def composeQ(app, tokenStart, tokenEnd):
    &#34;&#34;&#34;HTML for the query tokens.

    Parameters
    ----------
    app: object
        The TF app of the corpus in question.

    tokenStart, tokenEnd: int or None
        Specify the start slot number and the end slot number of a sequence of tokens.
        Only sentences that contain this token sentence will be passed through,
        all other sentences will be filtered out.

    Returns
    -------
    html string
        The finished HTML of the query parameters
    &#34;&#34;&#34;

    api = app.api
    F = api.F

    html = []

    wordHtml = (
        &#34; &#34;.join(
            f&#34;&#34;&#34;&lt;span&gt;{F.str.v(t) or &#34;&#34;}&lt;/span&gt; &#34;&#34;&#34;
            for t in range(tokenStart, tokenEnd + 1)
        )
        if tokenStart and tokenEnd
        else &#34;&#34;
    )

    html.append(
        dedent(
            f&#34;&#34;&#34;
            &lt;input type=&#34;hidden&#34;
                name=&#34;tselectstart&#34;
                id=&#34;tSelectStart&#34;
                value=&#34;{tokenStart or &#34;&#34;}&#34;
            &gt;
            &lt;input type=&#34;hidden&#34;
                name=&#34;tselectend&#34;
                id=&#34;tSelectEnd&#34;
                value=&#34;{tokenEnd or &#34;&#34;}&#34;
            &gt;
            &lt;span id=&#34;qWordShow&#34;&gt;{wordHtml}&lt;/span&gt;
            &#34;&#34;&#34;
        )
    )

    html.append(
        dedent(
            &#34;&#34;&#34;
            &lt;button type=&#34;submit&#34; id=&#34;queryFilter&#34;&gt;filter&lt;/button&gt;
            &lt;button type=&#34;submit&#34; id=&#34;queryClear&#34;&gt;clear&lt;/button&gt;
            &#34;&#34;&#34;
        )
    )

    return &#34;\n&#34;.join(html)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.tables.composeS"><code class="name flex">
<span>def <span class="ident">composeS</span></span>(<span>app, setData, tokenStart, tokenEnd)</span>
</code></dt>
<dd>
<div class="desc"><p>Compose a table of sentences.</p>
<p>Will filter the sentences by tokens if the <code>tokens</code> parameter is not None.
In that case, <code>tokens</code> should be an array of slots.
All sentences that contain the words of those slots will show up,
all other sentences will be left out.
The matching slots will be highlighted.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>app</code></strong> :&ensp;<code>object</code></dt>
<dd>The TF app of the corpus in question.</dd>
<dt><strong><code>setData</code></strong> :&ensp;<code>dict</code></dt>
<dd>The entity data of the chosen set.</dd>
<dt><strong><code>tokenStart</code></strong>, <strong><code>tokenEnd</code></strong> :&ensp;<code>int</code> or <code>None</code></dt>
<dd>Specify the start slot number and the end slot number of a sequence of tokens.
Only sentences that contain this token sentence will be passed through,
all other sentences will be filtered out.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>html string</code></dt>
<dd>The finished HTML of the table, ready to put into the Flask template.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ce3eadd9c62d7871af2a4eb6bf9dfc3118886de7/tf/browser/ner/tables.py#L99-L185" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def composeS(app, setData, tokenStart, tokenEnd):
    &#34;&#34;&#34;Compose a table of sentences.

    Will filter the sentences by tokens if the `tokens` parameter is not None.
    In that case, `tokens` should be an array of slots.
    All sentences that contain the words of those slots will show up,
    all other sentences will be left out.
    The matching slots will be highlighted.

    Parameters
    ----------
    app: object
        The TF app of the corpus in question.

    setData: dict
        The entity data of the chosen set.

    tokenStart, tokenEnd: int or None
        Specify the start slot number and the end slot number of a sequence of tokens.
        Only sentences that contain this token sentence will be passed through,
        all other sentences will be filtered out.

    Returns
    -------
    html string
        The finished HTML of the table, ready to put into the Flask template.
    &#34;&#34;&#34;

    api = app.api
    L = api.L
    F = api.F

    html = []
    words = []

    if tokenStart and tokenEnd:
        for t in range(tokenStart, tokenEnd + 1):
            words.append(F.str.v(t) or &#34;&#34;)

    entitiesSlotIndex = setData.entitiesSlotIndex

    for s in setData.sentences:
        result = tokenMatch(L, F, s, words)
        if result is None:
            continue

        (sTokens, matches) = result
        ht = []

        for (t, w) in sTokens.items():
            queried = &#39;class=&#34;queried&#34;&#39; if t in matches else &#34;&#34;
            after = F.after.v(t) or &#34;&#34;
            info = entitiesSlotIndex.get(t, None)
            inEntity = False

            if info is not None:
                inEntity = True
                for item in info:
                    if item is not None:
                        (status, kind, freq) = item
                        if status:
                            ht.append(
                                dedent(
                                    f&#34;&#34;&#34;
                                    &lt;span class=&#34;es&#34;
                                    &gt;{kind} &lt;span class=&#34;n&#34;&gt;{freq}&lt;/span
                                    &gt;&lt;/span&gt;&#34;&#34;&#34;
                                )
                            )
            inside = &#39;class=&#34;ei&#34;&#39; if inEntity else &#34;&#34;
            ht.append(f&#34;&#34;&#34;&lt;span {queried} {inside} t=&#34;{t}&#34;&gt;{w}&lt;/span&gt;{after}&#34;&#34;&#34;)

            if info is not None:
                for item in info:
                    if item is not None:
                        (status, kind, freq) = item
                        if not status:
                            ht.append(
                                dedent(
                                    f&#34;&#34;&#34;&lt;span class=&#34;ee&#34;&gt;{kind}&lt;/span&gt;&lt;/span&gt;&#34;&#34;&#34;
                                )
                            )

        ht = &#34;&#34;.join(ht)
        html.append(f&#34;&#34;&#34;&lt;div class=&#34;s&#34;&gt;{ht}&lt;/div&gt;&#34;&#34;&#34;)

    return &#34;&#34;.join(html)</code></pre>
</details>
</dd>
<dt id="tf.browser.ner.tables.tokenMatch"><code class="name flex">
<span>def <span class="ident">tokenMatch</span></span>(<span>L, F, s, words)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ce3eadd9c62d7871af2a4eb6bf9dfc3118886de7/tf/browser/ner/tables.py#L63-L96" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tokenMatch(L, F, s, words):
    nWords = len(words)

    sTokens = {t: F.str.v(t) or &#34;&#34; for t in L.d(s, otype=&#34;t&#34;)}
    matches = set()

    if nWords:
        sWords = set(sTokens.values())

        if any(w not in sWords for w in words):
            return None

        nSTokens = len(sTokens)

        for (i, (t, w)) in enumerate(sTokens.items()):
            if w != words[0]:
                continue
            if nSTokens &lt; i + nWords:
                return None

            match = True

            for (j, w) in enumerate(words[1:]):
                if sTokens[t + j + 1] != w:
                    match = False
                    break

            if match:
                matches |= set(range(t, t + nWords))

        if len(matches) == 0:
            return None

    return (sTokens, matches)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../../tf/index.html">tf home</a> -
<a href="../../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.browser.ner" href="index.html">tf.browser.ner</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tf.browser.ner.tables.composeE" href="#tf.browser.ner.tables.composeE">composeE</a></code></li>
<li><code><a title="tf.browser.ner.tables.composeQ" href="#tf.browser.ner.tables.composeQ">composeQ</a></code></li>
<li><code><a title="tf.browser.ner.tables.composeS" href="#tf.browser.ner.tables.composeS">composeS</a></code></li>
<li><code><a title="tf.browser.ner.tables.tokenMatch" href="#tf.browser.ner.tables.tokenMatch">tokenMatch</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>