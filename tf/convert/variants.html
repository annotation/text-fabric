<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.convert.variants API documentation</title>
<meta name="description" content="Variants â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.convert.variants</code></h1>
</header>
<section id="section-intro">
<h1 id="variants">Variants</h1>
<p>This module contains functions to help you constructing nodes
when you convert TEI material and encounter elements from
the
<a href="https://www.tei-c.org/release/doc/tei-p5-doc/en/html/examples-lem.html#TC">Critical Apparatus Module</a>.</p>
<p>An extensive description of the problems and solutions is in
<code><a title="tf.about.variants" href="../about/variants.html">tf.about.variants</a></code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/e3da1869a3a7b032eb0b9630438732555e94b150/tf/convert/variants.py#L1-L551" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# Variants

This module contains functions to help you constructing nodes
when you convert TEI material and encounter elements from
the
[Critical Apparatus Module](https://www.tei-c.org/release/doc/tei-p5-doc/en/html/examples-lem.html#TC).

An extensive description of the problems and solutions is in
`tf.about.variants`.
&#34;&#34;&#34;


APP = &#34;app&#34;
N_SENT = &#34;nSent&#34;
PARENT = &#34;parent&#34;
RDGS = &#34;rdgs&#34;
SLOTS = &#34;slots&#34;
VARIANTS = &#34;variants&#34;
WIT = &#34;wit&#34;

# Start new keys in cur

APP_STACK = &#34;appstack&#34;
APPS = &#34;apps&#34;
N_APP = &#34;nApp&#34;
TRANS_LAST = &#34;translast&#34;
TRANS_NEXT = &#34;transnext&#34;
WITNESSES = &#34;witnesses&#34;
WITS = &#34;wits&#34;
X_WITS = &#34;xwits&#34;

# End new keys in cur

# Start existing keys in cur

RDG = &#34;rdg&#34;
LEM = &#34;lem&#34;

# End existing keys in cur


class Variants:
    def __init__(self, cv, cur, baseWitness, sentType, checkPunc, addWarning, addError):
        &#34;&#34;&#34;Handlers to turn boundaries into nodes even across variants.

        This class works inside converters of the type `tf.convert.walker`.
        Import it as

        ``` python
        from tf.convert.variants import Variants
        ```

        It should typically be instantiated inside the `director()` function,
        at a point where `cv` and `cur` are known.

        Then issue `Variants.initApps`, either once or for each volume in the corpus.

        After initialization you should call `Variants.collectWitnesses()` for
        each TEI file in the corpus.

        After collecting the witnesses you should prepare for the final walk through
        the data by `Variants.resetApps()`. This should match the call(s) to
        `Variants.initApps`.

        Then, at the start of each app-, lem-, rdg- element, call
        `Variants.startApp(tag)` with tag the corresponding tag name (
        `app`, `lem`, or `rdg`).

        Likewise, at the end, call `Variants.endApp(tag)`.

        Whenever you create slots, isse a `Variants.startSent()` first,
        and a `Variants.checkSent()` after.

        Close every TEI file with a `Variants.endSent()`, to finish off all
        pending sentences.

        Parameters
        ----------
        cv: object
            The `tf.convert.walker.CV` object. This is the machinery that constructs
            nodes and assigns features.
        cur: dict
            Keys and values by which a conversion program maintains current information.
            The conversion proceeds by executing a custom `director()` function,
            and this director walks through the source material and fires `cv` actions.
            During the walk, the director can remember incoming data as needed in a
            dict, and it is this dict that should be passed. The `Variants` object
            stores additional information here under specific keys.

            Those keys are mentioned in constants in the source code and there are
            a few keys dependent on the `sentType` parameter, namely

                f&#34;n{sentType}&#34;
                f&#34;stack{sentType}&#34;
                f&#34;var{sentType}&#34;

        baseWitness: string
            The name of the base text. Take care that it is different from the names
            of the witnesses.

        sentType: string
            The name of the node type of the nodes that will be constructed on the
            basis of boundaries. It could be &#34;sentence&#34;, but it could also be any
            other name, and it is not assumed that the nodes in question represent
            sentences. It could be anything, provided we have access to its boundaries.

        checkPunc: function(string, string, punc): boolean
            Given a the texts of the last two slots and the punctuation after that,
            it determines whether is contains a boundary.
            This function should be written in the converter program.
            Hence it is up to the conversion code to define what constitues a boundary,
            and whether it are sentences or some things else that are being bounded.
            This function is called and depending on the outcome sentence nodes are
            terminated and/or created, or nothing is done.

        addWarning, addError: function(string, dict)
            Functions taking a message string and a dict with current information
            (typically cur).
            They will be called if a warning or error has to be issued.
            When they is called, `cur` will be passed as dict.
            This function should be defined in the conversion program. It may use values
            in `cur` to generate an indication where the warning/error occurred.

        &#34;&#34;&#34;
        self.cv = cv
        self.cur = cur
        self.sentType = sentType
        self.baseWitness = baseWitness
        self.checkPunc = checkPunc
        self.addWarning = addWarning
        self.addError = addError
        self.nSent = f&#34;n{sentType}&#34;
        self.stackSent = f&#34;stack{sentType}&#34;
        self.varSent = f&#34;variants{sentType}&#34;

        cur[WITNESSES] = set()

    def collectWitnesses(self, node):
        &#34;&#34;&#34;Collect all witnesses.

        Call this for the root nodes of every TEI file of the corpus.

        Collects the witnesses from all rdg-elements.
        For each lem-element the set of witnesses of its rdg siblings is collected in
        such a way that it can be retrieved later on.

        We also store a pointer to the parent app-element of each nested app-element.

        We also check that multiple direct-rdg children of the same
        app have disjoint witnesses.
        &#34;&#34;&#34;

        cur = self.cur
        addWarning = self.addWarning

        tag = node.tag.lower()
        atts = node.attrib

        appStack = cur[APP_STACK]
        apps = cur[APPS]

        if tag == APP:
            parentApp = appStack[-1] if len(appStack) else None
            nApp = cur[N_APP]
            cur[N_APP] = nApp + 1
            appStack.append(nApp + 1)
            apps[nApp + 1] = dict(parent=parentApp, xwits=set(), rdgs=[])

        elif tag == RDG:
            att = WIT

            if att in atts:
                ws = {w.strip(&#34;.&#34;).lower() for w in atts[att].split()}
                cur[WITNESSES] |= ws
                apps[appStack[-1]][X_WITS] |= ws
                rdgSeen = apps[appStack[-1]][RDGS]
                for rdg in rdgSeen:
                    if rdg &amp; ws:
                        addWarning(
                            &#34;witnesses of rdg not disjoint from sibling rdgs&#34;, cur
                        )
                apps[appStack[-1]][RDGS].append(ws)

        for child in node:
            self.collectWitnesses(child)

        if tag == APP:
            appStack.pop()

    def initApps(self):
        &#34;&#34;&#34;Initialize app- processing and witness collection.

        You can issue this command once for the whole corpus,
        or each time before entering a volume.
        &#34;&#34;&#34;
        cur = self.cur

        cur[APPS] = dict()
        cur[APP_STACK] = []
        cur[TRANS_NEXT] = []
        cur[N_APP] = 0

    def resetApps(self):
        &#34;&#34;&#34;Initialize app- and &#34;sentence&#34; processing.

        Set up the data store for collecting information and &#34;sentence&#34; processing.
        Do this after collecting the witnesses.

        You can issue this command once for the whole corpus,
        or each time before entering a volume.
        But it should be kept in tandem with `Variants.initApps`.
        &#34;&#34;&#34;
        cur = self.cur
        baseWitness = self.baseWitness
        nSent = self.nSent
        stackSent = self.stackSent
        varSent = self.varSent

        cur[N_APP] = 0
        cur[WITS] = []
        cur[X_WITS] = []
        cur[TRANS_LAST] = None
        cur[nSent] = 0
        cur[stackSent] = []
        cur[varSent] = {baseWitness: None}

    def startApp(self, tag, atts):
        &#34;&#34;&#34;Actions at the start of app- lem- and rdg-elements.

        Use this each time you enter one of these XML elements.

        Parameters
        ----------
        tag: string
            The tag name of the XML element that is being entered
        atts: dict
            The attributes of the XML element that is being entered
        &#34;&#34;&#34;

        cur = self.cur
        curStackSent = cur[self.stackSent]

        if tag == APP:
            nApp = cur[N_APP]
            cur[N_APP] = nApp + 1
            appInfo = cur[APPS][nApp + 1]
            parentApp = appInfo[PARENT]
            xwits = appInfo[X_WITS]

            slots = self._diverge()
            cur[TRANS_NEXT].append(&#34;&#34;)

            curStackSent.append(
                dict(
                    translast=cur[TRANS_LAST],
                    slots=slots,
                )
            )

            while parentApp is not None:
                appInfo = cur[APPS][parentApp]

                # keep xwits immutable, don&#39;t say xwits |= blabla
                # because that will change xwits in place

                xwits = xwits | appInfo[X_WITS]
                parentApp = appInfo[PARENT]

            cur[X_WITS].append(xwits)

        elif tag == LEM:
            xWits = self._getXwits()
            for wit in self._getWits():
                if wit in xWits:
                    self._suspend(wit)
                else:
                    self._resume(wit)

        elif tag == RDG:
            wits = set()
            if WIT in atts:
                wits = {w.strip(&#34;.&#34;).lower() for w in atts[WIT].split()}
                atts[WIT] = &#34; &#34;.join(wits)

            cur[WITS].append(wits)

            for wit in self._getWits():
                if wit in wits:
                    self._resume(wit)
                else:
                    self._suspend(wit)

    def endApp(self, tag):
        &#34;&#34;&#34;Actions at the end of app- lem- and rdg-elements.

        Use this each time you leave one of these XML elements.

        Parameters
        ----------
        tag: string
            The tag name of the XML element that is being left
        &#34;&#34;&#34;

        cur = self.cur
        curStackSent = cur[self.stackSent]

        if tag == APP:
            cur[X_WITS].pop()

            xWits = self._getXwits()
            for wit in self._getWits():
                if wit not in xWits:
                    self._resume(wit)

            curStackSent.pop()
            cur[TRANS_LAST] = cur[TRANS_NEXT].pop()

        elif tag == LEM:
            cur[TRANS_NEXT][-1] = cur[TRANS_LAST]

            xWits = self._getXwits()
            for wit in self._getWits():

                if wit not in xWits:
                    self._suspend(wit)

        elif tag == RDG:
            wits = cur[WITS][-1]

            for wit in wits:
                self._suspend(wit)

            cur[WITS].pop()

    def checkSent(self, trans, punc):
        &#34;&#34;&#34;Checks whether there is a &#34;sentence&#34; boundary at this point.

        Use this every time you have added a slot node.

        Parameters
        ----------
        trans: string
            The text of the newly added slot node.
            If this is empty, the text of the slot before that will be consulted.
            This value is taken from the context information.
            This very function is responsible for putting the last text value into
            the context.
        punc: string
            The non-alfanumeric text material after the text of the last slot.
            Will be used to determine whether there is a &#34;sentence&#34; break here.
            The actual check will be done by the function `checkPunc`,
            which has been passed as parameter when the `Variants` object was
            created.
        &#34;&#34;&#34;
        cur = self.cur
        checkPunc = self.checkPunc

        lastTrans = trans or cur[TRANS_LAST] or &#34;&#34;
        if checkPunc(lastTrans, trans, punc):
            self.endSent()
        else:
            cur[TRANS_LAST] = trans

    def startSent(self):
        &#34;&#34;&#34;Starts a &#34;sentence&#34; if there is no current sentence.

        When in an rdg-element, witness-dependend &#34;sentence&#34; nodes
        are created for each witness for the rdg.

        Use this before creating a slot and/or at the start of certain elements
        such as paragraphs.
        &#34;&#34;&#34;

        cur = self.cur
        baseWitness = self.baseWitness

        inRdg = RDG in cur and len(cur[RDG]) &gt; 0
        inLem = LEM in cur and len(cur[LEM]) &gt; 0

        if inLem:
            self._startSentLem()
        elif inRdg:
            self._startSentRdg()
        else:
            self._start(baseWitness, witAtt=False)

    def endSent(self):
        &#34;&#34;&#34;Ends a &#34;sentence&#34; if there is a current sentence.

        Use this at the end of each XML file if you are sure that
        there should not remain pending sentences. You can also call this
        at the end of certain elements, such as paragraphs.

        When in a lem-element, all pending &#34;sentences&#34; of all witnesses
        that agree with the base text here are also ended.
        No new sentences for these witnesses are started, since we are in
        the base text.
        &#34;&#34;&#34;

        cur = self.cur

        inRdg = RDG in cur and len(cur[RDG]) &gt; 0
        inLem = LEM in cur and len(cur[LEM]) &gt; 0

        if inLem:
            self._endSentLem()
        elif inRdg:
            self._endSentRdg()
        else:
            for wit in self._getWits():
                self._terminate(wit)

    def _startSentLem(self):
        baseWitness = self.baseWitness

        self._start(baseWitness)

    def _endSentLem(self):
        xWits = self._getXwits()
        for wit in self._getWits():
            if wit not in xWits:
                self._terminate(wit)

    def _startSentRdg(self):
        cur = self.cur
        curStackSent = cur[self.stackSent]

        wits = cur[WITS][-1]
        topStack = curStackSent[-1]
        cur[TRANS_LAST] = topStack[TRANS_LAST]

        for wit in wits:
            self._prepend(wit)

    def _endSentRdg(self):
        cur = self.cur

        wits = cur[WITS][-1]

        for wit in wits:
            self._terminate(wit)

    def _get(self, wit):
        cur = self.cur
        baseWitness = self.baseWitness

        curVarSent = cur[self.varSent]
        isBase = wit == baseWitness

        if isBase:
            return curVarSent[baseWitness]

        return curVarSent.get(wit, None)

    def _getWits(self):
        cur = self.cur
        curVarSent = cur[self.varSent]

        return list(curVarSent)

    def _getXwits(self):
        cur = self.cur

        xWits = cur[X_WITS]

        return xWits[-1] if xWits else set()

    def _start(self, wit, witAtt=True):
        s = self._get(wit)
        if s is not None:
            return s

        cv = self.cv
        cur = self.cur
        sentType = self.sentType
        curVarSent = cur[self.varSent]
        nSent = self.nSent
        baseWitness = self.baseWitness

        isBase = wit == baseWitness

        s = cv.node(sentType)

        cur[nSent] += 1
        cv.feature(s, n=cur[nSent])
        if witAtt:
            cv.feature(s, wit=wit)

        if isBase:
            curVarSent[baseWitness] = s
        else:
            curVarSent[wit] = s

        return s

    def _terminate(self, wit):
        cv = self.cv
        cur = self.cur
        baseWitness = self.baseWitness

        curVarSent = cur[self.varSent]
        isBase = wit == baseWitness

        s = self._get(wit)
        if s is not None:
            cv.terminate(s)

            if isBase:
                curVarSent[wit] = None
            else:
                del curVarSent[wit]

    def _resume(self, wit):
        cv = self.cv

        s = self._get(wit)
        if s is not None:
            cv.resume(s)

    def _suspend(self, wit):
        cv = self.cv

        s = self._get(wit)
        if s is not None:
            cv.terminate(s)

    def _diverge(self):
        cv = self.cv
        baseWitness = self.baseWitness

        s = self._get(baseWitness)

        if s is None:
            return None

        cv.feature(s, wit=baseWitness)
        return cv.linked(s)

    def _prepend(self, wit):
        if self._get(wit) is None:
            cv = self.cv
            cur = self.cur
            curStackSent = cur[self.stackSent]
            topStack = curStackSent[-1]
            slots = topStack[SLOTS]

            s = self._start(wit)

            if s is not None and slots is not None:
                cv.link(s, topStack[SLOTS])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.convert.variants.Variants"><code class="flex name class">
<span>class <span class="ident">Variants</span></span>
<span>(</span><span>cv, cur, baseWitness, sentType, checkPunc, addWarning, addError)</span>
</code></dt>
<dd>
<div class="desc"><p>Handlers to turn boundaries into nodes even across variants.</p>
<p>This class works inside converters of the type <code><a title="tf.convert.walker" href="walker.html">tf.convert.walker</a></code>.
Import it as</p>
<pre><code class="language-python">from tf.convert.variants import Variants
</code></pre>
<p>It should typically be instantiated inside the <code>director()</code> function,
at a point where <code>cv</code> and <code>cur</code> are known.</p>
<p>Then issue <code><a title="tf.convert.variants.Variants.initApps" href="#tf.convert.variants.Variants.initApps">Variants.initApps()</a></code>, either once or for each volume in the corpus.</p>
<p>After initialization you should call <code><a title="tf.convert.variants.Variants.collectWitnesses" href="#tf.convert.variants.Variants.collectWitnesses">Variants.collectWitnesses()</a></code> for
each TEI file in the corpus.</p>
<p>After collecting the witnesses you should prepare for the final walk through
the data by <code><a title="tf.convert.variants.Variants.resetApps" href="#tf.convert.variants.Variants.resetApps">Variants.resetApps()</a></code>. This should match the call(s) to
<code><a title="tf.convert.variants.Variants.initApps" href="#tf.convert.variants.Variants.initApps">Variants.initApps()</a></code>.</p>
<p>Then, at the start of each app-, lem-, rdg- element, call
<code><a title="tf.convert.variants.Variants.startApp" href="#tf.convert.variants.Variants.startApp">Variants.startApp()</a>(tag)</code> with tag the corresponding tag name (
<code>app</code>, <code>lem</code>, or <code>rdg</code>).</p>
<p>Likewise, at the end, call <code><a title="tf.convert.variants.Variants.endApp" href="#tf.convert.variants.Variants.endApp">Variants.endApp()</a>(tag)</code>.</p>
<p>Whenever you create slots, isse a <code><a title="tf.convert.variants.Variants.startSent" href="#tf.convert.variants.Variants.startSent">Variants.startSent()</a></code> first,
and a <code><a title="tf.convert.variants.Variants.checkSent" href="#tf.convert.variants.Variants.checkSent">Variants.checkSent()</a></code> after.</p>
<p>Close every TEI file with a <code><a title="tf.convert.variants.Variants.endSent" href="#tf.convert.variants.Variants.endSent">Variants.endSent()</a></code>, to finish off all
pending sentences.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>cv</code></strong> :&ensp;<code>object</code></dt>
<dd>The <code><a title="tf.convert.walker.CV" href="walker.html#tf.convert.walker.CV">CV</a></code> object. This is the machinery that constructs
nodes and assigns features.</dd>
<dt><strong><code>cur</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Keys and values by which a conversion program maintains current information.
The conversion proceeds by executing a custom <code>director()</code> function,
and this director walks through the source material and fires <code>cv</code> actions.
During the walk, the director can remember incoming data as needed in a
dict, and it is this dict that should be passed. The <code><a title="tf.convert.variants.Variants" href="#tf.convert.variants.Variants">Variants</a></code> object
stores additional information here under specific keys.</p>
<p>Those keys are mentioned in constants in the source code and there are
a few keys dependent on the <code>sentType</code> parameter, namely</p>
<pre><code>f"n{sentType}"
f"stack{sentType}"
f"var{sentType}"
</code></pre>
</dd>
<dt><strong><code>baseWitness</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the base text. Take care that it is different from the names
of the witnesses.</dd>
<dt><strong><code>sentType</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the node type of the nodes that will be constructed on the
basis of boundaries. It could be "sentence", but it could also be any
other name, and it is not assumed that the nodes in question represent
sentences. It could be anything, provided we have access to its boundaries.</dd>
<dt><strong><code>checkPunc</code></strong> :&ensp;<code>function(string, string, punc): boolean</code></dt>
<dd>Given a the texts of the last two slots and the punctuation after that,
it determines whether is contains a boundary.
This function should be written in the converter program.
Hence it is up to the conversion code to define what constitues a boundary,
and whether it are sentences or some things else that are being bounded.
This function is called and depending on the outcome sentence nodes are
terminated and/or created, or nothing is done.</dd>
<dt><strong><code>addWarning</code></strong>, <strong><code>addError</code></strong> :&ensp;<code>function(string, dict)</code></dt>
<dd>Functions taking a message string and a dict with current information
(typically cur).
They will be called if a warning or error has to be issued.
When they is called, <code>cur</code> will be passed as dict.
This function should be defined in the conversion program. It may use values
in <code>cur</code> to generate an indication where the warning/error occurred.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/e3da1869a3a7b032eb0b9630438732555e94b150/tf/convert/variants.py#L43-L551" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Variants:
    def __init__(self, cv, cur, baseWitness, sentType, checkPunc, addWarning, addError):
        &#34;&#34;&#34;Handlers to turn boundaries into nodes even across variants.

        This class works inside converters of the type `tf.convert.walker`.
        Import it as

        ``` python
        from tf.convert.variants import Variants
        ```

        It should typically be instantiated inside the `director()` function,
        at a point where `cv` and `cur` are known.

        Then issue `Variants.initApps`, either once or for each volume in the corpus.

        After initialization you should call `Variants.collectWitnesses()` for
        each TEI file in the corpus.

        After collecting the witnesses you should prepare for the final walk through
        the data by `Variants.resetApps()`. This should match the call(s) to
        `Variants.initApps`.

        Then, at the start of each app-, lem-, rdg- element, call
        `Variants.startApp(tag)` with tag the corresponding tag name (
        `app`, `lem`, or `rdg`).

        Likewise, at the end, call `Variants.endApp(tag)`.

        Whenever you create slots, isse a `Variants.startSent()` first,
        and a `Variants.checkSent()` after.

        Close every TEI file with a `Variants.endSent()`, to finish off all
        pending sentences.

        Parameters
        ----------
        cv: object
            The `tf.convert.walker.CV` object. This is the machinery that constructs
            nodes and assigns features.
        cur: dict
            Keys and values by which a conversion program maintains current information.
            The conversion proceeds by executing a custom `director()` function,
            and this director walks through the source material and fires `cv` actions.
            During the walk, the director can remember incoming data as needed in a
            dict, and it is this dict that should be passed. The `Variants` object
            stores additional information here under specific keys.

            Those keys are mentioned in constants in the source code and there are
            a few keys dependent on the `sentType` parameter, namely

                f&#34;n{sentType}&#34;
                f&#34;stack{sentType}&#34;
                f&#34;var{sentType}&#34;

        baseWitness: string
            The name of the base text. Take care that it is different from the names
            of the witnesses.

        sentType: string
            The name of the node type of the nodes that will be constructed on the
            basis of boundaries. It could be &#34;sentence&#34;, but it could also be any
            other name, and it is not assumed that the nodes in question represent
            sentences. It could be anything, provided we have access to its boundaries.

        checkPunc: function(string, string, punc): boolean
            Given a the texts of the last two slots and the punctuation after that,
            it determines whether is contains a boundary.
            This function should be written in the converter program.
            Hence it is up to the conversion code to define what constitues a boundary,
            and whether it are sentences or some things else that are being bounded.
            This function is called and depending on the outcome sentence nodes are
            terminated and/or created, or nothing is done.

        addWarning, addError: function(string, dict)
            Functions taking a message string and a dict with current information
            (typically cur).
            They will be called if a warning or error has to be issued.
            When they is called, `cur` will be passed as dict.
            This function should be defined in the conversion program. It may use values
            in `cur` to generate an indication where the warning/error occurred.

        &#34;&#34;&#34;
        self.cv = cv
        self.cur = cur
        self.sentType = sentType
        self.baseWitness = baseWitness
        self.checkPunc = checkPunc
        self.addWarning = addWarning
        self.addError = addError
        self.nSent = f&#34;n{sentType}&#34;
        self.stackSent = f&#34;stack{sentType}&#34;
        self.varSent = f&#34;variants{sentType}&#34;

        cur[WITNESSES] = set()

    def collectWitnesses(self, node):
        &#34;&#34;&#34;Collect all witnesses.

        Call this for the root nodes of every TEI file of the corpus.

        Collects the witnesses from all rdg-elements.
        For each lem-element the set of witnesses of its rdg siblings is collected in
        such a way that it can be retrieved later on.

        We also store a pointer to the parent app-element of each nested app-element.

        We also check that multiple direct-rdg children of the same
        app have disjoint witnesses.
        &#34;&#34;&#34;

        cur = self.cur
        addWarning = self.addWarning

        tag = node.tag.lower()
        atts = node.attrib

        appStack = cur[APP_STACK]
        apps = cur[APPS]

        if tag == APP:
            parentApp = appStack[-1] if len(appStack) else None
            nApp = cur[N_APP]
            cur[N_APP] = nApp + 1
            appStack.append(nApp + 1)
            apps[nApp + 1] = dict(parent=parentApp, xwits=set(), rdgs=[])

        elif tag == RDG:
            att = WIT

            if att in atts:
                ws = {w.strip(&#34;.&#34;).lower() for w in atts[att].split()}
                cur[WITNESSES] |= ws
                apps[appStack[-1]][X_WITS] |= ws
                rdgSeen = apps[appStack[-1]][RDGS]
                for rdg in rdgSeen:
                    if rdg &amp; ws:
                        addWarning(
                            &#34;witnesses of rdg not disjoint from sibling rdgs&#34;, cur
                        )
                apps[appStack[-1]][RDGS].append(ws)

        for child in node:
            self.collectWitnesses(child)

        if tag == APP:
            appStack.pop()

    def initApps(self):
        &#34;&#34;&#34;Initialize app- processing and witness collection.

        You can issue this command once for the whole corpus,
        or each time before entering a volume.
        &#34;&#34;&#34;
        cur = self.cur

        cur[APPS] = dict()
        cur[APP_STACK] = []
        cur[TRANS_NEXT] = []
        cur[N_APP] = 0

    def resetApps(self):
        &#34;&#34;&#34;Initialize app- and &#34;sentence&#34; processing.

        Set up the data store for collecting information and &#34;sentence&#34; processing.
        Do this after collecting the witnesses.

        You can issue this command once for the whole corpus,
        or each time before entering a volume.
        But it should be kept in tandem with `Variants.initApps`.
        &#34;&#34;&#34;
        cur = self.cur
        baseWitness = self.baseWitness
        nSent = self.nSent
        stackSent = self.stackSent
        varSent = self.varSent

        cur[N_APP] = 0
        cur[WITS] = []
        cur[X_WITS] = []
        cur[TRANS_LAST] = None
        cur[nSent] = 0
        cur[stackSent] = []
        cur[varSent] = {baseWitness: None}

    def startApp(self, tag, atts):
        &#34;&#34;&#34;Actions at the start of app- lem- and rdg-elements.

        Use this each time you enter one of these XML elements.

        Parameters
        ----------
        tag: string
            The tag name of the XML element that is being entered
        atts: dict
            The attributes of the XML element that is being entered
        &#34;&#34;&#34;

        cur = self.cur
        curStackSent = cur[self.stackSent]

        if tag == APP:
            nApp = cur[N_APP]
            cur[N_APP] = nApp + 1
            appInfo = cur[APPS][nApp + 1]
            parentApp = appInfo[PARENT]
            xwits = appInfo[X_WITS]

            slots = self._diverge()
            cur[TRANS_NEXT].append(&#34;&#34;)

            curStackSent.append(
                dict(
                    translast=cur[TRANS_LAST],
                    slots=slots,
                )
            )

            while parentApp is not None:
                appInfo = cur[APPS][parentApp]

                # keep xwits immutable, don&#39;t say xwits |= blabla
                # because that will change xwits in place

                xwits = xwits | appInfo[X_WITS]
                parentApp = appInfo[PARENT]

            cur[X_WITS].append(xwits)

        elif tag == LEM:
            xWits = self._getXwits()
            for wit in self._getWits():
                if wit in xWits:
                    self._suspend(wit)
                else:
                    self._resume(wit)

        elif tag == RDG:
            wits = set()
            if WIT in atts:
                wits = {w.strip(&#34;.&#34;).lower() for w in atts[WIT].split()}
                atts[WIT] = &#34; &#34;.join(wits)

            cur[WITS].append(wits)

            for wit in self._getWits():
                if wit in wits:
                    self._resume(wit)
                else:
                    self._suspend(wit)

    def endApp(self, tag):
        &#34;&#34;&#34;Actions at the end of app- lem- and rdg-elements.

        Use this each time you leave one of these XML elements.

        Parameters
        ----------
        tag: string
            The tag name of the XML element that is being left
        &#34;&#34;&#34;

        cur = self.cur
        curStackSent = cur[self.stackSent]

        if tag == APP:
            cur[X_WITS].pop()

            xWits = self._getXwits()
            for wit in self._getWits():
                if wit not in xWits:
                    self._resume(wit)

            curStackSent.pop()
            cur[TRANS_LAST] = cur[TRANS_NEXT].pop()

        elif tag == LEM:
            cur[TRANS_NEXT][-1] = cur[TRANS_LAST]

            xWits = self._getXwits()
            for wit in self._getWits():

                if wit not in xWits:
                    self._suspend(wit)

        elif tag == RDG:
            wits = cur[WITS][-1]

            for wit in wits:
                self._suspend(wit)

            cur[WITS].pop()

    def checkSent(self, trans, punc):
        &#34;&#34;&#34;Checks whether there is a &#34;sentence&#34; boundary at this point.

        Use this every time you have added a slot node.

        Parameters
        ----------
        trans: string
            The text of the newly added slot node.
            If this is empty, the text of the slot before that will be consulted.
            This value is taken from the context information.
            This very function is responsible for putting the last text value into
            the context.
        punc: string
            The non-alfanumeric text material after the text of the last slot.
            Will be used to determine whether there is a &#34;sentence&#34; break here.
            The actual check will be done by the function `checkPunc`,
            which has been passed as parameter when the `Variants` object was
            created.
        &#34;&#34;&#34;
        cur = self.cur
        checkPunc = self.checkPunc

        lastTrans = trans or cur[TRANS_LAST] or &#34;&#34;
        if checkPunc(lastTrans, trans, punc):
            self.endSent()
        else:
            cur[TRANS_LAST] = trans

    def startSent(self):
        &#34;&#34;&#34;Starts a &#34;sentence&#34; if there is no current sentence.

        When in an rdg-element, witness-dependend &#34;sentence&#34; nodes
        are created for each witness for the rdg.

        Use this before creating a slot and/or at the start of certain elements
        such as paragraphs.
        &#34;&#34;&#34;

        cur = self.cur
        baseWitness = self.baseWitness

        inRdg = RDG in cur and len(cur[RDG]) &gt; 0
        inLem = LEM in cur and len(cur[LEM]) &gt; 0

        if inLem:
            self._startSentLem()
        elif inRdg:
            self._startSentRdg()
        else:
            self._start(baseWitness, witAtt=False)

    def endSent(self):
        &#34;&#34;&#34;Ends a &#34;sentence&#34; if there is a current sentence.

        Use this at the end of each XML file if you are sure that
        there should not remain pending sentences. You can also call this
        at the end of certain elements, such as paragraphs.

        When in a lem-element, all pending &#34;sentences&#34; of all witnesses
        that agree with the base text here are also ended.
        No new sentences for these witnesses are started, since we are in
        the base text.
        &#34;&#34;&#34;

        cur = self.cur

        inRdg = RDG in cur and len(cur[RDG]) &gt; 0
        inLem = LEM in cur and len(cur[LEM]) &gt; 0

        if inLem:
            self._endSentLem()
        elif inRdg:
            self._endSentRdg()
        else:
            for wit in self._getWits():
                self._terminate(wit)

    def _startSentLem(self):
        baseWitness = self.baseWitness

        self._start(baseWitness)

    def _endSentLem(self):
        xWits = self._getXwits()
        for wit in self._getWits():
            if wit not in xWits:
                self._terminate(wit)

    def _startSentRdg(self):
        cur = self.cur
        curStackSent = cur[self.stackSent]

        wits = cur[WITS][-1]
        topStack = curStackSent[-1]
        cur[TRANS_LAST] = topStack[TRANS_LAST]

        for wit in wits:
            self._prepend(wit)

    def _endSentRdg(self):
        cur = self.cur

        wits = cur[WITS][-1]

        for wit in wits:
            self._terminate(wit)

    def _get(self, wit):
        cur = self.cur
        baseWitness = self.baseWitness

        curVarSent = cur[self.varSent]
        isBase = wit == baseWitness

        if isBase:
            return curVarSent[baseWitness]

        return curVarSent.get(wit, None)

    def _getWits(self):
        cur = self.cur
        curVarSent = cur[self.varSent]

        return list(curVarSent)

    def _getXwits(self):
        cur = self.cur

        xWits = cur[X_WITS]

        return xWits[-1] if xWits else set()

    def _start(self, wit, witAtt=True):
        s = self._get(wit)
        if s is not None:
            return s

        cv = self.cv
        cur = self.cur
        sentType = self.sentType
        curVarSent = cur[self.varSent]
        nSent = self.nSent
        baseWitness = self.baseWitness

        isBase = wit == baseWitness

        s = cv.node(sentType)

        cur[nSent] += 1
        cv.feature(s, n=cur[nSent])
        if witAtt:
            cv.feature(s, wit=wit)

        if isBase:
            curVarSent[baseWitness] = s
        else:
            curVarSent[wit] = s

        return s

    def _terminate(self, wit):
        cv = self.cv
        cur = self.cur
        baseWitness = self.baseWitness

        curVarSent = cur[self.varSent]
        isBase = wit == baseWitness

        s = self._get(wit)
        if s is not None:
            cv.terminate(s)

            if isBase:
                curVarSent[wit] = None
            else:
                del curVarSent[wit]

    def _resume(self, wit):
        cv = self.cv

        s = self._get(wit)
        if s is not None:
            cv.resume(s)

    def _suspend(self, wit):
        cv = self.cv

        s = self._get(wit)
        if s is not None:
            cv.terminate(s)

    def _diverge(self):
        cv = self.cv
        baseWitness = self.baseWitness

        s = self._get(baseWitness)

        if s is None:
            return None

        cv.feature(s, wit=baseWitness)
        return cv.linked(s)

    def _prepend(self, wit):
        if self._get(wit) is None:
            cv = self.cv
            cur = self.cur
            curStackSent = cur[self.stackSent]
            topStack = curStackSent[-1]
            slots = topStack[SLOTS]

            s = self._start(wit)

            if s is not None and slots is not None:
                cv.link(s, topStack[SLOTS])</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tf.convert.variants.Variants.checkSent"><code class="name flex">
<span>def <span class="ident">checkSent</span></span>(<span>self, trans, punc)</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether there is a "sentence" boundary at this point.</p>
<p>Use this every time you have added a slot node.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>trans</code></strong> :&ensp;<code>string</code></dt>
<dd>The text of the newly added slot node.
If this is empty, the text of the slot before that will be consulted.
This value is taken from the context information.
This very function is responsible for putting the last text value into
the context.</dd>
<dt><strong><code>punc</code></strong> :&ensp;<code>string</code></dt>
<dd>The non-alfanumeric text material after the text of the last slot.
Will be used to determine whether there is a "sentence" break here.
The actual check will be done by the function <code>checkPunc</code>,
which has been passed as parameter when the <code><a title="tf.convert.variants.Variants" href="#tf.convert.variants.Variants">Variants</a></code> object was
created.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/e3da1869a3a7b032eb0b9630438732555e94b150/tf/convert/variants.py#L336-L363" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def checkSent(self, trans, punc):
    &#34;&#34;&#34;Checks whether there is a &#34;sentence&#34; boundary at this point.

    Use this every time you have added a slot node.

    Parameters
    ----------
    trans: string
        The text of the newly added slot node.
        If this is empty, the text of the slot before that will be consulted.
        This value is taken from the context information.
        This very function is responsible for putting the last text value into
        the context.
    punc: string
        The non-alfanumeric text material after the text of the last slot.
        Will be used to determine whether there is a &#34;sentence&#34; break here.
        The actual check will be done by the function `checkPunc`,
        which has been passed as parameter when the `Variants` object was
        created.
    &#34;&#34;&#34;
    cur = self.cur
    checkPunc = self.checkPunc

    lastTrans = trans or cur[TRANS_LAST] or &#34;&#34;
    if checkPunc(lastTrans, trans, punc):
        self.endSent()
    else:
        cur[TRANS_LAST] = trans</code></pre>
</details>
</dd>
<dt id="tf.convert.variants.Variants.collectWitnesses"><code class="name flex">
<span>def <span class="ident">collectWitnesses</span></span>(<span>self, node)</span>
</code></dt>
<dd>
<div class="desc"><p>Collect all witnesses.</p>
<p>Call this for the root nodes of every TEI file of the corpus.</p>
<p>Collects the witnesses from all rdg-elements.
For each lem-element the set of witnesses of its rdg siblings is collected in
such a way that it can be retrieved later on.</p>
<p>We also store a pointer to the parent app-element of each nested app-element.</p>
<p>We also check that multiple direct-rdg children of the same
app have disjoint witnesses.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/e3da1869a3a7b032eb0b9630438732555e94b150/tf/convert/variants.py#L139-L189" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def collectWitnesses(self, node):
    &#34;&#34;&#34;Collect all witnesses.

    Call this for the root nodes of every TEI file of the corpus.

    Collects the witnesses from all rdg-elements.
    For each lem-element the set of witnesses of its rdg siblings is collected in
    such a way that it can be retrieved later on.

    We also store a pointer to the parent app-element of each nested app-element.

    We also check that multiple direct-rdg children of the same
    app have disjoint witnesses.
    &#34;&#34;&#34;

    cur = self.cur
    addWarning = self.addWarning

    tag = node.tag.lower()
    atts = node.attrib

    appStack = cur[APP_STACK]
    apps = cur[APPS]

    if tag == APP:
        parentApp = appStack[-1] if len(appStack) else None
        nApp = cur[N_APP]
        cur[N_APP] = nApp + 1
        appStack.append(nApp + 1)
        apps[nApp + 1] = dict(parent=parentApp, xwits=set(), rdgs=[])

    elif tag == RDG:
        att = WIT

        if att in atts:
            ws = {w.strip(&#34;.&#34;).lower() for w in atts[att].split()}
            cur[WITNESSES] |= ws
            apps[appStack[-1]][X_WITS] |= ws
            rdgSeen = apps[appStack[-1]][RDGS]
            for rdg in rdgSeen:
                if rdg &amp; ws:
                    addWarning(
                        &#34;witnesses of rdg not disjoint from sibling rdgs&#34;, cur
                    )
            apps[appStack[-1]][RDGS].append(ws)

    for child in node:
        self.collectWitnesses(child)

    if tag == APP:
        appStack.pop()</code></pre>
</details>
</dd>
<dt id="tf.convert.variants.Variants.endApp"><code class="name flex">
<span>def <span class="ident">endApp</span></span>(<span>self, tag)</span>
</code></dt>
<dd>
<div class="desc"><p>Actions at the end of app- lem- and rdg-elements.</p>
<p>Use this each time you leave one of these XML elements.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tag</code></strong> :&ensp;<code>string</code></dt>
<dd>The tag name of the XML element that is being left</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/e3da1869a3a7b032eb0b9630438732555e94b150/tf/convert/variants.py#L294-L334" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def endApp(self, tag):
    &#34;&#34;&#34;Actions at the end of app- lem- and rdg-elements.

    Use this each time you leave one of these XML elements.

    Parameters
    ----------
    tag: string
        The tag name of the XML element that is being left
    &#34;&#34;&#34;

    cur = self.cur
    curStackSent = cur[self.stackSent]

    if tag == APP:
        cur[X_WITS].pop()

        xWits = self._getXwits()
        for wit in self._getWits():
            if wit not in xWits:
                self._resume(wit)

        curStackSent.pop()
        cur[TRANS_LAST] = cur[TRANS_NEXT].pop()

    elif tag == LEM:
        cur[TRANS_NEXT][-1] = cur[TRANS_LAST]

        xWits = self._getXwits()
        for wit in self._getWits():

            if wit not in xWits:
                self._suspend(wit)

    elif tag == RDG:
        wits = cur[WITS][-1]

        for wit in wits:
            self._suspend(wit)

        cur[WITS].pop()</code></pre>
</details>
</dd>
<dt id="tf.convert.variants.Variants.endSent"><code class="name flex">
<span>def <span class="ident">endSent</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Ends a "sentence" if there is a current sentence.</p>
<p>Use this at the end of each XML file if you are sure that
there should not remain pending sentences. You can also call this
at the end of certain elements, such as paragraphs.</p>
<p>When in a lem-element, all pending "sentences" of all witnesses
that agree with the base text here are also ended.
No new sentences for these witnesses are started, since we are in
the base text.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/e3da1869a3a7b032eb0b9630438732555e94b150/tf/convert/variants.py#L388-L412" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def endSent(self):
    &#34;&#34;&#34;Ends a &#34;sentence&#34; if there is a current sentence.

    Use this at the end of each XML file if you are sure that
    there should not remain pending sentences. You can also call this
    at the end of certain elements, such as paragraphs.

    When in a lem-element, all pending &#34;sentences&#34; of all witnesses
    that agree with the base text here are also ended.
    No new sentences for these witnesses are started, since we are in
    the base text.
    &#34;&#34;&#34;

    cur = self.cur

    inRdg = RDG in cur and len(cur[RDG]) &gt; 0
    inLem = LEM in cur and len(cur[LEM]) &gt; 0

    if inLem:
        self._endSentLem()
    elif inRdg:
        self._endSentRdg()
    else:
        for wit in self._getWits():
            self._terminate(wit)</code></pre>
</details>
</dd>
<dt id="tf.convert.variants.Variants.initApps"><code class="name flex">
<span>def <span class="ident">initApps</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize app- processing and witness collection.</p>
<p>You can issue this command once for the whole corpus,
or each time before entering a volume.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/e3da1869a3a7b032eb0b9630438732555e94b150/tf/convert/variants.py#L191-L202" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def initApps(self):
    &#34;&#34;&#34;Initialize app- processing and witness collection.

    You can issue this command once for the whole corpus,
    or each time before entering a volume.
    &#34;&#34;&#34;
    cur = self.cur

    cur[APPS] = dict()
    cur[APP_STACK] = []
    cur[TRANS_NEXT] = []
    cur[N_APP] = 0</code></pre>
</details>
</dd>
<dt id="tf.convert.variants.Variants.resetApps"><code class="name flex">
<span>def <span class="ident">resetApps</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize app- and "sentence" processing.</p>
<p>Set up the data store for collecting information and "sentence" processing.
Do this after collecting the witnesses.</p>
<p>You can issue this command once for the whole corpus,
or each time before entering a volume.
But it should be kept in tandem with <code><a title="tf.convert.variants.Variants.initApps" href="#tf.convert.variants.Variants.initApps">Variants.initApps()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/e3da1869a3a7b032eb0b9630438732555e94b150/tf/convert/variants.py#L204-L226" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def resetApps(self):
    &#34;&#34;&#34;Initialize app- and &#34;sentence&#34; processing.

    Set up the data store for collecting information and &#34;sentence&#34; processing.
    Do this after collecting the witnesses.

    You can issue this command once for the whole corpus,
    or each time before entering a volume.
    But it should be kept in tandem with `Variants.initApps`.
    &#34;&#34;&#34;
    cur = self.cur
    baseWitness = self.baseWitness
    nSent = self.nSent
    stackSent = self.stackSent
    varSent = self.varSent

    cur[N_APP] = 0
    cur[WITS] = []
    cur[X_WITS] = []
    cur[TRANS_LAST] = None
    cur[nSent] = 0
    cur[stackSent] = []
    cur[varSent] = {baseWitness: None}</code></pre>
</details>
</dd>
<dt id="tf.convert.variants.Variants.startApp"><code class="name flex">
<span>def <span class="ident">startApp</span></span>(<span>self, tag, atts)</span>
</code></dt>
<dd>
<div class="desc"><p>Actions at the start of app- lem- and rdg-elements.</p>
<p>Use this each time you enter one of these XML elements.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tag</code></strong> :&ensp;<code>string</code></dt>
<dd>The tag name of the XML element that is being entered</dd>
<dt><strong><code>atts</code></strong> :&ensp;<code>dict</code></dt>
<dd>The attributes of the XML element that is being entered</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/e3da1869a3a7b032eb0b9630438732555e94b150/tf/convert/variants.py#L228-L292" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def startApp(self, tag, atts):
    &#34;&#34;&#34;Actions at the start of app- lem- and rdg-elements.

    Use this each time you enter one of these XML elements.

    Parameters
    ----------
    tag: string
        The tag name of the XML element that is being entered
    atts: dict
        The attributes of the XML element that is being entered
    &#34;&#34;&#34;

    cur = self.cur
    curStackSent = cur[self.stackSent]

    if tag == APP:
        nApp = cur[N_APP]
        cur[N_APP] = nApp + 1
        appInfo = cur[APPS][nApp + 1]
        parentApp = appInfo[PARENT]
        xwits = appInfo[X_WITS]

        slots = self._diverge()
        cur[TRANS_NEXT].append(&#34;&#34;)

        curStackSent.append(
            dict(
                translast=cur[TRANS_LAST],
                slots=slots,
            )
        )

        while parentApp is not None:
            appInfo = cur[APPS][parentApp]

            # keep xwits immutable, don&#39;t say xwits |= blabla
            # because that will change xwits in place

            xwits = xwits | appInfo[X_WITS]
            parentApp = appInfo[PARENT]

        cur[X_WITS].append(xwits)

    elif tag == LEM:
        xWits = self._getXwits()
        for wit in self._getWits():
            if wit in xWits:
                self._suspend(wit)
            else:
                self._resume(wit)

    elif tag == RDG:
        wits = set()
        if WIT in atts:
            wits = {w.strip(&#34;.&#34;).lower() for w in atts[WIT].split()}
            atts[WIT] = &#34; &#34;.join(wits)

        cur[WITS].append(wits)

        for wit in self._getWits():
            if wit in wits:
                self._resume(wit)
            else:
                self._suspend(wit)</code></pre>
</details>
</dd>
<dt id="tf.convert.variants.Variants.startSent"><code class="name flex">
<span>def <span class="ident">startSent</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts a "sentence" if there is no current sentence.</p>
<p>When in an rdg-element, witness-dependend "sentence" nodes
are created for each witness for the rdg.</p>
<p>Use this before creating a slot and/or at the start of certain elements
such as paragraphs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/e3da1869a3a7b032eb0b9630438732555e94b150/tf/convert/variants.py#L365-L386" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def startSent(self):
    &#34;&#34;&#34;Starts a &#34;sentence&#34; if there is no current sentence.

    When in an rdg-element, witness-dependend &#34;sentence&#34; nodes
    are created for each witness for the rdg.

    Use this before creating a slot and/or at the start of certain elements
    such as paragraphs.
    &#34;&#34;&#34;

    cur = self.cur
    baseWitness = self.baseWitness

    inRdg = RDG in cur and len(cur[RDG]) &gt; 0
    inLem = LEM in cur and len(cur[LEM]) &gt; 0

    if inLem:
        self._startSentLem()
    elif inRdg:
        self._startSentRdg()
    else:
        self._start(baseWitness, witAtt=False)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#variants">Variants</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.convert" href="index.html">tf.convert</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.convert.variants.Variants" href="#tf.convert.variants.Variants">Variants</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.convert.variants.Variants.checkSent" href="#tf.convert.variants.Variants.checkSent">checkSent</a></code></li>
<li><code><a title="tf.convert.variants.Variants.collectWitnesses" href="#tf.convert.variants.Variants.collectWitnesses">collectWitnesses</a></code></li>
<li><code><a title="tf.convert.variants.Variants.endApp" href="#tf.convert.variants.Variants.endApp">endApp</a></code></li>
<li><code><a title="tf.convert.variants.Variants.endSent" href="#tf.convert.variants.Variants.endSent">endSent</a></code></li>
<li><code><a title="tf.convert.variants.Variants.initApps" href="#tf.convert.variants.Variants.initApps">initApps</a></code></li>
<li><code><a title="tf.convert.variants.Variants.resetApps" href="#tf.convert.variants.Variants.resetApps">resetApps</a></code></li>
<li><code><a title="tf.convert.variants.Variants.startApp" href="#tf.convert.variants.Variants.startApp">startApp</a></code></li>
<li><code><a title="tf.convert.variants.Variants.startSent" href="#tf.convert.variants.Variants.startSent">startSent</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>