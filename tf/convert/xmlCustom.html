<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.convert.xmlCustom API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-GjqubOlYA6/wOZV7F31o2t4ogk4JGDGFa6XmL+BfAG0=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-qDPJ4nH38AgHyK3U6cvI6DBifA+7hPBo8mVoH6pyN9c=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.convert.xmlCustom</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/907f19d3e96ac1b3319bededbfce2fc092364301/tf/convert/xmlCustom.py#L1-L334" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import re
from io import BytesIO

from tf.core.helpers import console
from tf.core.files import fileOpen, initTree, unexpanduser as ux

from tf.convert.helpers import ZWSP, XNEST, TNEST, CHAR, FOLDER, FILE


def convertTaskDefault(etree):
    if etree is None:
        def dummy(self):
            pass

        return dummy

    def convertTaskDefaultInner(self):
        &#34;&#34;&#34;Implementation of the &#34;convert&#34; task.

        It sets up the `tf.convert.walker` machinery and runs it.

        Returns
        -------
        boolean
            Whether the conversion was successful.
        &#34;&#34;&#34;
        if not self.good:
            return

        procins = self.procins
        verbose = self.verbose
        tfPath = self.tfPath
        xmlPath = self.xmlPath

        if verbose == 1:
            console(f&#34;XML to TF converting: {ux(xmlPath)} =&gt; {ux(tfPath)}&#34;)
        if verbose &gt;= 0:
            console(
                f&#34;Processing instructions are {&#39;treated&#39; if procins else &#39;ignored&#39;}&#34;
            )

        slotType = CHAR
        otext = {
            &#34;fmt:text-orig-full&#34;: &#34;{ch}&#34;,
            &#34;sectionFeatures&#34;: &#34;folder,file&#34;,
            &#34;sectionTypes&#34;: &#34;folder,file&#34;,
        }
        intFeatures = {&#34;empty&#34;}
        featureMeta = dict(
            str=dict(description=&#34;the text of a word&#34;),
            after=dict(description=&#34;the text after a word till the next word&#34;),
            empty=dict(description=&#34;whether a slot has been inserted in an empty element&#34;),
        )

        featureMeta[&#34;ch&#34;] = dict(description=&#34;the UNICODE character of a slot&#34;)
        featureMeta[FOLDER] = dict(description=f&#34;name of source {FOLDER}&#34;)
        featureMeta[FILE] = dict(description=f&#34;name of source {FILE}&#34;)

        self.intFeatures = intFeatures
        self.featureMeta = featureMeta

        tfVersion = self.tfVersion
        xmlVersion = self.xmlVersion
        generic = self.generic
        generic[&#34;sourceFormat&#34;] = &#34;XML&#34;
        generic[&#34;version&#34;] = tfVersion
        generic[&#34;xmlVersion&#34;] = xmlVersion

        initTree(tfPath, fresh=True, gentle=True)

        cv = self.getConverter()

        self.good = cv.walk(
            getDirector(self, etree),
            slotType,
            otext=otext,
            generic=generic,
            intFeatures=intFeatures,
            featureMeta=featureMeta,
            generateTf=True,
        )

    return convertTaskDefaultInner


def getDirector(self, etree):
    &#34;&#34;&#34;Factory for the director function.

    The `tf.convert.walker` relies on a corpus dependent `director` function
    that walks through the source data and spits out actions that
    produces the TF dataset.

    We collect all needed data, store it, and define a local director function
    that has access to this data.

    You can also include a copy of this file in the script that constructs the
    object. If you then tweak it, you can pass it to the XML() object constructor.

    Returns
    -------
    function
        The local director function that has been constructed.
    &#34;&#34;&#34;
    PASS_THROUGH = set(
        &#34;&#34;&#34;
        xml
        &#34;&#34;&#34;.strip().split()
    )

    verbose = self.verbose
    xmlPath = self.xmlPath
    featureMeta = self.featureMeta
    transform = self.transform
    renameAtts = self.renameAtts
    procins = self.procins

    transformFunc = (
        (lambda x: BytesIO(x.encode(&#34;utf-8&#34;)))
        if transform is None
        else (lambda x: BytesIO(transform(x).encode(&#34;utf-8&#34;)))
    )

    parser = self.getParser()

    # WALKERS

    WHITE_TRIM_RE = re.compile(r&#34;\s+&#34;, re.S)

    def walkNode(cv, cur, xnode):
        &#34;&#34;&#34;Internal function to deal with a single element.

        Will be called recursively.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        xnode: object
            An LXML element node.
        &#34;&#34;&#34;
        if procins and isinstance(xnode, etree._ProcessingInstruction):
            target = xnode.target
            tag = f&#34;?{target}&#34;
        else:
            tag = etree.QName(xnode.tag).localname

        atts = {etree.QName(k).localname: v for (k, v) in xnode.attrib.items()}
        atts = {renameAtts.get(k, k): v for (k, v) in atts.items()}

        cur[XNEST].append((tag, atts))

        beforeChildren(cv, cur, xnode, tag, atts)

        for child in xnode.iterchildren(
            tag=(etree.Element, etree.ProcessingInstruction)
            if procins
            else etree.Element
        ):
            walkNode(cv, cur, child)

        afterChildren(cv, cur, xnode, tag, atts)
        cur[XNEST].pop()
        afterTag(cv, cur, xnode, tag, atts)

    def addSlot(cv, cur, ch):
        &#34;&#34;&#34;Add a slot.

        Whenever we encounter a character, we add it as a new slot.
        If needed, we start / terminate word nodes as well.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        ch: string
            A single character, the next slot in the result data.
        &#34;&#34;&#34;
        s = cv.slot()
        cv.feature(s, ch=ch)

    def beforeChildren(cv, cur, xnode, tag, atts):
        &#34;&#34;&#34;Actions before dealing with the element&#39;s children.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        xnode: object
            An LXML element node.
        tag: string
            The tag of the LXML node.
        atts: dict
            The attributes of the LXML node, possibly renamed.
        &#34;&#34;&#34;
        if tag not in PASS_THROUGH:
            curNode = cv.node(tag)
            cur[TNEST].append(curNode)
            if len(atts):
                cv.feature(curNode, **atts)

        if not hasattr(xnode, &#34;target&#34;) and xnode.text:
            textMaterial = WHITE_TRIM_RE.sub(&#34; &#34;, xnode.text)
            for ch in textMaterial:
                addSlot(cv, cur, ch)

    def afterChildren(cv, cur, xnode, tag, atts):
        &#34;&#34;&#34;Node actions after dealing with the children, but before the end tag.

        Here we make sure that the newline elements will get their last slot
        having a newline at the end of their `after` feature.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        xnode: object
            An LXML element node.
        tag: string
            The tag of the LXML node.
        atts: dict
            The attributes of the LXML node, possibly renamed.
        &#34;&#34;&#34;
        if tag not in PASS_THROUGH:
            curNode = cur[TNEST].pop()

            if not cv.linked(curNode):
                s = cv.slot()
                cv.feature(s, ch=ZWSP, empty=1)

            cv.terminate(curNode)

    def afterTag(cv, cur, xnode, tag, atts):
        &#34;&#34;&#34;Node actions after dealing with the children and after the end tag.

        This is the place where we process the `tail` of an LXML node: the
        text material after the element and before the next open/close
        tag of any element.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        xnode: object
            An LXML element node.
        tag: string
            The tag of the LXML node.
        atts: dict
            The attributes of the LXML node, possibly renamed.
        &#34;&#34;&#34;
        if xnode.tail:
            tailMaterial = WHITE_TRIM_RE.sub(&#34; &#34;, xnode.tail)
            for ch in tailMaterial:
                addSlot(cv, cur, ch)

    def director(cv):
        &#34;&#34;&#34;Director function.

        Here we program a walk through the XML sources.
        At every step of the walk we fire some actions that build TF nodes
        and assign features for them.

        Because everything is rather dynamic, we generate fairly standard
        metadata for the features.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        &#34;&#34;&#34;
        cur = {}

        i = 0
        for (xmlFolder, xmlFiles) in self.getXML():
            console(f&#34;Start folder {xmlFolder}:&#34;)

            cur[FOLDER] = cv.node(FOLDER)
            cv.feature(cur[FOLDER], folder=xmlFolder)

            for xmlFile in xmlFiles:
                i += 1
                console(f&#34;\r{i:&gt;4} {xmlFile:&lt;50}&#34;, newline=False)

                cur[FILE] = cv.node(FILE)
                cv.feature(cur[FILE], file=xmlFile.removesuffix(&#34;.xml&#34;))

                with fileOpen(f&#34;{xmlPath}/{xmlFolder}/{xmlFile}&#34;) as fh:
                    text = fh.read()
                    text = transformFunc(text)
                    tree = etree.parse(text, parser)
                    root = tree.getroot()
                    cur[XNEST] = []
                    cur[TNEST] = []
                    walkNode(cv, cur, root)

                addSlot(cv, cur, None)
                cv.terminate(cur[FILE])

            console(&#34;&#34;)
            console(f&#34;End   folder {xmlFolder}&#34;)
            cv.terminate(cur[FOLDER])

        console(&#34;&#34;)

        for fName in featureMeta:
            if not cv.occurs(fName):
                cv.meta(fName)
        for fName in cv.features():
            if fName not in featureMeta:
                cv.meta(
                    fName,
                    description=f&#34;this is XML attribute {fName}&#34;,
                    valueType=&#34;str&#34;,
                )

        if verbose == 1:
            console(&#34;source reading done&#34;)
        return True

    return director</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.convert.xmlCustom.convertTaskDefault"><code class="name flex">
<span>def <span class="ident">convertTaskDefault</span></span>(<span>etree)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/907f19d3e96ac1b3319bededbfce2fc092364301/tf/convert/xmlCustom.py#L10-L83" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def convertTaskDefault(etree):
    if etree is None:
        def dummy(self):
            pass

        return dummy

    def convertTaskDefaultInner(self):
        &#34;&#34;&#34;Implementation of the &#34;convert&#34; task.

        It sets up the `tf.convert.walker` machinery and runs it.

        Returns
        -------
        boolean
            Whether the conversion was successful.
        &#34;&#34;&#34;
        if not self.good:
            return

        procins = self.procins
        verbose = self.verbose
        tfPath = self.tfPath
        xmlPath = self.xmlPath

        if verbose == 1:
            console(f&#34;XML to TF converting: {ux(xmlPath)} =&gt; {ux(tfPath)}&#34;)
        if verbose &gt;= 0:
            console(
                f&#34;Processing instructions are {&#39;treated&#39; if procins else &#39;ignored&#39;}&#34;
            )

        slotType = CHAR
        otext = {
            &#34;fmt:text-orig-full&#34;: &#34;{ch}&#34;,
            &#34;sectionFeatures&#34;: &#34;folder,file&#34;,
            &#34;sectionTypes&#34;: &#34;folder,file&#34;,
        }
        intFeatures = {&#34;empty&#34;}
        featureMeta = dict(
            str=dict(description=&#34;the text of a word&#34;),
            after=dict(description=&#34;the text after a word till the next word&#34;),
            empty=dict(description=&#34;whether a slot has been inserted in an empty element&#34;),
        )

        featureMeta[&#34;ch&#34;] = dict(description=&#34;the UNICODE character of a slot&#34;)
        featureMeta[FOLDER] = dict(description=f&#34;name of source {FOLDER}&#34;)
        featureMeta[FILE] = dict(description=f&#34;name of source {FILE}&#34;)

        self.intFeatures = intFeatures
        self.featureMeta = featureMeta

        tfVersion = self.tfVersion
        xmlVersion = self.xmlVersion
        generic = self.generic
        generic[&#34;sourceFormat&#34;] = &#34;XML&#34;
        generic[&#34;version&#34;] = tfVersion
        generic[&#34;xmlVersion&#34;] = xmlVersion

        initTree(tfPath, fresh=True, gentle=True)

        cv = self.getConverter()

        self.good = cv.walk(
            getDirector(self, etree),
            slotType,
            otext=otext,
            generic=generic,
            intFeatures=intFeatures,
            featureMeta=featureMeta,
            generateTf=True,
        )

    return convertTaskDefaultInner</code></pre>
</details>
</dd>
<dt id="tf.convert.xmlCustom.getDirector"><code class="name flex">
<span>def <span class="ident">getDirector</span></span>(<span>self, etree)</span>
</code></dt>
<dd>
<div class="desc"><p>Factory for the director function.</p>
<p>The <code><a title="tf.convert.walker" href="walker.html">tf.convert.walker</a></code> relies on a corpus dependent <code>director</code> function
that walks through the source data and spits out actions that
produces the TF dataset.</p>
<p>We collect all needed data, store it, and define a local director function
that has access to this data.</p>
<p>You can also include a copy of this file in the script that constructs the
object. If you then tweak it, you can pass it to the XML() object constructor.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>function</code></dt>
<dd>The local director function that has been constructed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/907f19d3e96ac1b3319bededbfce2fc092364301/tf/convert/xmlCustom.py#L86-L334" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getDirector(self, etree):
    &#34;&#34;&#34;Factory for the director function.

    The `tf.convert.walker` relies on a corpus dependent `director` function
    that walks through the source data and spits out actions that
    produces the TF dataset.

    We collect all needed data, store it, and define a local director function
    that has access to this data.

    You can also include a copy of this file in the script that constructs the
    object. If you then tweak it, you can pass it to the XML() object constructor.

    Returns
    -------
    function
        The local director function that has been constructed.
    &#34;&#34;&#34;
    PASS_THROUGH = set(
        &#34;&#34;&#34;
        xml
        &#34;&#34;&#34;.strip().split()
    )

    verbose = self.verbose
    xmlPath = self.xmlPath
    featureMeta = self.featureMeta
    transform = self.transform
    renameAtts = self.renameAtts
    procins = self.procins

    transformFunc = (
        (lambda x: BytesIO(x.encode(&#34;utf-8&#34;)))
        if transform is None
        else (lambda x: BytesIO(transform(x).encode(&#34;utf-8&#34;)))
    )

    parser = self.getParser()

    # WALKERS

    WHITE_TRIM_RE = re.compile(r&#34;\s+&#34;, re.S)

    def walkNode(cv, cur, xnode):
        &#34;&#34;&#34;Internal function to deal with a single element.

        Will be called recursively.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        xnode: object
            An LXML element node.
        &#34;&#34;&#34;
        if procins and isinstance(xnode, etree._ProcessingInstruction):
            target = xnode.target
            tag = f&#34;?{target}&#34;
        else:
            tag = etree.QName(xnode.tag).localname

        atts = {etree.QName(k).localname: v for (k, v) in xnode.attrib.items()}
        atts = {renameAtts.get(k, k): v for (k, v) in atts.items()}

        cur[XNEST].append((tag, atts))

        beforeChildren(cv, cur, xnode, tag, atts)

        for child in xnode.iterchildren(
            tag=(etree.Element, etree.ProcessingInstruction)
            if procins
            else etree.Element
        ):
            walkNode(cv, cur, child)

        afterChildren(cv, cur, xnode, tag, atts)
        cur[XNEST].pop()
        afterTag(cv, cur, xnode, tag, atts)

    def addSlot(cv, cur, ch):
        &#34;&#34;&#34;Add a slot.

        Whenever we encounter a character, we add it as a new slot.
        If needed, we start / terminate word nodes as well.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        ch: string
            A single character, the next slot in the result data.
        &#34;&#34;&#34;
        s = cv.slot()
        cv.feature(s, ch=ch)

    def beforeChildren(cv, cur, xnode, tag, atts):
        &#34;&#34;&#34;Actions before dealing with the element&#39;s children.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        xnode: object
            An LXML element node.
        tag: string
            The tag of the LXML node.
        atts: dict
            The attributes of the LXML node, possibly renamed.
        &#34;&#34;&#34;
        if tag not in PASS_THROUGH:
            curNode = cv.node(tag)
            cur[TNEST].append(curNode)
            if len(atts):
                cv.feature(curNode, **atts)

        if not hasattr(xnode, &#34;target&#34;) and xnode.text:
            textMaterial = WHITE_TRIM_RE.sub(&#34; &#34;, xnode.text)
            for ch in textMaterial:
                addSlot(cv, cur, ch)

    def afterChildren(cv, cur, xnode, tag, atts):
        &#34;&#34;&#34;Node actions after dealing with the children, but before the end tag.

        Here we make sure that the newline elements will get their last slot
        having a newline at the end of their `after` feature.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        xnode: object
            An LXML element node.
        tag: string
            The tag of the LXML node.
        atts: dict
            The attributes of the LXML node, possibly renamed.
        &#34;&#34;&#34;
        if tag not in PASS_THROUGH:
            curNode = cur[TNEST].pop()

            if not cv.linked(curNode):
                s = cv.slot()
                cv.feature(s, ch=ZWSP, empty=1)

            cv.terminate(curNode)

    def afterTag(cv, cur, xnode, tag, atts):
        &#34;&#34;&#34;Node actions after dealing with the children and after the end tag.

        This is the place where we process the `tail` of an LXML node: the
        text material after the element and before the next open/close
        tag of any element.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        xnode: object
            An LXML element node.
        tag: string
            The tag of the LXML node.
        atts: dict
            The attributes of the LXML node, possibly renamed.
        &#34;&#34;&#34;
        if xnode.tail:
            tailMaterial = WHITE_TRIM_RE.sub(&#34; &#34;, xnode.tail)
            for ch in tailMaterial:
                addSlot(cv, cur, ch)

    def director(cv):
        &#34;&#34;&#34;Director function.

        Here we program a walk through the XML sources.
        At every step of the walk we fire some actions that build TF nodes
        and assign features for them.

        Because everything is rather dynamic, we generate fairly standard
        metadata for the features.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        &#34;&#34;&#34;
        cur = {}

        i = 0
        for (xmlFolder, xmlFiles) in self.getXML():
            console(f&#34;Start folder {xmlFolder}:&#34;)

            cur[FOLDER] = cv.node(FOLDER)
            cv.feature(cur[FOLDER], folder=xmlFolder)

            for xmlFile in xmlFiles:
                i += 1
                console(f&#34;\r{i:&gt;4} {xmlFile:&lt;50}&#34;, newline=False)

                cur[FILE] = cv.node(FILE)
                cv.feature(cur[FILE], file=xmlFile.removesuffix(&#34;.xml&#34;))

                with fileOpen(f&#34;{xmlPath}/{xmlFolder}/{xmlFile}&#34;) as fh:
                    text = fh.read()
                    text = transformFunc(text)
                    tree = etree.parse(text, parser)
                    root = tree.getroot()
                    cur[XNEST] = []
                    cur[TNEST] = []
                    walkNode(cv, cur, root)

                addSlot(cv, cur, None)
                cv.terminate(cur[FILE])

            console(&#34;&#34;)
            console(f&#34;End   folder {xmlFolder}&#34;)
            cv.terminate(cur[FOLDER])

        console(&#34;&#34;)

        for fName in featureMeta:
            if not cv.occurs(fName):
                cv.meta(fName)
        for fName in cv.features():
            if fName not in featureMeta:
                cv.meta(
                    fName,
                    description=f&#34;this is XML attribute {fName}&#34;,
                    valueType=&#34;str&#34;,
                )

        if verbose == 1:
            console(&#34;source reading done&#34;)
        return True

    return director</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.convert" href="index.html">tf.convert</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tf.convert.xmlCustom.convertTaskDefault" href="#tf.convert.xmlCustom.convertTaskDefault">convertTaskDefault</a></code></li>
<li><code><a title="tf.convert.xmlCustom.getDirector" href="#tf.convert.xmlCustom.getDirector">getDirector</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>