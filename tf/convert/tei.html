<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.convert.tei API documentation</title>
<meta name="description" content="TEI import …" />
<!-- integrity SRI from https://cdnjs.com/libraries/10up-sanitize.css/11.0.1 -->
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css"
integrity="sha512-kcbluZFacWN57NgWZ4aH6eUMBEaTyErFhIFD3y5qYZbKuuyImH0K/AKsBbfXlivh2z5C+3IDTIhI11YmKomzmA=="
crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css"
integrity="sha512-uVeAgzAmieLUTGba0qr9vXQgVD7fko2kcbYIKIraXUIDg9iJLxveTFUrg3DJhqn3cAf3HFDbgmhq0eGko5wEAA=="
crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.convert.tei</code></h1>
</header>
<section id="section-intro">
<h1 id="tei-import">TEI import</h1>
<p>You can convert any TEI source into TF by specifying a few details about the source.</p>
<p>TF then invokes the <code><a title="tf.convert.walker" href="walker.html">tf.convert.walker</a></code> machinery to produce a TF
dataset out of the source.</p>
<p>TF knows the TEI elements, because it will read and parse the complete
TEI schema. From this the set of complex, mixed elements is distilled.</p>
<p>If the TEI source conforms to a customised TEI schema, it will be detected and
the importer will read it and override the generic information of the TEI elements.</p>
<p>It is also possible to pass a choice of template and adaptation in a processing
instruction. This does not influence validation, but it may influence further
processing.</p>
<p>If the TEI consists of multiple source files, it is possible to specify different
templates and adaptations for different files.</p>
<p>The possible values for models, templates, and adaptations should be declared in
the configuration file.
For each model there should be a corresponding schema in the schema directory,
either an RNG or an XSD file.</p>
<p>The converter goes the extra mile: it generates a TF app and documentation
(an <em>about.md</em> file and a <em>transcription.md</em> file), in such a way that the TF
browser is instantly usable.</p>
<p>The TEI conversion is rather straightforward because of some conventions
that cannot be changed.</p>
<h1 id="configuration-and-customization">Configuration and customization</h1>
<p>We assume that you have a <code>programs</code> directory at the top-level of your repo.
In this directory we'll look for two optional files:</p>
<ul>
<li>
<p>a file <code>tei.yaml</code> in which you specify a bunch of values to
get the conversion off the ground.</p>
</li>
<li>
<p>a file <code>tei.py</code> in which you define custom functions that are executed at certain
specific hooks:</p>
<ul>
<li><code>transform(text)</code> which takes a text string argument and delivers a
text string as result. The converter will call this on every TEI input
file it reads <em>before</em> feeding it to the XML parser.
This can be used to solve some quirks in the input, e.g. replacing two
consecutive commas (<code>,,</code>) by a single unicode character (<code>„</code> = 201E);</li>
<li><code>beforeTag</code>: just before the walker starts processing the start tag of
a TEI element;</li>
<li><code>beforeChildren</code>: just after processing the start tag, but before processing
the element content (text and child elements);</li>
<li><code>afterChildren</code>: just after processing the complete element content
(text and child elements), but before processing the end tag of the
TEI element;</li>
<li>
<p><code>afterTag</code>: just after processing the end tag of a TEI element.</p>
<p>The
<code>before</code> and <code>after</code> functions should take the following arguments</p>
<ul>
<li><code>cv</code>: the walker converter object;</li>
<li><code>cur</code>: the dictionary with information that has been gathered during the
conversion so far and that can be used to dump new information
into; it is nonlocal, i.e. all invocations of the hooks get the same
dictionary object passed to them;</li>
<li><code>xnode</code>: the LXML node corresponding to the TEI element;</li>
<li><code>tag</code>: the tag name of the element, without namespaces;
this is a bit redundant, because it can also be extracted from
the <code>xnode</code>, but it is convenient.</li>
<li><code>atts</code>: the attributes (names and values) of the element,
without namespaces;
this is a bit redundant, because it can also be extracted from
the <code>xnode</code>, but it is convenient.</li>
</ul>
<p>These functions should not return anything, but they can write things to
the <code>cur</code> dictionary.
And they can create slots, nodes, and terminate them, in short, they
can do every <code>cv</code>-based action that is needed.</p>
<p>You can define these functions out of this context, but it is good to know
what information in <code>cur</code> is guaranteed to be available:</p>
<ul>
<li><code>xnest</code>: the stack of XML tag names seen at this point;</li>
<li><code>tnest</code>: the stack of TF nodes built at this point;</li>
<li><code>tsiblings</code> (only if sibling nodes are being recorded): the list of
preceding TF nodes corresponding to the TEI sibling elements of the
current TEI element.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="keys-and-values-of-the-teiyaml-file">Keys and values of the <code>tei.yaml</code> file</h2>
<h3 id="generic"><code>generic</code></h3>
<p>dict, optional <code>{}</code></p>
<p>Metadata for all generated TF features.
The actual source version of the TEI files does not have to be stated here,
it will be inserted based on the version that the converter will actually use.
That version depends on the <code>tei</code> argument passed to the program.
The key under which the source version will be inserted is <code>teiVersion</code>.</p>
<h3 id="extra"><code>extra</code></h3>
<p>dict, optional <code>{}</code></p>
<p>Instructions and metadata for specific generated TF features, namely those that
have not been generated by the vanilla TEI conversion, but by extra code in one
of the customised hooks.
The dict is keyed by feature name, the values are again dictionaries.
These value dictionaries have a key meta under which any number of metadata key value
pairs, such as <code>description="xxx"</code>.</p>
<p>If you put the string «base» in such a field, it will be expanded on the
basis of the contents of the <code>path</code> key, see below.</p>
<p>You must provide the key <code>valueType</code> and pass <code>int</code> or <code>str</code> there, depending on the
values of the feature.
You may provide extra keys, such as <code>conversionMethod="derived"</code>, so that other programs
can determine what to do with these features.
The information in this dict will also end up in the generated feature docs.</p>
<p>Besides the <code>meta</code> key, there may also be the keys <code>path</code>, and <code>nodeType</code>.
Together they contain an instruction to produce a feature value from element content
that can be found on the current stack of XML nodes and attributes.
The value found will be put in the feature in question
for the node of type specified in <code>nodeType</code> that is recently constructed.</p>
<p>Example:</p>
<pre><code class="language-yaml">extra:
  letterid:
    meta:
      description: The identifier of a letter; «base»
      valueType: str
      conversionMethod: derived
      conversionCode: tt
    path:
      - idno:
        type: letterId
      - altIdentifier
      - msIdentifier
      - msDesc
      - sourceDesc
    nodeType: letter
    feature: letterid
</code></pre>
<p>The meaning is:</p>
<ul>
<li>if, while parsing the XML, I encounter an element <code>idno</code>,</li>
<li>and if that element has an attribute <code>type</code> with value <code>letterId</code>,</li>
<li>and if it has parent <code>altIdentifier</code>,</li>
<li>and grandparent <code>msIdentifier</code>,</li>
<li>and great-grandparent <code>msDesc</code>,</li>
<li>and great-great-grandparent <code>sourceDesc</code>,</li>
<li>then look up the last created node of type <code>letter</code></li>
<li>and get the text content of the current XML node (the <code>idno</code> one),</li>
<li>and put it in the feature <code>letterid</code> for that node.</li>
<li>Moreover, the feature <code>letterid</code> gets metadata as specified under the key <code>meta</code>,
where the <code>description</code> will be filled with the text<pre><code>The identifier of a letter; the content is taken from sourceDesc/msDesc/msIdentifier/altIdentifier/idno[type=letterId]
</code></pre>
</li>
</ul>
<h3 id="models"><code>models</code></h3>
<p>list, optional <code>[]</code></p>
<p>Which TEI-based schemas are to be used.
For each model there should be an XSD or RNG file with that name in the <code>schema</code>
directory. The <code>tei_all</code> schema is known to TF, no need to specify that one.</p>
<p>We'll try a RelaxNG schema (<code>.rng</code>) first. If that exists, we use it for validation
with JING, and we also convert it with TRANG to an XSD schema, which we use for
analysing the schema: we want to know which elements are mixed and pure.</p>
<p>If there is no RelaxNG schema, we try an XSD schema (<code>.xsd</code>). If that exists,
we can do the analysis, and we will use it also for validation.</p>
<div class="admonition note">
<p class="admonition-title">Problems with RelaxNG validation</p>
<p>RelaxNG validation is not always reliable when performed with LXML, or any tool
based on <code>libxml</code>, for that matter. That's why we try to avoid it. Even if we
translate the RelaxNG schema to an XSD schema by means of TRANG, the resulting
validation is not always reliable. So we use JING to validate the RelaxNG schema.</p>
</div>
<p>See also <a href="https://code.google.com/archive/p/jing-trang/downloads">JING-TRANG</a>.</p>
<h3 id="templates"><code>templates</code></h3>
<p>list, optional <code>[]</code></p>
<p>Which template(s) are to be used.
A template is just a keyword, associated with an XML file, that can be used to switch
to a specific kind of processing, such as <code>letter</code>, <code>bibliolist</code>, <code>artworklist</code>.</p>
<p>You may specify an element or processing instruction with an attribute
that triggers the template for the file in which it is found.</p>
<p>This will be retrieved from the file before XML parsing starts.
For example,</p>
<pre><code class="language-python">    templateTrigger=&quot;?editem@template&quot;
</code></pre>
<p>will read the file and extract the value of the <code>template</code> attribute of the <code>editem</code>
processing instruction and use that as the template for this file.
If no template is found in this way, the empty template is assumed.</p>
<h3 id="adaptations"><code>adaptations</code></h3>
<p>list, optional <code>[]</code></p>
<p>Which adaptations(s) are to be used.
An adaptation is just a keyword, associated with an XML file, that can be used to switch
to a specific kind of processing.
It is meant to trigger tweaks on top of the behaviour of a template.</p>
<p>You may specify an element or processing instruction with an attribute
that triggers the adaptation for the file in which it is found.</p>
<p>This will be retrieved from the file before XML parsing starts.
For example,</p>
<pre><code class="language-python">    adaptationTrigger=&quot;?editem@adaptation&quot;
</code></pre>
<p>will read the file and extract the value of the <code>adaptation</code> attribute of the <code>editem</code>
processing instruction and use that as the adaptation for this file.
If no adaptation is found in this way, the empty adaptation is assumed.</p>
<h3 id="prelim"><code>prelim</code></h3>
<p>boolean, optional <code>True</code></p>
<p>Whether to work with the <code>pre</code> TF versions.
Use this if you convert TEI to a preliminary TF dataset, which will
receive NLP additions later on. That version will then lose the <code>pre</code>.</p>
<h3 id="granularity"><code>granularity</code></h3>
<p>string, optional <code>token</code></p>
<p>What to take the basic entities (slots). Possible values:</p>
<ul>
<li><code>word</code>: words are slots, even if they cross element boundaries. This leads to some
imprecisions: words containing an element boundary will belong to just one
of both elements around the boundary.</li>
<li><code>char</code>: all individual characters are separate slots. Very precise, but the dataset
gets expensive with so many slots.</li>
<li><code>token</code>: every sequence of alphanumeric characters becomes a token, in sofar there
is no intervening markup. Non alphanumeric characters become separate tokens.
There are some additional rules: <code>.</code> or <code>,</code> tightly surrounded by digits also
count as tokens.</li>
</ul>
<p>The datasets with granularity <code>word</code> and <code>token</code> have features <code>str</code> for the string
content of the slots, and <code>after</code> for the material after the slots.
In the case of <code>word</code>, the feature <code>after</code> can contain whitespace and punctuation
characters, in the case of <code>token</code>, it only contains whitespace.</p>
<p>If not, the characters are taken as basic entities.</p>
<p>If you use an NLP pipeline to detect tokens, use the value <code>False</code>.
The preliminary dataset is then based on characters, but the final dataset that we build
from there is based on tokens, which are mostly words and non-word characters.</p>
<h3 id="parentedges"><code>parentEdges</code></h3>
<p>boolean, optional <code>True</code></p>
<p>Whether to create edges between nodes that correspond to XML elements and their parents.</p>
<h3 id="siblingedges"><code>siblingEdges</code></h3>
<p>boolean, optional <code>False</code></p>
<p>Whether to create edges between nodes that correspond to XML elements and siblings.
Edges will be created between each sibling and its <em>preceding</em> siblings.
If you use these edges in the binary way, you can also find the following siblings.
The edges are labeled with the distance between the siblings, adjacent siblings
get distance 1.</p>
<div class="admonition caution">
<p class="admonition-title">Overwhelming space requirement</p>
<p>If the corpus is divided into relatively few elements that each have very many
direct children, the number of sibling edges is comparable to the size of the
corpus squared. That means that the TF dataset will consist for 50-99% of
sibling edges!
An example is <a href="https://github.com/ETCBC/nestle1904"><code>ETCBC/nestle1904</code></a> (Greek New
Testament) where each book element has all of its sentences as direct children.
In that dataset, the siblings would occupy 40% of the size, and we have taken care
not to produce sibling edges for sentences.</p>
</div>
<h3 id="procins"><code>procins</code></h3>
<p>boolean, optional <code>False</code></p>
<p>If True, processing instructions will be treated.
Processing instruction <code>&lt;?foo bar="xxx"?&gt;</code> will be converted as if it were an empty
element named <code>foo</code> with attribute <code>bar</code> with value <code>xxx</code>.</p>
<h3 id="linemodel"><code>lineModel</code></h3>
<p>dict, optional <code>False</code></p>
<p>If not passed, or an empty dict, line model I is assumed.
A line model must be specified with the parameters relevant for the
model:</p>
<pre><code class="language-python">dict(
    model=&quot;I&quot;,
)
</code></pre>
<p>(model I does not require any parameters)</p>
<p>or</p>
<pre><code class="language-python">dict(
    model=&quot;II&quot;,
    element=&quot;p&quot;,
    nodeType=&quot;ln&quot;,
)
</code></pre>
<p>For model II, the default parameters are:</p>
<pre><code class="language-python">element=&quot;p&quot;,
nodeType=&quot;ln&quot;,
</code></pre>
<p>Model I is the default, and nothing special happens to the <code>&lt;lb&gt;</code> elements.</p>
<p>In model II the <code>&lt;lb&gt;</code> elements translate to nodes of type <code>ln</code>, which span
content, whereas the original <code>lb</code> elements just mark positions.
Instead of <code>ln</code>, you can also specify another node type by the parameter <code>element</code>.</p>
<p>We assume that the material that the <code>&lt;lb&gt;</code> elements divide up is the material
that corresponds to their <code>&lt;p&gt;</code> parent element. Instead of <code>&lt;p&gt;</code>,
you can also specify another element in the parameter <code>element</code>.</p>
<p>We assume that lines start and end at the start and end of the <code>&lt;p&gt;</code> elements and
the <code>&lt;lb&gt;</code> elements. For the material etween these boundaries, we build <code>ln</code> nodes.
If an <code>&lt;lb&gt;</code> element follows a <code>&lt;p&gt;</code> start tag without intervening slots, a <code>ln</code>
node will be created but not linked to slots, and it will be deleted later in
the conversion.
Likewise, if an <code>&lt;lb&gt;</code> element is followed by a <code>&lt;p&gt;</code> end tag without
intervening slots, a <code>ln</code> node is created that is not linked to slots.</p>
<p>The attributes of the <code>&lt;lb&gt;</code> elements become features of the <code>ln</code> node that starts
with that <code>&lt;lb&gt;</code> element. If there is no explicit <code>&lt;lb&gt;</code> element at the start of
a paragraph, the first <code>ln</code> node of that paragraph gets no features.</p>
<h3 id="pagemodel"><code>pageModel</code></h3>
<p>dict, optional <code>False</code></p>
<p>If not passed, or an empty dict, page model I is assumed.
A page model must be specified with the parameters relevant for the
model:</p>
<pre><code class="language-python">dict(
    model=&quot;I&quot;,
)
</code></pre>
<p>(model I does not require any parameters)</p>
<p>or</p>
<pre><code class="language-python">dict(
    model=&quot;II&quot;,
    element=&quot;div&quot;,
    attributes=dict(type=[&quot;original&quot;, &quot;translation&quot;]),
    pbAtTop=True,
    nodeType=&quot;page&quot;,
)
</code></pre>
<p>For model II, the default parameters are:</p>
<pre><code class="language-python">element=&quot;div&quot;,
pbAtTop=True,
nodeType=&quot;page&quot;,
attributes={},
</code></pre>
<p>Model I is the default, and nothing special happens to the <code>&lt;pb&gt;</code> elements.</p>
<p>In model II the <code>&lt;pb&gt;</code> elements translate to nodes of type <code>page</code>, which span
content, whereas the original <code>pb</code> elements just mark positions.
Instead of <code>page</code>, you can also specify another node type by the parameter <code>element</code>.</p>
<p>We assume that the material that the <code>&lt;pb&gt;</code> elements divide up is the material
that corresponds to their <code>&lt;div&gt;</code> parent element. Instead of <code>&lt;div&gt;</code>,
you can also specify another element in the parameter <code>element</code>.
If you want to restrict the parent elements of pages, you can do so by specifying
attributes, like <code>type="original"</code>. Then only parents that carry those attributes
will be chopped up into pages.
You can specify multiple values for each attribute. Elements that carry one of these
values are candidates for having their content divided into pages.</p>
<p>We assume that the material to be divided starts with a <code>&lt;pb&gt;</code> (as the TEI-guidelines
prescribe) and we translate it to a page element that we close either at the
next <code>&lt;pb&gt;</code> or at the end of the <code>div</code>.</p>
<p>But if you specify <code>pbAtTop=False</code>, we assume that the <code>&lt;pb&gt;</code> marks the end of
the corresponding page element. We start the first page at the start of the enclosing
element. If there is material at between the last <code>&lt;pb&gt;</code> till the end of the enclosing
element, we generate an extra page node without features.</p>
<h3 id="sectionmodel"><code>sectionModel</code></h3>
<p>dict, optional <code>{}</code></p>
<p>If not passed, or an empty dict, section model I is assumed.
A section model must be specified with the parameters relevant for the
model:</p>
<pre><code class="language-python">dict(
    model=&quot;II&quot;,
    levels=[&quot;chapter&quot;, &quot;chunk&quot;],
    element=&quot;head&quot;,
    attributes=dict(rend=&quot;h3&quot;),
)
</code></pre>
<p>(model I does not require the <em>element</em> and <em>attribute</em> parameters)</p>
<p>or</p>
<pre><code class="language-python">dict(
    model=&quot;I&quot;,
    levels=[&quot;folder&quot;, &quot;file&quot;, &quot;chunk&quot;],
)
</code></pre>
<p>This section model (I) accepts a few other parameters:</p>
<pre><code class="language-python">    backMatter=&quot;backmatter&quot;
</code></pre>
<p>This is the name of the folder that should not be treated as an ordinary folder, but
as the folder with the sources for the back-matter, such as references, lists, indices,
bibliography, biographies, etc.</p>
<pre><code class="language-python">    drillDownDivs=True
</code></pre>
<p>Whether the chunks are the immediate children of <code>body</code> elements, or whether
we should drill through all intervening <code>div</code> levels.</p>
<p>For model II, the default parameters are:</p>
<pre><code class="language-python">element=&quot;head&quot;
levels=[&quot;chapter&quot;, &quot;chunk&quot;],
attributes={}
</code></pre>
<p>In model I, there are three section levels in total.
The corpus is divided in folders (section level 1), files (section level 2),
and chunks within files. The parameter <code>levels</code> allows you to choose names for the
node types of these section levels.</p>
<p>In model II, there are 2 section levels in total.
The corpus consists of a single file, and section nodes will be added
for nodes at various levels, mainly outermost <code>&lt;div&gt;</code> and <code>&lt;p&gt;</code> elements and their
siblings of other element types.
The section heading for the second level is taken from elements in the neighbourhood,
whose name is given in the parameter <code>element</code>, but only if they carry some attributes,
which can be specified in the <code>attributes</code> parameter.</p>
<h1 id="usage">Usage</h1>
<h2 id="command-line">Command-line</h2>
<pre><code class="language-sh">tf-fromtei tasks flags
</code></pre>
<h2 id="from-python">From Python</h2>
<pre><code class="language-python">from tf.convert.tei import TEI

T = TEI()
T.task(**tasks, **flags)
</code></pre>
<p>For a short overview the tasks and flags, see <code>HELP</code>.</p>
<h2 id="tasks">Tasks</h2>
<p>We have the following conversion tasks:</p>
<ol>
<li><code>check</code>: makes and inventory of all XML elements and attributes used.</li>
<li><code>convert</code>: produces actual TF files by converting XML files.</li>
<li><code>load</code>: loads the generated TF for the first time, by which the pre-computation
step is triggered. During pre-computation some checks are performed. Once this
has succeeded, we have a workable TF dataset.</li>
<li><code>app</code>: creates or updates a corpus specific TF app with minimal sensible settings,
plus basic documentation.</li>
<li><code>apptoken</code>: updates a corpus specific TF app from a character-based dataset
to a token-based dataset.</li>
<li><code>browse</code>: starts the TF browser on the newly created dataset.</li>
</ol>
<p>Tasks can be run by passing any choice of task keywords to the
<code><a title="tf.convert.tei.TEI.task" href="#tf.convert.tei.TEI.task">TEI.task()</a></code> method.</p>
<h2 id="note-on-versions">Note on versions</h2>
<p>The TEI source files come in versions, indicated with a data.
The converter picks the most recent one, unless you specify an other one:</p>
<pre><code class="language-python">tf-from-tei tei=-2  # previous version
tf-from-tei tei=0  # first version
tf-from-tei tei=3  # third version
tf-from-tei tei=2019-12-23  # explicit version
</code></pre>
<p>The resulting TF data is independently versioned, like <code>1.2.3</code> or <code>1.2.3pre</code>.
When the converter runs, by default it overwrites the most recent version,
unless you specify another one.</p>
<p>It looks at the latest version and then bumps a part of the version number.</p>
<pre><code class="language-python">tf-fromtei tf=3  # minor version, 1.2.3 becomes 1.2.4; 1.2.3pre becomes 1.2.4pre
tf-fromtei tf=2  # intermediate version, 1.2.3 becomes 1.3.0
tf-fromtei tf=1  # major version, 1.2.3 becomes 2.0.0
tf-fromtei tf=1.8.3  # explicit version
</code></pre>
<h2 id="examples">Examples</h2>
<p>Exactly how you can call the methods of this module is demonstrated in the small
corpus of 14 letter by the Dutch artist Piet Mondriaan.</p>
<ul>
<li><a href="https://nbviewer.org/github/annotation/mondriaan/blob/master/programs/convertExpress.ipynb">Mondriaan</a>.</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/331baa8460d48d644338cf8e085d696cb9cbdbb0/tf/convert/tei.py#L1-L4646" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# TEI import

You can convert any TEI source into TF by specifying a few details about the source.

TF then invokes the `tf.convert.walker` machinery to produce a TF
dataset out of the source.

TF knows the TEI elements, because it will read and parse the complete
TEI schema. From this the set of complex, mixed elements is distilled.

If the TEI source conforms to a customised TEI schema, it will be detected and
the importer will read it and override the generic information of the TEI elements.

It is also possible to pass a choice of template and adaptation in a processing
instruction. This does not influence validation, but it may influence further
processing.

If the TEI consists of multiple source files, it is possible to specify different
templates and adaptations for different files.

The possible values for models, templates, and adaptations should be declared in
the configuration file.
For each model there should be a corresponding schema in the schema directory,
either an RNG or an XSD file.

The converter goes the extra mile: it generates a TF app and documentation
(an *about.md* file and a *transcription.md* file), in such a way that the TF
browser is instantly usable.

The TEI conversion is rather straightforward because of some conventions
that cannot be changed.

# Configuration and customization

We assume that you have a `programs` directory at the top-level of your repo.
In this directory we&#39;ll look for two optional files:

*   a file `tei.yaml` in which you specify a bunch of values to
    get the conversion off the ground.

*   a file `tei.py` in which you define custom functions that are executed at certain
    specific hooks:

    *   `transform(text)` which takes a text string argument and delivers a
        text string as result. The converter will call this on every TEI input
        file it reads *before* feeding it to the XML parser.
        This can be used to solve some quirks in the input, e.g. replacing two
        consecutive commas (`,,`) by a single unicode character (`„` = 201E);
    *   `beforeTag`: just before the walker starts processing the start tag of
        a TEI element;
    *   `beforeChildren`: just after processing the start tag, but before processing
        the element content (text and child elements);
    *   `afterChildren`: just after processing the complete element content
        (text and child elements), but before processing the end tag of the
        TEI element;
    *   `afterTag`: just after processing the end tag of a TEI element.

        The  `before` and `after` functions should take the following arguments

        *   `cv`: the walker converter object;
        *   `cur`: the dictionary with information that has been gathered during the
            conversion so far and that can be used to dump new information
            into; it is nonlocal, i.e. all invocations of the hooks get the same
            dictionary object passed to them;
        *   `xnode`: the LXML node corresponding to the TEI element;
        *   `tag`: the tag name of the element, without namespaces;
            this is a bit redundant, because it can also be extracted from
            the `xnode`, but it is convenient.
        *   `atts`: the attributes (names and values) of the element,
            without namespaces;
            this is a bit redundant, because it can also be extracted from
            the `xnode`, but it is convenient.

        These functions should not return anything, but they can write things to
        the `cur` dictionary.
        And they can create slots, nodes, and terminate them, in short, they
        can do every `cv`-based action that is needed.

        You can define these functions out of this context, but it is good to know
        what information in `cur` is guaranteed to be available:

        *   `xnest`: the stack of XML tag names seen at this point;
        *   `tnest`: the stack of TF nodes built at this point;
        *   `tsiblings` (only if sibling nodes are being recorded): the list of
            preceding TF nodes corresponding to the TEI sibling elements of the
            current TEI element.

## Keys and values of the `tei.yaml` file

### `generic`

dict, optional `{}`

Metadata for all generated TF features.
The actual source version of the TEI files does not have to be stated here,
it will be inserted based on the version that the converter will actually use.
That version depends on the `tei` argument passed to the program.
The key under which the source version will be inserted is `teiVersion`.

### `extra`

dict, optional `{}`

Instructions and metadata for specific generated TF features, namely those that
have not been generated by the vanilla TEI conversion, but by extra code in one
of the customised hooks.
The dict is keyed by feature name, the values are again dictionaries.
These value dictionaries have a key meta under which any number of metadata key value
pairs, such as `description=&#34;xxx&#34;`.

If you put the string «base» in such a field, it will be expanded on the
basis of the contents of the `path` key, see below.

You must provide the key `valueType` and pass `int` or `str` there, depending on the
values of the feature.
You may provide extra keys, such as `conversionMethod=&#34;derived&#34;`, so that other programs
can determine what to do with these features.
The information in this dict will also end up in the generated feature docs.

Besides the `meta` key, there may also be the keys `path`, and `nodeType`.
Together they contain an instruction to produce a feature value from element content
that can be found on the current stack of XML nodes and attributes.
The value found will be put in the feature in question
for the node of type specified in `nodeType` that is recently constructed.

Example:

``` yaml
extra:
  letterid:
    meta:
      description: The identifier of a letter; «base»
      valueType: str
      conversionMethod: derived
      conversionCode: tt
    path:
      - idno:
        type: letterId
      - altIdentifier
      - msIdentifier
      - msDesc
      - sourceDesc
    nodeType: letter
    feature: letterid
```

The meaning is:

*   if, while parsing the XML, I encounter an element `idno`,
*   and if that element has an attribute `type` with value `letterId`,
*   and if it has parent `altIdentifier`,
*   and grandparent `msIdentifier`,
*   and great-grandparent `msDesc`,
*   and great-great-grandparent `sourceDesc`,
*   then look up the last created node of type `letter`
*   and get the text content of the current XML node (the `idno` one),
*   and put it in the feature `letterid` for that node.
*   Moreover, the feature `letterid` gets metadata as specified under the key `meta`,
    where the `description` will be filled with the text

        The identifier of a letter; the content is taken from sourceDesc/msDesc/msIdentifier/altIdentifier/idno[type=letterId]

### `models`

list, optional `[]`

Which TEI-based schemas are to be used.
For each model there should be an XSD or RNG file with that name in the `schema`
directory. The `tei_all` schema is known to TF, no need to specify that one.

We&#39;ll try a RelaxNG schema (`.rng`) first. If that exists, we use it for validation
with JING, and we also convert it with TRANG to an XSD schema, which we use for
analysing the schema: we want to know which elements are mixed and pure.

If there is no RelaxNG schema, we try an XSD schema (`.xsd`). If that exists,
we can do the analysis, and we will use it also for validation.

!!! note &#34;Problems with RelaxNG validation&#34;
    RelaxNG validation is not always reliable when performed with LXML, or any tool
    based on `libxml`, for that matter. That&#39;s why we try to avoid it. Even if we
    translate the RelaxNG schema to an XSD schema by means of TRANG, the resulting
    validation is not always reliable. So we use JING to validate the RelaxNG schema.

See also [JING-TRANG](https://code.google.com/archive/p/jing-trang/downloads).

### `templates`

list, optional `[]`

Which template(s) are to be used.
A template is just a keyword, associated with an XML file, that can be used to switch
to a specific kind of processing, such as `letter`, `bibliolist`, `artworklist`.

You may specify an element or processing instruction with an attribute
that triggers the template for the file in which it is found.

This will be retrieved from the file before XML parsing starts.
For example,

``` python
    templateTrigger=&#34;?editem@template&#34;
```

will read the file and extract the value of the `template` attribute of the `editem`
processing instruction and use that as the template for this file.
If no template is found in this way, the empty template is assumed.

### `adaptations`

list, optional `[]`

Which adaptations(s) are to be used.
An adaptation is just a keyword, associated with an XML file, that can be used to switch
to a specific kind of processing.
It is meant to trigger tweaks on top of the behaviour of a template.

You may specify an element or processing instruction with an attribute
that triggers the adaptation for the file in which it is found.

This will be retrieved from the file before XML parsing starts.
For example,

``` python
    adaptationTrigger=&#34;?editem@adaptation&#34;
```

will read the file and extract the value of the `adaptation` attribute of the `editem`
processing instruction and use that as the adaptation for this file.
If no adaptation is found in this way, the empty adaptation is assumed.

### `prelim`

boolean, optional `True`

Whether to work with the `pre` TF versions.
Use this if you convert TEI to a preliminary TF dataset, which will
receive NLP additions later on. That version will then lose the `pre`.

### `granularity`

string, optional `token`

What to take the basic entities (slots). Possible values:

*   `word`: words are slots, even if they cross element boundaries. This leads to some
    imprecisions: words containing an element boundary will belong to just one
    of both elements around the boundary.
*   `char`: all individual characters are separate slots. Very precise, but the dataset
    gets expensive with so many slots.
*   `token`: every sequence of alphanumeric characters becomes a token, in sofar there
    is no intervening markup. Non alphanumeric characters become separate tokens.
    There are some additional rules: `.` or `,` tightly surrounded by digits also
    count as tokens.

The datasets with granularity `word` and `token` have features `str` for the string
content of the slots, and `after` for the material after the slots.
In the case of `word`, the feature `after` can contain whitespace and punctuation
characters, in the case of `token`, it only contains whitespace.

If not, the characters are taken as basic entities.

If you use an NLP pipeline to detect tokens, use the value `False`.
The preliminary dataset is then based on characters, but the final dataset that we build
from there is based on tokens, which are mostly words and non-word characters.

### `parentEdges`

boolean, optional `True`

Whether to create edges between nodes that correspond to XML elements and their parents.

### `siblingEdges`

boolean, optional `False`

Whether to create edges between nodes that correspond to XML elements and siblings.
Edges will be created between each sibling and its *preceding* siblings.
If you use these edges in the binary way, you can also find the following siblings.
The edges are labeled with the distance between the siblings, adjacent siblings
get distance 1.

!!! caution &#34;Overwhelming space requirement&#34;
    If the corpus is divided into relatively few elements that each have very many
    direct children, the number of sibling edges is comparable to the size of the
    corpus squared. That means that the TF dataset will consist for 50-99% of
    sibling edges!
    An example is [`ETCBC/nestle1904`](https://github.com/ETCBC/nestle1904) (Greek New
    Testament) where each book element has all of its sentences as direct children.
    In that dataset, the siblings would occupy 40% of the size, and we have taken care
    not to produce sibling edges for sentences.

### `procins`

boolean, optional `False`

If True, processing instructions will be treated.
Processing instruction `&lt;?foo bar=&#34;xxx&#34;?&gt;` will be converted as if it were an empty
element named `foo` with attribute `bar` with value `xxx`.


### `lineModel`

dict, optional `False`

If not passed, or an empty dict, line model I is assumed.
A line model must be specified with the parameters relevant for the
model:

``` python
dict(
    model=&#34;I&#34;,
)
```

(model I does not require any parameters)

or

``` python
dict(
    model=&#34;II&#34;,
    element=&#34;p&#34;,
    nodeType=&#34;ln&#34;,
)
```

For model II, the default parameters are:

``` python
element=&#34;p&#34;,
nodeType=&#34;ln&#34;,
```

Model I is the default, and nothing special happens to the `&lt;lb&gt;` elements.

In model II the `&lt;lb&gt;` elements translate to nodes of type `ln`, which span
content, whereas the original `lb` elements just mark positions.
Instead of `ln`, you can also specify another node type by the parameter `element`.

We assume that the material that the `&lt;lb&gt;` elements divide up is the material
that corresponds to their `&lt;p&gt;` parent element. Instead of `&lt;p&gt;`,
you can also specify another element in the parameter `element`.

We assume that lines start and end at the start and end of the `&lt;p&gt;` elements and
the `&lt;lb&gt;` elements. For the material etween these boundaries, we build `ln` nodes.
If an `&lt;lb&gt;` element follows a `&lt;p&gt;` start tag without intervening slots, a `ln`
node will be created but not linked to slots, and it will be deleted later in
the conversion.
Likewise, if an `&lt;lb&gt;` element is followed by a `&lt;p&gt;` end tag without
intervening slots, a `ln` node is created that is not linked to slots.

The attributes of the `&lt;lb&gt;` elements become features of the `ln` node that starts
with that `&lt;lb&gt;` element. If there is no explicit `&lt;lb&gt;` element at the start of
a paragraph, the first `ln` node of that paragraph gets no features.


### `pageModel`

dict, optional `False`

If not passed, or an empty dict, page model I is assumed.
A page model must be specified with the parameters relevant for the
model:

``` python
dict(
    model=&#34;I&#34;,
)
```

(model I does not require any parameters)

or

``` python
dict(
    model=&#34;II&#34;,
    element=&#34;div&#34;,
    attributes=dict(type=[&#34;original&#34;, &#34;translation&#34;]),
    pbAtTop=True,
    nodeType=&#34;page&#34;,
)
```

For model II, the default parameters are:

``` python
element=&#34;div&#34;,
pbAtTop=True,
nodeType=&#34;page&#34;,
attributes={},
```

Model I is the default, and nothing special happens to the `&lt;pb&gt;` elements.

In model II the `&lt;pb&gt;` elements translate to nodes of type `page`, which span
content, whereas the original `pb` elements just mark positions.
Instead of `page`, you can also specify another node type by the parameter `element`.

We assume that the material that the `&lt;pb&gt;` elements divide up is the material
that corresponds to their `&lt;div&gt;` parent element. Instead of `&lt;div&gt;`,
you can also specify another element in the parameter `element`.
If you want to restrict the parent elements of pages, you can do so by specifying
attributes, like `type=&#34;original&#34;`. Then only parents that carry those attributes
will be chopped up into pages.
You can specify multiple values for each attribute. Elements that carry one of these
values are candidates for having their content divided into pages.

We assume that the material to be divided starts with a `&lt;pb&gt;` (as the TEI-guidelines
prescribe) and we translate it to a page element that we close either at the
next `&lt;pb&gt;` or at the end of the `div`.

But if you specify `pbAtTop=False`, we assume that the `&lt;pb&gt;` marks the end of
the corresponding page element. We start the first page at the start of the enclosing
element. If there is material at between the last `&lt;pb&gt;` till the end of the enclosing
element, we generate an extra page node without features.


### `sectionModel`

dict, optional `{}`

If not passed, or an empty dict, section model I is assumed.
A section model must be specified with the parameters relevant for the
model:

``` python
dict(
    model=&#34;II&#34;,
    levels=[&#34;chapter&#34;, &#34;chunk&#34;],
    element=&#34;head&#34;,
    attributes=dict(rend=&#34;h3&#34;),
)
```

(model I does not require the *element* and *attribute* parameters)

or

``` python
dict(
    model=&#34;I&#34;,
    levels=[&#34;folder&#34;, &#34;file&#34;, &#34;chunk&#34;],
)
```

This section model (I) accepts a few other parameters:

``` python
    backMatter=&#34;backmatter&#34;
```

This is the name of the folder that should not be treated as an ordinary folder, but
as the folder with the sources for the back-matter, such as references, lists, indices,
bibliography, biographies, etc.

``` python
    drillDownDivs=True
```

Whether the chunks are the immediate children of `body` elements, or whether
we should drill through all intervening `div` levels.

For model II, the default parameters are:

``` python
element=&#34;head&#34;
levels=[&#34;chapter&#34;, &#34;chunk&#34;],
attributes={}
```

In model I, there are three section levels in total.
The corpus is divided in folders (section level 1), files (section level 2),
and chunks within files. The parameter `levels` allows you to choose names for the
node types of these section levels.

In model II, there are 2 section levels in total.
The corpus consists of a single file, and section nodes will be added
for nodes at various levels, mainly outermost `&lt;div&gt;` and `&lt;p&gt;` elements and their
siblings of other element types.
The section heading for the second level is taken from elements in the neighbourhood,
whose name is given in the parameter `element`, but only if they carry some attributes,
which can be specified in the `attributes` parameter.


# Usage

## Command-line

``` sh
tf-fromtei tasks flags
```

## From Python

``` python
from tf.convert.tei import TEI

T = TEI()
T.task(**tasks, **flags)
```

For a short overview the tasks and flags, see `HELP`.

## Tasks

We have the following conversion tasks:

1.  `check`: makes and inventory of all XML elements and attributes used.
1.  `convert`: produces actual TF files by converting XML files.
1.  `load`: loads the generated TF for the first time, by which the pre-computation
    step is triggered. During pre-computation some checks are performed. Once this
    has succeeded, we have a workable TF dataset.
1.  `app`: creates or updates a corpus specific TF app with minimal sensible settings,
    plus basic documentation.
1.  `apptoken`: updates a corpus specific TF app from a character-based dataset
    to a token-based dataset.
1.  `browse`: starts the TF browser on the newly created dataset.

Tasks can be run by passing any choice of task keywords to the
`TEI.task()` method.

## Note on versions

The TEI source files come in versions, indicated with a data.
The converter picks the most recent one, unless you specify an other one:

``` python
tf-from-tei tei=-2  # previous version
tf-from-tei tei=0  # first version
tf-from-tei tei=3  # third version
tf-from-tei tei=2019-12-23  # explicit version
```

The resulting TF data is independently versioned, like `1.2.3` or `1.2.3pre`.
When the converter runs, by default it overwrites the most recent version,
unless you specify another one.

It looks at the latest version and then bumps a part of the version number.

``` python
tf-fromtei tf=3  # minor version, 1.2.3 becomes 1.2.4; 1.2.3pre becomes 1.2.4pre
tf-fromtei tf=2  # intermediate version, 1.2.3 becomes 1.3.0
tf-fromtei tf=1  # major version, 1.2.3 becomes 2.0.0
tf-fromtei tf=1.8.3  # explicit version
```

## Examples

Exactly how you can call the methods of this module is demonstrated in the small
corpus of 14 letter by the Dutch artist Piet Mondriaan.

*   [Mondriaan](https://nbviewer.org/github/annotation/mondriaan/blob/master/programs/convertExpress.ipynb).
&#34;&#34;&#34;

import sys
import collections
import re
from textwrap import dedent, wrap
from io import BytesIO
from subprocess import run
from importlib import util

from ..capable import CheckImport
from .helpers import (
    setUp,
    tweakTrans,
    checkModel,
    matchModel,
    lookupSource,
    tokenize,
    getWhites,
    NODE,
    FILE,
    PAGE,
    LINE,
    PRE,
    ZWSP,
    XNEST,
    TNEST,
    TSIB,
    WORD,
    TOKEN,
    T,
    CHAR,
    CONVERSION_METHODS,
    CM_LIT,
    CM_LITP,
    CM_LITC,
    CM_PROV,
)
from ..parameters import BRANCH_DEFAULT_NEW
from ..fabric import Fabric
from ..core.helpers import console, versionSort, mergeDict
from ..convert.walker import CV
from ..core.timestamp import AUTO, DEEP, TERSE
from ..core.command import readArgs
from ..core.files import (
    fileOpen,
    abspath,
    expanduser as ex,
    unexpanduser as ux,
    getLocation,
    initTree,
    fileNm,
    dirNm,
    dirExists,
    dirContents,
    fileExists,
    fileCopy,
    scanDir,
    readYaml,
    writeYaml,
)

from ..tools.xmlschema import Analysis


(HELP, TASKS, TASKS_EXCLUDED, PARAMS, FLAGS) = setUp(&#34;TEI&#34;)

CSS_REND = dict(
    h1=(
        &#34;heading of level 1&#34;,
        dedent(
            &#34;&#34;&#34;
        font-size: xx-large;
        font-weight: bold;
        margin-top: 3rem;
        margin-bottom: 1rem;
        &#34;&#34;&#34;
        ),
    ),
    h2=(
        &#34;heading of level 2&#34;,
        dedent(
            &#34;&#34;&#34;
        font-size: x-large;
        font-weight: bold;
        margin-top: 2rem;
        margin-bottom: 1rem;
        &#34;&#34;&#34;
        ),
    ),
    h3=(
        &#34;heading of level 3&#34;,
        dedent(
            &#34;&#34;&#34;
        font-size: large;
        font-weight: bold;
        margin-top: 1rem;
        margin-bottom: 0.5rem;
        &#34;&#34;&#34;
        ),
    ),
    h4=(
        &#34;heading of level 4&#34;,
        dedent(
            &#34;&#34;&#34;
        font-size: large;
        font-style: italic;
        margin-top: 1rem;
        margin-bottom: 0.5rem;
        &#34;&#34;&#34;
        ),
    ),
    h5=(
        &#34;heading of level 5&#34;,
        dedent(
            &#34;&#34;&#34;
        font-size: medium;
        font-weight: bold;
        font-variant: small-caps;
        margin-top: 0.5rem;
        margin-bottom: 0.25rem;
        &#34;&#34;&#34;
        ),
    ),
    h6=(
        &#34;heading of level 6&#34;,
        dedent(
            &#34;&#34;&#34;
        font-size: medium;
        font-weight: normal;
        font-variant: small-caps;
        margin-top: 0.25rem;
        margin-bottom: 0.125rem;
        &#34;&#34;&#34;
        ),
    ),
    italic=(
        &#34;cursive font style&#34;,
        dedent(
            &#34;&#34;&#34;
        font-style: italic;
        &#34;&#34;&#34;
        ),
    ),
    bold=(
        &#34;bold font weight&#34;,
        dedent(
            &#34;&#34;&#34;
        font-weight: bold;
        &#34;&#34;&#34;
        ),
    ),
    underline=(
        &#34;underlined text&#34;,
        dedent(
            &#34;&#34;&#34;
        text-decoration: underline;
        &#34;&#34;&#34;
        ),
    ),
    center=(
        &#34;horizontally centered text&#34;,
        dedent(
            &#34;&#34;&#34;
        text-align: center;
        &#34;&#34;&#34;
        ),
    ),
    large=(
        &#34;large font size&#34;,
        dedent(
            &#34;&#34;&#34;
        font-size: large;
        &#34;&#34;&#34;
        ),
    ),
    spaced=(
        &#34;widely spaced between characters&#34;,
        dedent(
            &#34;&#34;&#34;
        letter-spacing: .2rem;
        &#34;&#34;&#34;
        ),
    ),
    margin=(
        &#34;in the margin&#34;,
        dedent(
            &#34;&#34;&#34;
        position: relative;
        top: -0.3em;
        font-weight: bold;
        color: #0000ee;
        &#34;&#34;&#34;
        ),
    ),
    above=(
        &#34;above the line&#34;,
        dedent(
            &#34;&#34;&#34;
        position: relative;
        top: -0.3em;
        &#34;&#34;&#34;
        ),
    ),
    below=(
        &#34;below the line&#34;,
        dedent(
            &#34;&#34;&#34;
        position: relative;
        top: 0.3em;
        &#34;&#34;&#34;
        ),
    ),
    small_caps=(
        &#34;small-caps font variation&#34;,
        dedent(
            &#34;&#34;&#34;
        font-variant: small-caps;
        &#34;&#34;&#34;
        ),
    ),
    sub=(
        &#34;as subscript&#34;,
        dedent(
            &#34;&#34;&#34;
        vertical-align: sub;
        font-size: small;
        &#34;&#34;&#34;
        ),
    ),
    super=(
        &#34;as superscript&#34;,
        dedent(
            &#34;&#34;&#34;
        vertical-align: super;
        font-size: small;
        &#34;&#34;&#34;
        ),
    ),
)
CSS_REND_ALIAS = dict(
    italic=&#34;italics i&#34;,
    bold=&#34;b&#34;,
    underline=&#34;ul&#34;,
    spaced=&#34;spat&#34;,
    small_caps=&#34;smallcaps sc&#34;,
    super=&#34;sup&#34;,
)


PROGRESS_LIMIT = 5
KNOWN_RENDS = set()
REND_DESC = {}


REFERENCING = dict(
    ptr=&#34;target&#34;,
    ref=&#34;target&#34;,
    rs=&#34;ref&#34;,
)


def makeCssInfo():
    &#34;&#34;&#34;Make the CSS info for the style sheet.&#34;&#34;&#34;
    rends = &#34;&#34;

    for rend, (description, css) in sorted(CSS_REND.items()):
        aliases = CSS_REND_ALIAS.get(rend, &#34;&#34;)
        aliases = sorted(set(aliases.split()) | {rend})
        for alias in aliases:
            KNOWN_RENDS.add(alias)
            REND_DESC[alias] = description
        selector = &#34;,&#34;.join(f&#34;.r_{alias}&#34; for alias in aliases)
        contribution = f&#34;\n{selector} {{{css}}}\n&#34;
        rends += contribution

    return rends


def getRefs(tag, atts, xmlFile):
    refAtt = REFERENCING.get(tag, None)
    result = []

    if refAtt is not None:
        refVal = atts.get(refAtt, None)
        if refVal is not None and not refVal.startswith(&#34;http&#34;):
            for refv in refVal.split():
                parts = refv.split(&#34;#&#34;, 1)
                if len(parts) == 1:
                    targetFile = refv
                    targetId = &#34;&#34;
                else:
                    (targetFile, targetId) = parts
                if targetFile == &#34;&#34;:
                    targetFile = xmlFile
                result.append((refAtt, targetFile, targetId))
    return result


class TEI(CheckImport):
    def __init__(
        self,
        tei=PARAMS[&#34;tei&#34;][1],
        tf=PARAMS[&#34;tf&#34;][1],
        validate=PARAMS[&#34;validate&#34;][1],
        verbose=FLAGS[&#34;verbose&#34;][1],
    ):
        &#34;&#34;&#34;Converts TEI to TF.

        For documentation of the resulting encoding, read the
        [transcription template](https://github.com/annotation/text-fabric/blob/master/tf/convert/app/transcription.md).

        Below we describe how to control the conversion machinery.

        We adopt a fair bit of &#34;convention over configuration&#34; here, in order to lessen
        the burden for the user of specifying so many details.

        Based on current directory from where the script is called,
        it defines all the ingredients to carry out
        a `tf.convert.walker` conversion of the TEI input.

        This function is assumed to work in the context of a repository,
        i.e. a directory on your computer relative to which the input directory exists,
        and various output directories: `tf`, `app`, `docs`.

        Your current directory must be at

        ```
        ~/backend/org/repo/relative
        ```

        where

        *   `~` is your home directory;
        *   `backend` is an online back-end name,
            like `github`, `gitlab`, `git.huc.knaw.nl`;
        *   `org` is an organization, person, or group in the back-end;
        *   `repo` is a repository in the `org`.
        *   `relative` is a directory path within the repo (0 or more components)

        This is only about the directory structure on your local computer;
        it is not required that you have online incarnations of your repository
        in that back-end.
        Even your local repository does not have to be a git repository.

        The only thing that matters is that the full path to your repo can be parsed
        as a sequence of `home/backend/org/repo/relative`.

        Relative to this directory the program expects and creates
        input / output directories.

        ## Input directories

        ### `tei`

        *Location of the TEI-XML sources.*

        **If it does not exist, the program aborts with an error.**

        Several levels of subdirectories are assumed:

        1.  the version of the source (this could be a date string).
        1.  volumes / collections of documents. The subdirectory `__ignore__` is ignored.
        1.  the TEI documents themselves, conforming to the TEI schema or some
            customization of it.

        ### `schema`

        *TEI or other XML schemas against which the sources can be validated.*

        They should be XSD or RNG files.

        !!! note &#34;Multiple XSD files&#34;
            When you started with a RNG file and used `tf.tools.xmlschema` to
            convert it to XSD, you may have got multiple XSD files.
            One of them has the same base name as the original RNG file,
            and you should pass that name. It will import the remaining XSD files,
            so do not throw them away.

        We use these files as custom TEI schemas,
        but to be sure, we still analyse the full TEI schema and
        use the schemas here as a set of overriding element definitions.

        ## Output directories

        ### `report`

        Directory to write the results of the `check` task to: an inventory
        of elements / attributes encountered, and possible validation errors.
        If the directory does not exist, it will be created.
        The default value is `.` (i.e. the current directory in which
        the script is invoked).

        ### `tf`

        The directory under which the TF output file (with extension `.tf`)
        are placed.
        If it does not exist, it will be created.
        The TF files will be generated in a folder named by a version number,
        passed as `tfVersion`.

        ### `app` and `docs`

        Location of additional TF app configuration and documentation files.
        If they do not exist, they will be created with some sensible default
        settings and generated documentation.
        These settings can be overridden in the `app/config_custom.yaml` file.
        Also a default `display.css` file and a logo are added.

        Custom content for these files can be provided in files
        with `_custom` appended to their base name.

        ### `docs`

        Location of additional documentation.
        This can be generated or hand-written material, or a mixture of the two.

        Parameters
        ----------
        tei: string, optional &#34;&#34;
            If empty, use the latest version under the `tei` directory with sources.
            Otherwise it should be a valid integer, and it is the index in the
            sorted list of versions there.

            *   `0` or `latest`: latest version;
            *   `-1`, `-2`, ... : previous version, version before previous, ...;
            *   `1`, `2`, ...: first version, second version, ....
            *   everything else that is not a number is an explicit version

            If the value cannot be parsed as an integer, it is used as the exact
            version name.

        tf: string, optional &#34;&#34;
            If empty, the TF version used will be the latest one under the `tf`
            directory. If the parameter `prelim` was used in the initialization of
            the TEI object, only versions ending in `pre` will be taken into account.

            If it can be parsed as the integers 1, 2, or 3 it will bump the latest
            relevant TF version:

            *   `0` or `latest`: overwrite the latest version
            *   `1` will bump the major version
            *   `2` will bump the intermediate version
            *   `3` will bump the minor version
            *   everything else is an explicit version

            Otherwise, the value is taken as the exact version name.

        verbose: integer, optional -1
            Produce no (-1), some (0) or many (1) progress and reporting messages

        &#34;&#34;&#34;
        super().__init__(&#34;lxml&#34;)
        if self.importOK(hint=True):
            self.etree = self.importGet()
        else:
            return

        self.good = True

        (backend, org, repo, relative) = getLocation()

        if any(s is None for s in (backend, org, repo, relative)):
            console(
                (
                    &#34;Not working in a repo: &#34;
                    f&#34;backend={backend} org={org} repo={repo} relative={relative}&#34;
                ),
                error=True,
            )
            self.good = False
            return

        if verbose == 1:
            console(
                f&#34;Working in repository {org}/{repo}{relative} in back-end {backend}&#34;
            )

        base = ex(f&#34;~/{backend}&#34;)
        repoDir = f&#34;{base}/{org}/{repo}&#34;
        refDir = f&#34;{repoDir}{relative}&#34;
        programDir = f&#34;{refDir}/programs&#34;
        schemaDir = f&#34;{refDir}/schema&#34;
        convertSpec = f&#34;{programDir}/tei.yaml&#34;
        convertCustom = f&#34;{programDir}/tei.py&#34;

        self.schemaDir = schemaDir

        settings = readYaml(asFile=convertSpec, plain=True)

        customKeys = set(
            &#34;&#34;&#34;
            transform
            beforeTag
            beforeChildren
            afterChildren
            afterTag
        &#34;&#34;&#34;.strip().split()
        )

        functionType = type(lambda x: x)

        if fileExists(convertCustom):
            hooked = []

            try:
                spec = util.spec_from_file_location(&#34;teicustom&#34;, convertCustom)
                code = util.module_from_spec(spec)
                sys.path.insert(0, dirNm(convertCustom))
                spec.loader.exec_module(code)
                sys.path.pop(0)
                for method in customKeys:
                    if not hasattr(code, method):
                        continue

                    func = getattr(code, method)
                    typeFunc = type(func)
                    if typeFunc is not functionType:
                        console(
                            (
                                f&#34;custom member {method} should be a function, &#34;
                                f&#34;but it is a {typeFunc.__name__}&#34;
                            ),
                            error=True,
                        )
                        continue

                    methodC = f&#34;{method}Custom&#34;
                    setattr(self, methodC, func)
                    hooked.append(method)

            except Exception as e:
                console(str(e), error=True)
                for method in customKeys:
                    if not hasattr(self, method):
                        methodC = f&#34;{method}Custom&#34;
                        setattr(self, methodC, None)

            if verbose &gt;= 0:
                console(&#34;With custom behaviour hooked in at:&#34;)
                for method in hooked:
                    methodC = f&#34;{method}Custom&#34;
                    console(f&#34;\t{methodC} = {ux(convertCustom)}.{method}&#34;)

        generic = settings.get(&#34;generic&#34;, {})
        extra = settings.get(&#34;extra&#34;, {})
        models = settings.get(&#34;models&#34;, [])
        templates = settings.get(&#34;templates&#34;, [])
        templateTrigger = settings.get(&#34;templateTrigger&#34;, None)
        adaptations = settings.get(&#34;adaptations&#34;, [])
        adaptationTrigger = settings.get(&#34;adaptationTrigger&#34;, None)
        prelim = settings.get(&#34;prelim&#34;, True)
        granularity = settings.get(&#34;granularity&#34;, TOKEN)
        wordAsSlot = granularity == WORD
        tokenAsSlot = granularity == TOKEN
        charAsSlot = granularity == CHAR
        parentEdges = settings.get(&#34;parentEdges&#34;, True)
        siblingEdges = settings.get(&#34;siblingEdges&#34;, True)
        procins = settings.get(&#34;procins&#34;, False)

        lineModel = settings.get(&#34;lineModel&#34;, {})
        lineModel = checkModel(LINE, lineModel, verbose)

        if not lineModel:
            self.good = False
            return

        makeLineElems = lineModel[&#34;model&#34;] == &#34;II&#34;
        lineProperties = lineModel.get(&#34;properties&#34;, None)
        lineModel = lineModel[&#34;model&#34;]

        self.makeLineElems = makeLineElems
        self.lineModel = lineModel
        self.lineProperties = lineProperties

        pageModel = settings.get(&#34;pageModel&#34;, {})
        pageModel = checkModel(PAGE, pageModel, verbose)

        if not pageModel:
            self.good = False
            return

        makePageElems = pageModel[&#34;model&#34;] == &#34;II&#34;
        pageProperties = pageModel.get(&#34;properties&#34;, None)
        pageModel = pageModel[&#34;model&#34;]

        self.makePageElems = makePageElems
        self.pageModel = pageModel
        self.pageProperties = pageProperties

        sectionModel = settings.get(&#34;sectionModel&#34;, {})
        sectionModel = checkModel(&#34;section&#34;, sectionModel, verbose)
        if not sectionModel:
            self.good = False
            return

        sectionProperties = sectionModel.get(&#34;properties&#34;, None)
        sectionModel = sectionModel[&#34;model&#34;]
        self.sectionModel = sectionModel
        self.sectionProperties = sectionProperties

        self.generic = generic
        self.extra = extra
        self.models = models
        self.templates = templates
        self.adaptations = adaptations

        if templateTrigger is None:
            self.templateAtt = None
            self.templateTag = None
        else:
            (tag, att) = templateTrigger.split(&#34;@&#34;)
            self.templateAtt = att
            self.templateTag = tag

        if adaptationTrigger is None:
            self.adaptationAtt = None
            self.adaptationTag = None
        else:
            (tag, att) = adaptationTrigger.split(&#34;@&#34;)
            self.adaptationAtt = att
            self.adaptationTag = tag

        templateTag = self.templateTag
        templateAtt = self.templateAtt
        adaptationTag = self.adaptationTag
        adaptationAtt = self.adaptationAtt

        triggers = {}
        self.triggers = triggers

        for kind, theAtt, theTag in (
            (&#34;template&#34;, templateAtt, templateTag),
            (&#34;adaptation&#34;, adaptationAtt, adaptationTag),
        ):
            triggerRe = None

            if theAtt is not None and theTag is not None:
                tagPat = re.escape(theTag)
                triggerRe = re.compile(
                    rf&#34;&#34;&#34;&lt;{tagPat}\b[^&gt;]*?{theAtt}=[&#39;&#34;]([^&#39;&#34;]+)[&#39;&#34;]&#34;&#34;&#34;
                )
            triggers[kind] = triggerRe

        self.A = Analysis(verbose=verbose)
        self.readSchemas()

        self.prelim = prelim
        self.wordAsSlot = wordAsSlot
        self.tokenAsSlot = tokenAsSlot
        self.charAsSlot = charAsSlot
        self.parentEdges = parentEdges
        self.siblingEdges = siblingEdges
        self.procins = procins

        reportDir = f&#34;{refDir}/report&#34;
        appDir = f&#34;{refDir}/app&#34;
        docsDir = f&#34;{refDir}/docs&#34;
        teiDir = f&#34;{refDir}/tei&#34;
        tfDir = f&#34;{refDir}/tf&#34;

        teiVersions = sorted(dirContents(teiDir)[1], key=versionSort)
        nTeiVersions = len(teiVersions)

        if tei in {&#34;latest&#34;, &#34;&#34;, &#34;0&#34;, 0} or str(tei).lstrip(&#34;-&#34;).isdecimal():
            teiIndex = (0 if tei == &#34;latest&#34; else int(tei)) - 1

            try:
                teiVersion = teiVersions[teiIndex]
            except Exception:
                absIndex = teiIndex + (nTeiVersions if teiIndex &lt; 0 else 0) + 1
                console(
                    (
                        f&#34;no item in {absIndex} in {nTeiVersions} source versions &#34;
                        f&#34;in {ux(teiDir)}&#34;
                    )
                    if len(teiVersions)
                    else f&#34;no source versions in {ux(teiDir)}&#34;,
                    error=True,
                )
                self.good = False
                return
        else:
            teiVersion = tei

        teiPath = f&#34;{teiDir}/{teiVersion}&#34;
        reportPath = f&#34;{reportDir}/{teiVersion}&#34;

        if not dirExists(teiPath):
            console(
                f&#34;source version {teiVersion} does not exists in {ux(teiDir)}&#34;,
                error=True,
            )
            self.good = False
            return

        teiStatuses = {tv: i for (i, tv) in enumerate(reversed(teiVersions))}
        teiStatus = teiStatuses[teiVersion]
        teiStatusRep = (
            &#34;most recent&#34;
            if teiStatus == 0
            else &#34;previous&#34;
            if teiStatus == 1
            else f&#34;{teiStatus - 1} before previous&#34;
        )
        if teiStatus == len(teiVersions) - 1 and len(teiVersions) &gt; 1:
            teiStatusRep = &#34;oldest&#34;

        if verbose &gt;= 0:
            console(f&#34;TEI data version is {teiVersion} ({teiStatusRep})&#34;)

        tfVersions = sorted(dirContents(tfDir)[1], key=versionSort)
        if prelim:
            tfVersions = [tv for tv in tfVersions if tv.endswith(PRE)]

        latestTfVersion = (
            tfVersions[-1] if len(tfVersions) else (&#34;0.0.0&#34; + (PRE if prelim else &#34;&#34;))
        )
        if tf in {&#34;latest&#34;, &#34;&#34;, &#34;0&#34;, 0}:
            tfVersion = latestTfVersion
            vRep = &#34;latest&#34;
        elif tf in {&#34;1&#34;, &#34;2&#34;, &#34;3&#34;, 1, 2, 3}:
            bump = int(tf)
            parts = latestTfVersion.split(&#34;.&#34;)

            def getVer(b):
                return (
                    int(parts[b].removesuffix(PRE))
                    if prelim and b == len(parts) - 1
                    else int(parts[b])
                )

            def setVer(b, val):
                parts[b] = f&#34;{val}{PRE}&#34; if prelim and b == len(parts) - 1 else f&#34;{val}&#34;

            if bump &gt; len(parts):
                console(
                    f&#34;Cannot bump part {bump} of latest TF version {latestTfVersion}&#34;,
                    error=True,
                )
                self.good = False
                return
            else:
                b1 = bump - 1
                old = getVer(b1)
                setVer(b1, old + 1)
                for b in range(b1 + 1, len(parts)):
                    setVer(b, 0)
                tfVersion = &#34;.&#34;.join(str(p) for p in parts)
                vRep = (
                    &#34;major&#34; if bump == 1 else &#34;intermediate&#34; if bump == 2 else &#34;minor&#34;
                )
                vRep = f&#34;next {vRep}&#34;
        else:
            tfVersion = tf
            status = &#34;existing&#34; if dirExists(f&#34;{tfDir}/{tfVersion}&#34;) else &#34;new&#34;
            vRep = f&#34;explicit {status}&#34;

        tfPath = f&#34;{tfDir}/{tfVersion}&#34;

        if verbose &gt;= 0:
            console(f&#34;TF data version is {tfVersion} ({vRep})&#34;)
            console(
                f&#34;Processing instructions are {&#39;treated&#39; if procins else &#39;ignored&#39;}&#34;
            )

        self.refDir = refDir
        self.teiVersion = teiVersion
        self.teiPath = teiPath
        self.tfVersion = tfVersion
        self.tfPath = tfPath
        self.reportPath = reportPath
        self.tfDir = tfDir
        self.appDir = appDir
        self.docsDir = docsDir
        self.backend = backend
        self.org = org
        self.repo = repo
        self.relative = relative

        levelNames = sectionProperties[&#34;levels&#34;]
        self.levelNames = levelNames
        self.chunkLevel = levelNames[-1]

        if sectionModel == &#34;II&#34;:
            self.chapterSection = levelNames[0]
            self.chunkSection = levelNames[1]
        else:
            self.folderSection = levelNames[0]
            self.fileSection = levelNames[1]
            self.chunkSection = levelNames[2]
            self.backMatter = sectionProperties.get(&#34;backMatter&#34;, None)

        chunkSection = self.chunkSection
        intFeatures = {&#34;empty&#34;, chunkSection}
        self.intFeatures = intFeatures

        if siblingEdges:
            intFeatures.add(&#34;sibling&#34;)

        slotType = WORD if wordAsSlot else T if tokenAsSlot else CHAR
        self.slotType = slotType

        sectionFeatures = &#34;,&#34;.join(levelNames)
        sectionTypes = &#34;,&#34;.join(levelNames)

        textFeatures = &#34;{ch}&#34; if charAsSlot else &#34;{str}{after}&#34;
        otext = {
            &#34;fmt:text-orig-full&#34;: textFeatures,
            &#34;sectionFeatures&#34;: sectionFeatures,
            &#34;sectionTypes&#34;: sectionTypes,
        }
        self.otext = otext

        featureMeta = dict(
            str=dict(
                description=&#34;the text of a word or token&#34;,
                conversionMethod=CM_LITC,
                conversionCode=CONVERSION_METHODS[CM_LITC],
            ),
            after=dict(
                description=&#34;the text after a word till the next word&#34;,
                conversionMethod=CM_LITC,
                conversionCode=CONVERSION_METHODS[CM_LITC],
            ),
            empty=dict(
                description=&#34;whether a slot has been inserted in an empty element&#34;,
                conversionMethod=CM_PROV,
                conversionCode=CONVERSION_METHODS[CM_PROV],
            ),
            is_meta=dict(
                description=&#34;whether a slot or word is in the teiHeader element&#34;,
                conversionMethod=CM_LITC,
                conversionCode=CONVERSION_METHODS[CM_LITC],
            ),
            is_note=dict(
                description=&#34;whether a slot or word is in the note element&#34;,
                conversionMethod=CM_LITC,
                conversionCode=CONVERSION_METHODS[CM_LITC],
            ),
        )
        if charAsSlot:
            featureMeta[&#34;extraspace&#34;] = dict(
                description=(
                    &#34;whether a space has been added after a character, &#34;
                    &#34;when it is in the direct child of a pure XML element&#34;
                ),
                conversionMethod=CM_LITP,
                conversionCode=CONVERSION_METHODS[CM_LITP],
            )
            featureMeta[&#34;ch&#34;] = dict(
                description=&#34;the UNICODE character of a slot&#34;,
                conversionMethod=CM_LITC,
                conversionCode=CONVERSION_METHODS[CM_LITC],
            )
        if parentEdges:
            featureMeta[&#34;parent&#34;] = dict(
                description=&#34;edge between a node and its parent node&#34;,
                conversionMethod=CM_LITP,
                conversionCode=CONVERSION_METHODS[CM_LITP],
            )
        if siblingEdges:
            featureMeta[&#34;sibling&#34;] = dict(
                description=(
                    &#34;edge between a node and its preceding sibling nodes; &#34;
                    &#34;labeled with the distance between them&#34;
                ),
                conversionMethod=CM_LITP,
                conversionCode=CONVERSION_METHODS[CM_LITP],
            )
        featureMeta[chunkSection] = dict(
            description=f&#34;number of a {chunkSection} within a document&#34;,
            conversionMethod=CM_PROV,
            conversionCode=CONVERSION_METHODS[CM_PROV],
        )

        if sectionModel == &#34;II&#34;:
            chapterSection = self.chapterSection
            featureMeta[chapterSection] = dict(
                description=f&#34;name of {chapterSection}&#34;,
                conversionMethod=CM_PROV,
                conversionCode=CONVERSION_METHODS[CM_PROV],
            )
        else:
            folderSection = self.folderSection
            fileSection = self.fileSection
            featureMeta[folderSection] = dict(
                description=f&#34;name of source {folderSection}&#34;,
                conversionMethod=CM_PROV,
                conversionCode=CONVERSION_METHODS[CM_PROV],
            )
            featureMeta[fileSection] = dict(
                description=f&#34;name of source {fileSection}&#34;,
                conversionMethod=CM_PROV,
                conversionCode=CONVERSION_METHODS[CM_PROV],
            )

        self.featureMeta = featureMeta

        generic[&#34;sourceFormat&#34;] = &#34;TEI&#34;
        generic[&#34;version&#34;] = tfVersion
        generic[&#34;teiVersion&#34;] = teiVersion
        generic[&#34;schema&#34;] = &#34;TEI&#34; + (&#34; + &#34; + (&#34; + &#34;.join(models))) if models else &#34;&#34;

        extraInstructions = []

        for feat, featSpecs in extra.items():
            featMeta = featSpecs.get(&#34;meta&#34;, {})
            if &#34;valueType&#34; in featMeta:
                if featMeta[&#34;valueType&#34;] == &#34;int&#34;:
                    intFeatures.add(feat)
                del featMeta[&#34;valueType&#34;]

            featPath = featSpecs.get(&#34;path&#34;, None)
            featPathRep = &#34;&#34; if featPath is None else &#34;the content is taken from &#34;
            featPathLogical = []

            sep = &#34;&#34;
            for comp in reversed(featPath or []):
                if type(comp) is str:
                    featPathRep += f&#34;{sep}{comp}&#34;
                    featPathLogical.append((comp, None))
                else:
                    for tag, atts in comp.items():
                        # there is only one item in this dict
                        featPathRep += f&#34;{sep}{tag}[&#34;
                        featPathRep += &#34;,&#34;.join(
                            f&#34;{att}={v}&#34; for (att, v) in sorted(atts.items())
                        )
                        featPathRep += &#34;]&#34;
                        featPathLogical.append((tag, atts))
                sep = &#34;/&#34;

            featureMeta[feat] = {
                k: v.replace(&#34;«base»&#34;, featPathRep) for (k, v) in featMeta.items()
            }
            nodeType = featSpecs.get(&#34;nodeType&#34;, None)
            if nodeType is not None and featPath:
                extraInstructions.append(
                    (list(reversed(featPathLogical)), nodeType, feat)
                )

        self.extraInstructions = tuple(extraInstructions)

        self.verbose = verbose
        self.validate = validate
        myDir = dirNm(abspath(__file__))
        self.myDir = myDir

    def readSchemas(self):
        schemaDir = self.schemaDir
        models = self.models
        A = self.A

        schemaFiles = dict(rng={}, xsd={})
        self.schemaFiles = schemaFiles
        modelInfo = {}
        self.modelInfo = modelInfo
        modelXsd = {}
        self.modelXsd = modelXsd
        modelInv = {}
        self.modelInv = modelInv

        for model in [None] + models:
            for kind in (&#34;rng&#34;, &#34;xsd&#34;):
                schemaFile = (
                    A.getBaseSchema()[kind]
                    if model is None
                    else f&#34;{schemaDir}/{model}.{kind}&#34;
                )
                if fileExists(schemaFile):
                    schemaFiles[kind][model] = schemaFile
                    if (
                        kind == &#34;rng&#34;
                        or kind == &#34;xsd&#34;
                        and model not in schemaFiles[&#34;rng&#34;]
                    ):
                        modelInfo[model] = schemaFile
            if model in schemaFiles[&#34;rng&#34;] and model not in schemaFiles[&#34;xsd&#34;]:
                schemaFileXsd = f&#34;{schemaDir}/{model}.xsd&#34;
                A.fromrelax(schemaFiles[&#34;rng&#34;][model], schemaFileXsd)
                schemaFiles[&#34;xsd&#34;][model] = schemaFileXsd

        baseSchema = schemaFiles[&#34;xsd&#34;][None]
        modelXsd[None] = baseSchema
        modelInv[(baseSchema, None)] = None

        for model in models:
            override = schemaFiles[&#34;xsd&#34;][model]
            modelXsd[model] = override
            modelInv[(baseSchema, override)] = model

    def getSwitches(self, xmlPath):
        verbose = self.verbose
        models = self.models
        adaptations = self.adaptations
        templates = self.templates
        triggers = self.triggers
        A = self.A

        text = None

        found = {}

        for kind, allOfKind in (
            (&#34;model&#34;, models),
            (&#34;adaptation&#34;, adaptations),
            (&#34;template&#34;, templates),
        ):
            if text is None:
                with fileOpen(xmlPath) as fh:
                    text = fh.read()

            found[kind] = None

            if kind == &#34;model&#34;:
                result = A.getModel(text)
                if result is None or result == &#34;tei_all&#34;:
                    result = None
            else:
                result = None
                triggerRe = triggers[kind]
                if triggerRe is not None:
                    match = triggerRe.search(text)
                    result = match.group(1) if match else None

            if result is not None and result not in allOfKind:
                if verbose &gt;= 0:
                    console(f&#34;unavailable {kind} {result} in {ux(xmlPath)}&#34;)
                result = None
            found[kind] = result

        return (found[&#34;model&#34;], found[&#34;adaptation&#34;], found[&#34;template&#34;])

    def getParser(self):
        &#34;&#34;&#34;Configure the LXML parser.

        See [parser options](https://lxml.de/parsing.html#parser-options).

        Returns
        -------
        object
            A configured LXML parse object.
        &#34;&#34;&#34;
        if not self.importOK():
            return None

        etree = self.etree
        procins = self.procins

        return etree.XMLParser(
            remove_blank_text=False,
            collect_ids=False,
            remove_comments=True,
            remove_pis=not procins,
            huge_tree=True,
        )

    def getXML(self):
        &#34;&#34;&#34;Make an inventory of the TEI source files.

        Returns
        -------
        tuple of tuple | string
            If section model I is in force:

            The outer tuple has sorted entries corresponding to folders under the
            TEI input directory.
            Each such entry consists of the folder name and an inner tuple
            that contains the file names in that folder, sorted.

            If section model II is in force:

            It is the name of the single XML file.
        &#34;&#34;&#34;
        verbose = self.verbose
        teiPath = self.teiPath
        sectionModel = self.sectionModel
        if verbose == 1:
            console(f&#34;Section model {sectionModel}&#34;)

        if sectionModel == &#34;I&#34;:
            backMatter = self.backMatter

            IGNORE = &#34;__ignore__&#34;

            xmlFilesRaw = collections.defaultdict(list)

            with scanDir(teiPath) as dh:
                for folder in dh:
                    folderName = folder.name
                    if folderName == IGNORE:
                        continue
                    if not folder.is_dir():
                        continue
                    with scanDir(f&#34;{teiPath}/{folderName}&#34;) as fh:
                        for file in fh:
                            fileName = file.name
                            if not (
                                fileName.lower().endswith(&#34;.xml&#34;) and file.is_file()
                            ):
                                continue
                            xmlFilesRaw[folderName].append(fileName)

            xmlFiles = []
            hasBackMatter = False

            for folderName in sorted(xmlFilesRaw, key=versionSort):
                if folderName == backMatter:
                    hasBackMatter = True
                else:
                    fileNames = xmlFilesRaw[folderName]
                    xmlFiles.append((folderName, tuple(sorted(fileNames))))

            if hasBackMatter:
                fileNames = xmlFilesRaw[backMatter]
                xmlFiles.append((backMatter, tuple(sorted(fileNames))))

            xmlFiles = tuple(xmlFiles)

            return xmlFiles

        if sectionModel == &#34;II&#34;:
            xmlFile = None
            with scanDir(teiPath) as fh:
                for file in fh:
                    fileName = file.name
                    if not (fileName.lower().endswith(&#34;.xml&#34;) and file.is_file()):
                        continue
                    xmlFile = fileName
                    break
            return xmlFile

    def checkTask(self):
        &#34;&#34;&#34;Implementation of the &#34;check&#34; task.

        It validates the TEI, but only if a schema file has been passed explicitly
        when constructing the `TEI()` object.

        Then it makes an inventory of all elements and attributes in the TEI files.

        If tags are used in multiple namespaces, it will be reported.

        !!! caution &#34;Conflation of namespaces&#34;
            The TEI to TF conversion does construct node types and attributes
            without taking namespaces into account.
            However, the parsing process is namespace aware.

        The inventory lists all elements and attributes, and many attribute values.
        But is represents any digit with `n`, and some attributes that contain
        ids or keywords, are reduced to the value `x`.

        This information reduction helps to get a clear overview.

        It writes reports to the `reportPath`:

        *   `errors.txt`: validation errors
        *   `elements.txt`: element / attribute inventory.
        &#34;&#34;&#34;
        if not self.importOK():
            return

        if not self.good:
            return

        verbose = self.verbose
        procins = self.procins
        validate = self.validate
        modelInfo = self.modelInfo
        modelInv = self.modelInv
        modelXsd = self.modelXsd
        A = self.A
        etree = self.etree

        teiPath = self.teiPath
        reportPath = self.reportPath
        docsDir = self.docsDir
        sectionModel = self.sectionModel

        if verbose == 1:
            console(f&#34;TEI to TF checking: {ux(teiPath)} =&gt; {ux(reportPath)}&#34;)
        if verbose &gt;= 0:
            console(
                f&#34;Processing instructions are {&#39;treated&#39; if procins else &#39;ignored&#39;}&#34;
            )
            console(f&#34;XML validation will be {&#39;performed&#39; if validate else &#39;skipped&#39;}&#34;)

        kindLabels = dict(
            format=&#34;Formatting Attributes&#34;,
            keyword=&#34;Keyword Attributes&#34;,
            rest=&#34;Remaining Attributes and Elements&#34;,
        )
        getStore = lambda: collections.defaultdict(  # noqa: E731
            lambda: collections.defaultdict(collections.Counter)
        )
        analysis = {x: getStore() for x in kindLabels}
        errors = []
        tagByNs = collections.defaultdict(collections.Counter)
        refs = collections.defaultdict(lambda: collections.Counter())
        ids = collections.defaultdict(lambda: collections.Counter())

        parser = self.getParser()
        baseSchema = modelXsd[None]
        overrides = [
            override for (model, override) in modelXsd.items() if model is not None
        ]
        A.getElementInfo(baseSchema, overrides, verbose=verbose)
        elementDefs = A.elementDefs

        initTree(reportPath)
        initTree(docsDir)

        nProcins = 0

        lbParents = collections.Counter()

        def analyse(root, analysis, xmlFile):
            FORMAT_ATTS = set(
                &#34;&#34;&#34;
                dim
                level
                place
                rend
            &#34;&#34;&#34;.strip().split()
            )

            KEYWORD_ATTS = set(
                &#34;&#34;&#34;
                facs
                form
                function
                lang
                reason
                type
                unit
                who
            &#34;&#34;&#34;.strip().split()
            )

            TRIM_ATTS = set(
                &#34;&#34;&#34;
                id
                key
                target
                value
            &#34;&#34;&#34;.strip().split()
            )

            NUM_RE = re.compile(r&#34;&#34;&#34;[0-9]&#34;&#34;&#34;, re.S)

            def nodeInfo(xnode):
                nonlocal nProcins

                if procins and isinstance(xnode, etree._ProcessingInstruction):
                    target = xnode.target
                    tag = f&#34;?{target}&#34;
                    ns = &#34;&#34;
                    nProcins += 1
                else:
                    qName = etree.QName(xnode.tag)
                    tag = qName.localname
                    ns = qName.namespace

                atts = {etree.QName(k).localname: v for (k, v) in xnode.attrib.items()}

                tagByNs[tag][ns] += 1

                if tag == &#34;lb&#34;:
                    parentTag = etree.QName(xnode.getparent().tag).localname
                    lbParents[parentTag] += 1

                if len(atts) == 0:
                    kind = &#34;rest&#34;
                    analysis[kind][tag][&#34;&#34;][&#34;&#34;] += 1
                else:
                    idv = atts.get(&#34;id&#34;, None)

                    if idv is not None:
                        ids[xmlFile][idv] += 1

                    for refAtt, targetFile, targetId in getRefs(tag, atts, xmlFile):
                        refs[xmlFile][(targetFile, targetId)] += 1

                    for k, v in atts.items():
                        kind = (
                            &#34;format&#34;
                            if k in FORMAT_ATTS
                            else &#34;keyword&#34;
                            if k in KEYWORD_ATTS
                            else &#34;rest&#34;
                        )
                        dest = analysis[kind]

                        if kind == &#34;rest&#34;:
                            vTrim = &#34;X&#34; if k in TRIM_ATTS else NUM_RE.sub(&#34;N&#34;, v)
                            dest[tag][k][vTrim] += 1
                        else:
                            words = v.strip().split()
                            for w in words:
                                dest[tag][k][w.strip()] += 1

                for child in xnode.iterchildren(
                    tag=(etree.Element, etree.ProcessingInstruction)
                    if procins
                    else etree.Element
                ):
                    nodeInfo(child)

            nodeInfo(root)

        def writeErrors():
            &#34;&#34;&#34;Write the errors to a file.&#34;&#34;&#34;

            errorFile = f&#34;{reportPath}/errors.txt&#34;

            nErrors = 0
            nFiles = 0

            with fileOpen(errorFile, mode=&#34;w&#34;) as fh:
                prevFolder = None
                prevFile = None

                for folder, file, line, col, kind, text in errors:
                    newFolder = prevFolder != folder
                    newFile = newFolder or prevFile != file

                    if newFile:
                        nFiles += 1

                    if kind == &#34;error&#34;:
                        nErrors += 1

                    indent1 = f&#34;{folder}\n\t&#34; if newFolder else &#34;\t&#34;
                    indent2 = f&#34;{file}\n\t\t&#34; if newFile else &#34;\t&#34;
                    loc = f&#34;{line or &#39;&#39;}:{col or &#39;&#39;}&#34;
                    text = &#34;\n&#34;.join(wrap(text, width=80, subsequent_indent=&#34;\t\t\t&#34;))
                    fh.write(f&#34;{indent1}{indent2}{loc} {kind or &#39;&#39;} {text}\n&#34;)
                    prevFolder = folder
                    prevFile = file

            if nErrors:
                console(
                    (
                        f&#34;{nErrors} validation error(s) in {nFiles} file(s) &#34;
                        f&#34;written to {errorFile}&#34;
                    ),
                    error=True,
                )
            else:
                if verbose &gt;= 0:
                    if validate:
                        console(&#34;Validation OK&#34;)
                    else:
                        console(&#34;No validation performed&#34;)

        def writeNamespaces():
            errorFile = f&#34;{reportPath}/namespaces.txt&#34;

            nErrors = 0

            nTags = len(tagByNs)

            with fileOpen(errorFile, mode=&#34;w&#34;) as fh:
                for tag, nsInfo in sorted(
                    tagByNs.items(), key=lambda x: (-len(x[1]), x[0])
                ):
                    label = &#34;OK&#34;
                    nNs = len(nsInfo)
                    if nNs &gt; 1:
                        nErrors += 1
                        label = &#34;XX&#34;

                    for ns, amount in sorted(
                        nsInfo.items(), key=lambda x: (-x[1], x[0])
                    ):
                        fh.write(
                            f&#34;{label} {nNs:&gt;2} namespace for &#34;
                            f&#34;{tag:&lt;16} : {amount:&gt;5}x {ns}\n&#34;
                        )

            if verbose &gt;= 0:
                if procins:
                    plural = &#34;&#34; if nProcins == 1 else &#34;s&#34;
                    console(f&#34;{nProcins} processing instruction{plural} encountered.&#34;)

                console(
                    f&#34;{nTags} tags of which {nErrors} with multiple namespaces &#34;
                    f&#34;written to {errorFile}&#34;
                    if verbose &gt;= 0 or nErrors
                    else &#34;Namespaces OK&#34;
                )

        def writeReport():
            reportFile = f&#34;{reportPath}/elements.txt&#34;
            with fileOpen(reportFile, mode=&#34;w&#34;) as fh:
                fh.write(
                    &#34;Inventory of tags and attributes in the source XML file(s).\n&#34;
                    &#34;Contains the following sections:\n&#34;
                )
                for label in kindLabels.values():
                    fh.write(f&#34;\t{label}\n&#34;)
                fh.write(&#34;\n\n&#34;)

                infoLines = 0

                def writeAttInfo(tag, att, attInfo):
                    nonlocal infoLines
                    nl = &#34;&#34; if tag == &#34;&#34; else &#34;\n&#34;
                    tagRep = &#34;&#34; if tag == &#34;&#34; else f&#34;&lt;{tag}&gt;&#34;
                    attRep = &#34;&#34; if att == &#34;&#34; else f&#34;{att}=&#34;
                    atts = sorted(attInfo.items())
                    (val, amount) = atts[0]
                    fh.write(
                        f&#34;{nl}\t{tagRep:&lt;18} &#34; f&#34;{attRep:&lt;11} {amount:&gt;5}x {val}\n&#34;
                    )
                    infoLines += 1
                    for val, amount in atts[1:]:
                        fh.write(
                            f&#34;&#34;&#34;\t{&#39;&#39;:&lt;7}{&#39;&#39;:&lt;18} {&#39;&#34;&#39;:&lt;18} {amount:&gt;5}x {val}\n&#34;&#34;&#34;
                        )
                        infoLines += 1

                def writeTagInfo(tag, tagInfo):
                    nonlocal infoLines
                    tags = sorted(tagInfo.items())
                    (att, attInfo) = tags[0]
                    writeAttInfo(tag, att, attInfo)
                    infoLines += 1
                    for att, attInfo in tags[1:]:
                        writeAttInfo(&#34;&#34;, att, attInfo)

                for kind, label in kindLabels.items():
                    fh.write(f&#34;\n{label}\n&#34;)
                    for tag, tagInfo in sorted(analysis[kind].items()):
                        writeTagInfo(tag, tagInfo)

            if verbose &gt;= 0:
                console(f&#34;{infoLines} info line(s) written to {reportFile}&#34;)

        def writeElemTypes():
            elemsCombined = {}

            modelSet = set()

            for schemaOverride, eDefs in elementDefs.items():
                model = modelInv[schemaOverride]
                modelSet.add(model)
                for tag, (typ, mixed) in eDefs.items():
                    elemsCombined.setdefault(tag, {}).setdefault(model, {})
                    elemsCombined[tag][model][&#34;typ&#34;] = typ
                    elemsCombined[tag][model][&#34;mixed&#34;] = mixed

            tagReport = {}

            for tag, tagInfo in elemsCombined.items():
                tagLines = []
                tagReport[tag] = tagLines

                if None in tagInfo:
                    teiInfo = tagInfo[None]
                    teiTyp = teiInfo[&#34;typ&#34;]
                    teiMixed = teiInfo[&#34;mixed&#34;]
                    teiTypRep = &#34;??&#34; if teiTyp is None else typ
                    teiMixedRep = (
                        &#34;??&#34; if teiMixed is None else &#34;mixed&#34; if teiMixed else &#34;pure&#34;
                    )
                    mds = [&#34;TEI&#34;]

                    for model in sorted(x for x in tagInfo if x is not None):
                        info = tagInfo[model]
                        typ = info[&#34;typ&#34;]
                        mixed = info[&#34;mixed&#34;]
                        if typ == teiTyp and mixed == teiMixed:
                            mds.append(model)
                        else:
                            typRep = (
                                &#34;&#34; if typ == teiTyp else &#34;??&#34; if typ is None else typ
                            )
                            mixedRep = (
                                &#34;&#34;
                                if mixed == teiMixed
                                else &#34;??&#34;
                                if mixed is None
                                else &#34;mixed&#34;
                                if mixed
                                else &#34;pure&#34;
                            )
                            tagLines.append((tag, [model], typRep, mixedRep))
                    tagLines.insert(0, (tag, mds, teiTypRep, teiMixedRep))
                else:
                    for model in sorted(tagInfo):
                        info = tagInfo[model]
                        typ = info[&#34;typ&#34;]
                        mixed = info[&#34;mixed&#34;]
                        typRep = &#34;??&#34; if typ is None else typ
                        mixedRep = (
                            &#34;??&#34; if mixed is None else &#34;mixed&#34; if mixed else &#34;pure&#34;
                        )
                        tagLines.append((tag, [model], typRep, mixedRep))

            reportFile = f&#34;{reportPath}/types.txt&#34;
            with fileOpen(reportFile, mode=&#34;w&#34;) as fh:
                for tag in sorted(tagReport):
                    tagLines = tagReport[tag]
                    for tag, mds, typ, mixed in tagLines:
                        model = &#34;,&#34;.join(mds)
                        fh.write(f&#34;{tag:&lt;18} {model:&lt;18} {typ:&lt;7} {mixed:&lt;5}\n&#34;)

            if verbose &gt;= 0:
                console(
                    f&#34;{len(elemsCombined)} tag(s) type info written to {reportFile}&#34;
                )

        def writeLbParents():
            reportFile = f&#34;{reportPath}/lb-parents.txt&#34;

            with open(reportFile, &#34;w&#34;) as fh:
                for parent, n in sorted(lbParents.items()):
                    fh.write(f&#34;{n:&gt;5} x {parent}\n&#34;)

            if verbose &gt;= 0:
                console(f&#34;lb-parent info written to {reportFile}&#34;)

        def writeIdRefs():
            reportIdFile = f&#34;{reportPath}/ids.txt&#34;
            reportRefFile = f&#34;{reportPath}/refs.txt&#34;

            ih = fileOpen(reportIdFile, mode=&#34;w&#34;)
            rh = fileOpen(reportRefFile, mode=&#34;w&#34;)

            refdIds = collections.Counter()
            missingIds = set()

            totalRefs = 0
            totalRefsU = 0

            totalResolvable = 0
            totalResolvableU = 0
            totalDangling = 0
            totalDanglingU = 0

            seenItems = set()

            for file, items in refs.items():
                rh.write(f&#34;{file}\n&#34;)

                resolvable = 0
                resolvableU = 0
                dangling = 0
                danglingU = 0

                for item, n in sorted(items.items()):
                    totalRefs += n

                    if item in seenItems:
                        newItem = False
                    else:
                        seenItems.add(item)
                        newItem = True
                        totalRefsU += 1

                    (target, idv) = item

                    if target not in ids or idv not in ids[target]:
                        status = &#34;dangling&#34;
                        dangling += n

                        if newItem:
                            missingIds.add((target, idv))
                            danglingU += 1
                    else:
                        status = &#34;ok&#34;
                        resolvable += n
                        refdIds[(target, idv)] += n

                        if newItem:
                            resolvableU += 1
                    rh.write(f&#34;\t{status:&lt;10} {n:&gt;5} x {target} # {idv}\n&#34;)

                msgs = (
                    f&#34;\tDangling:   {dangling:&gt;4} x {danglingU:&gt;4}&#34;,
                    f&#34;\tResolvable: {resolvable:&gt;4} x {resolvableU:&gt;4}&#34;,
                )
                for msg in msgs:
                    rh.write(f&#34;{msg}\n&#34;)

                totalResolvable += resolvable
                totalResolvableU += resolvableU
                totalDangling += dangling
                totalDanglingU += danglingU

            if verbose &gt;= 0:
                console(f&#34;Refs written to {reportRefFile}&#34;)
                msgs = (
                    f&#34;\tresolvable: {totalResolvableU:&gt;4} in {totalResolvable:&gt;4}&#34;,
                    f&#34;\tdangling:   {totalDanglingU:&gt;4} in {totalDangling:&gt;4}&#34;,
                    f&#34;\tALL:        {totalRefsU:&gt;4} in {totalRefs:&gt;4} &#34;,
                )
                for msg in msgs:
                    console(msg)

            totalIds = 0
            totalIdsU = 0
            totalIdsM = 0
            totalIdsRefd = 0
            totalIdsRefdU = 0
            totalIdsUnused = 0

            for file, items in ids.items():
                totalIds += len(items)

                ih.write(f&#34;{file}\n&#34;)

                unique = 0
                multiple = 0
                refd = 0
                refdU = 0
                unused = 0

                for item, n in sorted(items.items()):
                    nRefs = refdIds.get((file, item), 0)

                    if n == 1:
                        unique += 1
                    else:
                        multiple += 1

                    if nRefs == 0:
                        unused += 1
                    else:
                        refd += nRefs
                        refdU += 1

                    status1 = f&#34;{n}x&#34;
                    plural = &#34;&#34; if nRefs == 1 else &#34;s&#34;
                    status2 = f&#34;{nRefs}ref{plural}&#34;

                    ih.write(f&#34;\t{status1:&lt;8} {status2:&lt;8} {item}\n&#34;)

                msgs = (
                    f&#34;\tUnique:     {unique:&gt;4}&#34;,
                    f&#34;\tNon-unique: {multiple:&gt;4}&#34;,
                    f&#34;\tUnused:     {unused:&gt;4}&#34;,
                    f&#34;\tReferenced: {refd:&gt;4} x {refdU:&gt;4}&#34;,
                )
                for msg in msgs:
                    ih.write(f&#34;{msg}\n&#34;)

                totalIdsU += unique
                totalIdsM += multiple
                totalIdsRefdU += refdU
                totalIdsRefd += refd
                totalIdsUnused += unused

            if verbose &gt;= 0:
                console(f&#34;Ids written to {reportIdFile}&#34;)
                msgs = (
                    f&#34;\treferenced: {totalIdsRefdU:&gt;4} by {totalIdsRefd:&gt;4}&#34;,
                    f&#34;\tnon-unique: {totalIdsM:&gt;4}&#34;,
                    f&#34;\tunused:     {totalIdsUnused:&gt;4}&#34;,
                    f&#34;\tALL:        {totalIdsU:&gt;4} in {totalIds:&gt;4}&#34;,
                )
                for msg in msgs:
                    console(msg)

        def writeDoc():
            teiUrl = &#34;https://tei-c.org/release/doc/tei-p5-doc/en/html&#34;
            elUrlPrefix = f&#34;{teiUrl}/ref-&#34;
            attUrlPrefix = f&#34;{teiUrl}/REF-ATTS.html#&#34;
            docFile = f&#34;{docsDir}/elements.md&#34;
            with fileOpen(docFile, mode=&#34;w&#34;) as fh:
                fh.write(
                    dedent(
                        &#34;&#34;&#34;
                        # Element and attribute inventory

                        Table of contents

                        &#34;&#34;&#34;
                    )
                )
                for label in kindLabels.values():
                    labelAnchor = label.replace(&#34; &#34;, &#34;-&#34;)
                    fh.write(f&#34;*\t[{label}](#{labelAnchor})\n&#34;)

                fh.write(&#34;\n&#34;)

                tableHeader = dedent(
                    &#34;&#34;&#34;
                    | element | attribute | value | amount
                    | --- | --- | --- | ---
                    &#34;&#34;&#34;
                )

                def writeAttInfo(tag, att, attInfo):
                    tagRep = &#34; &#34; if tag == &#34;&#34; else f&#34;[{tag}]({elUrlPrefix}{tag}.html)&#34;
                    attRep = &#34; &#34; if att == &#34;&#34; else f&#34;[{att}]({attUrlPrefix}{att})&#34;
                    atts = sorted(attInfo.items())
                    (val, amount) = atts[0]
                    valRep = f&#34;`{val}`&#34; if val else &#34;&#34;
                    fh.write(
                        &#34;| &#34;
                        + (
                            &#34; | &#34;.join(
                                str(x)
                                for x in (
                                    tagRep,
                                    attRep,
                                    valRep,
                                    amount,
                                )
                            )
                        )
                        + &#34;\n&#34;
                    )
                    for val, amount in atts[1:]:
                        valRep = f&#34;`{val}`&#34; if val else &#34;&#34;
                        fh.write(f&#34;&#34;&#34;| | | {valRep} | {amount}\n&#34;&#34;&#34;)

                def writeTagInfo(tag, tagInfo):
                    tags = sorted(tagInfo.items())
                    (att, attInfo) = tags[0]
                    writeAttInfo(tag, att, attInfo)
                    for att, attInfo in tags[1:]:
                        writeAttInfo(&#34;&#34;, att, attInfo)

                for kind, label in kindLabels.items():
                    fh.write(f&#34;## {label}\n{tableHeader}&#34;)
                    for tag, tagInfo in sorted(analysis[kind].items()):
                        writeTagInfo(tag, tagInfo)
                    fh.write(&#34;\n&#34;)

        def filterError(msg):
            return msg == (
                &#34;Element &#39;graphic&#39;, attribute &#39;url&#39;: [facet &#39;pattern&#39;] &#34;
                &#34;The value &#39;&#39; is not accepted by the pattern &#39;\\S+&#39;.&#34;
            )

        def doXMLFile(xmlPath):
            tree = etree.parse(xmlPath, parser)
            root = tree.getroot()
            xmlFile = fileNm(xmlPath)
            ids[xmlFile][&#34;&#34;] = 1
            analyse(root, analysis, xmlFile)

        xmlFilesByModel = collections.defaultdict(list)

        if sectionModel == &#34;I&#34;:
            i = 0
            for xmlFolder, xmlFiles in self.getXML():
                msg = &#34;Start &#34; if verbose &gt;= 0 else &#34;\t&#34;
                console(f&#34;{msg}folder {xmlFolder}:&#34;)
                j = 0
                cr = &#34;&#34;
                nl = True

                for xmlFile in xmlFiles:
                    i += 1
                    j += 1
                    if j &gt; PROGRESS_LIMIT:
                        cr = &#34;\r&#34;
                        nl = False
                    xmlPath = f&#34;{teiPath}/{xmlFolder}/{xmlFile}&#34;
                    (model, adapt, tpl) = self.getSwitches(xmlPath)
                    mdRep = model or &#34;TEI&#34;
                    tplRep = tpl or &#34;&#34;
                    adRep = adapt or &#34;&#34;

                    label = f&#34;{mdRep:&lt;12} {tplRep:&lt;12} {adRep:&lt;12}&#34;

                    if verbose &gt;= 0:
                        console(f&#34;{cr}{i:&gt;4} {label} {xmlFile:&lt;50}&#34;, newline=nl)
                    xmlFilesByModel[model].append(xmlPath)
                if verbose &gt;= 0:
                    console(&#34;&#34;)
                    console(f&#34;End   folder {xmlFolder}&#34;)

        elif sectionModel == &#34;II&#34;:
            xmlFile = self.getXML()
            if xmlFile is None:
                console(&#34;No XML files found!&#34;, error=True)
                return False

            xmlPath = f&#34;{teiPath}/{xmlFile}&#34;
            (model, adapt, tpl) = self.getSwitches(xmlPath)
            xmlFilesByModel[model].append(xmlPath)

        good = True

        for model, xmlPaths in xmlFilesByModel.items():
            if verbose &gt;= 0:
                console(f&#34;{len(xmlPaths)} {model or &#39;TEI&#39;} file(s) ...&#34;)

            thisGood = True

            if validate:
                if verbose &gt;= 0:
                    console(&#34;\tValidating ...&#34;)

                schemaFile = modelInfo.get(model, None)

                if schemaFile is None:
                    if verbose &gt;= 0:
                        console(f&#34;\t\tNo schema file for {model}&#34;)
                    if good is not None and good is not False:
                        good = None
                    continue

                (thisGood, info, theseErrors) = A.validate(schemaFile, xmlPaths)

                for line in info:
                    if verbose &gt;= 0:
                        console(f&#34;\t\t{line}&#34;)

            if not thisGood:
                good = False
                errors.extend(theseErrors)

            if verbose &gt;= 0:
                console(&#34;\tMaking inventory ...&#34;)
            for xmlPath in xmlPaths:
                doXMLFile(xmlPath)

        if not good:
            self.good = False

        if verbose &gt;= 0:
            console(&#34;&#34;)
        writeErrors()
        writeReport()
        writeElemTypes()
        writeDoc()
        writeNamespaces()
        writeIdRefs()
        writeLbParents()

    # SET UP CONVERSION

    def getConverter(self):
        &#34;&#34;&#34;Initializes a converter.

        Returns
        -------
        object
            The `tf.convert.walker.CV` converter object, initialized.
        &#34;&#34;&#34;
        verbose = self.verbose
        tfPath = self.tfPath

        silent = AUTO if verbose == 1 else TERSE if verbose == 0 else DEEP
        TF = Fabric(locations=tfPath, silent=silent)
        return CV(TF, silent=silent)

    # DIRECTOR

    def getDirector(self):
        &#34;&#34;&#34;Factory for the director function.

        The `tf.convert.walker` relies on a corpus dependent `director` function
        that walks through the source data and spits out actions that
        produces the TF dataset.

        The director function that walks through the TEI input must be conditioned
        by the properties defined in the TEI schema and the customised schema, if any,
        that describes the source.

        Also some special additions need to be programmed, such as an extra section
        level, word boundaries, etc.

        We collect all needed data, store it, and define a local director function
        that has access to this data.

        Returns
        -------
        function
            The local director function that has been constructed.
        &#34;&#34;&#34;
        if not self.importOK():
            return

        if not self.good:
            return

        TEI_HEADER = &#34;teiHeader&#34;

        TEXT_ANCESTOR = &#34;text&#34;
        TEXT_ANCESTORS = set(
            &#34;&#34;&#34;
            front
            body
            back
            group
            &#34;&#34;&#34;.strip().split()
        )
        CHUNK_PARENTS = TEXT_ANCESTORS | {TEI_HEADER}

        CHUNK_ELEMS = set(
            &#34;&#34;&#34;
            facsimile
            fsdDecl
            sourceDoc
            standOff
            &#34;&#34;&#34;.strip().split()
        )

        PASS_THROUGH = set(
            &#34;&#34;&#34;
            TEI
            &#34;&#34;&#34;.strip().split()
        )

        # CHECKING

        HY = &#34;\u2010&#34;  # hyphen

        IN_WORD_HYPHENS = {HY, &#34;-&#34;}

        procins = self.procins
        verbose = self.verbose
        teiPath = self.teiPath
        wordAsSlot = self.wordAsSlot
        tokenAsSlot = self.tokenAsSlot
        parentEdges = self.parentEdges
        siblingEdges = self.siblingEdges
        featureMeta = self.featureMeta
        intFeatures = self.intFeatures
        transform = getattr(self, &#34;transformCustom&#34;, None)
        chunkLevel = self.chunkLevel
        modelInv = self.modelInv
        modelInfo = self.modelInfo
        modelXsd = self.modelXsd
        A = self.A
        etree = self.etree

        transformFunc = (
            (lambda x: BytesIO(x.encode(&#34;utf-8&#34;)))
            if transform is None
            else lambda x: BytesIO(transform(x).encode(&#34;utf-8&#34;))
        )

        parser = self.getParser()

        baseSchema = modelInfo[None]
        overrides = [
            override for (model, override) in modelInfo.items() if model is not None
        ]
        baseSchema = modelXsd[None]
        overrides = [
            override for (model, override) in modelXsd.items() if model is not None
        ]
        A.getElementInfo(baseSchema, overrides, verbose=-1)

        refs = collections.defaultdict(lambda: collections.defaultdict(set))
        ids = collections.defaultdict(dict)

        # WALKERS

        WHITE_TRIM_RE = re.compile(r&#34;\s+&#34;, re.S)
        NON_NAME_RE = re.compile(r&#34;[^a-zA-Z0-9_ ]+&#34;, re.S)

        NOTE_LIKE = set(
            &#34;&#34;&#34;
            note
            &#34;&#34;&#34;.strip().split()
        )
        EMPTY_ELEMENTS = set(
            &#34;&#34;&#34;
            addSpan
            alt
            anchor
            anyElement
            attRef
            binary
            caesura
            catRef
            cb
            citeData
            classRef
            conversion
            damageSpan
            dataFacet
            default
            delSpan
            elementRef
            empty
            equiv
            fsdLink
            gb
            handShift
            iff
            lacunaEnd
            lacunaStart
            lb
            link
            localProp
            macroRef
            milestone
            move
            numeric
            param
            path
            pause
            pb
            ptr
            redo
            refState
            specDesc
            specGrpRef
            symbol
            textNode
            then
            undo
            unicodeProp
            unihanProp
            variantEncoding
            when
            witEnd
            witStart
            &#34;&#34;&#34;.strip().split()
        )
        NEWLINE_ELEMENTS = set(
            &#34;&#34;&#34;
            ab
            addrLine
            cb
            l
            lb
            lg
            list
            p
            pb
            seg
            table
            u
            &#34;&#34;&#34;.strip().split()
        )
        CONTINUOUS_ELEMENTS = set(
            &#34;&#34;&#34;
            choice
            &#34;&#34;&#34;.strip().split()
        )

        def makeNameLike(x):
            return NON_NAME_RE.sub(&#34;_&#34;, x).strip(&#34;_&#34;)

        def walkNode(cv, cur, xnode):
            &#34;&#34;&#34;Internal function to deal with a single element.

            Will be called recursively.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

                The subdictionary `cur[&#34;node&#34;]` is used to store the currently generated
                nodes by node type.
            xnode: object
                An LXML element node.
            &#34;&#34;&#34;
            if procins and isinstance(xnode, etree._ProcessingInstruction):
                target = xnode.target
                tag = f&#34;?{target}&#34;
            else:
                tag = etree.QName(xnode.tag).localname

            atts = {etree.QName(k).localname: v for (k, v) in xnode.attrib.items()}

            beforeTag(cv, cur, xnode, tag, atts)

            cur[XNEST].append((tag, atts))

            curNode = beforeChildren(cv, cur, xnode, tag, atts)

            if curNode is not None:
                if parentEdges:
                    if len(cur[TNEST]):
                        parentNode = cur[TNEST][-1]
                        cv.edge(curNode, parentNode, parent=None)

                cur[TNEST].append(curNode)

                if siblingEdges:
                    if len(cur[TSIB]):
                        siblings = cur[TSIB][-1]

                        nSiblings = len(siblings)
                        for i, sib in enumerate(siblings):
                            cv.edge(sib, curNode, sibling=nSiblings - i)
                        siblings.append(curNode)

                    cur[TSIB].append([])

            for child in xnode.iterchildren(
                tag=(etree.Element, etree.ProcessingInstruction)
                if procins
                else etree.Element
            ):
                walkNode(cv, cur, child)

            afterChildren(cv, cur, xnode, tag, atts)

            if curNode is not None:
                xmlFile = cur[&#34;xmlFile&#34;]

                for refAtt, targetFile, targetId in getRefs(tag, atts, xmlFile):
                    refs[refAtt][(targetFile, targetId)].add(curNode)

                idVal = atts.get(&#34;id&#34;, None)
                if idVal is not None:
                    ids[xmlFile][idVal] = curNode

                if len(cur[TNEST]):
                    cur[TNEST].pop()
                if siblingEdges:
                    if len(cur[TSIB]):
                        cur[TSIB].pop()

            cur[XNEST].pop()
            afterTag(cv, cur, xnode, tag, atts)

        def isChapter(cur):
            &#34;&#34;&#34;Whether the current element counts as a chapter node.

            ## Model I

            Not relevant: there are no chapter nodes inside an XML file.

            ## Model II

            Chapters are the highest section level (the only lower level is chunks).

            Chapters come in two kinds:

            *   the TEI header;
            *   the immediate children of `&lt;text&gt;`
                except `&lt;front&gt;`, `&lt;body&gt;`, `&lt;back&gt;`, `&lt;group&gt;`;
            *   the immediate children of
                `&lt;front&gt;`, `&lt;body&gt;`, `&lt;back&gt;`, `&lt;group&gt;`.

            Parameters
            ----------
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

            Returns
            -------
            boolean
            &#34;&#34;&#34;
            sectionModel = self.sectionModel

            if sectionModel == &#34;II&#34;:
                nest = cur[XNEST]
                nNest = len(nest)

                if nNest &gt; 0 and nest[-1][0] in EMPTY_ELEMENTS:
                    return False

                outcome = nNest &gt; 0 and (
                    nest[-1][0] == TEI_HEADER
                    or (
                        nNest &gt; 1
                        and (
                            nest[-2][0] in TEXT_ANCESTORS
                            or nest[-2][0] == TEXT_ANCESTOR
                            and nest[-1][0] not in TEXT_ANCESTORS
                        )
                    )
                )
                if outcome:
                    cur[&#34;chapterElems&#34;].add(nest[-1][0])

                return outcome

            return False

        def isChunk(cur):
            &#34;&#34;&#34;Whether the current element counts as a chunk node.

            It depends on the section model, but also on the template.

            Note that we only can have distinct templates if we deal with
            multiple files, so only when we are in section model I.

            ## Model I

            Chunks are the lowest section level (the higher levels are folders
            and then files)

            The default is that chunks are the immediate children of the
            `&lt;teiHeader&gt;` and the `&lt;body&gt;`
            elements; a few other elements also count as chunks.

            However, if `drillDownDivs` is True and if the chunk appears to be
            a `&lt;div&gt;` element, we drill further down, until we arrive at a
            non-`&lt;div&gt;` element.

            But in specific templates we have different rules:

            ### `bibliolist`:

            *   The TEI Header is a chunk, and nothing inside the TEI header is a chunk;
            *   Everything at level 5, except `&lt;listBibl&gt;` is a chunk;
            *   The children of `&lt;listBibl&gt;` are chunks (the `&lt;bibl&gt;` elements
                and a few others), provided they are at level 6.

            ### `artworklist`

            *   The TEI Header is a chunk, and nothing inside the TEI header is a chunk;
            *   Everything at level 5 is a chunk.

            ## Model II

            Chunks are the lowest section level (the only higher level is chapters).

            Chunks are the immediate children of the chapters, and they come in two
            kinds: the ones that are `&lt;p&gt;` elements, and the rest.

            Deviation from this rule:

            *   If a chapter is a mixed content node, then it is also a chunk.
                and its subelements are not chunks

            Parameters
            ----------
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

            Returns
            -------
            boolean
            &#34;&#34;&#34;
            sectionModel = self.sectionModel

            nest = cur[XNEST]
            nNest = len(nest)
            model = cur[&#34;model&#34;]

            if nNest == 0:
                return False

            thisTag = nest[-1][0]

            if sectionModel == &#34;II&#34;:
                if nNest == 1:
                    outcome = False
                else:
                    parentTag = nest[-2][0]
                    meChptChnk = (
                        isChapter(cur) and thisTag not in cur[&#34;pureElems&#34;][model]
                    )

                    if meChptChnk:
                        outcome = True
                    elif parentTag == TEI_HEADER:
                        outcome = True
                    elif nNest &lt;= 2:
                        outcome = False
                    elif parentTag not in cur[&#34;pureElems&#34;][model]:
                        outcome = False
                    else:
                        grandParentTag = nest[-3][0]
                        outcome = (
                            grandParentTag in TEXT_ANCESTORS
                            and thisTag not in EMPTY_ELEMENTS
                        ) or (
                            grandParentTag == TEXT_ANCESTOR
                            and parentTag not in TEXT_ANCESTORS
                        )

            elif sectionModel == &#34;I&#34;:
                template = cur[&#34;template&#34;]

                if template == &#34;biolist&#34;:
                    if thisTag == TEI_HEADER:
                        outcome = True
                    elif any(n[0] == TEI_HEADER for n in nest[0:-1]):
                        outcome = False
                    elif nNest not in {5, 6}:
                        outcome = False
                    else:
                        parentTag = nest[-2][0]
                        if nNest == 5:
                            outcome = thisTag != &#34;listPerson&#34;
                        else:
                            outcome = parentTag == &#34;listPerson&#34;

                elif template == &#34;bibliolist&#34;:
                    if thisTag == TEI_HEADER:
                        outcome = True
                    elif any(n[0] == TEI_HEADER for n in nest[0:-1]):
                        outcome = False
                    elif nNest not in {5, 6}:
                        outcome = False
                    else:
                        parentTag = nest[-2][0]
                        if nNest == 5:
                            outcome = thisTag != &#34;listBibl&#34;
                        else:
                            outcome = parentTag == &#34;listBibl&#34;

                elif template == &#34;artworklist&#34;:
                    if thisTag == TEI_HEADER:
                        outcome = True
                    elif any(n[0] == TEI_HEADER for n in nest[0:-1]):
                        outcome = False
                    else:
                        outcome = nNest == 5

                else:
                    if thisTag in CHUNK_ELEMS:
                        outcome = True
                    elif nNest == 1:
                        outcome = False
                    else:
                        sectionProperties = self.sectionProperties
                        drillDownDivs = sectionProperties[&#34;drillDownDivs&#34;]

                        parentTag = nest[-2][0]
                        if drillDownDivs:
                            if thisTag == &#34;div&#34;:
                                outcome = False
                            else:
                                dParentTag = None
                                for ancestor in reversed(nest[0:-1]):
                                    if ancestor[0] != &#34;div&#34;:
                                        dParentTag = ancestor[0]
                                        break
                                outcome = (
                                    dParentTag in CHUNK_PARENTS
                                    and thisTag not in EMPTY_ELEMENTS
                                ) or (
                                    dParentTag == TEXT_ANCESTOR
                                    and thisTag not in TEXT_ANCESTORS
                                )
                        else:
                            outcome = (
                                parentTag in CHUNK_PARENTS
                                and thisTag not in EMPTY_ELEMENTS
                            ) or (
                                parentTag == TEXT_ANCESTOR
                                and thisTag not in TEXT_ANCESTORS
                            )

            if outcome:
                cur[&#34;chunkElems&#34;].add(nest[-1][0])

            return outcome

        def isPure(cur):
            &#34;&#34;&#34;Whether the current tag has pure content.

            Parameters
            ----------
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

            Returns
            -------
            boolean
            &#34;&#34;&#34;
            nest = cur[XNEST]
            model = cur[&#34;model&#34;]
            return (
                len(nest) == 0
                or len(nest) &gt; 0
                and nest[-1][0] in cur[&#34;pureElems&#34;][model]
            )

        def isEndInPure(cur):
            &#34;&#34;&#34;Whether the current end tag occurs in an element with pure content.

            If that is the case, then it is very likely that the end tag also
            marks the end of the current word.

            And we should not strip spaces after it.

            Parameters
            ----------
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

            Returns
            -------
            boolean
            &#34;&#34;&#34;
            nest = cur[XNEST]
            model = cur[&#34;model&#34;]
            return len(nest) &gt; 1 and nest[-2][0] in cur[&#34;pureElems&#34;][model]

        def hasMixedAncestor(cur):
            &#34;&#34;&#34;Whether the current tag has an ancestor with mixed content.

            We use this in case a tag ends in an element with pure content.
            We should then add white-space to separate it from the next
            element of its parent.

            If the whole stack of element has pure content, we add
            a newline, because then we are probably in the TEI header,
            and things are most clear if they are on separate lines.

            But if one of the ancestors has mixed content, we are typically
            in some structured piece of information within running text,
            such as change markup. In this case we want to add merely a space.

            And we should not strip spaces after it.

            Parameters
            ----------
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

            Returns
            -------
            boolean
            &#34;&#34;&#34;
            nest = cur[XNEST]
            model = cur[&#34;model&#34;]
            return any(n[0] in cur[&#34;mixedElems&#34;][model] for n in nest[0:-1])

        def hasContinuousAncestor(cur):
            &#34;&#34;&#34;Whether an ancestor tag is a continuous pure element.

            A continuous pure element is an element whose child elements do not
            imply word separation, e.g. `&lt;choice&gt;`.

            Parameters
            ----------
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

            Returns
            -------
            boolean
            &#34;&#34;&#34;
            nest = cur[XNEST]
            return any(n[0] in CONTINUOUS_ELEMENTS for n in nest[0:-1])

        def startWord(cv, cur, ch):
            &#34;&#34;&#34;Start a word node if necessary.

            Whenever we encounter a character, we determine
            whether it starts or ends a word, and if it starts
            one, this function takes care of the necessary actions.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            ch: string
                A single character, the next character in the result data.
            &#34;&#34;&#34;
            curWord = cur[NODE][WORD]

            if not curWord:
                prevWord = cur[&#34;prevWord&#34;]
                if prevWord is not None:
                    cv.feature(prevWord, after=cur[&#34;afterStr&#34;])
                if ch is not None:
                    if wordAsSlot:
                        curWord = cv.slot()
                    else:
                        curWord = cv.node(WORD)
                    cur[NODE][WORD] = curWord
                    addSlotFeatures(cv, cur, curWord)

            if ch is not None:
                cur[&#34;wordStr&#34;] += ch

        def finishWord(cv, cur, ch, spaceChar):
            &#34;&#34;&#34;Terminate a word node if necessary.

            Whenever we encounter a character, we determine
            whether it starts or ends a word, and if it ends
            one, this function takes care of the necessary actions.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            ch: string
                A single character, the next slot in the result data.
            spaceChar: string | void
                If None, no extra space or newline will be added.
                Otherwise, the `spaceChar` (a single space or newline will be added).
            &#34;&#34;&#34;
            curWord = cur[NODE][WORD]
            if curWord:
                cv.feature(curWord, str=cur[&#34;wordStr&#34;])
                if not wordAsSlot:
                    cv.terminate(curWord)
                cur[NODE][WORD] = None
                cur[&#34;wordStr&#34;] = &#34;&#34;
                cur[&#34;prevWord&#34;] = curWord
                cur[&#34;afterStr&#34;] = &#34;&#34;

            if ch is not None:
                cur[&#34;afterStr&#34;] += ch
            if spaceChar is not None:
                cur[&#34;afterStr&#34;] = cur[&#34;afterStr&#34;].rstrip() + spaceChar
                if not wordAsSlot:
                    addSpace(cv, cur, spaceChar)
                cur[&#34;afterSpace&#34;] = True
            else:
                cur[&#34;afterSpace&#34;] = False

        def addSlotFeatures(cv, cur, s):
            &#34;&#34;&#34;Add generic features to a slot.

            Whenever we encounter a character, we add it as a new slot, unless
            `wordAsSlot` is in force. In that case we suppress the triggering of a
            slot node.
            If needed, we start / terminate word nodes as well.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            s: slot
                A previously added (slot) node
            &#34;&#34;&#34;
            if cur[&#34;inHeader&#34;]:
                cv.feature(s, is_meta=1)
            if cur[&#34;inNote&#34;]:
                cv.feature(s, is_note=1)
            for r, stack in cur.get(&#34;rend&#34;, {}).items():
                if len(stack) &gt; 0:
                    cv.feature(s, **{f&#34;rend_{r}&#34;: 1})

        def addTokens(cv, cur, text):
            &#34;&#34;&#34;Adds text as a series of tokens.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            text: string
                The text to be added.

            Only meant for the case where slots are tokens.
            &#34;&#34;&#34;
            (beforew, material, afterw) = getWhites(text)

            if beforew:
                makeSpace(cv, cur)

            s = None

            for tx, after in tokenize(material):
                s = cv.slot()
                cv.feature(s, str=tx, after=after)
                addSlotFeatures(cv, cur, s)

            if afterw:
                if s is None:
                    makeSpace(cv, cur)
                else:
                    cv.feature(s, after=&#34; &#34;)

        def addSlot(cv, cur, ch):
            &#34;&#34;&#34;Add a slot.

            Whenever we encounter a character, we add it as a new slot, unless
            `wordAsSlot` is in force. In that case we suppress the triggering of a
            slot node.
            If needed, we start / terminate word nodes as well.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            ch: string
                A single character, the next slot in the result data.
            &#34;&#34;&#34;
            if ch in {&#34;_&#34;, None} or ch.isalnum() or ch in IN_WORD_HYPHENS:
                startWord(cv, cur, ch)
            else:
                finishWord(cv, cur, ch, None)

            if wordAsSlot:
                s = cur[NODE][WORD]
            elif ch is None:
                s = None
            else:
                s = cv.slot()
                cv.feature(s, ch=ch)
            if s is not None:
                addSlotFeatures(cv, cur, s)

        def addEmpty(cv, cur):
            &#34;&#34;&#34;Add an empty slot.

            We also terminate the current word.
            If words are slots, the empty slot is a word on its own.

            Returns
            -------
            node
                The empty slot
            &#34;&#34;&#34;
            if tokenAsSlot:
                emptyNode = cv.slot()
                cv.feature(emptyNode, str=ZWSP, after=&#34;&#34;, empty=1)
            else:
                finishWord(cv, cur, None, None)
                startWord(cv, cur, ZWSP)
                emptyNode = cur[NODE][WORD]
                cv.feature(emptyNode, empty=1)

                if not wordAsSlot:
                    emptyNode = cv.slot()
                    cv.feature(emptyNode, ch=ZWSP, empty=1)

                finishWord(cv, cur, None, None)

            return emptyNode

        def addSpace(cv, cur, spaceChar):
            &#34;&#34;&#34;Adds a space or a new line.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            spaceChar: string
                The character to add (supposed to be either a space or a newline).

            Only meant for the case where slots are characters or tokens.

            Suppressed when not in a lowest-level section.
            &#34;&#34;&#34;
            if chunkLevel in cv.activeTypes():
                s = cv.slot()
                if tokenAsSlot:
                    cv.feature(s, str=&#34;&#34;, after=spaceChar, extraspace=1)
                else:
                    cv.feature(s, ch=spaceChar, extraspace=1)
                addSlotFeatures(cv, cur, s)

        def makeSpace(cv, cur):
            &#34;&#34;&#34;Adds a space.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

            Only meant for the case where slots are tokens.
            &#34;&#34;&#34;
            s = cv.slot()
            cv.feature(s, str=&#34;&#34;, after=&#34; &#34;, extraspace=1)
            addSlotFeatures(cv, cur, s)

        def endLine(cv, cur):
            &#34;&#34;&#34;Ends a line node.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            &#34;&#34;&#34;
            lineProperties = self.lineProperties
            lineType = lineProperties[&#34;nodeType&#34;]

            slots = cv.linked(cur[NODE][lineType])
            empty = len(slots) == 0

            if empty:
                lastSlot = addEmpty(cv, cur)
                if cur[&#34;inNote&#34;]:
                    cv.feature(lastSlot, is_note=1)
            else:
                lastSlot = (T, slots[-1])

            if not wordAsSlot:
                after = cv.get(&#34;after&#34;, lastSlot)
                if after is not None and &#34;\n&#34; not in after:
                    cv.feature(lastSlot, after=f&#34;{after.rstrip()}\n&#34;)
            cv.terminate(cur[NODE][lineType])

        def endPage(cv, cur):
            &#34;&#34;&#34;Ends a page node.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            &#34;&#34;&#34;
            pageProperties = self.pageProperties
            pageType = pageProperties[&#34;nodeType&#34;]

            slots = cv.linked(cur[NODE][pageType])
            empty = len(slots) == 0

            if empty:
                lastSlot = addEmpty(cv, cur)
                if cur[&#34;inNote&#34;]:
                    cv.feature(lastSlot, is_note=1)
            cv.terminate(cur[NODE][pageType])

        def beforeTag(cv, cur, xnode, tag, atts):
            &#34;&#34;&#34;Actions before dealing with the element&#39;s tag.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            xnode: object
                An LXML element node.
            tag: string
                The tag of the LXML node.
            &#34;&#34;&#34;
            beforeTagCustom = getattr(self, &#34;beforeTagCustom&#34;, None)
            if beforeTagCustom is not None:
                beforeTagCustom(cv, cur, xnode, tag, atts)

        def beforeChildren(cv, cur, xnode, tag, atts):
            &#34;&#34;&#34;Actions before dealing with the element&#39;s children.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            xnode: object
                An LXML element node.
            tag: string
                The tag of the LXML node.
            atts: string
                The attributes of the LXML node, with namespaces stripped.
            &#34;&#34;&#34;
            makeLineElems = self.makeLineElems

            if makeLineElems:
                lineProperties = self.lineProperties
                lineElem = lineProperties[&#34;element&#34;]
                lineType = lineProperties[&#34;nodeType&#34;]
                isLineContainer = tag == lineElem
                inLine = cur[&#34;inLine&#34;]

                if isLineContainer:
                    cur[&#34;inLine&#34;] = True

                    # the line starts with the container
                    cur[NODE][lineType] = cv.node(lineType)

            makePageElems = self.makePageElems

            if makePageElems:
                pageProperties = self.pageProperties
                pageType = pageProperties[&#34;nodeType&#34;]
                isPageContainer = matchModel(pageProperties, tag, atts)
                inPage = cur[&#34;inPage&#34;]

                pbAtTop = pageProperties[&#34;pbAtTop&#34;]

                if isPageContainer:
                    cur[&#34;inPage&#34;] = True

                    if pbAtTop:
                        # material before the first pb in the container is not in a page
                        pass
                    else:
                        # the page starts with the container
                        cur[NODE][pageType] = cv.node(pageType)

            sectionModel = self.sectionModel
            sectionProperties = self.sectionProperties

            if sectionModel == &#34;II&#34;:
                chapterSection = self.chapterSection
                chunkSection = self.chunkSection

                if isChapter(cur):
                    cur[&#34;chapterNum&#34;] += 1
                    cur[&#34;prevChapter&#34;] = cur[NODE].get(chapterSection, None)
                    cur[NODE][chapterSection] = cv.node(chapterSection)
                    cv.link(cur[NODE][chapterSection], cur[&#34;danglingSlots&#34;])

                    value = {chapterSection: f&#34;{cur[&#39;chapterNum&#39;]} {tag}&#34;}
                    cv.feature(cur[NODE][chapterSection], **value)
                    cur[&#34;chunkPNum&#34;] = 0
                    cur[&#34;chunkONum&#34;] = 0
                    cur[&#34;prevChunk&#34;] = cur[NODE].get(chunkSection, None)
                    cur[NODE][chunkSection] = cv.node(chunkSection)
                    cv.link(cur[NODE][chunkSection], cur[&#34;danglingSlots&#34;])
                    cur[&#34;danglingSlots&#34;] = set()
                    cur[&#34;infirstChunk&#34;] = True

                # N.B. A node can count both as chapter and as chunk,
                # e.g. a &lt;trailer&gt; sibling of the chapter &lt;div&gt;s
                # A trailer has mixed content, so its subelements aren&#39;t typical chunks.
                if isChunk(cur):
                    if cur[&#34;infirstChunk&#34;]:
                        cur[&#34;infirstChunk&#34;] = False
                    else:
                        cur[NODE][chunkSection] = cv.node(chunkSection)
                        cv.link(cur[NODE][chunkSection], cur[&#34;danglingSlots&#34;])
                        cur[&#34;danglingSlots&#34;] = set()
                    if tag == &#34;p&#34;:
                        cur[&#34;chunkPNum&#34;] += 1
                        cn = cur[&#34;chunkPNum&#34;]
                    else:
                        cur[&#34;chunkONum&#34;] -= 1
                        cn = cur[&#34;chunkONum&#34;]
                    value = {chunkSection: cn}
                    cv.feature(cur[NODE][chunkSection], **value)

                if matchModel(sectionProperties, tag, atts):
                    heading = etree.tostring(
                        xnode, encoding=&#34;unicode&#34;, method=&#34;text&#34;, with_tail=False
                    ).replace(&#34;\n&#34;, &#34; &#34;)
                    value = {chapterSection: heading}
                    cv.feature(cur[NODE][chapterSection], **value)
                    chapterNum = cur[&#34;chapterNum&#34;]
                    if verbose &gt;= 0:
                        console(
                            f&#34;\rchapter {chapterNum:&gt;4} {heading:&lt;50}&#34;, newline=False
                        )
            else:
                chunkSection = self.chunkSection

                if isChunk(cur):
                    cur[&#34;chunkNum&#34;] += 1
                    cur[&#34;prevChunk&#34;] = cur[NODE].get(chunkSection, None)
                    cur[NODE][chunkSection] = cv.node(chunkSection)
                    cv.link(cur[NODE][chunkSection], cur[&#34;danglingSlots&#34;])
                    cur[&#34;danglingSlots&#34;] = set()
                    value = {chunkSection: cur[&#34;chunkNum&#34;]}
                    cv.feature(cur[NODE][chunkSection], **value)

            if tag == TEI_HEADER:
                cur[&#34;inHeader&#34;] = True
                if sectionModel == &#34;II&#34;:
                    value = {chapterSection: &#34;TEI header&#34;}
                    cv.feature(cur[NODE][chapterSection], **value)
            if tag in NOTE_LIKE:
                cur[&#34;inNote&#34;] = True
                if not tokenAsSlot:
                    finishWord(cv, cur, None, None)

            curNode = None

            if makeLineElems:
                if inLine and tag == &#34;lb&#34;:
                    if cur[NODE][lineType] is not None:
                        if cur[&#34;lineAtts&#34;] is not None and len(cur[&#34;lineAtts&#34;]):
                            cv.feature(cur[NODE][lineType], **cur[&#34;lineAtts&#34;])
                        endLine(cv, cur)
                    cur[NODE][lineType] = cv.node(lineType)
                    cur[&#34;lineAtts&#34;] = atts

            if makePageElems:
                if inPage and tag == &#34;pb&#34;:
                    if pbAtTop:
                        if cur[NODE][pageType] is not None:
                            endPage(cv, cur)
                        cur[NODE][pageType] = cv.node(pageType)
                        if len(atts):
                            cv.feature(cur[NODE][pageType], **atts)
                    else:
                        if cur[NODE][pageType] is not None:
                            if cur[&#34;pageAtts&#34;] is not None and len(cur[&#34;pageAtts&#34;]):
                                cv.feature(cur[NODE][pageType], **cur[&#34;pageAtts&#34;])
                            endPage(cv, cur)
                        cur[NODE][pageType] = cv.node(pageType)
                        cur[&#34;pageAtts&#34;] = atts

            isBoundaryElem = (
                makeLineElems and tag == &#34;lb&#34; or makePageElems and tag == &#34;pb&#34;
            )

            if tag not in PASS_THROUGH and not isBoundaryElem:
                cur[&#34;afterSpace&#34;] = False
                cur[NODE][tag] = cv.node(tag)
                curNode = cur[NODE][tag]
                if wordAsSlot:
                    if cur[NODE][WORD]:
                        cv.link(curNode, [cur[NODE][WORD][1]])
                if len(atts):
                    cv.feature(curNode, **atts)
                    if &#34;rend&#34; in atts:
                        rValue = atts[&#34;rend&#34;]
                        r = makeNameLike(rValue)
                        if r:
                            for q in r.split():
                                cur.setdefault(&#34;rend&#34;, {}).setdefault(q, []).append(
                                    True
                                )

            beforeChildrenCustom = getattr(self, &#34;beforeChildrenCustom&#34;, None)
            if beforeChildrenCustom is not None:
                beforeChildrenCustom(cv, cur, xnode, tag, atts)

            if not hasattr(xnode, &#34;target&#34;) and xnode.text:
                textMaterial = WHITE_TRIM_RE.sub(&#34; &#34;, xnode.text)
                if isPure(cur):
                    if textMaterial and textMaterial != &#34; &#34;:
                        console(
                            (
                                &#34;WARNING: Text material at the start of &#34;
                                f&#34;pure-content element &lt;{tag}&gt;&#34;
                            ),
                            error=True,
                        )
                        stack = &#34;-&#34;.join(n[0] for n in cur[XNEST])
                        console(f&#34;\tElement stack: {stack}&#34;, error=True)
                        console(f&#34;\tMaterial: `{textMaterial}`&#34;, error=True)
                else:
                    if tokenAsSlot:
                        addTokens(cv, cur, textMaterial)
                    else:
                        for ch in textMaterial:
                            addSlot(cv, cur, ch)

            return curNode

        def afterChildren(cv, cur, xnode, tag, atts):
            &#34;&#34;&#34;Node actions after dealing with the children, but before the end tag.

            Here we make sure that the newline elements will get their last slot
            having a newline at the end of their `after` feature.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            xnode: object
                An LXML element node.
            tag: string
                The tag of the LXML node.
            atts: string
                The attributes of the LXML node, with namespaces stripped.
            &#34;&#34;&#34;
            chunkSection = self.chunkSection
            makeLineElems = self.makeLineElems

            if makeLineElems:
                lineProperties = self.lineProperties
                lineType = lineProperties[&#34;nodeType&#34;]
                lineElem = lineProperties[&#34;element&#34;]
                lineProperties = self.lineProperties

            makePageElems = self.makePageElems

            if makePageElems:
                pageProperties = self.pageProperties
                pageType = pageProperties[&#34;nodeType&#34;]
                pageProperties = self.pageProperties

            sectionModel = self.sectionModel

            if sectionModel == &#34;II&#34;:
                chapterSection = self.chapterSection

            extraInstructions = self.extraInstructions

            if len(extraInstructions):
                lookupSource(cv, cur, tokenAsSlot, extraInstructions)

            isChap = isChapter(cur)
            isChnk = isChunk(cur)

            afterChildrenCustom = getattr(self, &#34;afterChildrenCustom&#34;, None)
            if afterChildrenCustom is not None:
                afterChildrenCustom(cv, cur, xnode, tag, atts)

            if makeLineElems:
                isLineContainer = tag == lineElem
                inLine = cur[&#34;inLine&#34;]

            if makePageElems:
                isPageContainer = matchModel(pageProperties, tag, atts)
                inPage = cur[&#34;inPage&#34;]

            hasFinishedWord = False

            if makeLineElems and inLine and tag == &#34;lb&#34;:
                pass

            if makePageElems and inPage and tag == &#34;pb&#34;:
                pass

            isBoundaryElem = (
                makeLineElems and tag == &#34;lb&#34; or makePageElems and tag == &#34;pb&#34;
            )

            if makeLineElems and isLineContainer:
                # the page ends with the container
                if cur[NODE][lineType] is not None:
                    endLine(cv, cur)
                cur[&#34;inLine&#34;] = False

            if makePageElems and isPageContainer:
                pbAtTop = pageProperties[&#34;pbAtTop&#34;]
                if pbAtTop:
                    # the page ends with the container
                    if cur[NODE][pageType] is not None:
                        endPage(cv, cur)
                else:
                    # material after the last pb is not in a page
                    if cur[NODE][pageType] is not None:
                        cv.delete(cur[NODE][pageType])
                cur[&#34;inPage&#34;] = False

            if tag not in PASS_THROUGH and not isBoundaryElem:
                curNode = cur[TNEST][-1]
                slots = cv.linked(curNode)
                empty = len(slots) == 0

                newLineTag = tag in NEWLINE_ELEMENTS

                if (
                    newLineTag
                    or isEndInPure(cur)
                    and not hasContinuousAncestor(cur)
                    and not cur[&#34;afterSpace&#34;]
                ) and not empty:
                    spaceChar = &#34;\n&#34; if newLineTag or not hasMixedAncestor(cur) else &#34; &#34;
                    if tokenAsSlot:
                        cv.feature((T, slots[-1]), after=spaceChar)
                    else:
                        finishWord(cv, cur, None, spaceChar)
                        hasFinishedWord = True

                slots = cv.linked(curNode)
                empty = len(slots) == 0

                if empty:
                    lastSlot = addEmpty(cv, cur)
                    if cur[&#34;inHeader&#34;]:
                        cv.feature(lastSlot, is_meta=1)
                    if cur[&#34;inNote&#34;]:
                        cv.feature(lastSlot, is_note=1)
                    # take care that this empty slot falls under all sections
                    # for folders and files this is already guaranteed
                    # We need only to watch out for chapters and chunks
                    if cur[NODE].get(chunkSection, None) is None:
                        prevChunk = cur.get(&#34;prevChunk&#34;, None)
                        if prevChunk is None:
                            cur[&#34;danglingSlots&#34;].add(lastSlot[1])
                        else:
                            cv.link(prevChunk, lastSlot)
                    if sectionModel == &#34;II&#34;:
                        if cur[NODE].get(chapterSection, None) is None:
                            prevChapter = cur.get(&#34;prevChapter&#34;, None)
                            if prevChapter is None:
                                cur[&#34;danglingSlots&#34;].add(lastSlot[1])
                            else:
                                cv.link(prevChapter, lastSlot)

                cv.terminate(curNode)

            if isChnk:
                if tokenAsSlot:
                    addSpace(cv, cur, &#34;\n&#34;)
                else:
                    if not hasFinishedWord:
                        finishWord(cv, cur, None, &#34;\n&#34;)
                cv.terminate(cur[NODE][chunkSection])

            if sectionModel == &#34;II&#34;:
                if isChap:
                    if tokenAsSlot:
                        addSpace(cv, cur, &#34;\n&#34;)
                    else:
                        if not hasFinishedWord:
                            finishWord(cv, cur, None, &#34;\n&#34;)
                    cv.terminate(cur[NODE][chapterSection])

        def afterTag(cv, cur, xnode, tag, atts):
            &#34;&#34;&#34;Node actions after dealing with the children and after the end tag.

            This is the place where we process the `tail` of an LXML node: the
            text material after the element and before the next open/close
            tag of any element.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            xnode: object
                An LXML element node.
            tag: string
                The tag of the LXML node.
            atts: string
                The attributes of the LXML node, with namespaces stripped.
            &#34;&#34;&#34;
            if tag == TEI_HEADER:
                cur[&#34;inHeader&#34;] = False
            elif tag in NOTE_LIKE:
                cur[&#34;inNote&#34;] = False

            if tag not in PASS_THROUGH:
                if &#34;rend&#34; in atts:
                    rValue = atts[&#34;rend&#34;]
                    r = makeNameLike(rValue)
                    if r:
                        for q in r.split():
                            cur[&#34;rend&#34;][q].pop()

            if xnode.tail:
                if tag == &#34;lb&#34; and self.makeLineElems:
                    tail = xnode.tail.lstrip()
                    if not wordAsSlot:
                        pass
                else:
                    tail = xnode.tail

                tailMaterial = WHITE_TRIM_RE.sub(&#34; &#34;, tail)
                if isPure(cur):
                    if tailMaterial and tailMaterial != &#34; &#34;:
                        elem = cur[XNEST][-1][0]
                        console(
                            (
                                &#34;WARNING: Text material after &#34;
                                f&#34;&lt;{tag}&gt; in pure-content element &lt;{elem}&gt;&#34;
                            ),
                            error=True,
                        )
                        stack = &#34;-&#34;.join(cur[XNEST][0])
                        console(f&#34;\tElement stack: {stack}-{tag}&#34;, error=True)
                        console(f&#34;\tMaterial: `{tailMaterial}`&#34;, error=True)
                else:
                    if tokenAsSlot:
                        addTokens(cv, cur, tailMaterial)
                    else:
                        for ch in tailMaterial:
                            addSlot(cv, cur, ch)

            afterTagCustom = getattr(self, &#34;afterTagCustom&#34;, None)
            if afterTagCustom is not None:
                afterTagCustom(cv, cur, xnode, tag, atts)

        def director(cv):
            &#34;&#34;&#34;Director function.

            Here we program a walk through the TEI sources.
            At every step of the walk we fire some actions that build TF nodes
            and assign features for them.

            Because everything is rather dynamic, we generate fairly standard
            metadata for the features, namely a link to the
            [TEI website](https://tei-c.org).

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            &#34;&#34;&#34;
            makeLineElems = self.makeLineElems

            if makeLineElems:
                lineProperties = self.lineProperties
                lineType = lineProperties[&#34;nodeType&#34;]

            makePageElems = self.makePageElems

            if makePageElems:
                pageProperties = self.pageProperties
                pageType = pageProperties[&#34;nodeType&#34;]

            sectionModel = self.sectionModel
            A = self.A
            elementDefs = A.elementDefs

            cur = {}
            cur[&#34;pureElems&#34;] = {
                modelInv[schemaOverride]: {
                    x for (x, (typ, mixed)) in eDefs.items() if not mixed
                }
                for (schemaOverride, eDefs) in elementDefs.items()
            }
            cur[&#34;mixedElems&#34;] = {
                modelInv[schemaOverride]: {
                    x for (x, (typ, mixed)) in eDefs.items() if mixed
                }
                for (schemaOverride, eDefs) in elementDefs.items()
            }
            cur[NODE] = {}

            if sectionModel == &#34;I&#34;:
                folderSection = self.folderSection
                fileSection = self.fileSection

                i = 0
                for xmlFolder, xmlFiles in self.getXML():
                    msg = &#34;Start &#34; if verbose &gt;= 0 else &#34;\t&#34;
                    console(f&#34;{msg}folder {xmlFolder}:&#34;)

                    cur[NODE][folderSection] = cv.node(folderSection)
                    value = {folderSection: xmlFolder}
                    cv.feature(cur[NODE][folderSection], **value)

                    j = 0
                    cr = &#34;&#34;
                    nl = True

                    for xmlFile in xmlFiles:
                        i += 1
                        j += 1
                        if j &gt; PROGRESS_LIMIT:
                            cr = &#34;\r&#34;
                            nl = False

                        cur[&#34;xmlFile&#34;] = xmlFile
                        xmlPath = f&#34;{teiPath}/{xmlFolder}/{xmlFile}&#34;
                        (model, adapt, tpl) = self.getSwitches(xmlPath)
                        cur[&#34;model&#34;] = model
                        cur[&#34;template&#34;] = tpl
                        cur[&#34;adaptation&#34;] = adapt
                        modelRep = model or &#34;TEI&#34;
                        tplRep = tpl or &#34;&#34;
                        adRep = adapt or &#34;&#34;
                        label = f&#34;{modelRep:&lt;12} {adRep:&lt;12} {tplRep:&lt;12}&#34;
                        if verbose &gt;= 0:
                            console(
                                f&#34;{cr}{i:&gt;4} {label} {xmlFile:&lt;50}&#34;,
                                newline=nl,
                            )

                        cur[NODE][fileSection] = cv.node(fileSection)
                        ids[xmlFile][&#34;&#34;] = cur[NODE][fileSection]
                        value = {fileSection: xmlFile.removesuffix(&#34;.xml&#34;)}
                        cv.feature(cur[NODE][fileSection], **value)
                        if tpl:
                            cur[NODE][tpl] = cv.node(tpl)
                            cv.feature(cur[NODE][tpl], **value)

                        with fileOpen(xmlPath) as fh:
                            text = fh.read()
                            if transformFunc is not None:
                                text = transformFunc(text)
                            tree = etree.parse(text, parser)
                            root = tree.getroot()

                            if makeLineElems:
                                cur[NODE][lineType] = None
                                cur[&#34;inLine&#34;] = False
                                cur[&#34;lineAtts&#34;] = None

                            if makePageElems:
                                cur[NODE][pageType] = None
                                cur[&#34;inPage&#34;] = False
                                cur[&#34;pageAtts&#34;] = None

                            if not tokenAsSlot:
                                cur[NODE][WORD] = None
                            cur[&#34;inHeader&#34;] = False
                            cur[&#34;inNote&#34;] = False
                            cur[XNEST] = []
                            cur[TNEST] = []
                            cur[TSIB] = []
                            cur[&#34;chunkNum&#34;] = 0
                            cur[&#34;prevChunk&#34;] = None
                            cur[&#34;danglingSlots&#34;] = set()
                            cur[&#34;prevWord&#34;] = None
                            cur[&#34;wordStr&#34;] = &#34;&#34;
                            cur[&#34;afterStr&#34;] = &#34;&#34;
                            cur[&#34;afterSpace&#34;] = True
                            cur[&#34;chunkElems&#34;] = set()
                            walkNode(cv, cur, root)

                        if not tokenAsSlot:
                            addSlot(cv, cur, None)
                        if tpl:
                            cv.terminate(cur[NODE][tpl])
                        cv.terminate(cur[NODE][fileSection])

                    if verbose &gt;= 0:
                        console(&#34;&#34;)
                        console(f&#34;End   folder {xmlFolder}&#34;)

                    cv.terminate(cur[NODE][folderSection])

            elif sectionModel == &#34;II&#34;:
                xmlFile = self.getXML()
                if xmlFile is None:
                    console(&#34;No XML files found!&#34;, error=True)
                    return False

                xmlPath = f&#34;{teiPath}/{xmlFile}&#34;
                (cur[&#34;model&#34;], cur[&#34;adaptation&#34;], cur[&#34;template&#34;]) = self.getSwitches(
                    xmlPath
                )

                with fileOpen(f&#34;{teiPath}/{xmlFile}&#34;) as fh:
                    cur[&#34;xmlFile&#34;] = xmlFile
                    text = fh.read()
                    if transformFunc is not None:
                        text = transformFunc(text)
                    tree = etree.parse(text, parser)
                    root = tree.getroot()

                    if makeLineElems:
                        cur[NODE][lineType] = None
                        cur[&#34;inLine&#34;] = False
                        cur[&#34;lineAtts&#34;] = None

                    if makePageElems:
                        cur[NODE][pageType] = None
                        cur[&#34;inPage&#34;] = False
                        cur[&#34;pageAtts&#34;] = None

                    if not tokenAsSlot:
                        cur[NODE][WORD] = None
                    cur[&#34;inHeader&#34;] = False
                    cur[&#34;inNote&#34;] = False
                    cur[XNEST] = []
                    cur[TNEST] = []
                    cur[TSIB] = []
                    cur[&#34;chapterNum&#34;] = 0
                    cur[&#34;chunkPNum&#34;] = 0
                    cur[&#34;chunkONum&#34;] = 0
                    cur[&#34;prevChunk&#34;] = None
                    cur[&#34;prevChapter&#34;] = None
                    cur[&#34;danglingSlots&#34;] = set()
                    cur[&#34;prevWord&#34;] = None
                    cur[&#34;wordStr&#34;] = &#34;&#34;
                    cur[&#34;afterStr&#34;] = &#34;&#34;
                    cur[&#34;afterSpace&#34;] = True
                    cur[&#34;chunkElems&#34;] = set()
                    cur[&#34;chapterElems&#34;] = set()
                    for child in root.iterchildren(tag=etree.Element):
                        walkNode(cv, cur, child)

                if not tokenAsSlot:
                    addSlot(cv, cur, None)

            if verbose &gt;= 0:
                console(&#34;&#34;)

            if verbose &gt;= 0:
                console(&#34;Resolving links into edges ...&#34;)

            unresolvedRefs = {}
            unresolved = 0
            unresolvedUnique = 0
            resolved = 0
            resolvedUnique = 0

            for att, attRefs in refs.items():
                feature = f&#34;link_{att}&#34;
                edgeFeat = {feature: None}

                for (targetFile, targetId), sourceNodes in attRefs.items():
                    nSourceNodes = len(sourceNodes)
                    targetNode = ids[targetFile].get(targetId, None)
                    if targetNode is None:
                        unresolvedRefs.setdefault(targetFile, set()).add(targetId)
                        unresolvedUnique += 1
                        unresolved += nSourceNodes
                    else:
                        for sourceNode in sourceNodes:
                            cv.edge(sourceNode, targetNode, **edgeFeat)
                        resolvedUnique += 1
                        resolved += nSourceNodes

            if verbose &gt;= 0:
                console(f&#34;\t{resolvedUnique} in {resolved} reference(s) resolved&#34;)
                if unresolvedRefs:
                    console(
                        f&#34;\t{unresolvedUnique} in {unresolved} reference(s): &#34;
                        &#34;could not be resolved&#34;
                    )
                    if verbose == 1:
                        for targetFile, targetIds in sorted(unresolvedRefs.items()):
                            examples = &#34; &#34;.join(sorted(targetIds)[0:3])
                            console(f&#34;\t\t{targetFile}: {len(targetIds)} x: {examples}&#34;)

            for fName in featureMeta:
                if not cv.occurs(fName):
                    cv.meta(fName)
            for fName in cv.features():
                if fName not in featureMeta:
                    if fName.startswith(&#34;rend_&#34;):
                        r = fName[5:]
                        cv.meta(
                            fName,
                            description=f&#34;whether text is to be rendered as {r}&#34;,
                            valueType=&#34;int&#34;,
                            conversionMethod=CM_LITC,
                            conversionCode=CONVERSION_METHODS[CM_LITC],
                        )
                        intFeatures.add(fName)
                    elif fName.startswith(&#34;link_&#34;):
                        r = fName[5:]
                        cv.meta(
                            fName,
                            description=(
                                f&#34;links to node identified by xml:id in attribute {r}&#34;
                            ),
                            valueType=&#34;str&#34;,
                            conversionMethod=CM_LITP,
                            conversionCode=CONVERSION_METHODS[CM_LITP],
                        )
                    else:
                        cv.meta(
                            fName,
                            description=f&#34;this is TEI attribute {fName}&#34;,
                            valueType=&#34;str&#34;,
                            conversionMethod=CM_LIT,
                            conversionCode=CONVERSION_METHODS[CM_LIT],
                        )

            levelConstraints = [&#34;note &lt; chunk, p&#34;, &#34;salute &lt; opener, closer&#34;]
            if &#34;chapterElems&#34; in cur:
                for elem in cur[&#34;chapterElems&#34;]:
                    levelConstraints.append(f&#34;{elem} &lt; chapter&#34;)
            if &#34;chunkElems&#34; in cur:
                for elem in cur[&#34;chunkElems&#34;]:
                    levelConstraints.append(f&#34;{elem} &lt; chunk&#34;)

            levelConstraints = &#34;; &#34;.join(levelConstraints)

            cv.meta(&#34;otext&#34;, levelConstraints=levelConstraints)

            if verbose == 1:
                console(&#34;source reading done&#34;)
            return True

        return director

    def convertTask(self):
        &#34;&#34;&#34;Implementation of the &#34;convert&#34; task.

        It sets up the `tf.convert.walker` machinery and runs it.

        Returns
        -------
        boolean
            Whether the conversion was successful.
        &#34;&#34;&#34;
        if not self.importOK():
            return

        if not self.good:
            return

        procins = self.procins
        verbose = self.verbose
        slotType = self.slotType
        generic = self.generic
        otext = self.otext
        featureMeta = self.featureMeta
        intFeatures = self.intFeatures

        makeLineElems = self.makeLineElems
        lineModel = self.lineModel
        if makeLineElems:
            lineProperties = self.lineProperties
            lineType = lineProperties[&#34;nodeType&#34;]

        makePageElems = self.makePageElems
        pageModel = self.pageModel

        if makePageElems:
            pageProperties = self.pageProperties
            pageType = pageProperties[&#34;nodeType&#34;]
            pbAtTop = pageProperties[&#34;pbAtTop&#34;] if makePageElems else None

        tfPath = self.tfPath
        teiPath = self.teiPath

        if verbose &gt;= 0:
            if verbose == 1:
                console(f&#34;TEI to TF converting: {ux(teiPath)} =&gt; {ux(tfPath)}&#34;)
            if makeLineElems:
                lbRep = f&#34; with {lineType} nodes for lines between lb elements&#34;
                console(f&#34;Line model {lineModel}{lbRep}&#34;)

            if makePageElems:
                wrt = &#34;started&#34; if pbAtTop else &#34;ended&#34;
                pbRep = f&#34; with {pageType} nodes for pages {wrt} by pb elements&#34;
                console(f&#34;Page model {pageModel}{pbRep}&#34;)

            console(
                f&#34;Processing instructions are {&#39;treated&#39; if procins else &#39;ignored&#39;}&#34;
            )

        initTree(tfPath, fresh=True, gentle=True)

        cv = self.getConverter()

        self.good = cv.walk(
            self.getDirector(),
            slotType,
            otext=otext,
            generic=generic,
            intFeatures=intFeatures,
            featureMeta=featureMeta,
            generateTf=True,
        )

    def loadTask(self):
        &#34;&#34;&#34;Implementation of the &#34;load&#34; task.

        It loads the TF data that resides in the directory where the &#34;convert&#34; task
        deliver its results.

        During loading there are additional checks. If they succeed, we have evidence
        that we have a valid TF dataset.

        Also, during the first load intensive pre-computation of TF data takes place,
        the results of which will be cached in the invisible `.tf` directory there.

        That makes the TF data ready to be loaded fast, next time it is needed.

        Returns
        -------
        boolean
            Whether the loading was successful.
        &#34;&#34;&#34;
        if not self.importOK():
            return

        if not self.good:
            return

        tfPath = self.tfPath
        verbose = self.verbose
        silent = AUTO if verbose == 1 else TERSE if verbose == 0 else DEEP

        if not dirExists(tfPath):
            console(f&#34;Directory {ux(tfPath)} does not exist.&#34;, error=True)
            console(&#34;No TF found, nothing to load&#34;, error=True)
            self.good = False
            return

        TF = Fabric(locations=[tfPath], silent=silent)
        allFeatures = TF.explore(silent=True, show=True)
        loadableFeatures = allFeatures[&#34;nodes&#34;] + allFeatures[&#34;edges&#34;]
        api = TF.load(loadableFeatures, silent=silent)
        if api:
            if verbose &gt;= 0:
                console(f&#34;max node = {api.F.otype.maxNode}&#34;)
            self.good = True
            return

        self.good = False

    # APP CREATION/UPDATING

    def appTask(self, tokenBased=False):
        &#34;&#34;&#34;Implementation of the &#34;app&#34; task.

        It creates / updates a corpus-specific app plus specific documentation files.
        There should be a valid TF dataset in place, because some
        settings in the app derive from it.

        It will also read custom additions that are present in the target app directory.
        These files are:

        *   `about_custom.md`:
            A markdown file with specific colophon information about the dataset.
            In the generated file, this information will be put at the start.
        *   `transcription_custom.md`:
            A markdown file with specific encoding information about the dataset.
            In the generated file, this information will be put at the start.
        *   `config_custom.yaml`:
            A YAML file with configuration data that will be *merged* into the generated
            config.yaml.
        *   `app_custom.py`:
            A python file with named snippets of code to be inserted
            at corresponding places in the generated `app.py`
        *   `display_custom.css`:
            Additional CSS definitions that will be appended to the generated
            `display.css`.

        If the TF app for this resource needs custom code, this is the way to retain
        that code between automatic generation of files.

        Returns
        -------
        boolean
            Whether the operation was successful.
        &#34;&#34;&#34;
        if not self.importOK():
            return

        if not self.good:
            return

        verbose = self.verbose

        refDir = self.refDir
        myDir = self.myDir
        procins = self.procins
        wordAsSlot = self.wordAsSlot
        tokenAsSlot = self.tokenAsSlot
        charAsSlot = self.charAsSlot
        parentEdges = self.parentEdges
        siblingEdges = self.siblingEdges
        sectionModel = self.sectionModel
        sectionProperties = self.sectionProperties
        tfVersion = self.tfVersion

        # key | parentDir | file | template based

        # if parentDir is a tuple, the first part is the parentDir of the source
        # end the second part is the parentDir of the destination

        itemSpecs = (
            (&#34;about&#34;, &#34;docs&#34;, &#34;about.md&#34;, False),
            (&#34;trans&#34;, (&#34;app&#34;, &#34;docs&#34;), &#34;transcription.md&#34;, False),
            (&#34;logo&#34;, &#34;app/static&#34;, &#34;logo.png&#34;, True),
            (&#34;display&#34;, &#34;app/static&#34;, &#34;display.css&#34;, False),
            (&#34;config&#34;, &#34;app&#34;, &#34;config.yaml&#34;, False),
            (&#34;app&#34;, &#34;app&#34;, &#34;app.py&#34;, False),
        )
        genTasks = {
            s[0]: dict(parentDir=s[1], file=s[2], justCopy=s[3]) for s in itemSpecs
        }
        cssInfo = makeCssInfo()

        version = tfVersion.removesuffix(PRE) if tokenBased else tfVersion

        def createConfig(sourceText, customText):
            text = sourceText.replace(&#34;«version»&#34;, f&#39;&#34;{version}&#34;&#39;)

            settings = readYaml(text=text, plain=True)
            settings.setdefault(&#34;provenanceSpec&#34;, {})[&#34;branch&#34;] = BRANCH_DEFAULT_NEW

            if tokenBased:
                if &#34;typeDisplay&#34; in settings and &#34;word&#34; in settings[&#34;typeDisplay&#34;]:
                    del settings[&#34;typeDisplay&#34;][&#34;word&#34;]

            customSettings = (
                {} if not customText else readYaml(text=customText, plain=True)
            )

            mergeDict(settings, customSettings)

            text = writeYaml(settings)

            return text

        def createDisplay(sourceText, customText):
            &#34;&#34;&#34;Copies and tweaks the display.css file of an TF app.

            We generate CSS code for a certain text formatting styles,
            triggered by `rend` attributes in the source.
            &#34;&#34;&#34;

            css = sourceText.replace(&#34;«rends»&#34;, cssInfo)
            return f&#34;{css}\n\n{customText}\n&#34;

        def createApp(sourceText, customText):
            &#34;&#34;&#34;Copies and tweaks the app.py file of an TF app.

            The template app.py provides text formatting functions.
            It retrieves text from features, but that is dependent on
            the settings of the conversion, in particular whether we have words as
            slots or characters.

            Depending on that we insert some code in the template.

            The template contains the string `F.matérial`, and it will be replaced
            by something like

            ```
            F.ch.v(n)
            ```

            or

            ```
            f&#34;{F.str.v(n)}{F.after.v(n)}&#34;
            ```

            That&#39;s why the variable `materialCode` in the body gets a rather
            unusual value: it is interpreted later on as code.
            &#34;&#34;&#34;

            materialCode = (
                &#39;&#39;&#39;F.ch.v(n) or &#34;&#34;&#39;&#39;&#39;
                if charAsSlot or tokenBased
                else &#34;&#34;&#34;f&#39;{F.str.v(n) or &#34;&#34;}{F.after.v(n) or &#34;&#34;}&#39;&#34;&#34;&#34;
            )
            rendValues = repr(KNOWN_RENDS)

            code = sourceText.replace(&#34;F.matérial&#34;, materialCode)
            code = code.replace(&#39;&#34;rèndValues&#34;&#39;, rendValues)

            hookStartRe = re.compile(r&#34;^# DEF (import|init|extra)\s*$&#34;, re.M)
            hookEndRe = re.compile(r&#34;^# END DEF\s*$&#34;, re.M)
            hookInsertRe = re.compile(r&#34;^\s*# INSERT (import|init|extra)\s*$&#34;, re.M)

            custom = {}
            section = None

            for line in (customText or &#34;&#34;).split(&#34;\n&#34;):
                line = line.rstrip()

                if section is None:
                    match = hookStartRe.match(line)
                    if match:
                        section = match.group(1)
                        custom[section] = []
                else:
                    match = hookEndRe.match(line)
                    if match:
                        section = None
                    else:
                        custom[section].append(line)

            codeLines = []

            for line in code.split(&#34;\n&#34;):
                line = line.rstrip()

                match = hookInsertRe.match(line)
                if match:
                    section = match.group(1)
                    codeLines.extend(custom.get(section, []))
                else:
                    codeLines.append(line)

            return &#34;\n&#34;.join(codeLines) + &#34;\n&#34;

        def createTranscription(sourceText, customText):
            &#34;&#34;&#34;Copies and tweaks the transcription.md file for a TF corpus.&#34;&#34;&#34;
            org = self.org
            repo = self.repo
            relative = self.relative
            intFeatures = self.intFeatures
            extra = self.extra

            def metaRep(feat, meta):
                valueType = &#34;int&#34; if feat in intFeatures else &#34;str&#34;
                description = meta.get(&#34;description&#34;, &#34;&#34;)
                extraFieldRep = &#34;\n&#34;.join(
                    f&#34;*   `{field}`: `{value}`&#34;
                    for (field, value) in meta.items()
                    if field not in {&#34;description&#34;, &#34;valueType&#34;}
                )

                return (
                    f&#34;&#34;&#34;{description}\n&#34;&#34;&#34;
                    f&#34;&#34;&#34;The values of this feature have type {valueType}.\n&#34;&#34;&#34;
                    f&#34;&#34;&#34;{extraFieldRep}&#34;&#34;&#34;
                )

            extra = &#34;\n\n&#34;.join(
                f&#34;## `{feat}`\n\n{metaRep(feat, info[&#39;meta&#39;])}\n&#34;
                for (feat, info) in extra.items()
            )

            text = (
                dedent(
                    f&#34;&#34;&#34;
                # Corpus {org} - {repo}{relative}

                &#34;&#34;&#34;
                )
                + tweakTrans(
                    sourceText,
                    procins,
                    wordAsSlot,
                    tokenAsSlot,
                    charAsSlot,
                    parentEdges,
                    siblingEdges,
                    tokenBased,
                    sectionModel,
                    sectionProperties,
                    REND_DESC,
                    extra,
                )
                + dedent(
                    &#34;&#34;&#34;

                    ## See also

                    *   [about](about.md)
                    &#34;&#34;&#34;
                )
            )
            return f&#34;{text}\n\n{customText}\n&#34;

        def createAbout(sourceText, customText):
            org = self.org
            repo = self.repo
            relative = self.relative
            generic = self.generic
            if tokenBased:
                generic[&#34;version&#34;] = version

            generic = &#34;\n\n&#34;.join(
                f&#34;## `{key}`\n\n`{value}`\n&#34; for (key, value) in generic.items()
            )

            return f&#34;{customText}\n\n{sourceText}\n\n&#34; + (
                dedent(
                    f&#34;&#34;&#34;
                # Corpus {org} - {repo}{relative}

                &#34;&#34;&#34;
                )
                + generic
                + dedent(
                    &#34;&#34;&#34;

                    ## Conversion

                    Converted from TEI to TF

                    ## See also

                    *   [transcription](transcription.md)
                    &#34;&#34;&#34;
                )
            )

        extraRep = &#34; with NLP output &#34; if tokenBased else &#34;&#34;

        if verbose &gt;= 0:
            console(f&#34;App updating {extraRep} ...&#34;)

        for name, info in genTasks.items():
            parentDir = info[&#34;parentDir&#34;]
            (sourceBit, targetBit) = (
                parentDir if type(parentDir) is tuple else (parentDir, parentDir)
            )
            file = info[FILE]
            fileParts = file.rsplit(&#34;.&#34;, 1)
            if len(fileParts) == 1:
                fileParts = [file, &#34;&#34;]
            (fileBase, fileExt) = fileParts
            if fileExt:
                fileExt = f&#34;.{fileExt}&#34;
            targetDir = f&#34;{refDir}/{targetBit}&#34;
            itemTarget = f&#34;{targetDir}/{file}&#34;
            itemCustom = f&#34;{targetDir}/{fileBase}_custom{fileExt}&#34;
            itemPre = f&#34;{targetDir}/{fileBase}_orig{fileExt}&#34;

            justCopy = info[&#34;justCopy&#34;]
            teiDir = f&#34;{myDir}/{sourceBit}&#34;
            itemSource = f&#34;{teiDir}/{file}&#34;

            # If there is custom info, we do not have to preserve the previous version.
            # Otherwise we save the target before overwriting it; # unless it
            # has been saved before

            preExists = fileExists(itemPre)
            targetExists = fileExists(itemTarget)
            customExists = fileExists(itemCustom)

            msg = &#34;&#34;

            if justCopy:
                if targetExists:
                    msg = &#34;(already exists, not overwritten)&#34;
                    safe = False
                else:
                    msg = &#34;(copied)&#34;
                    safe = True
            else:
                if targetExists:
                    if customExists:
                        msg = &#34;(generated with custom info)&#34;
                    else:
                        if preExists:
                            msg = &#34;(no custom info, older original exists)&#34;
                        else:
                            msg = &#34;(no custom info, original preserved)&#34;
                            fileCopy(itemTarget, itemPre)
                else:
                    msg = &#34;(created)&#34;

            initTree(targetDir, fresh=False)

            if justCopy:
                if safe:
                    fileCopy(itemSource, itemTarget)
            else:
                if fileExists(itemSource):
                    with fileOpen(itemSource) as fh:
                        sourceText = fh.read()
                else:
                    sourceText = &#34;&#34;

                if fileExists(itemCustom):
                    with fileOpen(itemCustom) as fh:
                        customText = fh.read()
                else:
                    customText = &#34;&#34;

                targetText = (
                    createConfig
                    if name == &#34;config&#34;
                    else createApp
                    if name == &#34;app&#34;
                    else createDisplay
                    if name == &#34;display&#34;
                    else createTranscription
                    if name == &#34;trans&#34;
                    else createAbout
                    if name == &#34;about&#34;
                    else fileCopy  # this cannot occur because justCopy is False
                )(sourceText, customText)

                with fileOpen(itemTarget, mode=&#34;w&#34;) as fh:
                    fh.write(targetText)

            if verbose &gt;= 0:
                console(f&#34;\t{ux(itemTarget):30} {msg}&#34;)

        if verbose &gt;= 0:
            console(&#34;Done&#34;)
        else:
            console(f&#34;App updated{extraRep}&#34;)

    # START the TEXT-FABRIC BROWSER on this CORPUS

    def browseTask(self):
        &#34;&#34;&#34;Implementation of the &#34;browse&#34; task.

        It gives a shell command to start the TF browser on
        the newly created corpus.
        There should be a valid TF dataset and app configuration in place

        Returns
        -------
        boolean
            Whether the operation was successful.
        &#34;&#34;&#34;
        if not self.importOK():
            return

        if not self.good:
            return

        org = self.org
        repo = self.repo
        relative = self.relative
        backend = self.backend
        tfVersion = self.tfVersion

        backendOpt = &#34;&#34; if backend == &#34;github&#34; else f&#34;--backend={backend}&#34;
        versionOpt = f&#34;--version={tfVersion}&#34;
        versionOpt = &#34;&#34;
        try:
            run(
                (
                    f&#34;tf {org}/{repo}{relative}:clone --checkout=clone &#34;
                    f&#34;{versionOpt} {backendOpt}&#34;
                ),
                shell=True,
            )
        except KeyboardInterrupt:
            pass

    def task(
        self,
        check=False,
        convert=False,
        load=False,
        app=False,
        apptoken=False,
        browse=False,
        verbose=None,
        validate=None,
    ):
        &#34;&#34;&#34;Carry out any task, possibly modified by any flag.

        This is a higher level function that can execute a selection of tasks.

        The tasks will be executed in a fixed order:
        `check`, `convert`, `load`, `app`, `apptoken`, `browse`.
        But you can select which one(s) must be executed.

        If multiple tasks must be executed and one fails, the subsequent tasks
        will not be executed.

        Parameters
        ----------
        check: boolean, optional False
            Whether to carry out the `check` task.
        convert: boolean, optional False
            Whether to carry out the `convert` task.
        load: boolean, optional False
            Whether to carry out the `load` task.
        app: boolean, optional False
            Whether to carry out the `app` task.
        apptoken: boolean, optional False
            Whether to carry out the `apptoken` task.
        browse: boolean, optional False
            Whether to carry out the `browse` task&#34;
        verbose: integer, optional -1
            Produce no (-1), some (0) or many (1) progress and reporting messages
        validate: boolean, optional True
            Whether to perform XML validation during the check task

        Returns
        -------
        boolean
            Whether all tasks have executed successfully.
        &#34;&#34;&#34;
        if not self.importOK():
            return

        if verbose is not None:
            verboseSav = self.verbose
            self.verbose = verbose

        if validate is not None:
            self.validate = validate

        if not self.good:
            return False

        for condition, method, kwargs in (
            (check, self.checkTask, {}),
            (convert, self.convertTask, {}),
            (load, self.loadTask, {}),
            (app, self.appTask, {}),
            (apptoken, self.appTask, dict(tokenBased=True)),
            (browse, self.browseTask, {}),
        ):
            if condition:
                method(**kwargs)
                if not self.good:
                    break

        if verbose is not None:
            self.verbose = verboseSav
        return self.good


def main():
    (good, tasks, params, flags) = readArgs(
        &#34;tf-fromtei&#34;, HELP, TASKS, PARAMS, FLAGS, notInAll=TASKS_EXCLUDED
    )
    if not good:
        return False

    Obj = TEI(**params, **flags)
    Obj.task(**tasks, **flags)

    return Obj.good


if __name__ == &#34;__main__&#34;:
    sys.exit(0 if main() else 1)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.convert.tei.getRefs"><code class="name flex">
<span>def <span class="ident">getRefs</span></span>(<span>tag, atts, xmlFile)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/331baa8460d48d644338cf8e085d696cb9cbdbb0/tf/convert/tei.py#L834-L851" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getRefs(tag, atts, xmlFile):
    refAtt = REFERENCING.get(tag, None)
    result = []

    if refAtt is not None:
        refVal = atts.get(refAtt, None)
        if refVal is not None and not refVal.startswith(&#34;http&#34;):
            for refv in refVal.split():
                parts = refv.split(&#34;#&#34;, 1)
                if len(parts) == 1:
                    targetFile = refv
                    targetId = &#34;&#34;
                else:
                    (targetFile, targetId) = parts
                if targetFile == &#34;&#34;:
                    targetFile = xmlFile
                result.append((refAtt, targetFile, targetId))
    return result</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/331baa8460d48d644338cf8e085d696cb9cbdbb0/tf/convert/tei.py#L4632-L4642" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def main():
    (good, tasks, params, flags) = readArgs(
        &#34;tf-fromtei&#34;, HELP, TASKS, PARAMS, FLAGS, notInAll=TASKS_EXCLUDED
    )
    if not good:
        return False

    Obj = TEI(**params, **flags)
    Obj.task(**tasks, **flags)

    return Obj.good</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.makeCssInfo"><code class="name flex">
<span>def <span class="ident">makeCssInfo</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Make the CSS info for the style sheet.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/331baa8460d48d644338cf8e085d696cb9cbdbb0/tf/convert/tei.py#L817-L831" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeCssInfo():
    &#34;&#34;&#34;Make the CSS info for the style sheet.&#34;&#34;&#34;
    rends = &#34;&#34;

    for rend, (description, css) in sorted(CSS_REND.items()):
        aliases = CSS_REND_ALIAS.get(rend, &#34;&#34;)
        aliases = sorted(set(aliases.split()) | {rend})
        for alias in aliases:
            KNOWN_RENDS.add(alias)
            REND_DESC[alias] = description
        selector = &#34;,&#34;.join(f&#34;.r_{alias}&#34; for alias in aliases)
        contribution = f&#34;\n{selector} {{{css}}}\n&#34;
        rends += contribution

    return rends</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.convert.tei.TEI"><code class="flex name class">
<span>class <span class="ident">TEI</span></span>
<span>(</span><span>tei='latest', tf='latest', validate=True, verbose=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts TEI to TF.</p>
<p>For documentation of the resulting encoding, read the
<a href="https://github.com/annotation/text-fabric/blob/master/tf/convert/app/transcription.md">transcription template</a>.</p>
<p>Below we describe how to control the conversion machinery.</p>
<p>We adopt a fair bit of "convention over configuration" here, in order to lessen
the burden for the user of specifying so many details.</p>
<p>Based on current directory from where the script is called,
it defines all the ingredients to carry out
a <code><a title="tf.convert.walker" href="walker.html">tf.convert.walker</a></code> conversion of the TEI input.</p>
<p>This function is assumed to work in the context of a repository,
i.e. a directory on your computer relative to which the input directory exists,
and various output directories: <code><a title="tf" href="../index.html">tf</a></code>, <code>app</code>, <code>docs</code>.</p>
<p>Your current directory must be at</p>
<pre><code>~/backend/org/repo/relative
</code></pre>
<p>where</p>
<ul>
<li><code>~</code> is your home directory;</li>
<li><code>backend</code> is an online back-end name,
like <code>github</code>, <code>gitlab</code>, <code>git.huc.knaw.nl</code>;</li>
<li><code>org</code> is an organization, person, or group in the back-end;</li>
<li><code>repo</code> is a repository in the <code>org</code>.</li>
<li><code>relative</code> is a directory path within the repo (0 or more components)</li>
</ul>
<p>This is only about the directory structure on your local computer;
it is not required that you have online incarnations of your repository
in that back-end.
Even your local repository does not have to be a git repository.</p>
<p>The only thing that matters is that the full path to your repo can be parsed
as a sequence of <code>home/backend/org/repo/relative</code>.</p>
<p>Relative to this directory the program expects and creates
input / output directories.</p>
<h2 id="input-directories">Input directories</h2>
<h3 id="tei"><code>tei</code></h3>
<p><em>Location of the TEI-XML sources.</em></p>
<p><strong>If it does not exist, the program aborts with an error.</strong></p>
<p>Several levels of subdirectories are assumed:</p>
<ol>
<li>the version of the source (this could be a date string).</li>
<li>volumes / collections of documents. The subdirectory <code>__ignore__</code> is ignored.</li>
<li>the TEI documents themselves, conforming to the TEI schema or some
customization of it.</li>
</ol>
<h3 id="schema"><code>schema</code></h3>
<p><em>TEI or other XML schemas against which the sources can be validated.</em></p>
<p>They should be XSD or RNG files.</p>
<div class="admonition note">
<p class="admonition-title">Multiple XSD files</p>
<p>When you started with a RNG file and used <code><a title="tf.tools.xmlschema" href="../tools/xmlschema.html">tf.tools.xmlschema</a></code> to
convert it to XSD, you may have got multiple XSD files.
One of them has the same base name as the original RNG file,
and you should pass that name. It will import the remaining XSD files,
so do not throw them away.</p>
</div>
<p>We use these files as custom TEI schemas,
but to be sure, we still analyse the full TEI schema and
use the schemas here as a set of overriding element definitions.</p>
<h2 id="output-directories">Output directories</h2>
<h3 id="report"><code>report</code></h3>
<p>Directory to write the results of the <code>check</code> task to: an inventory
of elements / attributes encountered, and possible validation errors.
If the directory does not exist, it will be created.
The default value is <code>.</code> (i.e. the current directory in which
the script is invoked).</p>
<h3 id="tf"><code><a title="tf" href="../index.html">tf</a></code></h3>
<p>The directory under which the TF output file (with extension <code>.<a title="tf" href="../index.html">tf</a></code>)
are placed.
If it does not exist, it will be created.
The TF files will be generated in a folder named by a version number,
passed as <code>tfVersion</code>.</p>
<h3 id="app-and-docs"><code>app</code> and <code>docs</code></h3>
<p>Location of additional TF app configuration and documentation files.
If they do not exist, they will be created with some sensible default
settings and generated documentation.
These settings can be overridden in the <code>app/config_custom.yaml</code> file.
Also a default <code>display.css</code> file and a logo are added.</p>
<p>Custom content for these files can be provided in files
with <code>_custom</code> appended to their base name.</p>
<h3 id="docs"><code>docs</code></h3>
<p>Location of additional documentation.
This can be generated or hand-written material, or a mixture of the two.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tei</code></strong> :&ensp;<code>string</code>, optional <code>""</code></dt>
<dd>
<p>If empty, use the latest version under the <code>tei</code> directory with sources.
Otherwise it should be a valid integer, and it is the index in the
sorted list of versions there.</p>
<ul>
<li><code>0</code> or <code>latest</code>: latest version;</li>
<li><code>-1</code>, <code>-2</code>, &hellip; : previous version, version before previous, &hellip;;</li>
<li><code>1</code>, <code>2</code>, &hellip;: first version, second version, ....</li>
<li>everything else that is not a number is an explicit version</li>
</ul>
<p>If the value cannot be parsed as an integer, it is used as the exact
version name.</p>
</dd>
<dt><strong><code>tf</code></strong> :&ensp;<code>string</code>, optional <code>""</code></dt>
<dd>
<p>If empty, the TF version used will be the latest one under the <code><a title="tf" href="../index.html">tf</a></code>
directory. If the parameter <code>prelim</code> was used in the initialization of
the TEI object, only versions ending in <code>pre</code> will be taken into account.</p>
<p>If it can be parsed as the integers 1, 2, or 3 it will bump the latest
relevant TF version:</p>
<ul>
<li><code>0</code> or <code>latest</code>: overwrite the latest version</li>
<li><code>1</code> will bump the major version</li>
<li><code>2</code> will bump the intermediate version</li>
<li><code>3</code> will bump the minor version</li>
<li>everything else is an explicit version</li>
</ul>
<p>Otherwise, the value is taken as the exact version name.</p>
</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>integer</code>, optional <code>-1</code></dt>
<dd>Produce no (-1), some (0) or many (1) progress and reporting messages</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/331baa8460d48d644338cf8e085d696cb9cbdbb0/tf/convert/tei.py#L854-L4629" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class TEI(CheckImport):
    def __init__(
        self,
        tei=PARAMS[&#34;tei&#34;][1],
        tf=PARAMS[&#34;tf&#34;][1],
        validate=PARAMS[&#34;validate&#34;][1],
        verbose=FLAGS[&#34;verbose&#34;][1],
    ):
        &#34;&#34;&#34;Converts TEI to TF.

        For documentation of the resulting encoding, read the
        [transcription template](https://github.com/annotation/text-fabric/blob/master/tf/convert/app/transcription.md).

        Below we describe how to control the conversion machinery.

        We adopt a fair bit of &#34;convention over configuration&#34; here, in order to lessen
        the burden for the user of specifying so many details.

        Based on current directory from where the script is called,
        it defines all the ingredients to carry out
        a `tf.convert.walker` conversion of the TEI input.

        This function is assumed to work in the context of a repository,
        i.e. a directory on your computer relative to which the input directory exists,
        and various output directories: `tf`, `app`, `docs`.

        Your current directory must be at

        ```
        ~/backend/org/repo/relative
        ```

        where

        *   `~` is your home directory;
        *   `backend` is an online back-end name,
            like `github`, `gitlab`, `git.huc.knaw.nl`;
        *   `org` is an organization, person, or group in the back-end;
        *   `repo` is a repository in the `org`.
        *   `relative` is a directory path within the repo (0 or more components)

        This is only about the directory structure on your local computer;
        it is not required that you have online incarnations of your repository
        in that back-end.
        Even your local repository does not have to be a git repository.

        The only thing that matters is that the full path to your repo can be parsed
        as a sequence of `home/backend/org/repo/relative`.

        Relative to this directory the program expects and creates
        input / output directories.

        ## Input directories

        ### `tei`

        *Location of the TEI-XML sources.*

        **If it does not exist, the program aborts with an error.**

        Several levels of subdirectories are assumed:

        1.  the version of the source (this could be a date string).
        1.  volumes / collections of documents. The subdirectory `__ignore__` is ignored.
        1.  the TEI documents themselves, conforming to the TEI schema or some
            customization of it.

        ### `schema`

        *TEI or other XML schemas against which the sources can be validated.*

        They should be XSD or RNG files.

        !!! note &#34;Multiple XSD files&#34;
            When you started with a RNG file and used `tf.tools.xmlschema` to
            convert it to XSD, you may have got multiple XSD files.
            One of them has the same base name as the original RNG file,
            and you should pass that name. It will import the remaining XSD files,
            so do not throw them away.

        We use these files as custom TEI schemas,
        but to be sure, we still analyse the full TEI schema and
        use the schemas here as a set of overriding element definitions.

        ## Output directories

        ### `report`

        Directory to write the results of the `check` task to: an inventory
        of elements / attributes encountered, and possible validation errors.
        If the directory does not exist, it will be created.
        The default value is `.` (i.e. the current directory in which
        the script is invoked).

        ### `tf`

        The directory under which the TF output file (with extension `.tf`)
        are placed.
        If it does not exist, it will be created.
        The TF files will be generated in a folder named by a version number,
        passed as `tfVersion`.

        ### `app` and `docs`

        Location of additional TF app configuration and documentation files.
        If they do not exist, they will be created with some sensible default
        settings and generated documentation.
        These settings can be overridden in the `app/config_custom.yaml` file.
        Also a default `display.css` file and a logo are added.

        Custom content for these files can be provided in files
        with `_custom` appended to their base name.

        ### `docs`

        Location of additional documentation.
        This can be generated or hand-written material, or a mixture of the two.

        Parameters
        ----------
        tei: string, optional &#34;&#34;
            If empty, use the latest version under the `tei` directory with sources.
            Otherwise it should be a valid integer, and it is the index in the
            sorted list of versions there.

            *   `0` or `latest`: latest version;
            *   `-1`, `-2`, ... : previous version, version before previous, ...;
            *   `1`, `2`, ...: first version, second version, ....
            *   everything else that is not a number is an explicit version

            If the value cannot be parsed as an integer, it is used as the exact
            version name.

        tf: string, optional &#34;&#34;
            If empty, the TF version used will be the latest one under the `tf`
            directory. If the parameter `prelim` was used in the initialization of
            the TEI object, only versions ending in `pre` will be taken into account.

            If it can be parsed as the integers 1, 2, or 3 it will bump the latest
            relevant TF version:

            *   `0` or `latest`: overwrite the latest version
            *   `1` will bump the major version
            *   `2` will bump the intermediate version
            *   `3` will bump the minor version
            *   everything else is an explicit version

            Otherwise, the value is taken as the exact version name.

        verbose: integer, optional -1
            Produce no (-1), some (0) or many (1) progress and reporting messages

        &#34;&#34;&#34;
        super().__init__(&#34;lxml&#34;)
        if self.importOK(hint=True):
            self.etree = self.importGet()
        else:
            return

        self.good = True

        (backend, org, repo, relative) = getLocation()

        if any(s is None for s in (backend, org, repo, relative)):
            console(
                (
                    &#34;Not working in a repo: &#34;
                    f&#34;backend={backend} org={org} repo={repo} relative={relative}&#34;
                ),
                error=True,
            )
            self.good = False
            return

        if verbose == 1:
            console(
                f&#34;Working in repository {org}/{repo}{relative} in back-end {backend}&#34;
            )

        base = ex(f&#34;~/{backend}&#34;)
        repoDir = f&#34;{base}/{org}/{repo}&#34;
        refDir = f&#34;{repoDir}{relative}&#34;
        programDir = f&#34;{refDir}/programs&#34;
        schemaDir = f&#34;{refDir}/schema&#34;
        convertSpec = f&#34;{programDir}/tei.yaml&#34;
        convertCustom = f&#34;{programDir}/tei.py&#34;

        self.schemaDir = schemaDir

        settings = readYaml(asFile=convertSpec, plain=True)

        customKeys = set(
            &#34;&#34;&#34;
            transform
            beforeTag
            beforeChildren
            afterChildren
            afterTag
        &#34;&#34;&#34;.strip().split()
        )

        functionType = type(lambda x: x)

        if fileExists(convertCustom):
            hooked = []

            try:
                spec = util.spec_from_file_location(&#34;teicustom&#34;, convertCustom)
                code = util.module_from_spec(spec)
                sys.path.insert(0, dirNm(convertCustom))
                spec.loader.exec_module(code)
                sys.path.pop(0)
                for method in customKeys:
                    if not hasattr(code, method):
                        continue

                    func = getattr(code, method)
                    typeFunc = type(func)
                    if typeFunc is not functionType:
                        console(
                            (
                                f&#34;custom member {method} should be a function, &#34;
                                f&#34;but it is a {typeFunc.__name__}&#34;
                            ),
                            error=True,
                        )
                        continue

                    methodC = f&#34;{method}Custom&#34;
                    setattr(self, methodC, func)
                    hooked.append(method)

            except Exception as e:
                console(str(e), error=True)
                for method in customKeys:
                    if not hasattr(self, method):
                        methodC = f&#34;{method}Custom&#34;
                        setattr(self, methodC, None)

            if verbose &gt;= 0:
                console(&#34;With custom behaviour hooked in at:&#34;)
                for method in hooked:
                    methodC = f&#34;{method}Custom&#34;
                    console(f&#34;\t{methodC} = {ux(convertCustom)}.{method}&#34;)

        generic = settings.get(&#34;generic&#34;, {})
        extra = settings.get(&#34;extra&#34;, {})
        models = settings.get(&#34;models&#34;, [])
        templates = settings.get(&#34;templates&#34;, [])
        templateTrigger = settings.get(&#34;templateTrigger&#34;, None)
        adaptations = settings.get(&#34;adaptations&#34;, [])
        adaptationTrigger = settings.get(&#34;adaptationTrigger&#34;, None)
        prelim = settings.get(&#34;prelim&#34;, True)
        granularity = settings.get(&#34;granularity&#34;, TOKEN)
        wordAsSlot = granularity == WORD
        tokenAsSlot = granularity == TOKEN
        charAsSlot = granularity == CHAR
        parentEdges = settings.get(&#34;parentEdges&#34;, True)
        siblingEdges = settings.get(&#34;siblingEdges&#34;, True)
        procins = settings.get(&#34;procins&#34;, False)

        lineModel = settings.get(&#34;lineModel&#34;, {})
        lineModel = checkModel(LINE, lineModel, verbose)

        if not lineModel:
            self.good = False
            return

        makeLineElems = lineModel[&#34;model&#34;] == &#34;II&#34;
        lineProperties = lineModel.get(&#34;properties&#34;, None)
        lineModel = lineModel[&#34;model&#34;]

        self.makeLineElems = makeLineElems
        self.lineModel = lineModel
        self.lineProperties = lineProperties

        pageModel = settings.get(&#34;pageModel&#34;, {})
        pageModel = checkModel(PAGE, pageModel, verbose)

        if not pageModel:
            self.good = False
            return

        makePageElems = pageModel[&#34;model&#34;] == &#34;II&#34;
        pageProperties = pageModel.get(&#34;properties&#34;, None)
        pageModel = pageModel[&#34;model&#34;]

        self.makePageElems = makePageElems
        self.pageModel = pageModel
        self.pageProperties = pageProperties

        sectionModel = settings.get(&#34;sectionModel&#34;, {})
        sectionModel = checkModel(&#34;section&#34;, sectionModel, verbose)
        if not sectionModel:
            self.good = False
            return

        sectionProperties = sectionModel.get(&#34;properties&#34;, None)
        sectionModel = sectionModel[&#34;model&#34;]
        self.sectionModel = sectionModel
        self.sectionProperties = sectionProperties

        self.generic = generic
        self.extra = extra
        self.models = models
        self.templates = templates
        self.adaptations = adaptations

        if templateTrigger is None:
            self.templateAtt = None
            self.templateTag = None
        else:
            (tag, att) = templateTrigger.split(&#34;@&#34;)
            self.templateAtt = att
            self.templateTag = tag

        if adaptationTrigger is None:
            self.adaptationAtt = None
            self.adaptationTag = None
        else:
            (tag, att) = adaptationTrigger.split(&#34;@&#34;)
            self.adaptationAtt = att
            self.adaptationTag = tag

        templateTag = self.templateTag
        templateAtt = self.templateAtt
        adaptationTag = self.adaptationTag
        adaptationAtt = self.adaptationAtt

        triggers = {}
        self.triggers = triggers

        for kind, theAtt, theTag in (
            (&#34;template&#34;, templateAtt, templateTag),
            (&#34;adaptation&#34;, adaptationAtt, adaptationTag),
        ):
            triggerRe = None

            if theAtt is not None and theTag is not None:
                tagPat = re.escape(theTag)
                triggerRe = re.compile(
                    rf&#34;&#34;&#34;&lt;{tagPat}\b[^&gt;]*?{theAtt}=[&#39;&#34;]([^&#39;&#34;]+)[&#39;&#34;]&#34;&#34;&#34;
                )
            triggers[kind] = triggerRe

        self.A = Analysis(verbose=verbose)
        self.readSchemas()

        self.prelim = prelim
        self.wordAsSlot = wordAsSlot
        self.tokenAsSlot = tokenAsSlot
        self.charAsSlot = charAsSlot
        self.parentEdges = parentEdges
        self.siblingEdges = siblingEdges
        self.procins = procins

        reportDir = f&#34;{refDir}/report&#34;
        appDir = f&#34;{refDir}/app&#34;
        docsDir = f&#34;{refDir}/docs&#34;
        teiDir = f&#34;{refDir}/tei&#34;
        tfDir = f&#34;{refDir}/tf&#34;

        teiVersions = sorted(dirContents(teiDir)[1], key=versionSort)
        nTeiVersions = len(teiVersions)

        if tei in {&#34;latest&#34;, &#34;&#34;, &#34;0&#34;, 0} or str(tei).lstrip(&#34;-&#34;).isdecimal():
            teiIndex = (0 if tei == &#34;latest&#34; else int(tei)) - 1

            try:
                teiVersion = teiVersions[teiIndex]
            except Exception:
                absIndex = teiIndex + (nTeiVersions if teiIndex &lt; 0 else 0) + 1
                console(
                    (
                        f&#34;no item in {absIndex} in {nTeiVersions} source versions &#34;
                        f&#34;in {ux(teiDir)}&#34;
                    )
                    if len(teiVersions)
                    else f&#34;no source versions in {ux(teiDir)}&#34;,
                    error=True,
                )
                self.good = False
                return
        else:
            teiVersion = tei

        teiPath = f&#34;{teiDir}/{teiVersion}&#34;
        reportPath = f&#34;{reportDir}/{teiVersion}&#34;

        if not dirExists(teiPath):
            console(
                f&#34;source version {teiVersion} does not exists in {ux(teiDir)}&#34;,
                error=True,
            )
            self.good = False
            return

        teiStatuses = {tv: i for (i, tv) in enumerate(reversed(teiVersions))}
        teiStatus = teiStatuses[teiVersion]
        teiStatusRep = (
            &#34;most recent&#34;
            if teiStatus == 0
            else &#34;previous&#34;
            if teiStatus == 1
            else f&#34;{teiStatus - 1} before previous&#34;
        )
        if teiStatus == len(teiVersions) - 1 and len(teiVersions) &gt; 1:
            teiStatusRep = &#34;oldest&#34;

        if verbose &gt;= 0:
            console(f&#34;TEI data version is {teiVersion} ({teiStatusRep})&#34;)

        tfVersions = sorted(dirContents(tfDir)[1], key=versionSort)
        if prelim:
            tfVersions = [tv for tv in tfVersions if tv.endswith(PRE)]

        latestTfVersion = (
            tfVersions[-1] if len(tfVersions) else (&#34;0.0.0&#34; + (PRE if prelim else &#34;&#34;))
        )
        if tf in {&#34;latest&#34;, &#34;&#34;, &#34;0&#34;, 0}:
            tfVersion = latestTfVersion
            vRep = &#34;latest&#34;
        elif tf in {&#34;1&#34;, &#34;2&#34;, &#34;3&#34;, 1, 2, 3}:
            bump = int(tf)
            parts = latestTfVersion.split(&#34;.&#34;)

            def getVer(b):
                return (
                    int(parts[b].removesuffix(PRE))
                    if prelim and b == len(parts) - 1
                    else int(parts[b])
                )

            def setVer(b, val):
                parts[b] = f&#34;{val}{PRE}&#34; if prelim and b == len(parts) - 1 else f&#34;{val}&#34;

            if bump &gt; len(parts):
                console(
                    f&#34;Cannot bump part {bump} of latest TF version {latestTfVersion}&#34;,
                    error=True,
                )
                self.good = False
                return
            else:
                b1 = bump - 1
                old = getVer(b1)
                setVer(b1, old + 1)
                for b in range(b1 + 1, len(parts)):
                    setVer(b, 0)
                tfVersion = &#34;.&#34;.join(str(p) for p in parts)
                vRep = (
                    &#34;major&#34; if bump == 1 else &#34;intermediate&#34; if bump == 2 else &#34;minor&#34;
                )
                vRep = f&#34;next {vRep}&#34;
        else:
            tfVersion = tf
            status = &#34;existing&#34; if dirExists(f&#34;{tfDir}/{tfVersion}&#34;) else &#34;new&#34;
            vRep = f&#34;explicit {status}&#34;

        tfPath = f&#34;{tfDir}/{tfVersion}&#34;

        if verbose &gt;= 0:
            console(f&#34;TF data version is {tfVersion} ({vRep})&#34;)
            console(
                f&#34;Processing instructions are {&#39;treated&#39; if procins else &#39;ignored&#39;}&#34;
            )

        self.refDir = refDir
        self.teiVersion = teiVersion
        self.teiPath = teiPath
        self.tfVersion = tfVersion
        self.tfPath = tfPath
        self.reportPath = reportPath
        self.tfDir = tfDir
        self.appDir = appDir
        self.docsDir = docsDir
        self.backend = backend
        self.org = org
        self.repo = repo
        self.relative = relative

        levelNames = sectionProperties[&#34;levels&#34;]
        self.levelNames = levelNames
        self.chunkLevel = levelNames[-1]

        if sectionModel == &#34;II&#34;:
            self.chapterSection = levelNames[0]
            self.chunkSection = levelNames[1]
        else:
            self.folderSection = levelNames[0]
            self.fileSection = levelNames[1]
            self.chunkSection = levelNames[2]
            self.backMatter = sectionProperties.get(&#34;backMatter&#34;, None)

        chunkSection = self.chunkSection
        intFeatures = {&#34;empty&#34;, chunkSection}
        self.intFeatures = intFeatures

        if siblingEdges:
            intFeatures.add(&#34;sibling&#34;)

        slotType = WORD if wordAsSlot else T if tokenAsSlot else CHAR
        self.slotType = slotType

        sectionFeatures = &#34;,&#34;.join(levelNames)
        sectionTypes = &#34;,&#34;.join(levelNames)

        textFeatures = &#34;{ch}&#34; if charAsSlot else &#34;{str}{after}&#34;
        otext = {
            &#34;fmt:text-orig-full&#34;: textFeatures,
            &#34;sectionFeatures&#34;: sectionFeatures,
            &#34;sectionTypes&#34;: sectionTypes,
        }
        self.otext = otext

        featureMeta = dict(
            str=dict(
                description=&#34;the text of a word or token&#34;,
                conversionMethod=CM_LITC,
                conversionCode=CONVERSION_METHODS[CM_LITC],
            ),
            after=dict(
                description=&#34;the text after a word till the next word&#34;,
                conversionMethod=CM_LITC,
                conversionCode=CONVERSION_METHODS[CM_LITC],
            ),
            empty=dict(
                description=&#34;whether a slot has been inserted in an empty element&#34;,
                conversionMethod=CM_PROV,
                conversionCode=CONVERSION_METHODS[CM_PROV],
            ),
            is_meta=dict(
                description=&#34;whether a slot or word is in the teiHeader element&#34;,
                conversionMethod=CM_LITC,
                conversionCode=CONVERSION_METHODS[CM_LITC],
            ),
            is_note=dict(
                description=&#34;whether a slot or word is in the note element&#34;,
                conversionMethod=CM_LITC,
                conversionCode=CONVERSION_METHODS[CM_LITC],
            ),
        )
        if charAsSlot:
            featureMeta[&#34;extraspace&#34;] = dict(
                description=(
                    &#34;whether a space has been added after a character, &#34;
                    &#34;when it is in the direct child of a pure XML element&#34;
                ),
                conversionMethod=CM_LITP,
                conversionCode=CONVERSION_METHODS[CM_LITP],
            )
            featureMeta[&#34;ch&#34;] = dict(
                description=&#34;the UNICODE character of a slot&#34;,
                conversionMethod=CM_LITC,
                conversionCode=CONVERSION_METHODS[CM_LITC],
            )
        if parentEdges:
            featureMeta[&#34;parent&#34;] = dict(
                description=&#34;edge between a node and its parent node&#34;,
                conversionMethod=CM_LITP,
                conversionCode=CONVERSION_METHODS[CM_LITP],
            )
        if siblingEdges:
            featureMeta[&#34;sibling&#34;] = dict(
                description=(
                    &#34;edge between a node and its preceding sibling nodes; &#34;
                    &#34;labeled with the distance between them&#34;
                ),
                conversionMethod=CM_LITP,
                conversionCode=CONVERSION_METHODS[CM_LITP],
            )
        featureMeta[chunkSection] = dict(
            description=f&#34;number of a {chunkSection} within a document&#34;,
            conversionMethod=CM_PROV,
            conversionCode=CONVERSION_METHODS[CM_PROV],
        )

        if sectionModel == &#34;II&#34;:
            chapterSection = self.chapterSection
            featureMeta[chapterSection] = dict(
                description=f&#34;name of {chapterSection}&#34;,
                conversionMethod=CM_PROV,
                conversionCode=CONVERSION_METHODS[CM_PROV],
            )
        else:
            folderSection = self.folderSection
            fileSection = self.fileSection
            featureMeta[folderSection] = dict(
                description=f&#34;name of source {folderSection}&#34;,
                conversionMethod=CM_PROV,
                conversionCode=CONVERSION_METHODS[CM_PROV],
            )
            featureMeta[fileSection] = dict(
                description=f&#34;name of source {fileSection}&#34;,
                conversionMethod=CM_PROV,
                conversionCode=CONVERSION_METHODS[CM_PROV],
            )

        self.featureMeta = featureMeta

        generic[&#34;sourceFormat&#34;] = &#34;TEI&#34;
        generic[&#34;version&#34;] = tfVersion
        generic[&#34;teiVersion&#34;] = teiVersion
        generic[&#34;schema&#34;] = &#34;TEI&#34; + (&#34; + &#34; + (&#34; + &#34;.join(models))) if models else &#34;&#34;

        extraInstructions = []

        for feat, featSpecs in extra.items():
            featMeta = featSpecs.get(&#34;meta&#34;, {})
            if &#34;valueType&#34; in featMeta:
                if featMeta[&#34;valueType&#34;] == &#34;int&#34;:
                    intFeatures.add(feat)
                del featMeta[&#34;valueType&#34;]

            featPath = featSpecs.get(&#34;path&#34;, None)
            featPathRep = &#34;&#34; if featPath is None else &#34;the content is taken from &#34;
            featPathLogical = []

            sep = &#34;&#34;
            for comp in reversed(featPath or []):
                if type(comp) is str:
                    featPathRep += f&#34;{sep}{comp}&#34;
                    featPathLogical.append((comp, None))
                else:
                    for tag, atts in comp.items():
                        # there is only one item in this dict
                        featPathRep += f&#34;{sep}{tag}[&#34;
                        featPathRep += &#34;,&#34;.join(
                            f&#34;{att}={v}&#34; for (att, v) in sorted(atts.items())
                        )
                        featPathRep += &#34;]&#34;
                        featPathLogical.append((tag, atts))
                sep = &#34;/&#34;

            featureMeta[feat] = {
                k: v.replace(&#34;«base»&#34;, featPathRep) for (k, v) in featMeta.items()
            }
            nodeType = featSpecs.get(&#34;nodeType&#34;, None)
            if nodeType is not None and featPath:
                extraInstructions.append(
                    (list(reversed(featPathLogical)), nodeType, feat)
                )

        self.extraInstructions = tuple(extraInstructions)

        self.verbose = verbose
        self.validate = validate
        myDir = dirNm(abspath(__file__))
        self.myDir = myDir

    def readSchemas(self):
        schemaDir = self.schemaDir
        models = self.models
        A = self.A

        schemaFiles = dict(rng={}, xsd={})
        self.schemaFiles = schemaFiles
        modelInfo = {}
        self.modelInfo = modelInfo
        modelXsd = {}
        self.modelXsd = modelXsd
        modelInv = {}
        self.modelInv = modelInv

        for model in [None] + models:
            for kind in (&#34;rng&#34;, &#34;xsd&#34;):
                schemaFile = (
                    A.getBaseSchema()[kind]
                    if model is None
                    else f&#34;{schemaDir}/{model}.{kind}&#34;
                )
                if fileExists(schemaFile):
                    schemaFiles[kind][model] = schemaFile
                    if (
                        kind == &#34;rng&#34;
                        or kind == &#34;xsd&#34;
                        and model not in schemaFiles[&#34;rng&#34;]
                    ):
                        modelInfo[model] = schemaFile
            if model in schemaFiles[&#34;rng&#34;] and model not in schemaFiles[&#34;xsd&#34;]:
                schemaFileXsd = f&#34;{schemaDir}/{model}.xsd&#34;
                A.fromrelax(schemaFiles[&#34;rng&#34;][model], schemaFileXsd)
                schemaFiles[&#34;xsd&#34;][model] = schemaFileXsd

        baseSchema = schemaFiles[&#34;xsd&#34;][None]
        modelXsd[None] = baseSchema
        modelInv[(baseSchema, None)] = None

        for model in models:
            override = schemaFiles[&#34;xsd&#34;][model]
            modelXsd[model] = override
            modelInv[(baseSchema, override)] = model

    def getSwitches(self, xmlPath):
        verbose = self.verbose
        models = self.models
        adaptations = self.adaptations
        templates = self.templates
        triggers = self.triggers
        A = self.A

        text = None

        found = {}

        for kind, allOfKind in (
            (&#34;model&#34;, models),
            (&#34;adaptation&#34;, adaptations),
            (&#34;template&#34;, templates),
        ):
            if text is None:
                with fileOpen(xmlPath) as fh:
                    text = fh.read()

            found[kind] = None

            if kind == &#34;model&#34;:
                result = A.getModel(text)
                if result is None or result == &#34;tei_all&#34;:
                    result = None
            else:
                result = None
                triggerRe = triggers[kind]
                if triggerRe is not None:
                    match = triggerRe.search(text)
                    result = match.group(1) if match else None

            if result is not None and result not in allOfKind:
                if verbose &gt;= 0:
                    console(f&#34;unavailable {kind} {result} in {ux(xmlPath)}&#34;)
                result = None
            found[kind] = result

        return (found[&#34;model&#34;], found[&#34;adaptation&#34;], found[&#34;template&#34;])

    def getParser(self):
        &#34;&#34;&#34;Configure the LXML parser.

        See [parser options](https://lxml.de/parsing.html#parser-options).

        Returns
        -------
        object
            A configured LXML parse object.
        &#34;&#34;&#34;
        if not self.importOK():
            return None

        etree = self.etree
        procins = self.procins

        return etree.XMLParser(
            remove_blank_text=False,
            collect_ids=False,
            remove_comments=True,
            remove_pis=not procins,
            huge_tree=True,
        )

    def getXML(self):
        &#34;&#34;&#34;Make an inventory of the TEI source files.

        Returns
        -------
        tuple of tuple | string
            If section model I is in force:

            The outer tuple has sorted entries corresponding to folders under the
            TEI input directory.
            Each such entry consists of the folder name and an inner tuple
            that contains the file names in that folder, sorted.

            If section model II is in force:

            It is the name of the single XML file.
        &#34;&#34;&#34;
        verbose = self.verbose
        teiPath = self.teiPath
        sectionModel = self.sectionModel
        if verbose == 1:
            console(f&#34;Section model {sectionModel}&#34;)

        if sectionModel == &#34;I&#34;:
            backMatter = self.backMatter

            IGNORE = &#34;__ignore__&#34;

            xmlFilesRaw = collections.defaultdict(list)

            with scanDir(teiPath) as dh:
                for folder in dh:
                    folderName = folder.name
                    if folderName == IGNORE:
                        continue
                    if not folder.is_dir():
                        continue
                    with scanDir(f&#34;{teiPath}/{folderName}&#34;) as fh:
                        for file in fh:
                            fileName = file.name
                            if not (
                                fileName.lower().endswith(&#34;.xml&#34;) and file.is_file()
                            ):
                                continue
                            xmlFilesRaw[folderName].append(fileName)

            xmlFiles = []
            hasBackMatter = False

            for folderName in sorted(xmlFilesRaw, key=versionSort):
                if folderName == backMatter:
                    hasBackMatter = True
                else:
                    fileNames = xmlFilesRaw[folderName]
                    xmlFiles.append((folderName, tuple(sorted(fileNames))))

            if hasBackMatter:
                fileNames = xmlFilesRaw[backMatter]
                xmlFiles.append((backMatter, tuple(sorted(fileNames))))

            xmlFiles = tuple(xmlFiles)

            return xmlFiles

        if sectionModel == &#34;II&#34;:
            xmlFile = None
            with scanDir(teiPath) as fh:
                for file in fh:
                    fileName = file.name
                    if not (fileName.lower().endswith(&#34;.xml&#34;) and file.is_file()):
                        continue
                    xmlFile = fileName
                    break
            return xmlFile

    def checkTask(self):
        &#34;&#34;&#34;Implementation of the &#34;check&#34; task.

        It validates the TEI, but only if a schema file has been passed explicitly
        when constructing the `TEI()` object.

        Then it makes an inventory of all elements and attributes in the TEI files.

        If tags are used in multiple namespaces, it will be reported.

        !!! caution &#34;Conflation of namespaces&#34;
            The TEI to TF conversion does construct node types and attributes
            without taking namespaces into account.
            However, the parsing process is namespace aware.

        The inventory lists all elements and attributes, and many attribute values.
        But is represents any digit with `n`, and some attributes that contain
        ids or keywords, are reduced to the value `x`.

        This information reduction helps to get a clear overview.

        It writes reports to the `reportPath`:

        *   `errors.txt`: validation errors
        *   `elements.txt`: element / attribute inventory.
        &#34;&#34;&#34;
        if not self.importOK():
            return

        if not self.good:
            return

        verbose = self.verbose
        procins = self.procins
        validate = self.validate
        modelInfo = self.modelInfo
        modelInv = self.modelInv
        modelXsd = self.modelXsd
        A = self.A
        etree = self.etree

        teiPath = self.teiPath
        reportPath = self.reportPath
        docsDir = self.docsDir
        sectionModel = self.sectionModel

        if verbose == 1:
            console(f&#34;TEI to TF checking: {ux(teiPath)} =&gt; {ux(reportPath)}&#34;)
        if verbose &gt;= 0:
            console(
                f&#34;Processing instructions are {&#39;treated&#39; if procins else &#39;ignored&#39;}&#34;
            )
            console(f&#34;XML validation will be {&#39;performed&#39; if validate else &#39;skipped&#39;}&#34;)

        kindLabels = dict(
            format=&#34;Formatting Attributes&#34;,
            keyword=&#34;Keyword Attributes&#34;,
            rest=&#34;Remaining Attributes and Elements&#34;,
        )
        getStore = lambda: collections.defaultdict(  # noqa: E731
            lambda: collections.defaultdict(collections.Counter)
        )
        analysis = {x: getStore() for x in kindLabels}
        errors = []
        tagByNs = collections.defaultdict(collections.Counter)
        refs = collections.defaultdict(lambda: collections.Counter())
        ids = collections.defaultdict(lambda: collections.Counter())

        parser = self.getParser()
        baseSchema = modelXsd[None]
        overrides = [
            override for (model, override) in modelXsd.items() if model is not None
        ]
        A.getElementInfo(baseSchema, overrides, verbose=verbose)
        elementDefs = A.elementDefs

        initTree(reportPath)
        initTree(docsDir)

        nProcins = 0

        lbParents = collections.Counter()

        def analyse(root, analysis, xmlFile):
            FORMAT_ATTS = set(
                &#34;&#34;&#34;
                dim
                level
                place
                rend
            &#34;&#34;&#34;.strip().split()
            )

            KEYWORD_ATTS = set(
                &#34;&#34;&#34;
                facs
                form
                function
                lang
                reason
                type
                unit
                who
            &#34;&#34;&#34;.strip().split()
            )

            TRIM_ATTS = set(
                &#34;&#34;&#34;
                id
                key
                target
                value
            &#34;&#34;&#34;.strip().split()
            )

            NUM_RE = re.compile(r&#34;&#34;&#34;[0-9]&#34;&#34;&#34;, re.S)

            def nodeInfo(xnode):
                nonlocal nProcins

                if procins and isinstance(xnode, etree._ProcessingInstruction):
                    target = xnode.target
                    tag = f&#34;?{target}&#34;
                    ns = &#34;&#34;
                    nProcins += 1
                else:
                    qName = etree.QName(xnode.tag)
                    tag = qName.localname
                    ns = qName.namespace

                atts = {etree.QName(k).localname: v for (k, v) in xnode.attrib.items()}

                tagByNs[tag][ns] += 1

                if tag == &#34;lb&#34;:
                    parentTag = etree.QName(xnode.getparent().tag).localname
                    lbParents[parentTag] += 1

                if len(atts) == 0:
                    kind = &#34;rest&#34;
                    analysis[kind][tag][&#34;&#34;][&#34;&#34;] += 1
                else:
                    idv = atts.get(&#34;id&#34;, None)

                    if idv is not None:
                        ids[xmlFile][idv] += 1

                    for refAtt, targetFile, targetId in getRefs(tag, atts, xmlFile):
                        refs[xmlFile][(targetFile, targetId)] += 1

                    for k, v in atts.items():
                        kind = (
                            &#34;format&#34;
                            if k in FORMAT_ATTS
                            else &#34;keyword&#34;
                            if k in KEYWORD_ATTS
                            else &#34;rest&#34;
                        )
                        dest = analysis[kind]

                        if kind == &#34;rest&#34;:
                            vTrim = &#34;X&#34; if k in TRIM_ATTS else NUM_RE.sub(&#34;N&#34;, v)
                            dest[tag][k][vTrim] += 1
                        else:
                            words = v.strip().split()
                            for w in words:
                                dest[tag][k][w.strip()] += 1

                for child in xnode.iterchildren(
                    tag=(etree.Element, etree.ProcessingInstruction)
                    if procins
                    else etree.Element
                ):
                    nodeInfo(child)

            nodeInfo(root)

        def writeErrors():
            &#34;&#34;&#34;Write the errors to a file.&#34;&#34;&#34;

            errorFile = f&#34;{reportPath}/errors.txt&#34;

            nErrors = 0
            nFiles = 0

            with fileOpen(errorFile, mode=&#34;w&#34;) as fh:
                prevFolder = None
                prevFile = None

                for folder, file, line, col, kind, text in errors:
                    newFolder = prevFolder != folder
                    newFile = newFolder or prevFile != file

                    if newFile:
                        nFiles += 1

                    if kind == &#34;error&#34;:
                        nErrors += 1

                    indent1 = f&#34;{folder}\n\t&#34; if newFolder else &#34;\t&#34;
                    indent2 = f&#34;{file}\n\t\t&#34; if newFile else &#34;\t&#34;
                    loc = f&#34;{line or &#39;&#39;}:{col or &#39;&#39;}&#34;
                    text = &#34;\n&#34;.join(wrap(text, width=80, subsequent_indent=&#34;\t\t\t&#34;))
                    fh.write(f&#34;{indent1}{indent2}{loc} {kind or &#39;&#39;} {text}\n&#34;)
                    prevFolder = folder
                    prevFile = file

            if nErrors:
                console(
                    (
                        f&#34;{nErrors} validation error(s) in {nFiles} file(s) &#34;
                        f&#34;written to {errorFile}&#34;
                    ),
                    error=True,
                )
            else:
                if verbose &gt;= 0:
                    if validate:
                        console(&#34;Validation OK&#34;)
                    else:
                        console(&#34;No validation performed&#34;)

        def writeNamespaces():
            errorFile = f&#34;{reportPath}/namespaces.txt&#34;

            nErrors = 0

            nTags = len(tagByNs)

            with fileOpen(errorFile, mode=&#34;w&#34;) as fh:
                for tag, nsInfo in sorted(
                    tagByNs.items(), key=lambda x: (-len(x[1]), x[0])
                ):
                    label = &#34;OK&#34;
                    nNs = len(nsInfo)
                    if nNs &gt; 1:
                        nErrors += 1
                        label = &#34;XX&#34;

                    for ns, amount in sorted(
                        nsInfo.items(), key=lambda x: (-x[1], x[0])
                    ):
                        fh.write(
                            f&#34;{label} {nNs:&gt;2} namespace for &#34;
                            f&#34;{tag:&lt;16} : {amount:&gt;5}x {ns}\n&#34;
                        )

            if verbose &gt;= 0:
                if procins:
                    plural = &#34;&#34; if nProcins == 1 else &#34;s&#34;
                    console(f&#34;{nProcins} processing instruction{plural} encountered.&#34;)

                console(
                    f&#34;{nTags} tags of which {nErrors} with multiple namespaces &#34;
                    f&#34;written to {errorFile}&#34;
                    if verbose &gt;= 0 or nErrors
                    else &#34;Namespaces OK&#34;
                )

        def writeReport():
            reportFile = f&#34;{reportPath}/elements.txt&#34;
            with fileOpen(reportFile, mode=&#34;w&#34;) as fh:
                fh.write(
                    &#34;Inventory of tags and attributes in the source XML file(s).\n&#34;
                    &#34;Contains the following sections:\n&#34;
                )
                for label in kindLabels.values():
                    fh.write(f&#34;\t{label}\n&#34;)
                fh.write(&#34;\n\n&#34;)

                infoLines = 0

                def writeAttInfo(tag, att, attInfo):
                    nonlocal infoLines
                    nl = &#34;&#34; if tag == &#34;&#34; else &#34;\n&#34;
                    tagRep = &#34;&#34; if tag == &#34;&#34; else f&#34;&lt;{tag}&gt;&#34;
                    attRep = &#34;&#34; if att == &#34;&#34; else f&#34;{att}=&#34;
                    atts = sorted(attInfo.items())
                    (val, amount) = atts[0]
                    fh.write(
                        f&#34;{nl}\t{tagRep:&lt;18} &#34; f&#34;{attRep:&lt;11} {amount:&gt;5}x {val}\n&#34;
                    )
                    infoLines += 1
                    for val, amount in atts[1:]:
                        fh.write(
                            f&#34;&#34;&#34;\t{&#39;&#39;:&lt;7}{&#39;&#39;:&lt;18} {&#39;&#34;&#39;:&lt;18} {amount:&gt;5}x {val}\n&#34;&#34;&#34;
                        )
                        infoLines += 1

                def writeTagInfo(tag, tagInfo):
                    nonlocal infoLines
                    tags = sorted(tagInfo.items())
                    (att, attInfo) = tags[0]
                    writeAttInfo(tag, att, attInfo)
                    infoLines += 1
                    for att, attInfo in tags[1:]:
                        writeAttInfo(&#34;&#34;, att, attInfo)

                for kind, label in kindLabels.items():
                    fh.write(f&#34;\n{label}\n&#34;)
                    for tag, tagInfo in sorted(analysis[kind].items()):
                        writeTagInfo(tag, tagInfo)

            if verbose &gt;= 0:
                console(f&#34;{infoLines} info line(s) written to {reportFile}&#34;)

        def writeElemTypes():
            elemsCombined = {}

            modelSet = set()

            for schemaOverride, eDefs in elementDefs.items():
                model = modelInv[schemaOverride]
                modelSet.add(model)
                for tag, (typ, mixed) in eDefs.items():
                    elemsCombined.setdefault(tag, {}).setdefault(model, {})
                    elemsCombined[tag][model][&#34;typ&#34;] = typ
                    elemsCombined[tag][model][&#34;mixed&#34;] = mixed

            tagReport = {}

            for tag, tagInfo in elemsCombined.items():
                tagLines = []
                tagReport[tag] = tagLines

                if None in tagInfo:
                    teiInfo = tagInfo[None]
                    teiTyp = teiInfo[&#34;typ&#34;]
                    teiMixed = teiInfo[&#34;mixed&#34;]
                    teiTypRep = &#34;??&#34; if teiTyp is None else typ
                    teiMixedRep = (
                        &#34;??&#34; if teiMixed is None else &#34;mixed&#34; if teiMixed else &#34;pure&#34;
                    )
                    mds = [&#34;TEI&#34;]

                    for model in sorted(x for x in tagInfo if x is not None):
                        info = tagInfo[model]
                        typ = info[&#34;typ&#34;]
                        mixed = info[&#34;mixed&#34;]
                        if typ == teiTyp and mixed == teiMixed:
                            mds.append(model)
                        else:
                            typRep = (
                                &#34;&#34; if typ == teiTyp else &#34;??&#34; if typ is None else typ
                            )
                            mixedRep = (
                                &#34;&#34;
                                if mixed == teiMixed
                                else &#34;??&#34;
                                if mixed is None
                                else &#34;mixed&#34;
                                if mixed
                                else &#34;pure&#34;
                            )
                            tagLines.append((tag, [model], typRep, mixedRep))
                    tagLines.insert(0, (tag, mds, teiTypRep, teiMixedRep))
                else:
                    for model in sorted(tagInfo):
                        info = tagInfo[model]
                        typ = info[&#34;typ&#34;]
                        mixed = info[&#34;mixed&#34;]
                        typRep = &#34;??&#34; if typ is None else typ
                        mixedRep = (
                            &#34;??&#34; if mixed is None else &#34;mixed&#34; if mixed else &#34;pure&#34;
                        )
                        tagLines.append((tag, [model], typRep, mixedRep))

            reportFile = f&#34;{reportPath}/types.txt&#34;
            with fileOpen(reportFile, mode=&#34;w&#34;) as fh:
                for tag in sorted(tagReport):
                    tagLines = tagReport[tag]
                    for tag, mds, typ, mixed in tagLines:
                        model = &#34;,&#34;.join(mds)
                        fh.write(f&#34;{tag:&lt;18} {model:&lt;18} {typ:&lt;7} {mixed:&lt;5}\n&#34;)

            if verbose &gt;= 0:
                console(
                    f&#34;{len(elemsCombined)} tag(s) type info written to {reportFile}&#34;
                )

        def writeLbParents():
            reportFile = f&#34;{reportPath}/lb-parents.txt&#34;

            with open(reportFile, &#34;w&#34;) as fh:
                for parent, n in sorted(lbParents.items()):
                    fh.write(f&#34;{n:&gt;5} x {parent}\n&#34;)

            if verbose &gt;= 0:
                console(f&#34;lb-parent info written to {reportFile}&#34;)

        def writeIdRefs():
            reportIdFile = f&#34;{reportPath}/ids.txt&#34;
            reportRefFile = f&#34;{reportPath}/refs.txt&#34;

            ih = fileOpen(reportIdFile, mode=&#34;w&#34;)
            rh = fileOpen(reportRefFile, mode=&#34;w&#34;)

            refdIds = collections.Counter()
            missingIds = set()

            totalRefs = 0
            totalRefsU = 0

            totalResolvable = 0
            totalResolvableU = 0
            totalDangling = 0
            totalDanglingU = 0

            seenItems = set()

            for file, items in refs.items():
                rh.write(f&#34;{file}\n&#34;)

                resolvable = 0
                resolvableU = 0
                dangling = 0
                danglingU = 0

                for item, n in sorted(items.items()):
                    totalRefs += n

                    if item in seenItems:
                        newItem = False
                    else:
                        seenItems.add(item)
                        newItem = True
                        totalRefsU += 1

                    (target, idv) = item

                    if target not in ids or idv not in ids[target]:
                        status = &#34;dangling&#34;
                        dangling += n

                        if newItem:
                            missingIds.add((target, idv))
                            danglingU += 1
                    else:
                        status = &#34;ok&#34;
                        resolvable += n
                        refdIds[(target, idv)] += n

                        if newItem:
                            resolvableU += 1
                    rh.write(f&#34;\t{status:&lt;10} {n:&gt;5} x {target} # {idv}\n&#34;)

                msgs = (
                    f&#34;\tDangling:   {dangling:&gt;4} x {danglingU:&gt;4}&#34;,
                    f&#34;\tResolvable: {resolvable:&gt;4} x {resolvableU:&gt;4}&#34;,
                )
                for msg in msgs:
                    rh.write(f&#34;{msg}\n&#34;)

                totalResolvable += resolvable
                totalResolvableU += resolvableU
                totalDangling += dangling
                totalDanglingU += danglingU

            if verbose &gt;= 0:
                console(f&#34;Refs written to {reportRefFile}&#34;)
                msgs = (
                    f&#34;\tresolvable: {totalResolvableU:&gt;4} in {totalResolvable:&gt;4}&#34;,
                    f&#34;\tdangling:   {totalDanglingU:&gt;4} in {totalDangling:&gt;4}&#34;,
                    f&#34;\tALL:        {totalRefsU:&gt;4} in {totalRefs:&gt;4} &#34;,
                )
                for msg in msgs:
                    console(msg)

            totalIds = 0
            totalIdsU = 0
            totalIdsM = 0
            totalIdsRefd = 0
            totalIdsRefdU = 0
            totalIdsUnused = 0

            for file, items in ids.items():
                totalIds += len(items)

                ih.write(f&#34;{file}\n&#34;)

                unique = 0
                multiple = 0
                refd = 0
                refdU = 0
                unused = 0

                for item, n in sorted(items.items()):
                    nRefs = refdIds.get((file, item), 0)

                    if n == 1:
                        unique += 1
                    else:
                        multiple += 1

                    if nRefs == 0:
                        unused += 1
                    else:
                        refd += nRefs
                        refdU += 1

                    status1 = f&#34;{n}x&#34;
                    plural = &#34;&#34; if nRefs == 1 else &#34;s&#34;
                    status2 = f&#34;{nRefs}ref{plural}&#34;

                    ih.write(f&#34;\t{status1:&lt;8} {status2:&lt;8} {item}\n&#34;)

                msgs = (
                    f&#34;\tUnique:     {unique:&gt;4}&#34;,
                    f&#34;\tNon-unique: {multiple:&gt;4}&#34;,
                    f&#34;\tUnused:     {unused:&gt;4}&#34;,
                    f&#34;\tReferenced: {refd:&gt;4} x {refdU:&gt;4}&#34;,
                )
                for msg in msgs:
                    ih.write(f&#34;{msg}\n&#34;)

                totalIdsU += unique
                totalIdsM += multiple
                totalIdsRefdU += refdU
                totalIdsRefd += refd
                totalIdsUnused += unused

            if verbose &gt;= 0:
                console(f&#34;Ids written to {reportIdFile}&#34;)
                msgs = (
                    f&#34;\treferenced: {totalIdsRefdU:&gt;4} by {totalIdsRefd:&gt;4}&#34;,
                    f&#34;\tnon-unique: {totalIdsM:&gt;4}&#34;,
                    f&#34;\tunused:     {totalIdsUnused:&gt;4}&#34;,
                    f&#34;\tALL:        {totalIdsU:&gt;4} in {totalIds:&gt;4}&#34;,
                )
                for msg in msgs:
                    console(msg)

        def writeDoc():
            teiUrl = &#34;https://tei-c.org/release/doc/tei-p5-doc/en/html&#34;
            elUrlPrefix = f&#34;{teiUrl}/ref-&#34;
            attUrlPrefix = f&#34;{teiUrl}/REF-ATTS.html#&#34;
            docFile = f&#34;{docsDir}/elements.md&#34;
            with fileOpen(docFile, mode=&#34;w&#34;) as fh:
                fh.write(
                    dedent(
                        &#34;&#34;&#34;
                        # Element and attribute inventory

                        Table of contents

                        &#34;&#34;&#34;
                    )
                )
                for label in kindLabels.values():
                    labelAnchor = label.replace(&#34; &#34;, &#34;-&#34;)
                    fh.write(f&#34;*\t[{label}](#{labelAnchor})\n&#34;)

                fh.write(&#34;\n&#34;)

                tableHeader = dedent(
                    &#34;&#34;&#34;
                    | element | attribute | value | amount
                    | --- | --- | --- | ---
                    &#34;&#34;&#34;
                )

                def writeAttInfo(tag, att, attInfo):
                    tagRep = &#34; &#34; if tag == &#34;&#34; else f&#34;[{tag}]({elUrlPrefix}{tag}.html)&#34;
                    attRep = &#34; &#34; if att == &#34;&#34; else f&#34;[{att}]({attUrlPrefix}{att})&#34;
                    atts = sorted(attInfo.items())
                    (val, amount) = atts[0]
                    valRep = f&#34;`{val}`&#34; if val else &#34;&#34;
                    fh.write(
                        &#34;| &#34;
                        + (
                            &#34; | &#34;.join(
                                str(x)
                                for x in (
                                    tagRep,
                                    attRep,
                                    valRep,
                                    amount,
                                )
                            )
                        )
                        + &#34;\n&#34;
                    )
                    for val, amount in atts[1:]:
                        valRep = f&#34;`{val}`&#34; if val else &#34;&#34;
                        fh.write(f&#34;&#34;&#34;| | | {valRep} | {amount}\n&#34;&#34;&#34;)

                def writeTagInfo(tag, tagInfo):
                    tags = sorted(tagInfo.items())
                    (att, attInfo) = tags[0]
                    writeAttInfo(tag, att, attInfo)
                    for att, attInfo in tags[1:]:
                        writeAttInfo(&#34;&#34;, att, attInfo)

                for kind, label in kindLabels.items():
                    fh.write(f&#34;## {label}\n{tableHeader}&#34;)
                    for tag, tagInfo in sorted(analysis[kind].items()):
                        writeTagInfo(tag, tagInfo)
                    fh.write(&#34;\n&#34;)

        def filterError(msg):
            return msg == (
                &#34;Element &#39;graphic&#39;, attribute &#39;url&#39;: [facet &#39;pattern&#39;] &#34;
                &#34;The value &#39;&#39; is not accepted by the pattern &#39;\\S+&#39;.&#34;
            )

        def doXMLFile(xmlPath):
            tree = etree.parse(xmlPath, parser)
            root = tree.getroot()
            xmlFile = fileNm(xmlPath)
            ids[xmlFile][&#34;&#34;] = 1
            analyse(root, analysis, xmlFile)

        xmlFilesByModel = collections.defaultdict(list)

        if sectionModel == &#34;I&#34;:
            i = 0
            for xmlFolder, xmlFiles in self.getXML():
                msg = &#34;Start &#34; if verbose &gt;= 0 else &#34;\t&#34;
                console(f&#34;{msg}folder {xmlFolder}:&#34;)
                j = 0
                cr = &#34;&#34;
                nl = True

                for xmlFile in xmlFiles:
                    i += 1
                    j += 1
                    if j &gt; PROGRESS_LIMIT:
                        cr = &#34;\r&#34;
                        nl = False
                    xmlPath = f&#34;{teiPath}/{xmlFolder}/{xmlFile}&#34;
                    (model, adapt, tpl) = self.getSwitches(xmlPath)
                    mdRep = model or &#34;TEI&#34;
                    tplRep = tpl or &#34;&#34;
                    adRep = adapt or &#34;&#34;

                    label = f&#34;{mdRep:&lt;12} {tplRep:&lt;12} {adRep:&lt;12}&#34;

                    if verbose &gt;= 0:
                        console(f&#34;{cr}{i:&gt;4} {label} {xmlFile:&lt;50}&#34;, newline=nl)
                    xmlFilesByModel[model].append(xmlPath)
                if verbose &gt;= 0:
                    console(&#34;&#34;)
                    console(f&#34;End   folder {xmlFolder}&#34;)

        elif sectionModel == &#34;II&#34;:
            xmlFile = self.getXML()
            if xmlFile is None:
                console(&#34;No XML files found!&#34;, error=True)
                return False

            xmlPath = f&#34;{teiPath}/{xmlFile}&#34;
            (model, adapt, tpl) = self.getSwitches(xmlPath)
            xmlFilesByModel[model].append(xmlPath)

        good = True

        for model, xmlPaths in xmlFilesByModel.items():
            if verbose &gt;= 0:
                console(f&#34;{len(xmlPaths)} {model or &#39;TEI&#39;} file(s) ...&#34;)

            thisGood = True

            if validate:
                if verbose &gt;= 0:
                    console(&#34;\tValidating ...&#34;)

                schemaFile = modelInfo.get(model, None)

                if schemaFile is None:
                    if verbose &gt;= 0:
                        console(f&#34;\t\tNo schema file for {model}&#34;)
                    if good is not None and good is not False:
                        good = None
                    continue

                (thisGood, info, theseErrors) = A.validate(schemaFile, xmlPaths)

                for line in info:
                    if verbose &gt;= 0:
                        console(f&#34;\t\t{line}&#34;)

            if not thisGood:
                good = False
                errors.extend(theseErrors)

            if verbose &gt;= 0:
                console(&#34;\tMaking inventory ...&#34;)
            for xmlPath in xmlPaths:
                doXMLFile(xmlPath)

        if not good:
            self.good = False

        if verbose &gt;= 0:
            console(&#34;&#34;)
        writeErrors()
        writeReport()
        writeElemTypes()
        writeDoc()
        writeNamespaces()
        writeIdRefs()
        writeLbParents()

    # SET UP CONVERSION

    def getConverter(self):
        &#34;&#34;&#34;Initializes a converter.

        Returns
        -------
        object
            The `tf.convert.walker.CV` converter object, initialized.
        &#34;&#34;&#34;
        verbose = self.verbose
        tfPath = self.tfPath

        silent = AUTO if verbose == 1 else TERSE if verbose == 0 else DEEP
        TF = Fabric(locations=tfPath, silent=silent)
        return CV(TF, silent=silent)

    # DIRECTOR

    def getDirector(self):
        &#34;&#34;&#34;Factory for the director function.

        The `tf.convert.walker` relies on a corpus dependent `director` function
        that walks through the source data and spits out actions that
        produces the TF dataset.

        The director function that walks through the TEI input must be conditioned
        by the properties defined in the TEI schema and the customised schema, if any,
        that describes the source.

        Also some special additions need to be programmed, such as an extra section
        level, word boundaries, etc.

        We collect all needed data, store it, and define a local director function
        that has access to this data.

        Returns
        -------
        function
            The local director function that has been constructed.
        &#34;&#34;&#34;
        if not self.importOK():
            return

        if not self.good:
            return

        TEI_HEADER = &#34;teiHeader&#34;

        TEXT_ANCESTOR = &#34;text&#34;
        TEXT_ANCESTORS = set(
            &#34;&#34;&#34;
            front
            body
            back
            group
            &#34;&#34;&#34;.strip().split()
        )
        CHUNK_PARENTS = TEXT_ANCESTORS | {TEI_HEADER}

        CHUNK_ELEMS = set(
            &#34;&#34;&#34;
            facsimile
            fsdDecl
            sourceDoc
            standOff
            &#34;&#34;&#34;.strip().split()
        )

        PASS_THROUGH = set(
            &#34;&#34;&#34;
            TEI
            &#34;&#34;&#34;.strip().split()
        )

        # CHECKING

        HY = &#34;\u2010&#34;  # hyphen

        IN_WORD_HYPHENS = {HY, &#34;-&#34;}

        procins = self.procins
        verbose = self.verbose
        teiPath = self.teiPath
        wordAsSlot = self.wordAsSlot
        tokenAsSlot = self.tokenAsSlot
        parentEdges = self.parentEdges
        siblingEdges = self.siblingEdges
        featureMeta = self.featureMeta
        intFeatures = self.intFeatures
        transform = getattr(self, &#34;transformCustom&#34;, None)
        chunkLevel = self.chunkLevel
        modelInv = self.modelInv
        modelInfo = self.modelInfo
        modelXsd = self.modelXsd
        A = self.A
        etree = self.etree

        transformFunc = (
            (lambda x: BytesIO(x.encode(&#34;utf-8&#34;)))
            if transform is None
            else lambda x: BytesIO(transform(x).encode(&#34;utf-8&#34;))
        )

        parser = self.getParser()

        baseSchema = modelInfo[None]
        overrides = [
            override for (model, override) in modelInfo.items() if model is not None
        ]
        baseSchema = modelXsd[None]
        overrides = [
            override for (model, override) in modelXsd.items() if model is not None
        ]
        A.getElementInfo(baseSchema, overrides, verbose=-1)

        refs = collections.defaultdict(lambda: collections.defaultdict(set))
        ids = collections.defaultdict(dict)

        # WALKERS

        WHITE_TRIM_RE = re.compile(r&#34;\s+&#34;, re.S)
        NON_NAME_RE = re.compile(r&#34;[^a-zA-Z0-9_ ]+&#34;, re.S)

        NOTE_LIKE = set(
            &#34;&#34;&#34;
            note
            &#34;&#34;&#34;.strip().split()
        )
        EMPTY_ELEMENTS = set(
            &#34;&#34;&#34;
            addSpan
            alt
            anchor
            anyElement
            attRef
            binary
            caesura
            catRef
            cb
            citeData
            classRef
            conversion
            damageSpan
            dataFacet
            default
            delSpan
            elementRef
            empty
            equiv
            fsdLink
            gb
            handShift
            iff
            lacunaEnd
            lacunaStart
            lb
            link
            localProp
            macroRef
            milestone
            move
            numeric
            param
            path
            pause
            pb
            ptr
            redo
            refState
            specDesc
            specGrpRef
            symbol
            textNode
            then
            undo
            unicodeProp
            unihanProp
            variantEncoding
            when
            witEnd
            witStart
            &#34;&#34;&#34;.strip().split()
        )
        NEWLINE_ELEMENTS = set(
            &#34;&#34;&#34;
            ab
            addrLine
            cb
            l
            lb
            lg
            list
            p
            pb
            seg
            table
            u
            &#34;&#34;&#34;.strip().split()
        )
        CONTINUOUS_ELEMENTS = set(
            &#34;&#34;&#34;
            choice
            &#34;&#34;&#34;.strip().split()
        )

        def makeNameLike(x):
            return NON_NAME_RE.sub(&#34;_&#34;, x).strip(&#34;_&#34;)

        def walkNode(cv, cur, xnode):
            &#34;&#34;&#34;Internal function to deal with a single element.

            Will be called recursively.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

                The subdictionary `cur[&#34;node&#34;]` is used to store the currently generated
                nodes by node type.
            xnode: object
                An LXML element node.
            &#34;&#34;&#34;
            if procins and isinstance(xnode, etree._ProcessingInstruction):
                target = xnode.target
                tag = f&#34;?{target}&#34;
            else:
                tag = etree.QName(xnode.tag).localname

            atts = {etree.QName(k).localname: v for (k, v) in xnode.attrib.items()}

            beforeTag(cv, cur, xnode, tag, atts)

            cur[XNEST].append((tag, atts))

            curNode = beforeChildren(cv, cur, xnode, tag, atts)

            if curNode is not None:
                if parentEdges:
                    if len(cur[TNEST]):
                        parentNode = cur[TNEST][-1]
                        cv.edge(curNode, parentNode, parent=None)

                cur[TNEST].append(curNode)

                if siblingEdges:
                    if len(cur[TSIB]):
                        siblings = cur[TSIB][-1]

                        nSiblings = len(siblings)
                        for i, sib in enumerate(siblings):
                            cv.edge(sib, curNode, sibling=nSiblings - i)
                        siblings.append(curNode)

                    cur[TSIB].append([])

            for child in xnode.iterchildren(
                tag=(etree.Element, etree.ProcessingInstruction)
                if procins
                else etree.Element
            ):
                walkNode(cv, cur, child)

            afterChildren(cv, cur, xnode, tag, atts)

            if curNode is not None:
                xmlFile = cur[&#34;xmlFile&#34;]

                for refAtt, targetFile, targetId in getRefs(tag, atts, xmlFile):
                    refs[refAtt][(targetFile, targetId)].add(curNode)

                idVal = atts.get(&#34;id&#34;, None)
                if idVal is not None:
                    ids[xmlFile][idVal] = curNode

                if len(cur[TNEST]):
                    cur[TNEST].pop()
                if siblingEdges:
                    if len(cur[TSIB]):
                        cur[TSIB].pop()

            cur[XNEST].pop()
            afterTag(cv, cur, xnode, tag, atts)

        def isChapter(cur):
            &#34;&#34;&#34;Whether the current element counts as a chapter node.

            ## Model I

            Not relevant: there are no chapter nodes inside an XML file.

            ## Model II

            Chapters are the highest section level (the only lower level is chunks).

            Chapters come in two kinds:

            *   the TEI header;
            *   the immediate children of `&lt;text&gt;`
                except `&lt;front&gt;`, `&lt;body&gt;`, `&lt;back&gt;`, `&lt;group&gt;`;
            *   the immediate children of
                `&lt;front&gt;`, `&lt;body&gt;`, `&lt;back&gt;`, `&lt;group&gt;`.

            Parameters
            ----------
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

            Returns
            -------
            boolean
            &#34;&#34;&#34;
            sectionModel = self.sectionModel

            if sectionModel == &#34;II&#34;:
                nest = cur[XNEST]
                nNest = len(nest)

                if nNest &gt; 0 and nest[-1][0] in EMPTY_ELEMENTS:
                    return False

                outcome = nNest &gt; 0 and (
                    nest[-1][0] == TEI_HEADER
                    or (
                        nNest &gt; 1
                        and (
                            nest[-2][0] in TEXT_ANCESTORS
                            or nest[-2][0] == TEXT_ANCESTOR
                            and nest[-1][0] not in TEXT_ANCESTORS
                        )
                    )
                )
                if outcome:
                    cur[&#34;chapterElems&#34;].add(nest[-1][0])

                return outcome

            return False

        def isChunk(cur):
            &#34;&#34;&#34;Whether the current element counts as a chunk node.

            It depends on the section model, but also on the template.

            Note that we only can have distinct templates if we deal with
            multiple files, so only when we are in section model I.

            ## Model I

            Chunks are the lowest section level (the higher levels are folders
            and then files)

            The default is that chunks are the immediate children of the
            `&lt;teiHeader&gt;` and the `&lt;body&gt;`
            elements; a few other elements also count as chunks.

            However, if `drillDownDivs` is True and if the chunk appears to be
            a `&lt;div&gt;` element, we drill further down, until we arrive at a
            non-`&lt;div&gt;` element.

            But in specific templates we have different rules:

            ### `bibliolist`:

            *   The TEI Header is a chunk, and nothing inside the TEI header is a chunk;
            *   Everything at level 5, except `&lt;listBibl&gt;` is a chunk;
            *   The children of `&lt;listBibl&gt;` are chunks (the `&lt;bibl&gt;` elements
                and a few others), provided they are at level 6.

            ### `artworklist`

            *   The TEI Header is a chunk, and nothing inside the TEI header is a chunk;
            *   Everything at level 5 is a chunk.

            ## Model II

            Chunks are the lowest section level (the only higher level is chapters).

            Chunks are the immediate children of the chapters, and they come in two
            kinds: the ones that are `&lt;p&gt;` elements, and the rest.

            Deviation from this rule:

            *   If a chapter is a mixed content node, then it is also a chunk.
                and its subelements are not chunks

            Parameters
            ----------
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

            Returns
            -------
            boolean
            &#34;&#34;&#34;
            sectionModel = self.sectionModel

            nest = cur[XNEST]
            nNest = len(nest)
            model = cur[&#34;model&#34;]

            if nNest == 0:
                return False

            thisTag = nest[-1][0]

            if sectionModel == &#34;II&#34;:
                if nNest == 1:
                    outcome = False
                else:
                    parentTag = nest[-2][0]
                    meChptChnk = (
                        isChapter(cur) and thisTag not in cur[&#34;pureElems&#34;][model]
                    )

                    if meChptChnk:
                        outcome = True
                    elif parentTag == TEI_HEADER:
                        outcome = True
                    elif nNest &lt;= 2:
                        outcome = False
                    elif parentTag not in cur[&#34;pureElems&#34;][model]:
                        outcome = False
                    else:
                        grandParentTag = nest[-3][0]
                        outcome = (
                            grandParentTag in TEXT_ANCESTORS
                            and thisTag not in EMPTY_ELEMENTS
                        ) or (
                            grandParentTag == TEXT_ANCESTOR
                            and parentTag not in TEXT_ANCESTORS
                        )

            elif sectionModel == &#34;I&#34;:
                template = cur[&#34;template&#34;]

                if template == &#34;biolist&#34;:
                    if thisTag == TEI_HEADER:
                        outcome = True
                    elif any(n[0] == TEI_HEADER for n in nest[0:-1]):
                        outcome = False
                    elif nNest not in {5, 6}:
                        outcome = False
                    else:
                        parentTag = nest[-2][0]
                        if nNest == 5:
                            outcome = thisTag != &#34;listPerson&#34;
                        else:
                            outcome = parentTag == &#34;listPerson&#34;

                elif template == &#34;bibliolist&#34;:
                    if thisTag == TEI_HEADER:
                        outcome = True
                    elif any(n[0] == TEI_HEADER for n in nest[0:-1]):
                        outcome = False
                    elif nNest not in {5, 6}:
                        outcome = False
                    else:
                        parentTag = nest[-2][0]
                        if nNest == 5:
                            outcome = thisTag != &#34;listBibl&#34;
                        else:
                            outcome = parentTag == &#34;listBibl&#34;

                elif template == &#34;artworklist&#34;:
                    if thisTag == TEI_HEADER:
                        outcome = True
                    elif any(n[0] == TEI_HEADER for n in nest[0:-1]):
                        outcome = False
                    else:
                        outcome = nNest == 5

                else:
                    if thisTag in CHUNK_ELEMS:
                        outcome = True
                    elif nNest == 1:
                        outcome = False
                    else:
                        sectionProperties = self.sectionProperties
                        drillDownDivs = sectionProperties[&#34;drillDownDivs&#34;]

                        parentTag = nest[-2][0]
                        if drillDownDivs:
                            if thisTag == &#34;div&#34;:
                                outcome = False
                            else:
                                dParentTag = None
                                for ancestor in reversed(nest[0:-1]):
                                    if ancestor[0] != &#34;div&#34;:
                                        dParentTag = ancestor[0]
                                        break
                                outcome = (
                                    dParentTag in CHUNK_PARENTS
                                    and thisTag not in EMPTY_ELEMENTS
                                ) or (
                                    dParentTag == TEXT_ANCESTOR
                                    and thisTag not in TEXT_ANCESTORS
                                )
                        else:
                            outcome = (
                                parentTag in CHUNK_PARENTS
                                and thisTag not in EMPTY_ELEMENTS
                            ) or (
                                parentTag == TEXT_ANCESTOR
                                and thisTag not in TEXT_ANCESTORS
                            )

            if outcome:
                cur[&#34;chunkElems&#34;].add(nest[-1][0])

            return outcome

        def isPure(cur):
            &#34;&#34;&#34;Whether the current tag has pure content.

            Parameters
            ----------
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

            Returns
            -------
            boolean
            &#34;&#34;&#34;
            nest = cur[XNEST]
            model = cur[&#34;model&#34;]
            return (
                len(nest) == 0
                or len(nest) &gt; 0
                and nest[-1][0] in cur[&#34;pureElems&#34;][model]
            )

        def isEndInPure(cur):
            &#34;&#34;&#34;Whether the current end tag occurs in an element with pure content.

            If that is the case, then it is very likely that the end tag also
            marks the end of the current word.

            And we should not strip spaces after it.

            Parameters
            ----------
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

            Returns
            -------
            boolean
            &#34;&#34;&#34;
            nest = cur[XNEST]
            model = cur[&#34;model&#34;]
            return len(nest) &gt; 1 and nest[-2][0] in cur[&#34;pureElems&#34;][model]

        def hasMixedAncestor(cur):
            &#34;&#34;&#34;Whether the current tag has an ancestor with mixed content.

            We use this in case a tag ends in an element with pure content.
            We should then add white-space to separate it from the next
            element of its parent.

            If the whole stack of element has pure content, we add
            a newline, because then we are probably in the TEI header,
            and things are most clear if they are on separate lines.

            But if one of the ancestors has mixed content, we are typically
            in some structured piece of information within running text,
            such as change markup. In this case we want to add merely a space.

            And we should not strip spaces after it.

            Parameters
            ----------
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

            Returns
            -------
            boolean
            &#34;&#34;&#34;
            nest = cur[XNEST]
            model = cur[&#34;model&#34;]
            return any(n[0] in cur[&#34;mixedElems&#34;][model] for n in nest[0:-1])

        def hasContinuousAncestor(cur):
            &#34;&#34;&#34;Whether an ancestor tag is a continuous pure element.

            A continuous pure element is an element whose child elements do not
            imply word separation, e.g. `&lt;choice&gt;`.

            Parameters
            ----------
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

            Returns
            -------
            boolean
            &#34;&#34;&#34;
            nest = cur[XNEST]
            return any(n[0] in CONTINUOUS_ELEMENTS for n in nest[0:-1])

        def startWord(cv, cur, ch):
            &#34;&#34;&#34;Start a word node if necessary.

            Whenever we encounter a character, we determine
            whether it starts or ends a word, and if it starts
            one, this function takes care of the necessary actions.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            ch: string
                A single character, the next character in the result data.
            &#34;&#34;&#34;
            curWord = cur[NODE][WORD]

            if not curWord:
                prevWord = cur[&#34;prevWord&#34;]
                if prevWord is not None:
                    cv.feature(prevWord, after=cur[&#34;afterStr&#34;])
                if ch is not None:
                    if wordAsSlot:
                        curWord = cv.slot()
                    else:
                        curWord = cv.node(WORD)
                    cur[NODE][WORD] = curWord
                    addSlotFeatures(cv, cur, curWord)

            if ch is not None:
                cur[&#34;wordStr&#34;] += ch

        def finishWord(cv, cur, ch, spaceChar):
            &#34;&#34;&#34;Terminate a word node if necessary.

            Whenever we encounter a character, we determine
            whether it starts or ends a word, and if it ends
            one, this function takes care of the necessary actions.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            ch: string
                A single character, the next slot in the result data.
            spaceChar: string | void
                If None, no extra space or newline will be added.
                Otherwise, the `spaceChar` (a single space or newline will be added).
            &#34;&#34;&#34;
            curWord = cur[NODE][WORD]
            if curWord:
                cv.feature(curWord, str=cur[&#34;wordStr&#34;])
                if not wordAsSlot:
                    cv.terminate(curWord)
                cur[NODE][WORD] = None
                cur[&#34;wordStr&#34;] = &#34;&#34;
                cur[&#34;prevWord&#34;] = curWord
                cur[&#34;afterStr&#34;] = &#34;&#34;

            if ch is not None:
                cur[&#34;afterStr&#34;] += ch
            if spaceChar is not None:
                cur[&#34;afterStr&#34;] = cur[&#34;afterStr&#34;].rstrip() + spaceChar
                if not wordAsSlot:
                    addSpace(cv, cur, spaceChar)
                cur[&#34;afterSpace&#34;] = True
            else:
                cur[&#34;afterSpace&#34;] = False

        def addSlotFeatures(cv, cur, s):
            &#34;&#34;&#34;Add generic features to a slot.

            Whenever we encounter a character, we add it as a new slot, unless
            `wordAsSlot` is in force. In that case we suppress the triggering of a
            slot node.
            If needed, we start / terminate word nodes as well.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            s: slot
                A previously added (slot) node
            &#34;&#34;&#34;
            if cur[&#34;inHeader&#34;]:
                cv.feature(s, is_meta=1)
            if cur[&#34;inNote&#34;]:
                cv.feature(s, is_note=1)
            for r, stack in cur.get(&#34;rend&#34;, {}).items():
                if len(stack) &gt; 0:
                    cv.feature(s, **{f&#34;rend_{r}&#34;: 1})

        def addTokens(cv, cur, text):
            &#34;&#34;&#34;Adds text as a series of tokens.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            text: string
                The text to be added.

            Only meant for the case where slots are tokens.
            &#34;&#34;&#34;
            (beforew, material, afterw) = getWhites(text)

            if beforew:
                makeSpace(cv, cur)

            s = None

            for tx, after in tokenize(material):
                s = cv.slot()
                cv.feature(s, str=tx, after=after)
                addSlotFeatures(cv, cur, s)

            if afterw:
                if s is None:
                    makeSpace(cv, cur)
                else:
                    cv.feature(s, after=&#34; &#34;)

        def addSlot(cv, cur, ch):
            &#34;&#34;&#34;Add a slot.

            Whenever we encounter a character, we add it as a new slot, unless
            `wordAsSlot` is in force. In that case we suppress the triggering of a
            slot node.
            If needed, we start / terminate word nodes as well.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            ch: string
                A single character, the next slot in the result data.
            &#34;&#34;&#34;
            if ch in {&#34;_&#34;, None} or ch.isalnum() or ch in IN_WORD_HYPHENS:
                startWord(cv, cur, ch)
            else:
                finishWord(cv, cur, ch, None)

            if wordAsSlot:
                s = cur[NODE][WORD]
            elif ch is None:
                s = None
            else:
                s = cv.slot()
                cv.feature(s, ch=ch)
            if s is not None:
                addSlotFeatures(cv, cur, s)

        def addEmpty(cv, cur):
            &#34;&#34;&#34;Add an empty slot.

            We also terminate the current word.
            If words are slots, the empty slot is a word on its own.

            Returns
            -------
            node
                The empty slot
            &#34;&#34;&#34;
            if tokenAsSlot:
                emptyNode = cv.slot()
                cv.feature(emptyNode, str=ZWSP, after=&#34;&#34;, empty=1)
            else:
                finishWord(cv, cur, None, None)
                startWord(cv, cur, ZWSP)
                emptyNode = cur[NODE][WORD]
                cv.feature(emptyNode, empty=1)

                if not wordAsSlot:
                    emptyNode = cv.slot()
                    cv.feature(emptyNode, ch=ZWSP, empty=1)

                finishWord(cv, cur, None, None)

            return emptyNode

        def addSpace(cv, cur, spaceChar):
            &#34;&#34;&#34;Adds a space or a new line.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            spaceChar: string
                The character to add (supposed to be either a space or a newline).

            Only meant for the case where slots are characters or tokens.

            Suppressed when not in a lowest-level section.
            &#34;&#34;&#34;
            if chunkLevel in cv.activeTypes():
                s = cv.slot()
                if tokenAsSlot:
                    cv.feature(s, str=&#34;&#34;, after=spaceChar, extraspace=1)
                else:
                    cv.feature(s, ch=spaceChar, extraspace=1)
                addSlotFeatures(cv, cur, s)

        def makeSpace(cv, cur):
            &#34;&#34;&#34;Adds a space.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.

            Only meant for the case where slots are tokens.
            &#34;&#34;&#34;
            s = cv.slot()
            cv.feature(s, str=&#34;&#34;, after=&#34; &#34;, extraspace=1)
            addSlotFeatures(cv, cur, s)

        def endLine(cv, cur):
            &#34;&#34;&#34;Ends a line node.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            &#34;&#34;&#34;
            lineProperties = self.lineProperties
            lineType = lineProperties[&#34;nodeType&#34;]

            slots = cv.linked(cur[NODE][lineType])
            empty = len(slots) == 0

            if empty:
                lastSlot = addEmpty(cv, cur)
                if cur[&#34;inNote&#34;]:
                    cv.feature(lastSlot, is_note=1)
            else:
                lastSlot = (T, slots[-1])

            if not wordAsSlot:
                after = cv.get(&#34;after&#34;, lastSlot)
                if after is not None and &#34;\n&#34; not in after:
                    cv.feature(lastSlot, after=f&#34;{after.rstrip()}\n&#34;)
            cv.terminate(cur[NODE][lineType])

        def endPage(cv, cur):
            &#34;&#34;&#34;Ends a page node.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            &#34;&#34;&#34;
            pageProperties = self.pageProperties
            pageType = pageProperties[&#34;nodeType&#34;]

            slots = cv.linked(cur[NODE][pageType])
            empty = len(slots) == 0

            if empty:
                lastSlot = addEmpty(cv, cur)
                if cur[&#34;inNote&#34;]:
                    cv.feature(lastSlot, is_note=1)
            cv.terminate(cur[NODE][pageType])

        def beforeTag(cv, cur, xnode, tag, atts):
            &#34;&#34;&#34;Actions before dealing with the element&#39;s tag.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            xnode: object
                An LXML element node.
            tag: string
                The tag of the LXML node.
            &#34;&#34;&#34;
            beforeTagCustom = getattr(self, &#34;beforeTagCustom&#34;, None)
            if beforeTagCustom is not None:
                beforeTagCustom(cv, cur, xnode, tag, atts)

        def beforeChildren(cv, cur, xnode, tag, atts):
            &#34;&#34;&#34;Actions before dealing with the element&#39;s children.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            xnode: object
                An LXML element node.
            tag: string
                The tag of the LXML node.
            atts: string
                The attributes of the LXML node, with namespaces stripped.
            &#34;&#34;&#34;
            makeLineElems = self.makeLineElems

            if makeLineElems:
                lineProperties = self.lineProperties
                lineElem = lineProperties[&#34;element&#34;]
                lineType = lineProperties[&#34;nodeType&#34;]
                isLineContainer = tag == lineElem
                inLine = cur[&#34;inLine&#34;]

                if isLineContainer:
                    cur[&#34;inLine&#34;] = True

                    # the line starts with the container
                    cur[NODE][lineType] = cv.node(lineType)

            makePageElems = self.makePageElems

            if makePageElems:
                pageProperties = self.pageProperties
                pageType = pageProperties[&#34;nodeType&#34;]
                isPageContainer = matchModel(pageProperties, tag, atts)
                inPage = cur[&#34;inPage&#34;]

                pbAtTop = pageProperties[&#34;pbAtTop&#34;]

                if isPageContainer:
                    cur[&#34;inPage&#34;] = True

                    if pbAtTop:
                        # material before the first pb in the container is not in a page
                        pass
                    else:
                        # the page starts with the container
                        cur[NODE][pageType] = cv.node(pageType)

            sectionModel = self.sectionModel
            sectionProperties = self.sectionProperties

            if sectionModel == &#34;II&#34;:
                chapterSection = self.chapterSection
                chunkSection = self.chunkSection

                if isChapter(cur):
                    cur[&#34;chapterNum&#34;] += 1
                    cur[&#34;prevChapter&#34;] = cur[NODE].get(chapterSection, None)
                    cur[NODE][chapterSection] = cv.node(chapterSection)
                    cv.link(cur[NODE][chapterSection], cur[&#34;danglingSlots&#34;])

                    value = {chapterSection: f&#34;{cur[&#39;chapterNum&#39;]} {tag}&#34;}
                    cv.feature(cur[NODE][chapterSection], **value)
                    cur[&#34;chunkPNum&#34;] = 0
                    cur[&#34;chunkONum&#34;] = 0
                    cur[&#34;prevChunk&#34;] = cur[NODE].get(chunkSection, None)
                    cur[NODE][chunkSection] = cv.node(chunkSection)
                    cv.link(cur[NODE][chunkSection], cur[&#34;danglingSlots&#34;])
                    cur[&#34;danglingSlots&#34;] = set()
                    cur[&#34;infirstChunk&#34;] = True

                # N.B. A node can count both as chapter and as chunk,
                # e.g. a &lt;trailer&gt; sibling of the chapter &lt;div&gt;s
                # A trailer has mixed content, so its subelements aren&#39;t typical chunks.
                if isChunk(cur):
                    if cur[&#34;infirstChunk&#34;]:
                        cur[&#34;infirstChunk&#34;] = False
                    else:
                        cur[NODE][chunkSection] = cv.node(chunkSection)
                        cv.link(cur[NODE][chunkSection], cur[&#34;danglingSlots&#34;])
                        cur[&#34;danglingSlots&#34;] = set()
                    if tag == &#34;p&#34;:
                        cur[&#34;chunkPNum&#34;] += 1
                        cn = cur[&#34;chunkPNum&#34;]
                    else:
                        cur[&#34;chunkONum&#34;] -= 1
                        cn = cur[&#34;chunkONum&#34;]
                    value = {chunkSection: cn}
                    cv.feature(cur[NODE][chunkSection], **value)

                if matchModel(sectionProperties, tag, atts):
                    heading = etree.tostring(
                        xnode, encoding=&#34;unicode&#34;, method=&#34;text&#34;, with_tail=False
                    ).replace(&#34;\n&#34;, &#34; &#34;)
                    value = {chapterSection: heading}
                    cv.feature(cur[NODE][chapterSection], **value)
                    chapterNum = cur[&#34;chapterNum&#34;]
                    if verbose &gt;= 0:
                        console(
                            f&#34;\rchapter {chapterNum:&gt;4} {heading:&lt;50}&#34;, newline=False
                        )
            else:
                chunkSection = self.chunkSection

                if isChunk(cur):
                    cur[&#34;chunkNum&#34;] += 1
                    cur[&#34;prevChunk&#34;] = cur[NODE].get(chunkSection, None)
                    cur[NODE][chunkSection] = cv.node(chunkSection)
                    cv.link(cur[NODE][chunkSection], cur[&#34;danglingSlots&#34;])
                    cur[&#34;danglingSlots&#34;] = set()
                    value = {chunkSection: cur[&#34;chunkNum&#34;]}
                    cv.feature(cur[NODE][chunkSection], **value)

            if tag == TEI_HEADER:
                cur[&#34;inHeader&#34;] = True
                if sectionModel == &#34;II&#34;:
                    value = {chapterSection: &#34;TEI header&#34;}
                    cv.feature(cur[NODE][chapterSection], **value)
            if tag in NOTE_LIKE:
                cur[&#34;inNote&#34;] = True
                if not tokenAsSlot:
                    finishWord(cv, cur, None, None)

            curNode = None

            if makeLineElems:
                if inLine and tag == &#34;lb&#34;:
                    if cur[NODE][lineType] is not None:
                        if cur[&#34;lineAtts&#34;] is not None and len(cur[&#34;lineAtts&#34;]):
                            cv.feature(cur[NODE][lineType], **cur[&#34;lineAtts&#34;])
                        endLine(cv, cur)
                    cur[NODE][lineType] = cv.node(lineType)
                    cur[&#34;lineAtts&#34;] = atts

            if makePageElems:
                if inPage and tag == &#34;pb&#34;:
                    if pbAtTop:
                        if cur[NODE][pageType] is not None:
                            endPage(cv, cur)
                        cur[NODE][pageType] = cv.node(pageType)
                        if len(atts):
                            cv.feature(cur[NODE][pageType], **atts)
                    else:
                        if cur[NODE][pageType] is not None:
                            if cur[&#34;pageAtts&#34;] is not None and len(cur[&#34;pageAtts&#34;]):
                                cv.feature(cur[NODE][pageType], **cur[&#34;pageAtts&#34;])
                            endPage(cv, cur)
                        cur[NODE][pageType] = cv.node(pageType)
                        cur[&#34;pageAtts&#34;] = atts

            isBoundaryElem = (
                makeLineElems and tag == &#34;lb&#34; or makePageElems and tag == &#34;pb&#34;
            )

            if tag not in PASS_THROUGH and not isBoundaryElem:
                cur[&#34;afterSpace&#34;] = False
                cur[NODE][tag] = cv.node(tag)
                curNode = cur[NODE][tag]
                if wordAsSlot:
                    if cur[NODE][WORD]:
                        cv.link(curNode, [cur[NODE][WORD][1]])
                if len(atts):
                    cv.feature(curNode, **atts)
                    if &#34;rend&#34; in atts:
                        rValue = atts[&#34;rend&#34;]
                        r = makeNameLike(rValue)
                        if r:
                            for q in r.split():
                                cur.setdefault(&#34;rend&#34;, {}).setdefault(q, []).append(
                                    True
                                )

            beforeChildrenCustom = getattr(self, &#34;beforeChildrenCustom&#34;, None)
            if beforeChildrenCustom is not None:
                beforeChildrenCustom(cv, cur, xnode, tag, atts)

            if not hasattr(xnode, &#34;target&#34;) and xnode.text:
                textMaterial = WHITE_TRIM_RE.sub(&#34; &#34;, xnode.text)
                if isPure(cur):
                    if textMaterial and textMaterial != &#34; &#34;:
                        console(
                            (
                                &#34;WARNING: Text material at the start of &#34;
                                f&#34;pure-content element &lt;{tag}&gt;&#34;
                            ),
                            error=True,
                        )
                        stack = &#34;-&#34;.join(n[0] for n in cur[XNEST])
                        console(f&#34;\tElement stack: {stack}&#34;, error=True)
                        console(f&#34;\tMaterial: `{textMaterial}`&#34;, error=True)
                else:
                    if tokenAsSlot:
                        addTokens(cv, cur, textMaterial)
                    else:
                        for ch in textMaterial:
                            addSlot(cv, cur, ch)

            return curNode

        def afterChildren(cv, cur, xnode, tag, atts):
            &#34;&#34;&#34;Node actions after dealing with the children, but before the end tag.

            Here we make sure that the newline elements will get their last slot
            having a newline at the end of their `after` feature.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            xnode: object
                An LXML element node.
            tag: string
                The tag of the LXML node.
            atts: string
                The attributes of the LXML node, with namespaces stripped.
            &#34;&#34;&#34;
            chunkSection = self.chunkSection
            makeLineElems = self.makeLineElems

            if makeLineElems:
                lineProperties = self.lineProperties
                lineType = lineProperties[&#34;nodeType&#34;]
                lineElem = lineProperties[&#34;element&#34;]
                lineProperties = self.lineProperties

            makePageElems = self.makePageElems

            if makePageElems:
                pageProperties = self.pageProperties
                pageType = pageProperties[&#34;nodeType&#34;]
                pageProperties = self.pageProperties

            sectionModel = self.sectionModel

            if sectionModel == &#34;II&#34;:
                chapterSection = self.chapterSection

            extraInstructions = self.extraInstructions

            if len(extraInstructions):
                lookupSource(cv, cur, tokenAsSlot, extraInstructions)

            isChap = isChapter(cur)
            isChnk = isChunk(cur)

            afterChildrenCustom = getattr(self, &#34;afterChildrenCustom&#34;, None)
            if afterChildrenCustom is not None:
                afterChildrenCustom(cv, cur, xnode, tag, atts)

            if makeLineElems:
                isLineContainer = tag == lineElem
                inLine = cur[&#34;inLine&#34;]

            if makePageElems:
                isPageContainer = matchModel(pageProperties, tag, atts)
                inPage = cur[&#34;inPage&#34;]

            hasFinishedWord = False

            if makeLineElems and inLine and tag == &#34;lb&#34;:
                pass

            if makePageElems and inPage and tag == &#34;pb&#34;:
                pass

            isBoundaryElem = (
                makeLineElems and tag == &#34;lb&#34; or makePageElems and tag == &#34;pb&#34;
            )

            if makeLineElems and isLineContainer:
                # the page ends with the container
                if cur[NODE][lineType] is not None:
                    endLine(cv, cur)
                cur[&#34;inLine&#34;] = False

            if makePageElems and isPageContainer:
                pbAtTop = pageProperties[&#34;pbAtTop&#34;]
                if pbAtTop:
                    # the page ends with the container
                    if cur[NODE][pageType] is not None:
                        endPage(cv, cur)
                else:
                    # material after the last pb is not in a page
                    if cur[NODE][pageType] is not None:
                        cv.delete(cur[NODE][pageType])
                cur[&#34;inPage&#34;] = False

            if tag not in PASS_THROUGH and not isBoundaryElem:
                curNode = cur[TNEST][-1]
                slots = cv.linked(curNode)
                empty = len(slots) == 0

                newLineTag = tag in NEWLINE_ELEMENTS

                if (
                    newLineTag
                    or isEndInPure(cur)
                    and not hasContinuousAncestor(cur)
                    and not cur[&#34;afterSpace&#34;]
                ) and not empty:
                    spaceChar = &#34;\n&#34; if newLineTag or not hasMixedAncestor(cur) else &#34; &#34;
                    if tokenAsSlot:
                        cv.feature((T, slots[-1]), after=spaceChar)
                    else:
                        finishWord(cv, cur, None, spaceChar)
                        hasFinishedWord = True

                slots = cv.linked(curNode)
                empty = len(slots) == 0

                if empty:
                    lastSlot = addEmpty(cv, cur)
                    if cur[&#34;inHeader&#34;]:
                        cv.feature(lastSlot, is_meta=1)
                    if cur[&#34;inNote&#34;]:
                        cv.feature(lastSlot, is_note=1)
                    # take care that this empty slot falls under all sections
                    # for folders and files this is already guaranteed
                    # We need only to watch out for chapters and chunks
                    if cur[NODE].get(chunkSection, None) is None:
                        prevChunk = cur.get(&#34;prevChunk&#34;, None)
                        if prevChunk is None:
                            cur[&#34;danglingSlots&#34;].add(lastSlot[1])
                        else:
                            cv.link(prevChunk, lastSlot)
                    if sectionModel == &#34;II&#34;:
                        if cur[NODE].get(chapterSection, None) is None:
                            prevChapter = cur.get(&#34;prevChapter&#34;, None)
                            if prevChapter is None:
                                cur[&#34;danglingSlots&#34;].add(lastSlot[1])
                            else:
                                cv.link(prevChapter, lastSlot)

                cv.terminate(curNode)

            if isChnk:
                if tokenAsSlot:
                    addSpace(cv, cur, &#34;\n&#34;)
                else:
                    if not hasFinishedWord:
                        finishWord(cv, cur, None, &#34;\n&#34;)
                cv.terminate(cur[NODE][chunkSection])

            if sectionModel == &#34;II&#34;:
                if isChap:
                    if tokenAsSlot:
                        addSpace(cv, cur, &#34;\n&#34;)
                    else:
                        if not hasFinishedWord:
                            finishWord(cv, cur, None, &#34;\n&#34;)
                    cv.terminate(cur[NODE][chapterSection])

        def afterTag(cv, cur, xnode, tag, atts):
            &#34;&#34;&#34;Node actions after dealing with the children and after the end tag.

            This is the place where we process the `tail` of an LXML node: the
            text material after the element and before the next open/close
            tag of any element.

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            cur: dict
                Various pieces of data collected during walking
                and relevant for some next steps in the walk.
            xnode: object
                An LXML element node.
            tag: string
                The tag of the LXML node.
            atts: string
                The attributes of the LXML node, with namespaces stripped.
            &#34;&#34;&#34;
            if tag == TEI_HEADER:
                cur[&#34;inHeader&#34;] = False
            elif tag in NOTE_LIKE:
                cur[&#34;inNote&#34;] = False

            if tag not in PASS_THROUGH:
                if &#34;rend&#34; in atts:
                    rValue = atts[&#34;rend&#34;]
                    r = makeNameLike(rValue)
                    if r:
                        for q in r.split():
                            cur[&#34;rend&#34;][q].pop()

            if xnode.tail:
                if tag == &#34;lb&#34; and self.makeLineElems:
                    tail = xnode.tail.lstrip()
                    if not wordAsSlot:
                        pass
                else:
                    tail = xnode.tail

                tailMaterial = WHITE_TRIM_RE.sub(&#34; &#34;, tail)
                if isPure(cur):
                    if tailMaterial and tailMaterial != &#34; &#34;:
                        elem = cur[XNEST][-1][0]
                        console(
                            (
                                &#34;WARNING: Text material after &#34;
                                f&#34;&lt;{tag}&gt; in pure-content element &lt;{elem}&gt;&#34;
                            ),
                            error=True,
                        )
                        stack = &#34;-&#34;.join(cur[XNEST][0])
                        console(f&#34;\tElement stack: {stack}-{tag}&#34;, error=True)
                        console(f&#34;\tMaterial: `{tailMaterial}`&#34;, error=True)
                else:
                    if tokenAsSlot:
                        addTokens(cv, cur, tailMaterial)
                    else:
                        for ch in tailMaterial:
                            addSlot(cv, cur, ch)

            afterTagCustom = getattr(self, &#34;afterTagCustom&#34;, None)
            if afterTagCustom is not None:
                afterTagCustom(cv, cur, xnode, tag, atts)

        def director(cv):
            &#34;&#34;&#34;Director function.

            Here we program a walk through the TEI sources.
            At every step of the walk we fire some actions that build TF nodes
            and assign features for them.

            Because everything is rather dynamic, we generate fairly standard
            metadata for the features, namely a link to the
            [TEI website](https://tei-c.org).

            Parameters
            ----------
            cv: object
                The converter object, needed to issue actions.
            &#34;&#34;&#34;
            makeLineElems = self.makeLineElems

            if makeLineElems:
                lineProperties = self.lineProperties
                lineType = lineProperties[&#34;nodeType&#34;]

            makePageElems = self.makePageElems

            if makePageElems:
                pageProperties = self.pageProperties
                pageType = pageProperties[&#34;nodeType&#34;]

            sectionModel = self.sectionModel
            A = self.A
            elementDefs = A.elementDefs

            cur = {}
            cur[&#34;pureElems&#34;] = {
                modelInv[schemaOverride]: {
                    x for (x, (typ, mixed)) in eDefs.items() if not mixed
                }
                for (schemaOverride, eDefs) in elementDefs.items()
            }
            cur[&#34;mixedElems&#34;] = {
                modelInv[schemaOverride]: {
                    x for (x, (typ, mixed)) in eDefs.items() if mixed
                }
                for (schemaOverride, eDefs) in elementDefs.items()
            }
            cur[NODE] = {}

            if sectionModel == &#34;I&#34;:
                folderSection = self.folderSection
                fileSection = self.fileSection

                i = 0
                for xmlFolder, xmlFiles in self.getXML():
                    msg = &#34;Start &#34; if verbose &gt;= 0 else &#34;\t&#34;
                    console(f&#34;{msg}folder {xmlFolder}:&#34;)

                    cur[NODE][folderSection] = cv.node(folderSection)
                    value = {folderSection: xmlFolder}
                    cv.feature(cur[NODE][folderSection], **value)

                    j = 0
                    cr = &#34;&#34;
                    nl = True

                    for xmlFile in xmlFiles:
                        i += 1
                        j += 1
                        if j &gt; PROGRESS_LIMIT:
                            cr = &#34;\r&#34;
                            nl = False

                        cur[&#34;xmlFile&#34;] = xmlFile
                        xmlPath = f&#34;{teiPath}/{xmlFolder}/{xmlFile}&#34;
                        (model, adapt, tpl) = self.getSwitches(xmlPath)
                        cur[&#34;model&#34;] = model
                        cur[&#34;template&#34;] = tpl
                        cur[&#34;adaptation&#34;] = adapt
                        modelRep = model or &#34;TEI&#34;
                        tplRep = tpl or &#34;&#34;
                        adRep = adapt or &#34;&#34;
                        label = f&#34;{modelRep:&lt;12} {adRep:&lt;12} {tplRep:&lt;12}&#34;
                        if verbose &gt;= 0:
                            console(
                                f&#34;{cr}{i:&gt;4} {label} {xmlFile:&lt;50}&#34;,
                                newline=nl,
                            )

                        cur[NODE][fileSection] = cv.node(fileSection)
                        ids[xmlFile][&#34;&#34;] = cur[NODE][fileSection]
                        value = {fileSection: xmlFile.removesuffix(&#34;.xml&#34;)}
                        cv.feature(cur[NODE][fileSection], **value)
                        if tpl:
                            cur[NODE][tpl] = cv.node(tpl)
                            cv.feature(cur[NODE][tpl], **value)

                        with fileOpen(xmlPath) as fh:
                            text = fh.read()
                            if transformFunc is not None:
                                text = transformFunc(text)
                            tree = etree.parse(text, parser)
                            root = tree.getroot()

                            if makeLineElems:
                                cur[NODE][lineType] = None
                                cur[&#34;inLine&#34;] = False
                                cur[&#34;lineAtts&#34;] = None

                            if makePageElems:
                                cur[NODE][pageType] = None
                                cur[&#34;inPage&#34;] = False
                                cur[&#34;pageAtts&#34;] = None

                            if not tokenAsSlot:
                                cur[NODE][WORD] = None
                            cur[&#34;inHeader&#34;] = False
                            cur[&#34;inNote&#34;] = False
                            cur[XNEST] = []
                            cur[TNEST] = []
                            cur[TSIB] = []
                            cur[&#34;chunkNum&#34;] = 0
                            cur[&#34;prevChunk&#34;] = None
                            cur[&#34;danglingSlots&#34;] = set()
                            cur[&#34;prevWord&#34;] = None
                            cur[&#34;wordStr&#34;] = &#34;&#34;
                            cur[&#34;afterStr&#34;] = &#34;&#34;
                            cur[&#34;afterSpace&#34;] = True
                            cur[&#34;chunkElems&#34;] = set()
                            walkNode(cv, cur, root)

                        if not tokenAsSlot:
                            addSlot(cv, cur, None)
                        if tpl:
                            cv.terminate(cur[NODE][tpl])
                        cv.terminate(cur[NODE][fileSection])

                    if verbose &gt;= 0:
                        console(&#34;&#34;)
                        console(f&#34;End   folder {xmlFolder}&#34;)

                    cv.terminate(cur[NODE][folderSection])

            elif sectionModel == &#34;II&#34;:
                xmlFile = self.getXML()
                if xmlFile is None:
                    console(&#34;No XML files found!&#34;, error=True)
                    return False

                xmlPath = f&#34;{teiPath}/{xmlFile}&#34;
                (cur[&#34;model&#34;], cur[&#34;adaptation&#34;], cur[&#34;template&#34;]) = self.getSwitches(
                    xmlPath
                )

                with fileOpen(f&#34;{teiPath}/{xmlFile}&#34;) as fh:
                    cur[&#34;xmlFile&#34;] = xmlFile
                    text = fh.read()
                    if transformFunc is not None:
                        text = transformFunc(text)
                    tree = etree.parse(text, parser)
                    root = tree.getroot()

                    if makeLineElems:
                        cur[NODE][lineType] = None
                        cur[&#34;inLine&#34;] = False
                        cur[&#34;lineAtts&#34;] = None

                    if makePageElems:
                        cur[NODE][pageType] = None
                        cur[&#34;inPage&#34;] = False
                        cur[&#34;pageAtts&#34;] = None

                    if not tokenAsSlot:
                        cur[NODE][WORD] = None
                    cur[&#34;inHeader&#34;] = False
                    cur[&#34;inNote&#34;] = False
                    cur[XNEST] = []
                    cur[TNEST] = []
                    cur[TSIB] = []
                    cur[&#34;chapterNum&#34;] = 0
                    cur[&#34;chunkPNum&#34;] = 0
                    cur[&#34;chunkONum&#34;] = 0
                    cur[&#34;prevChunk&#34;] = None
                    cur[&#34;prevChapter&#34;] = None
                    cur[&#34;danglingSlots&#34;] = set()
                    cur[&#34;prevWord&#34;] = None
                    cur[&#34;wordStr&#34;] = &#34;&#34;
                    cur[&#34;afterStr&#34;] = &#34;&#34;
                    cur[&#34;afterSpace&#34;] = True
                    cur[&#34;chunkElems&#34;] = set()
                    cur[&#34;chapterElems&#34;] = set()
                    for child in root.iterchildren(tag=etree.Element):
                        walkNode(cv, cur, child)

                if not tokenAsSlot:
                    addSlot(cv, cur, None)

            if verbose &gt;= 0:
                console(&#34;&#34;)

            if verbose &gt;= 0:
                console(&#34;Resolving links into edges ...&#34;)

            unresolvedRefs = {}
            unresolved = 0
            unresolvedUnique = 0
            resolved = 0
            resolvedUnique = 0

            for att, attRefs in refs.items():
                feature = f&#34;link_{att}&#34;
                edgeFeat = {feature: None}

                for (targetFile, targetId), sourceNodes in attRefs.items():
                    nSourceNodes = len(sourceNodes)
                    targetNode = ids[targetFile].get(targetId, None)
                    if targetNode is None:
                        unresolvedRefs.setdefault(targetFile, set()).add(targetId)
                        unresolvedUnique += 1
                        unresolved += nSourceNodes
                    else:
                        for sourceNode in sourceNodes:
                            cv.edge(sourceNode, targetNode, **edgeFeat)
                        resolvedUnique += 1
                        resolved += nSourceNodes

            if verbose &gt;= 0:
                console(f&#34;\t{resolvedUnique} in {resolved} reference(s) resolved&#34;)
                if unresolvedRefs:
                    console(
                        f&#34;\t{unresolvedUnique} in {unresolved} reference(s): &#34;
                        &#34;could not be resolved&#34;
                    )
                    if verbose == 1:
                        for targetFile, targetIds in sorted(unresolvedRefs.items()):
                            examples = &#34; &#34;.join(sorted(targetIds)[0:3])
                            console(f&#34;\t\t{targetFile}: {len(targetIds)} x: {examples}&#34;)

            for fName in featureMeta:
                if not cv.occurs(fName):
                    cv.meta(fName)
            for fName in cv.features():
                if fName not in featureMeta:
                    if fName.startswith(&#34;rend_&#34;):
                        r = fName[5:]
                        cv.meta(
                            fName,
                            description=f&#34;whether text is to be rendered as {r}&#34;,
                            valueType=&#34;int&#34;,
                            conversionMethod=CM_LITC,
                            conversionCode=CONVERSION_METHODS[CM_LITC],
                        )
                        intFeatures.add(fName)
                    elif fName.startswith(&#34;link_&#34;):
                        r = fName[5:]
                        cv.meta(
                            fName,
                            description=(
                                f&#34;links to node identified by xml:id in attribute {r}&#34;
                            ),
                            valueType=&#34;str&#34;,
                            conversionMethod=CM_LITP,
                            conversionCode=CONVERSION_METHODS[CM_LITP],
                        )
                    else:
                        cv.meta(
                            fName,
                            description=f&#34;this is TEI attribute {fName}&#34;,
                            valueType=&#34;str&#34;,
                            conversionMethod=CM_LIT,
                            conversionCode=CONVERSION_METHODS[CM_LIT],
                        )

            levelConstraints = [&#34;note &lt; chunk, p&#34;, &#34;salute &lt; opener, closer&#34;]
            if &#34;chapterElems&#34; in cur:
                for elem in cur[&#34;chapterElems&#34;]:
                    levelConstraints.append(f&#34;{elem} &lt; chapter&#34;)
            if &#34;chunkElems&#34; in cur:
                for elem in cur[&#34;chunkElems&#34;]:
                    levelConstraints.append(f&#34;{elem} &lt; chunk&#34;)

            levelConstraints = &#34;; &#34;.join(levelConstraints)

            cv.meta(&#34;otext&#34;, levelConstraints=levelConstraints)

            if verbose == 1:
                console(&#34;source reading done&#34;)
            return True

        return director

    def convertTask(self):
        &#34;&#34;&#34;Implementation of the &#34;convert&#34; task.

        It sets up the `tf.convert.walker` machinery and runs it.

        Returns
        -------
        boolean
            Whether the conversion was successful.
        &#34;&#34;&#34;
        if not self.importOK():
            return

        if not self.good:
            return

        procins = self.procins
        verbose = self.verbose
        slotType = self.slotType
        generic = self.generic
        otext = self.otext
        featureMeta = self.featureMeta
        intFeatures = self.intFeatures

        makeLineElems = self.makeLineElems
        lineModel = self.lineModel
        if makeLineElems:
            lineProperties = self.lineProperties
            lineType = lineProperties[&#34;nodeType&#34;]

        makePageElems = self.makePageElems
        pageModel = self.pageModel

        if makePageElems:
            pageProperties = self.pageProperties
            pageType = pageProperties[&#34;nodeType&#34;]
            pbAtTop = pageProperties[&#34;pbAtTop&#34;] if makePageElems else None

        tfPath = self.tfPath
        teiPath = self.teiPath

        if verbose &gt;= 0:
            if verbose == 1:
                console(f&#34;TEI to TF converting: {ux(teiPath)} =&gt; {ux(tfPath)}&#34;)
            if makeLineElems:
                lbRep = f&#34; with {lineType} nodes for lines between lb elements&#34;
                console(f&#34;Line model {lineModel}{lbRep}&#34;)

            if makePageElems:
                wrt = &#34;started&#34; if pbAtTop else &#34;ended&#34;
                pbRep = f&#34; with {pageType} nodes for pages {wrt} by pb elements&#34;
                console(f&#34;Page model {pageModel}{pbRep}&#34;)

            console(
                f&#34;Processing instructions are {&#39;treated&#39; if procins else &#39;ignored&#39;}&#34;
            )

        initTree(tfPath, fresh=True, gentle=True)

        cv = self.getConverter()

        self.good = cv.walk(
            self.getDirector(),
            slotType,
            otext=otext,
            generic=generic,
            intFeatures=intFeatures,
            featureMeta=featureMeta,
            generateTf=True,
        )

    def loadTask(self):
        &#34;&#34;&#34;Implementation of the &#34;load&#34; task.

        It loads the TF data that resides in the directory where the &#34;convert&#34; task
        deliver its results.

        During loading there are additional checks. If they succeed, we have evidence
        that we have a valid TF dataset.

        Also, during the first load intensive pre-computation of TF data takes place,
        the results of which will be cached in the invisible `.tf` directory there.

        That makes the TF data ready to be loaded fast, next time it is needed.

        Returns
        -------
        boolean
            Whether the loading was successful.
        &#34;&#34;&#34;
        if not self.importOK():
            return

        if not self.good:
            return

        tfPath = self.tfPath
        verbose = self.verbose
        silent = AUTO if verbose == 1 else TERSE if verbose == 0 else DEEP

        if not dirExists(tfPath):
            console(f&#34;Directory {ux(tfPath)} does not exist.&#34;, error=True)
            console(&#34;No TF found, nothing to load&#34;, error=True)
            self.good = False
            return

        TF = Fabric(locations=[tfPath], silent=silent)
        allFeatures = TF.explore(silent=True, show=True)
        loadableFeatures = allFeatures[&#34;nodes&#34;] + allFeatures[&#34;edges&#34;]
        api = TF.load(loadableFeatures, silent=silent)
        if api:
            if verbose &gt;= 0:
                console(f&#34;max node = {api.F.otype.maxNode}&#34;)
            self.good = True
            return

        self.good = False

    # APP CREATION/UPDATING

    def appTask(self, tokenBased=False):
        &#34;&#34;&#34;Implementation of the &#34;app&#34; task.

        It creates / updates a corpus-specific app plus specific documentation files.
        There should be a valid TF dataset in place, because some
        settings in the app derive from it.

        It will also read custom additions that are present in the target app directory.
        These files are:

        *   `about_custom.md`:
            A markdown file with specific colophon information about the dataset.
            In the generated file, this information will be put at the start.
        *   `transcription_custom.md`:
            A markdown file with specific encoding information about the dataset.
            In the generated file, this information will be put at the start.
        *   `config_custom.yaml`:
            A YAML file with configuration data that will be *merged* into the generated
            config.yaml.
        *   `app_custom.py`:
            A python file with named snippets of code to be inserted
            at corresponding places in the generated `app.py`
        *   `display_custom.css`:
            Additional CSS definitions that will be appended to the generated
            `display.css`.

        If the TF app for this resource needs custom code, this is the way to retain
        that code between automatic generation of files.

        Returns
        -------
        boolean
            Whether the operation was successful.
        &#34;&#34;&#34;
        if not self.importOK():
            return

        if not self.good:
            return

        verbose = self.verbose

        refDir = self.refDir
        myDir = self.myDir
        procins = self.procins
        wordAsSlot = self.wordAsSlot
        tokenAsSlot = self.tokenAsSlot
        charAsSlot = self.charAsSlot
        parentEdges = self.parentEdges
        siblingEdges = self.siblingEdges
        sectionModel = self.sectionModel
        sectionProperties = self.sectionProperties
        tfVersion = self.tfVersion

        # key | parentDir | file | template based

        # if parentDir is a tuple, the first part is the parentDir of the source
        # end the second part is the parentDir of the destination

        itemSpecs = (
            (&#34;about&#34;, &#34;docs&#34;, &#34;about.md&#34;, False),
            (&#34;trans&#34;, (&#34;app&#34;, &#34;docs&#34;), &#34;transcription.md&#34;, False),
            (&#34;logo&#34;, &#34;app/static&#34;, &#34;logo.png&#34;, True),
            (&#34;display&#34;, &#34;app/static&#34;, &#34;display.css&#34;, False),
            (&#34;config&#34;, &#34;app&#34;, &#34;config.yaml&#34;, False),
            (&#34;app&#34;, &#34;app&#34;, &#34;app.py&#34;, False),
        )
        genTasks = {
            s[0]: dict(parentDir=s[1], file=s[2], justCopy=s[3]) for s in itemSpecs
        }
        cssInfo = makeCssInfo()

        version = tfVersion.removesuffix(PRE) if tokenBased else tfVersion

        def createConfig(sourceText, customText):
            text = sourceText.replace(&#34;«version»&#34;, f&#39;&#34;{version}&#34;&#39;)

            settings = readYaml(text=text, plain=True)
            settings.setdefault(&#34;provenanceSpec&#34;, {})[&#34;branch&#34;] = BRANCH_DEFAULT_NEW

            if tokenBased:
                if &#34;typeDisplay&#34; in settings and &#34;word&#34; in settings[&#34;typeDisplay&#34;]:
                    del settings[&#34;typeDisplay&#34;][&#34;word&#34;]

            customSettings = (
                {} if not customText else readYaml(text=customText, plain=True)
            )

            mergeDict(settings, customSettings)

            text = writeYaml(settings)

            return text

        def createDisplay(sourceText, customText):
            &#34;&#34;&#34;Copies and tweaks the display.css file of an TF app.

            We generate CSS code for a certain text formatting styles,
            triggered by `rend` attributes in the source.
            &#34;&#34;&#34;

            css = sourceText.replace(&#34;«rends»&#34;, cssInfo)
            return f&#34;{css}\n\n{customText}\n&#34;

        def createApp(sourceText, customText):
            &#34;&#34;&#34;Copies and tweaks the app.py file of an TF app.

            The template app.py provides text formatting functions.
            It retrieves text from features, but that is dependent on
            the settings of the conversion, in particular whether we have words as
            slots or characters.

            Depending on that we insert some code in the template.

            The template contains the string `F.matérial`, and it will be replaced
            by something like

            ```
            F.ch.v(n)
            ```

            or

            ```
            f&#34;{F.str.v(n)}{F.after.v(n)}&#34;
            ```

            That&#39;s why the variable `materialCode` in the body gets a rather
            unusual value: it is interpreted later on as code.
            &#34;&#34;&#34;

            materialCode = (
                &#39;&#39;&#39;F.ch.v(n) or &#34;&#34;&#39;&#39;&#39;
                if charAsSlot or tokenBased
                else &#34;&#34;&#34;f&#39;{F.str.v(n) or &#34;&#34;}{F.after.v(n) or &#34;&#34;}&#39;&#34;&#34;&#34;
            )
            rendValues = repr(KNOWN_RENDS)

            code = sourceText.replace(&#34;F.matérial&#34;, materialCode)
            code = code.replace(&#39;&#34;rèndValues&#34;&#39;, rendValues)

            hookStartRe = re.compile(r&#34;^# DEF (import|init|extra)\s*$&#34;, re.M)
            hookEndRe = re.compile(r&#34;^# END DEF\s*$&#34;, re.M)
            hookInsertRe = re.compile(r&#34;^\s*# INSERT (import|init|extra)\s*$&#34;, re.M)

            custom = {}
            section = None

            for line in (customText or &#34;&#34;).split(&#34;\n&#34;):
                line = line.rstrip()

                if section is None:
                    match = hookStartRe.match(line)
                    if match:
                        section = match.group(1)
                        custom[section] = []
                else:
                    match = hookEndRe.match(line)
                    if match:
                        section = None
                    else:
                        custom[section].append(line)

            codeLines = []

            for line in code.split(&#34;\n&#34;):
                line = line.rstrip()

                match = hookInsertRe.match(line)
                if match:
                    section = match.group(1)
                    codeLines.extend(custom.get(section, []))
                else:
                    codeLines.append(line)

            return &#34;\n&#34;.join(codeLines) + &#34;\n&#34;

        def createTranscription(sourceText, customText):
            &#34;&#34;&#34;Copies and tweaks the transcription.md file for a TF corpus.&#34;&#34;&#34;
            org = self.org
            repo = self.repo
            relative = self.relative
            intFeatures = self.intFeatures
            extra = self.extra

            def metaRep(feat, meta):
                valueType = &#34;int&#34; if feat in intFeatures else &#34;str&#34;
                description = meta.get(&#34;description&#34;, &#34;&#34;)
                extraFieldRep = &#34;\n&#34;.join(
                    f&#34;*   `{field}`: `{value}`&#34;
                    for (field, value) in meta.items()
                    if field not in {&#34;description&#34;, &#34;valueType&#34;}
                )

                return (
                    f&#34;&#34;&#34;{description}\n&#34;&#34;&#34;
                    f&#34;&#34;&#34;The values of this feature have type {valueType}.\n&#34;&#34;&#34;
                    f&#34;&#34;&#34;{extraFieldRep}&#34;&#34;&#34;
                )

            extra = &#34;\n\n&#34;.join(
                f&#34;## `{feat}`\n\n{metaRep(feat, info[&#39;meta&#39;])}\n&#34;
                for (feat, info) in extra.items()
            )

            text = (
                dedent(
                    f&#34;&#34;&#34;
                # Corpus {org} - {repo}{relative}

                &#34;&#34;&#34;
                )
                + tweakTrans(
                    sourceText,
                    procins,
                    wordAsSlot,
                    tokenAsSlot,
                    charAsSlot,
                    parentEdges,
                    siblingEdges,
                    tokenBased,
                    sectionModel,
                    sectionProperties,
                    REND_DESC,
                    extra,
                )
                + dedent(
                    &#34;&#34;&#34;

                    ## See also

                    *   [about](about.md)
                    &#34;&#34;&#34;
                )
            )
            return f&#34;{text}\n\n{customText}\n&#34;

        def createAbout(sourceText, customText):
            org = self.org
            repo = self.repo
            relative = self.relative
            generic = self.generic
            if tokenBased:
                generic[&#34;version&#34;] = version

            generic = &#34;\n\n&#34;.join(
                f&#34;## `{key}`\n\n`{value}`\n&#34; for (key, value) in generic.items()
            )

            return f&#34;{customText}\n\n{sourceText}\n\n&#34; + (
                dedent(
                    f&#34;&#34;&#34;
                # Corpus {org} - {repo}{relative}

                &#34;&#34;&#34;
                )
                + generic
                + dedent(
                    &#34;&#34;&#34;

                    ## Conversion

                    Converted from TEI to TF

                    ## See also

                    *   [transcription](transcription.md)
                    &#34;&#34;&#34;
                )
            )

        extraRep = &#34; with NLP output &#34; if tokenBased else &#34;&#34;

        if verbose &gt;= 0:
            console(f&#34;App updating {extraRep} ...&#34;)

        for name, info in genTasks.items():
            parentDir = info[&#34;parentDir&#34;]
            (sourceBit, targetBit) = (
                parentDir if type(parentDir) is tuple else (parentDir, parentDir)
            )
            file = info[FILE]
            fileParts = file.rsplit(&#34;.&#34;, 1)
            if len(fileParts) == 1:
                fileParts = [file, &#34;&#34;]
            (fileBase, fileExt) = fileParts
            if fileExt:
                fileExt = f&#34;.{fileExt}&#34;
            targetDir = f&#34;{refDir}/{targetBit}&#34;
            itemTarget = f&#34;{targetDir}/{file}&#34;
            itemCustom = f&#34;{targetDir}/{fileBase}_custom{fileExt}&#34;
            itemPre = f&#34;{targetDir}/{fileBase}_orig{fileExt}&#34;

            justCopy = info[&#34;justCopy&#34;]
            teiDir = f&#34;{myDir}/{sourceBit}&#34;
            itemSource = f&#34;{teiDir}/{file}&#34;

            # If there is custom info, we do not have to preserve the previous version.
            # Otherwise we save the target before overwriting it; # unless it
            # has been saved before

            preExists = fileExists(itemPre)
            targetExists = fileExists(itemTarget)
            customExists = fileExists(itemCustom)

            msg = &#34;&#34;

            if justCopy:
                if targetExists:
                    msg = &#34;(already exists, not overwritten)&#34;
                    safe = False
                else:
                    msg = &#34;(copied)&#34;
                    safe = True
            else:
                if targetExists:
                    if customExists:
                        msg = &#34;(generated with custom info)&#34;
                    else:
                        if preExists:
                            msg = &#34;(no custom info, older original exists)&#34;
                        else:
                            msg = &#34;(no custom info, original preserved)&#34;
                            fileCopy(itemTarget, itemPre)
                else:
                    msg = &#34;(created)&#34;

            initTree(targetDir, fresh=False)

            if justCopy:
                if safe:
                    fileCopy(itemSource, itemTarget)
            else:
                if fileExists(itemSource):
                    with fileOpen(itemSource) as fh:
                        sourceText = fh.read()
                else:
                    sourceText = &#34;&#34;

                if fileExists(itemCustom):
                    with fileOpen(itemCustom) as fh:
                        customText = fh.read()
                else:
                    customText = &#34;&#34;

                targetText = (
                    createConfig
                    if name == &#34;config&#34;
                    else createApp
                    if name == &#34;app&#34;
                    else createDisplay
                    if name == &#34;display&#34;
                    else createTranscription
                    if name == &#34;trans&#34;
                    else createAbout
                    if name == &#34;about&#34;
                    else fileCopy  # this cannot occur because justCopy is False
                )(sourceText, customText)

                with fileOpen(itemTarget, mode=&#34;w&#34;) as fh:
                    fh.write(targetText)

            if verbose &gt;= 0:
                console(f&#34;\t{ux(itemTarget):30} {msg}&#34;)

        if verbose &gt;= 0:
            console(&#34;Done&#34;)
        else:
            console(f&#34;App updated{extraRep}&#34;)

    # START the TEXT-FABRIC BROWSER on this CORPUS

    def browseTask(self):
        &#34;&#34;&#34;Implementation of the &#34;browse&#34; task.

        It gives a shell command to start the TF browser on
        the newly created corpus.
        There should be a valid TF dataset and app configuration in place

        Returns
        -------
        boolean
            Whether the operation was successful.
        &#34;&#34;&#34;
        if not self.importOK():
            return

        if not self.good:
            return

        org = self.org
        repo = self.repo
        relative = self.relative
        backend = self.backend
        tfVersion = self.tfVersion

        backendOpt = &#34;&#34; if backend == &#34;github&#34; else f&#34;--backend={backend}&#34;
        versionOpt = f&#34;--version={tfVersion}&#34;
        versionOpt = &#34;&#34;
        try:
            run(
                (
                    f&#34;tf {org}/{repo}{relative}:clone --checkout=clone &#34;
                    f&#34;{versionOpt} {backendOpt}&#34;
                ),
                shell=True,
            )
        except KeyboardInterrupt:
            pass

    def task(
        self,
        check=False,
        convert=False,
        load=False,
        app=False,
        apptoken=False,
        browse=False,
        verbose=None,
        validate=None,
    ):
        &#34;&#34;&#34;Carry out any task, possibly modified by any flag.

        This is a higher level function that can execute a selection of tasks.

        The tasks will be executed in a fixed order:
        `check`, `convert`, `load`, `app`, `apptoken`, `browse`.
        But you can select which one(s) must be executed.

        If multiple tasks must be executed and one fails, the subsequent tasks
        will not be executed.

        Parameters
        ----------
        check: boolean, optional False
            Whether to carry out the `check` task.
        convert: boolean, optional False
            Whether to carry out the `convert` task.
        load: boolean, optional False
            Whether to carry out the `load` task.
        app: boolean, optional False
            Whether to carry out the `app` task.
        apptoken: boolean, optional False
            Whether to carry out the `apptoken` task.
        browse: boolean, optional False
            Whether to carry out the `browse` task&#34;
        verbose: integer, optional -1
            Produce no (-1), some (0) or many (1) progress and reporting messages
        validate: boolean, optional True
            Whether to perform XML validation during the check task

        Returns
        -------
        boolean
            Whether all tasks have executed successfully.
        &#34;&#34;&#34;
        if not self.importOK():
            return

        if verbose is not None:
            verboseSav = self.verbose
            self.verbose = verbose

        if validate is not None:
            self.validate = validate

        if not self.good:
            return False

        for condition, method, kwargs in (
            (check, self.checkTask, {}),
            (convert, self.convertTask, {}),
            (load, self.loadTask, {}),
            (app, self.appTask, {}),
            (apptoken, self.appTask, dict(tokenBased=True)),
            (browse, self.browseTask, {}),
        ):
            if condition:
                method(**kwargs)
                if not self.good:
                    break

        if verbose is not None:
            self.verbose = verboseSav
        return self.good</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tf.capable.CheckImport" href="../capable.html#tf.capable.CheckImport">CheckImport</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tf.convert.tei.TEI.appTask"><code class="name flex">
<span>def <span class="ident">appTask</span></span>(<span>self, tokenBased=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of the "app" task.</p>
<p>It creates / updates a corpus-specific app plus specific documentation files.
There should be a valid TF dataset in place, because some
settings in the app derive from it.</p>
<p>It will also read custom additions that are present in the target app directory.
These files are:</p>
<ul>
<li><code>about_custom.md</code>:
A markdown file with specific colophon information about the dataset.
In the generated file, this information will be put at the start.</li>
<li><code>transcription_custom.md</code>:
A markdown file with specific encoding information about the dataset.
In the generated file, this information will be put at the start.</li>
<li><code>config_custom.yaml</code>:
A YAML file with configuration data that will be <em>merged</em> into the generated
config.yaml.</li>
<li><code>app_custom.py</code>:
A python file with named snippets of code to be inserted
at corresponding places in the generated <code>app.py</code></li>
<li><code>display_custom.css</code>:
Additional CSS definitions that will be appended to the generated
<code>display.css</code>.</li>
</ul>
<p>If the TF app for this resource needs custom code, this is the way to retain
that code between automatic generation of files.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>Whether the operation was successful.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/331baa8460d48d644338cf8e085d696cb9cbdbb0/tf/convert/tei.py#L4145-L4513" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def appTask(self, tokenBased=False):
    &#34;&#34;&#34;Implementation of the &#34;app&#34; task.

    It creates / updates a corpus-specific app plus specific documentation files.
    There should be a valid TF dataset in place, because some
    settings in the app derive from it.

    It will also read custom additions that are present in the target app directory.
    These files are:

    *   `about_custom.md`:
        A markdown file with specific colophon information about the dataset.
        In the generated file, this information will be put at the start.
    *   `transcription_custom.md`:
        A markdown file with specific encoding information about the dataset.
        In the generated file, this information will be put at the start.
    *   `config_custom.yaml`:
        A YAML file with configuration data that will be *merged* into the generated
        config.yaml.
    *   `app_custom.py`:
        A python file with named snippets of code to be inserted
        at corresponding places in the generated `app.py`
    *   `display_custom.css`:
        Additional CSS definitions that will be appended to the generated
        `display.css`.

    If the TF app for this resource needs custom code, this is the way to retain
    that code between automatic generation of files.

    Returns
    -------
    boolean
        Whether the operation was successful.
    &#34;&#34;&#34;
    if not self.importOK():
        return

    if not self.good:
        return

    verbose = self.verbose

    refDir = self.refDir
    myDir = self.myDir
    procins = self.procins
    wordAsSlot = self.wordAsSlot
    tokenAsSlot = self.tokenAsSlot
    charAsSlot = self.charAsSlot
    parentEdges = self.parentEdges
    siblingEdges = self.siblingEdges
    sectionModel = self.sectionModel
    sectionProperties = self.sectionProperties
    tfVersion = self.tfVersion

    # key | parentDir | file | template based

    # if parentDir is a tuple, the first part is the parentDir of the source
    # end the second part is the parentDir of the destination

    itemSpecs = (
        (&#34;about&#34;, &#34;docs&#34;, &#34;about.md&#34;, False),
        (&#34;trans&#34;, (&#34;app&#34;, &#34;docs&#34;), &#34;transcription.md&#34;, False),
        (&#34;logo&#34;, &#34;app/static&#34;, &#34;logo.png&#34;, True),
        (&#34;display&#34;, &#34;app/static&#34;, &#34;display.css&#34;, False),
        (&#34;config&#34;, &#34;app&#34;, &#34;config.yaml&#34;, False),
        (&#34;app&#34;, &#34;app&#34;, &#34;app.py&#34;, False),
    )
    genTasks = {
        s[0]: dict(parentDir=s[1], file=s[2], justCopy=s[3]) for s in itemSpecs
    }
    cssInfo = makeCssInfo()

    version = tfVersion.removesuffix(PRE) if tokenBased else tfVersion

    def createConfig(sourceText, customText):
        text = sourceText.replace(&#34;«version»&#34;, f&#39;&#34;{version}&#34;&#39;)

        settings = readYaml(text=text, plain=True)
        settings.setdefault(&#34;provenanceSpec&#34;, {})[&#34;branch&#34;] = BRANCH_DEFAULT_NEW

        if tokenBased:
            if &#34;typeDisplay&#34; in settings and &#34;word&#34; in settings[&#34;typeDisplay&#34;]:
                del settings[&#34;typeDisplay&#34;][&#34;word&#34;]

        customSettings = (
            {} if not customText else readYaml(text=customText, plain=True)
        )

        mergeDict(settings, customSettings)

        text = writeYaml(settings)

        return text

    def createDisplay(sourceText, customText):
        &#34;&#34;&#34;Copies and tweaks the display.css file of an TF app.

        We generate CSS code for a certain text formatting styles,
        triggered by `rend` attributes in the source.
        &#34;&#34;&#34;

        css = sourceText.replace(&#34;«rends»&#34;, cssInfo)
        return f&#34;{css}\n\n{customText}\n&#34;

    def createApp(sourceText, customText):
        &#34;&#34;&#34;Copies and tweaks the app.py file of an TF app.

        The template app.py provides text formatting functions.
        It retrieves text from features, but that is dependent on
        the settings of the conversion, in particular whether we have words as
        slots or characters.

        Depending on that we insert some code in the template.

        The template contains the string `F.matérial`, and it will be replaced
        by something like

        ```
        F.ch.v(n)
        ```

        or

        ```
        f&#34;{F.str.v(n)}{F.after.v(n)}&#34;
        ```

        That&#39;s why the variable `materialCode` in the body gets a rather
        unusual value: it is interpreted later on as code.
        &#34;&#34;&#34;

        materialCode = (
            &#39;&#39;&#39;F.ch.v(n) or &#34;&#34;&#39;&#39;&#39;
            if charAsSlot or tokenBased
            else &#34;&#34;&#34;f&#39;{F.str.v(n) or &#34;&#34;}{F.after.v(n) or &#34;&#34;}&#39;&#34;&#34;&#34;
        )
        rendValues = repr(KNOWN_RENDS)

        code = sourceText.replace(&#34;F.matérial&#34;, materialCode)
        code = code.replace(&#39;&#34;rèndValues&#34;&#39;, rendValues)

        hookStartRe = re.compile(r&#34;^# DEF (import|init|extra)\s*$&#34;, re.M)
        hookEndRe = re.compile(r&#34;^# END DEF\s*$&#34;, re.M)
        hookInsertRe = re.compile(r&#34;^\s*# INSERT (import|init|extra)\s*$&#34;, re.M)

        custom = {}
        section = None

        for line in (customText or &#34;&#34;).split(&#34;\n&#34;):
            line = line.rstrip()

            if section is None:
                match = hookStartRe.match(line)
                if match:
                    section = match.group(1)
                    custom[section] = []
            else:
                match = hookEndRe.match(line)
                if match:
                    section = None
                else:
                    custom[section].append(line)

        codeLines = []

        for line in code.split(&#34;\n&#34;):
            line = line.rstrip()

            match = hookInsertRe.match(line)
            if match:
                section = match.group(1)
                codeLines.extend(custom.get(section, []))
            else:
                codeLines.append(line)

        return &#34;\n&#34;.join(codeLines) + &#34;\n&#34;

    def createTranscription(sourceText, customText):
        &#34;&#34;&#34;Copies and tweaks the transcription.md file for a TF corpus.&#34;&#34;&#34;
        org = self.org
        repo = self.repo
        relative = self.relative
        intFeatures = self.intFeatures
        extra = self.extra

        def metaRep(feat, meta):
            valueType = &#34;int&#34; if feat in intFeatures else &#34;str&#34;
            description = meta.get(&#34;description&#34;, &#34;&#34;)
            extraFieldRep = &#34;\n&#34;.join(
                f&#34;*   `{field}`: `{value}`&#34;
                for (field, value) in meta.items()
                if field not in {&#34;description&#34;, &#34;valueType&#34;}
            )

            return (
                f&#34;&#34;&#34;{description}\n&#34;&#34;&#34;
                f&#34;&#34;&#34;The values of this feature have type {valueType}.\n&#34;&#34;&#34;
                f&#34;&#34;&#34;{extraFieldRep}&#34;&#34;&#34;
            )

        extra = &#34;\n\n&#34;.join(
            f&#34;## `{feat}`\n\n{metaRep(feat, info[&#39;meta&#39;])}\n&#34;
            for (feat, info) in extra.items()
        )

        text = (
            dedent(
                f&#34;&#34;&#34;
            # Corpus {org} - {repo}{relative}

            &#34;&#34;&#34;
            )
            + tweakTrans(
                sourceText,
                procins,
                wordAsSlot,
                tokenAsSlot,
                charAsSlot,
                parentEdges,
                siblingEdges,
                tokenBased,
                sectionModel,
                sectionProperties,
                REND_DESC,
                extra,
            )
            + dedent(
                &#34;&#34;&#34;

                ## See also

                *   [about](about.md)
                &#34;&#34;&#34;
            )
        )
        return f&#34;{text}\n\n{customText}\n&#34;

    def createAbout(sourceText, customText):
        org = self.org
        repo = self.repo
        relative = self.relative
        generic = self.generic
        if tokenBased:
            generic[&#34;version&#34;] = version

        generic = &#34;\n\n&#34;.join(
            f&#34;## `{key}`\n\n`{value}`\n&#34; for (key, value) in generic.items()
        )

        return f&#34;{customText}\n\n{sourceText}\n\n&#34; + (
            dedent(
                f&#34;&#34;&#34;
            # Corpus {org} - {repo}{relative}

            &#34;&#34;&#34;
            )
            + generic
            + dedent(
                &#34;&#34;&#34;

                ## Conversion

                Converted from TEI to TF

                ## See also

                *   [transcription](transcription.md)
                &#34;&#34;&#34;
            )
        )

    extraRep = &#34; with NLP output &#34; if tokenBased else &#34;&#34;

    if verbose &gt;= 0:
        console(f&#34;App updating {extraRep} ...&#34;)

    for name, info in genTasks.items():
        parentDir = info[&#34;parentDir&#34;]
        (sourceBit, targetBit) = (
            parentDir if type(parentDir) is tuple else (parentDir, parentDir)
        )
        file = info[FILE]
        fileParts = file.rsplit(&#34;.&#34;, 1)
        if len(fileParts) == 1:
            fileParts = [file, &#34;&#34;]
        (fileBase, fileExt) = fileParts
        if fileExt:
            fileExt = f&#34;.{fileExt}&#34;
        targetDir = f&#34;{refDir}/{targetBit}&#34;
        itemTarget = f&#34;{targetDir}/{file}&#34;
        itemCustom = f&#34;{targetDir}/{fileBase}_custom{fileExt}&#34;
        itemPre = f&#34;{targetDir}/{fileBase}_orig{fileExt}&#34;

        justCopy = info[&#34;justCopy&#34;]
        teiDir = f&#34;{myDir}/{sourceBit}&#34;
        itemSource = f&#34;{teiDir}/{file}&#34;

        # If there is custom info, we do not have to preserve the previous version.
        # Otherwise we save the target before overwriting it; # unless it
        # has been saved before

        preExists = fileExists(itemPre)
        targetExists = fileExists(itemTarget)
        customExists = fileExists(itemCustom)

        msg = &#34;&#34;

        if justCopy:
            if targetExists:
                msg = &#34;(already exists, not overwritten)&#34;
                safe = False
            else:
                msg = &#34;(copied)&#34;
                safe = True
        else:
            if targetExists:
                if customExists:
                    msg = &#34;(generated with custom info)&#34;
                else:
                    if preExists:
                        msg = &#34;(no custom info, older original exists)&#34;
                    else:
                        msg = &#34;(no custom info, original preserved)&#34;
                        fileCopy(itemTarget, itemPre)
            else:
                msg = &#34;(created)&#34;

        initTree(targetDir, fresh=False)

        if justCopy:
            if safe:
                fileCopy(itemSource, itemTarget)
        else:
            if fileExists(itemSource):
                with fileOpen(itemSource) as fh:
                    sourceText = fh.read()
            else:
                sourceText = &#34;&#34;

            if fileExists(itemCustom):
                with fileOpen(itemCustom) as fh:
                    customText = fh.read()
            else:
                customText = &#34;&#34;

            targetText = (
                createConfig
                if name == &#34;config&#34;
                else createApp
                if name == &#34;app&#34;
                else createDisplay
                if name == &#34;display&#34;
                else createTranscription
                if name == &#34;trans&#34;
                else createAbout
                if name == &#34;about&#34;
                else fileCopy  # this cannot occur because justCopy is False
            )(sourceText, customText)

            with fileOpen(itemTarget, mode=&#34;w&#34;) as fh:
                fh.write(targetText)

        if verbose &gt;= 0:
            console(f&#34;\t{ux(itemTarget):30} {msg}&#34;)

    if verbose &gt;= 0:
        console(&#34;Done&#34;)
    else:
        console(f&#34;App updated{extraRep}&#34;)</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.TEI.browseTask"><code class="name flex">
<span>def <span class="ident">browseTask</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of the "browse" task.</p>
<p>It gives a shell command to start the TF browser on
the newly created corpus.
There should be a valid TF dataset and app configuration in place</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>Whether the operation was successful.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/331baa8460d48d644338cf8e085d696cb9cbdbb0/tf/convert/tei.py#L4517-L4553" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def browseTask(self):
    &#34;&#34;&#34;Implementation of the &#34;browse&#34; task.

    It gives a shell command to start the TF browser on
    the newly created corpus.
    There should be a valid TF dataset and app configuration in place

    Returns
    -------
    boolean
        Whether the operation was successful.
    &#34;&#34;&#34;
    if not self.importOK():
        return

    if not self.good:
        return

    org = self.org
    repo = self.repo
    relative = self.relative
    backend = self.backend
    tfVersion = self.tfVersion

    backendOpt = &#34;&#34; if backend == &#34;github&#34; else f&#34;--backend={backend}&#34;
    versionOpt = f&#34;--version={tfVersion}&#34;
    versionOpt = &#34;&#34;
    try:
        run(
            (
                f&#34;tf {org}/{repo}{relative}:clone --checkout=clone &#34;
                f&#34;{versionOpt} {backendOpt}&#34;
            ),
            shell=True,
        )
    except KeyboardInterrupt:
        pass</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.TEI.checkTask"><code class="name flex">
<span>def <span class="ident">checkTask</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of the "check" task.</p>
<p>It validates the TEI, but only if a schema file has been passed explicitly
when constructing the <code><a title="tf.convert.tei.TEI" href="#tf.convert.tei.TEI">TEI</a></code> object.</p>
<p>Then it makes an inventory of all elements and attributes in the TEI files.</p>
<p>If tags are used in multiple namespaces, it will be reported.</p>
<div class="admonition caution">
<p class="admonition-title">Conflation of namespaces</p>
<p>The TEI to TF conversion does construct node types and attributes
without taking namespaces into account.
However, the parsing process is namespace aware.</p>
</div>
<p>The inventory lists all elements and attributes, and many attribute values.
But is represents any digit with <code>n</code>, and some attributes that contain
ids or keywords, are reduced to the value <code>x</code>.</p>
<p>This information reduction helps to get a clear overview.</p>
<p>It writes reports to the <code>reportPath</code>:</p>
<ul>
<li><code>errors.txt</code>: validation errors</li>
<li><code>elements.txt</code>: element / attribute inventory.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/331baa8460d48d644338cf8e085d696cb9cbdbb0/tf/convert/tei.py#L1688-L2389" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def checkTask(self):
    &#34;&#34;&#34;Implementation of the &#34;check&#34; task.

    It validates the TEI, but only if a schema file has been passed explicitly
    when constructing the `TEI()` object.

    Then it makes an inventory of all elements and attributes in the TEI files.

    If tags are used in multiple namespaces, it will be reported.

    !!! caution &#34;Conflation of namespaces&#34;
        The TEI to TF conversion does construct node types and attributes
        without taking namespaces into account.
        However, the parsing process is namespace aware.

    The inventory lists all elements and attributes, and many attribute values.
    But is represents any digit with `n`, and some attributes that contain
    ids or keywords, are reduced to the value `x`.

    This information reduction helps to get a clear overview.

    It writes reports to the `reportPath`:

    *   `errors.txt`: validation errors
    *   `elements.txt`: element / attribute inventory.
    &#34;&#34;&#34;
    if not self.importOK():
        return

    if not self.good:
        return

    verbose = self.verbose
    procins = self.procins
    validate = self.validate
    modelInfo = self.modelInfo
    modelInv = self.modelInv
    modelXsd = self.modelXsd
    A = self.A
    etree = self.etree

    teiPath = self.teiPath
    reportPath = self.reportPath
    docsDir = self.docsDir
    sectionModel = self.sectionModel

    if verbose == 1:
        console(f&#34;TEI to TF checking: {ux(teiPath)} =&gt; {ux(reportPath)}&#34;)
    if verbose &gt;= 0:
        console(
            f&#34;Processing instructions are {&#39;treated&#39; if procins else &#39;ignored&#39;}&#34;
        )
        console(f&#34;XML validation will be {&#39;performed&#39; if validate else &#39;skipped&#39;}&#34;)

    kindLabels = dict(
        format=&#34;Formatting Attributes&#34;,
        keyword=&#34;Keyword Attributes&#34;,
        rest=&#34;Remaining Attributes and Elements&#34;,
    )
    getStore = lambda: collections.defaultdict(  # noqa: E731
        lambda: collections.defaultdict(collections.Counter)
    )
    analysis = {x: getStore() for x in kindLabels}
    errors = []
    tagByNs = collections.defaultdict(collections.Counter)
    refs = collections.defaultdict(lambda: collections.Counter())
    ids = collections.defaultdict(lambda: collections.Counter())

    parser = self.getParser()
    baseSchema = modelXsd[None]
    overrides = [
        override for (model, override) in modelXsd.items() if model is not None
    ]
    A.getElementInfo(baseSchema, overrides, verbose=verbose)
    elementDefs = A.elementDefs

    initTree(reportPath)
    initTree(docsDir)

    nProcins = 0

    lbParents = collections.Counter()

    def analyse(root, analysis, xmlFile):
        FORMAT_ATTS = set(
            &#34;&#34;&#34;
            dim
            level
            place
            rend
        &#34;&#34;&#34;.strip().split()
        )

        KEYWORD_ATTS = set(
            &#34;&#34;&#34;
            facs
            form
            function
            lang
            reason
            type
            unit
            who
        &#34;&#34;&#34;.strip().split()
        )

        TRIM_ATTS = set(
            &#34;&#34;&#34;
            id
            key
            target
            value
        &#34;&#34;&#34;.strip().split()
        )

        NUM_RE = re.compile(r&#34;&#34;&#34;[0-9]&#34;&#34;&#34;, re.S)

        def nodeInfo(xnode):
            nonlocal nProcins

            if procins and isinstance(xnode, etree._ProcessingInstruction):
                target = xnode.target
                tag = f&#34;?{target}&#34;
                ns = &#34;&#34;
                nProcins += 1
            else:
                qName = etree.QName(xnode.tag)
                tag = qName.localname
                ns = qName.namespace

            atts = {etree.QName(k).localname: v for (k, v) in xnode.attrib.items()}

            tagByNs[tag][ns] += 1

            if tag == &#34;lb&#34;:
                parentTag = etree.QName(xnode.getparent().tag).localname
                lbParents[parentTag] += 1

            if len(atts) == 0:
                kind = &#34;rest&#34;
                analysis[kind][tag][&#34;&#34;][&#34;&#34;] += 1
            else:
                idv = atts.get(&#34;id&#34;, None)

                if idv is not None:
                    ids[xmlFile][idv] += 1

                for refAtt, targetFile, targetId in getRefs(tag, atts, xmlFile):
                    refs[xmlFile][(targetFile, targetId)] += 1

                for k, v in atts.items():
                    kind = (
                        &#34;format&#34;
                        if k in FORMAT_ATTS
                        else &#34;keyword&#34;
                        if k in KEYWORD_ATTS
                        else &#34;rest&#34;
                    )
                    dest = analysis[kind]

                    if kind == &#34;rest&#34;:
                        vTrim = &#34;X&#34; if k in TRIM_ATTS else NUM_RE.sub(&#34;N&#34;, v)
                        dest[tag][k][vTrim] += 1
                    else:
                        words = v.strip().split()
                        for w in words:
                            dest[tag][k][w.strip()] += 1

            for child in xnode.iterchildren(
                tag=(etree.Element, etree.ProcessingInstruction)
                if procins
                else etree.Element
            ):
                nodeInfo(child)

        nodeInfo(root)

    def writeErrors():
        &#34;&#34;&#34;Write the errors to a file.&#34;&#34;&#34;

        errorFile = f&#34;{reportPath}/errors.txt&#34;

        nErrors = 0
        nFiles = 0

        with fileOpen(errorFile, mode=&#34;w&#34;) as fh:
            prevFolder = None
            prevFile = None

            for folder, file, line, col, kind, text in errors:
                newFolder = prevFolder != folder
                newFile = newFolder or prevFile != file

                if newFile:
                    nFiles += 1

                if kind == &#34;error&#34;:
                    nErrors += 1

                indent1 = f&#34;{folder}\n\t&#34; if newFolder else &#34;\t&#34;
                indent2 = f&#34;{file}\n\t\t&#34; if newFile else &#34;\t&#34;
                loc = f&#34;{line or &#39;&#39;}:{col or &#39;&#39;}&#34;
                text = &#34;\n&#34;.join(wrap(text, width=80, subsequent_indent=&#34;\t\t\t&#34;))
                fh.write(f&#34;{indent1}{indent2}{loc} {kind or &#39;&#39;} {text}\n&#34;)
                prevFolder = folder
                prevFile = file

        if nErrors:
            console(
                (
                    f&#34;{nErrors} validation error(s) in {nFiles} file(s) &#34;
                    f&#34;written to {errorFile}&#34;
                ),
                error=True,
            )
        else:
            if verbose &gt;= 0:
                if validate:
                    console(&#34;Validation OK&#34;)
                else:
                    console(&#34;No validation performed&#34;)

    def writeNamespaces():
        errorFile = f&#34;{reportPath}/namespaces.txt&#34;

        nErrors = 0

        nTags = len(tagByNs)

        with fileOpen(errorFile, mode=&#34;w&#34;) as fh:
            for tag, nsInfo in sorted(
                tagByNs.items(), key=lambda x: (-len(x[1]), x[0])
            ):
                label = &#34;OK&#34;
                nNs = len(nsInfo)
                if nNs &gt; 1:
                    nErrors += 1
                    label = &#34;XX&#34;

                for ns, amount in sorted(
                    nsInfo.items(), key=lambda x: (-x[1], x[0])
                ):
                    fh.write(
                        f&#34;{label} {nNs:&gt;2} namespace for &#34;
                        f&#34;{tag:&lt;16} : {amount:&gt;5}x {ns}\n&#34;
                    )

        if verbose &gt;= 0:
            if procins:
                plural = &#34;&#34; if nProcins == 1 else &#34;s&#34;
                console(f&#34;{nProcins} processing instruction{plural} encountered.&#34;)

            console(
                f&#34;{nTags} tags of which {nErrors} with multiple namespaces &#34;
                f&#34;written to {errorFile}&#34;
                if verbose &gt;= 0 or nErrors
                else &#34;Namespaces OK&#34;
            )

    def writeReport():
        reportFile = f&#34;{reportPath}/elements.txt&#34;
        with fileOpen(reportFile, mode=&#34;w&#34;) as fh:
            fh.write(
                &#34;Inventory of tags and attributes in the source XML file(s).\n&#34;
                &#34;Contains the following sections:\n&#34;
            )
            for label in kindLabels.values():
                fh.write(f&#34;\t{label}\n&#34;)
            fh.write(&#34;\n\n&#34;)

            infoLines = 0

            def writeAttInfo(tag, att, attInfo):
                nonlocal infoLines
                nl = &#34;&#34; if tag == &#34;&#34; else &#34;\n&#34;
                tagRep = &#34;&#34; if tag == &#34;&#34; else f&#34;&lt;{tag}&gt;&#34;
                attRep = &#34;&#34; if att == &#34;&#34; else f&#34;{att}=&#34;
                atts = sorted(attInfo.items())
                (val, amount) = atts[0]
                fh.write(
                    f&#34;{nl}\t{tagRep:&lt;18} &#34; f&#34;{attRep:&lt;11} {amount:&gt;5}x {val}\n&#34;
                )
                infoLines += 1
                for val, amount in atts[1:]:
                    fh.write(
                        f&#34;&#34;&#34;\t{&#39;&#39;:&lt;7}{&#39;&#39;:&lt;18} {&#39;&#34;&#39;:&lt;18} {amount:&gt;5}x {val}\n&#34;&#34;&#34;
                    )
                    infoLines += 1

            def writeTagInfo(tag, tagInfo):
                nonlocal infoLines
                tags = sorted(tagInfo.items())
                (att, attInfo) = tags[0]
                writeAttInfo(tag, att, attInfo)
                infoLines += 1
                for att, attInfo in tags[1:]:
                    writeAttInfo(&#34;&#34;, att, attInfo)

            for kind, label in kindLabels.items():
                fh.write(f&#34;\n{label}\n&#34;)
                for tag, tagInfo in sorted(analysis[kind].items()):
                    writeTagInfo(tag, tagInfo)

        if verbose &gt;= 0:
            console(f&#34;{infoLines} info line(s) written to {reportFile}&#34;)

    def writeElemTypes():
        elemsCombined = {}

        modelSet = set()

        for schemaOverride, eDefs in elementDefs.items():
            model = modelInv[schemaOverride]
            modelSet.add(model)
            for tag, (typ, mixed) in eDefs.items():
                elemsCombined.setdefault(tag, {}).setdefault(model, {})
                elemsCombined[tag][model][&#34;typ&#34;] = typ
                elemsCombined[tag][model][&#34;mixed&#34;] = mixed

        tagReport = {}

        for tag, tagInfo in elemsCombined.items():
            tagLines = []
            tagReport[tag] = tagLines

            if None in tagInfo:
                teiInfo = tagInfo[None]
                teiTyp = teiInfo[&#34;typ&#34;]
                teiMixed = teiInfo[&#34;mixed&#34;]
                teiTypRep = &#34;??&#34; if teiTyp is None else typ
                teiMixedRep = (
                    &#34;??&#34; if teiMixed is None else &#34;mixed&#34; if teiMixed else &#34;pure&#34;
                )
                mds = [&#34;TEI&#34;]

                for model in sorted(x for x in tagInfo if x is not None):
                    info = tagInfo[model]
                    typ = info[&#34;typ&#34;]
                    mixed = info[&#34;mixed&#34;]
                    if typ == teiTyp and mixed == teiMixed:
                        mds.append(model)
                    else:
                        typRep = (
                            &#34;&#34; if typ == teiTyp else &#34;??&#34; if typ is None else typ
                        )
                        mixedRep = (
                            &#34;&#34;
                            if mixed == teiMixed
                            else &#34;??&#34;
                            if mixed is None
                            else &#34;mixed&#34;
                            if mixed
                            else &#34;pure&#34;
                        )
                        tagLines.append((tag, [model], typRep, mixedRep))
                tagLines.insert(0, (tag, mds, teiTypRep, teiMixedRep))
            else:
                for model in sorted(tagInfo):
                    info = tagInfo[model]
                    typ = info[&#34;typ&#34;]
                    mixed = info[&#34;mixed&#34;]
                    typRep = &#34;??&#34; if typ is None else typ
                    mixedRep = (
                        &#34;??&#34; if mixed is None else &#34;mixed&#34; if mixed else &#34;pure&#34;
                    )
                    tagLines.append((tag, [model], typRep, mixedRep))

        reportFile = f&#34;{reportPath}/types.txt&#34;
        with fileOpen(reportFile, mode=&#34;w&#34;) as fh:
            for tag in sorted(tagReport):
                tagLines = tagReport[tag]
                for tag, mds, typ, mixed in tagLines:
                    model = &#34;,&#34;.join(mds)
                    fh.write(f&#34;{tag:&lt;18} {model:&lt;18} {typ:&lt;7} {mixed:&lt;5}\n&#34;)

        if verbose &gt;= 0:
            console(
                f&#34;{len(elemsCombined)} tag(s) type info written to {reportFile}&#34;
            )

    def writeLbParents():
        reportFile = f&#34;{reportPath}/lb-parents.txt&#34;

        with open(reportFile, &#34;w&#34;) as fh:
            for parent, n in sorted(lbParents.items()):
                fh.write(f&#34;{n:&gt;5} x {parent}\n&#34;)

        if verbose &gt;= 0:
            console(f&#34;lb-parent info written to {reportFile}&#34;)

    def writeIdRefs():
        reportIdFile = f&#34;{reportPath}/ids.txt&#34;
        reportRefFile = f&#34;{reportPath}/refs.txt&#34;

        ih = fileOpen(reportIdFile, mode=&#34;w&#34;)
        rh = fileOpen(reportRefFile, mode=&#34;w&#34;)

        refdIds = collections.Counter()
        missingIds = set()

        totalRefs = 0
        totalRefsU = 0

        totalResolvable = 0
        totalResolvableU = 0
        totalDangling = 0
        totalDanglingU = 0

        seenItems = set()

        for file, items in refs.items():
            rh.write(f&#34;{file}\n&#34;)

            resolvable = 0
            resolvableU = 0
            dangling = 0
            danglingU = 0

            for item, n in sorted(items.items()):
                totalRefs += n

                if item in seenItems:
                    newItem = False
                else:
                    seenItems.add(item)
                    newItem = True
                    totalRefsU += 1

                (target, idv) = item

                if target not in ids or idv not in ids[target]:
                    status = &#34;dangling&#34;
                    dangling += n

                    if newItem:
                        missingIds.add((target, idv))
                        danglingU += 1
                else:
                    status = &#34;ok&#34;
                    resolvable += n
                    refdIds[(target, idv)] += n

                    if newItem:
                        resolvableU += 1
                rh.write(f&#34;\t{status:&lt;10} {n:&gt;5} x {target} # {idv}\n&#34;)

            msgs = (
                f&#34;\tDangling:   {dangling:&gt;4} x {danglingU:&gt;4}&#34;,
                f&#34;\tResolvable: {resolvable:&gt;4} x {resolvableU:&gt;4}&#34;,
            )
            for msg in msgs:
                rh.write(f&#34;{msg}\n&#34;)

            totalResolvable += resolvable
            totalResolvableU += resolvableU
            totalDangling += dangling
            totalDanglingU += danglingU

        if verbose &gt;= 0:
            console(f&#34;Refs written to {reportRefFile}&#34;)
            msgs = (
                f&#34;\tresolvable: {totalResolvableU:&gt;4} in {totalResolvable:&gt;4}&#34;,
                f&#34;\tdangling:   {totalDanglingU:&gt;4} in {totalDangling:&gt;4}&#34;,
                f&#34;\tALL:        {totalRefsU:&gt;4} in {totalRefs:&gt;4} &#34;,
            )
            for msg in msgs:
                console(msg)

        totalIds = 0
        totalIdsU = 0
        totalIdsM = 0
        totalIdsRefd = 0
        totalIdsRefdU = 0
        totalIdsUnused = 0

        for file, items in ids.items():
            totalIds += len(items)

            ih.write(f&#34;{file}\n&#34;)

            unique = 0
            multiple = 0
            refd = 0
            refdU = 0
            unused = 0

            for item, n in sorted(items.items()):
                nRefs = refdIds.get((file, item), 0)

                if n == 1:
                    unique += 1
                else:
                    multiple += 1

                if nRefs == 0:
                    unused += 1
                else:
                    refd += nRefs
                    refdU += 1

                status1 = f&#34;{n}x&#34;
                plural = &#34;&#34; if nRefs == 1 else &#34;s&#34;
                status2 = f&#34;{nRefs}ref{plural}&#34;

                ih.write(f&#34;\t{status1:&lt;8} {status2:&lt;8} {item}\n&#34;)

            msgs = (
                f&#34;\tUnique:     {unique:&gt;4}&#34;,
                f&#34;\tNon-unique: {multiple:&gt;4}&#34;,
                f&#34;\tUnused:     {unused:&gt;4}&#34;,
                f&#34;\tReferenced: {refd:&gt;4} x {refdU:&gt;4}&#34;,
            )
            for msg in msgs:
                ih.write(f&#34;{msg}\n&#34;)

            totalIdsU += unique
            totalIdsM += multiple
            totalIdsRefdU += refdU
            totalIdsRefd += refd
            totalIdsUnused += unused

        if verbose &gt;= 0:
            console(f&#34;Ids written to {reportIdFile}&#34;)
            msgs = (
                f&#34;\treferenced: {totalIdsRefdU:&gt;4} by {totalIdsRefd:&gt;4}&#34;,
                f&#34;\tnon-unique: {totalIdsM:&gt;4}&#34;,
                f&#34;\tunused:     {totalIdsUnused:&gt;4}&#34;,
                f&#34;\tALL:        {totalIdsU:&gt;4} in {totalIds:&gt;4}&#34;,
            )
            for msg in msgs:
                console(msg)

    def writeDoc():
        teiUrl = &#34;https://tei-c.org/release/doc/tei-p5-doc/en/html&#34;
        elUrlPrefix = f&#34;{teiUrl}/ref-&#34;
        attUrlPrefix = f&#34;{teiUrl}/REF-ATTS.html#&#34;
        docFile = f&#34;{docsDir}/elements.md&#34;
        with fileOpen(docFile, mode=&#34;w&#34;) as fh:
            fh.write(
                dedent(
                    &#34;&#34;&#34;
                    # Element and attribute inventory

                    Table of contents

                    &#34;&#34;&#34;
                )
            )
            for label in kindLabels.values():
                labelAnchor = label.replace(&#34; &#34;, &#34;-&#34;)
                fh.write(f&#34;*\t[{label}](#{labelAnchor})\n&#34;)

            fh.write(&#34;\n&#34;)

            tableHeader = dedent(
                &#34;&#34;&#34;
                | element | attribute | value | amount
                | --- | --- | --- | ---
                &#34;&#34;&#34;
            )

            def writeAttInfo(tag, att, attInfo):
                tagRep = &#34; &#34; if tag == &#34;&#34; else f&#34;[{tag}]({elUrlPrefix}{tag}.html)&#34;
                attRep = &#34; &#34; if att == &#34;&#34; else f&#34;[{att}]({attUrlPrefix}{att})&#34;
                atts = sorted(attInfo.items())
                (val, amount) = atts[0]
                valRep = f&#34;`{val}`&#34; if val else &#34;&#34;
                fh.write(
                    &#34;| &#34;
                    + (
                        &#34; | &#34;.join(
                            str(x)
                            for x in (
                                tagRep,
                                attRep,
                                valRep,
                                amount,
                            )
                        )
                    )
                    + &#34;\n&#34;
                )
                for val, amount in atts[1:]:
                    valRep = f&#34;`{val}`&#34; if val else &#34;&#34;
                    fh.write(f&#34;&#34;&#34;| | | {valRep} | {amount}\n&#34;&#34;&#34;)

            def writeTagInfo(tag, tagInfo):
                tags = sorted(tagInfo.items())
                (att, attInfo) = tags[0]
                writeAttInfo(tag, att, attInfo)
                for att, attInfo in tags[1:]:
                    writeAttInfo(&#34;&#34;, att, attInfo)

            for kind, label in kindLabels.items():
                fh.write(f&#34;## {label}\n{tableHeader}&#34;)
                for tag, tagInfo in sorted(analysis[kind].items()):
                    writeTagInfo(tag, tagInfo)
                fh.write(&#34;\n&#34;)

    def filterError(msg):
        return msg == (
            &#34;Element &#39;graphic&#39;, attribute &#39;url&#39;: [facet &#39;pattern&#39;] &#34;
            &#34;The value &#39;&#39; is not accepted by the pattern &#39;\\S+&#39;.&#34;
        )

    def doXMLFile(xmlPath):
        tree = etree.parse(xmlPath, parser)
        root = tree.getroot()
        xmlFile = fileNm(xmlPath)
        ids[xmlFile][&#34;&#34;] = 1
        analyse(root, analysis, xmlFile)

    xmlFilesByModel = collections.defaultdict(list)

    if sectionModel == &#34;I&#34;:
        i = 0
        for xmlFolder, xmlFiles in self.getXML():
            msg = &#34;Start &#34; if verbose &gt;= 0 else &#34;\t&#34;
            console(f&#34;{msg}folder {xmlFolder}:&#34;)
            j = 0
            cr = &#34;&#34;
            nl = True

            for xmlFile in xmlFiles:
                i += 1
                j += 1
                if j &gt; PROGRESS_LIMIT:
                    cr = &#34;\r&#34;
                    nl = False
                xmlPath = f&#34;{teiPath}/{xmlFolder}/{xmlFile}&#34;
                (model, adapt, tpl) = self.getSwitches(xmlPath)
                mdRep = model or &#34;TEI&#34;
                tplRep = tpl or &#34;&#34;
                adRep = adapt or &#34;&#34;

                label = f&#34;{mdRep:&lt;12} {tplRep:&lt;12} {adRep:&lt;12}&#34;

                if verbose &gt;= 0:
                    console(f&#34;{cr}{i:&gt;4} {label} {xmlFile:&lt;50}&#34;, newline=nl)
                xmlFilesByModel[model].append(xmlPath)
            if verbose &gt;= 0:
                console(&#34;&#34;)
                console(f&#34;End   folder {xmlFolder}&#34;)

    elif sectionModel == &#34;II&#34;:
        xmlFile = self.getXML()
        if xmlFile is None:
            console(&#34;No XML files found!&#34;, error=True)
            return False

        xmlPath = f&#34;{teiPath}/{xmlFile}&#34;
        (model, adapt, tpl) = self.getSwitches(xmlPath)
        xmlFilesByModel[model].append(xmlPath)

    good = True

    for model, xmlPaths in xmlFilesByModel.items():
        if verbose &gt;= 0:
            console(f&#34;{len(xmlPaths)} {model or &#39;TEI&#39;} file(s) ...&#34;)

        thisGood = True

        if validate:
            if verbose &gt;= 0:
                console(&#34;\tValidating ...&#34;)

            schemaFile = modelInfo.get(model, None)

            if schemaFile is None:
                if verbose &gt;= 0:
                    console(f&#34;\t\tNo schema file for {model}&#34;)
                if good is not None and good is not False:
                    good = None
                continue

            (thisGood, info, theseErrors) = A.validate(schemaFile, xmlPaths)

            for line in info:
                if verbose &gt;= 0:
                    console(f&#34;\t\t{line}&#34;)

        if not thisGood:
            good = False
            errors.extend(theseErrors)

        if verbose &gt;= 0:
            console(&#34;\tMaking inventory ...&#34;)
        for xmlPath in xmlPaths:
            doXMLFile(xmlPath)

    if not good:
        self.good = False

    if verbose &gt;= 0:
        console(&#34;&#34;)
    writeErrors()
    writeReport()
    writeElemTypes()
    writeDoc()
    writeNamespaces()
    writeIdRefs()
    writeLbParents()</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.TEI.convertTask"><code class="name flex">
<span>def <span class="ident">convertTask</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of the "convert" task.</p>
<p>It sets up the <code><a title="tf.convert.walker" href="walker.html">tf.convert.walker</a></code> machinery and runs it.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>Whether the conversion was successful.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/331baa8460d48d644338cf8e085d696cb9cbdbb0/tf/convert/tei.py#L4025-L4094" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def convertTask(self):
    &#34;&#34;&#34;Implementation of the &#34;convert&#34; task.

    It sets up the `tf.convert.walker` machinery and runs it.

    Returns
    -------
    boolean
        Whether the conversion was successful.
    &#34;&#34;&#34;
    if not self.importOK():
        return

    if not self.good:
        return

    procins = self.procins
    verbose = self.verbose
    slotType = self.slotType
    generic = self.generic
    otext = self.otext
    featureMeta = self.featureMeta
    intFeatures = self.intFeatures

    makeLineElems = self.makeLineElems
    lineModel = self.lineModel
    if makeLineElems:
        lineProperties = self.lineProperties
        lineType = lineProperties[&#34;nodeType&#34;]

    makePageElems = self.makePageElems
    pageModel = self.pageModel

    if makePageElems:
        pageProperties = self.pageProperties
        pageType = pageProperties[&#34;nodeType&#34;]
        pbAtTop = pageProperties[&#34;pbAtTop&#34;] if makePageElems else None

    tfPath = self.tfPath
    teiPath = self.teiPath

    if verbose &gt;= 0:
        if verbose == 1:
            console(f&#34;TEI to TF converting: {ux(teiPath)} =&gt; {ux(tfPath)}&#34;)
        if makeLineElems:
            lbRep = f&#34; with {lineType} nodes for lines between lb elements&#34;
            console(f&#34;Line model {lineModel}{lbRep}&#34;)

        if makePageElems:
            wrt = &#34;started&#34; if pbAtTop else &#34;ended&#34;
            pbRep = f&#34; with {pageType} nodes for pages {wrt} by pb elements&#34;
            console(f&#34;Page model {pageModel}{pbRep}&#34;)

        console(
            f&#34;Processing instructions are {&#39;treated&#39; if procins else &#39;ignored&#39;}&#34;
        )

    initTree(tfPath, fresh=True, gentle=True)

    cv = self.getConverter()

    self.good = cv.walk(
        self.getDirector(),
        slotType,
        otext=otext,
        generic=generic,
        intFeatures=intFeatures,
        featureMeta=featureMeta,
        generateTf=True,
    )</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.TEI.getConverter"><code class="name flex">
<span>def <span class="ident">getConverter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a converter.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object</code></dt>
<dd>The <code><a title="tf.convert.walker.CV" href="walker.html#tf.convert.walker.CV">CV</a></code> converter object, initialized.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/331baa8460d48d644338cf8e085d696cb9cbdbb0/tf/convert/tei.py#L2393-L2406" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getConverter(self):
    &#34;&#34;&#34;Initializes a converter.

    Returns
    -------
    object
        The `tf.convert.walker.CV` converter object, initialized.
    &#34;&#34;&#34;
    verbose = self.verbose
    tfPath = self.tfPath

    silent = AUTO if verbose == 1 else TERSE if verbose == 0 else DEEP
    TF = Fabric(locations=tfPath, silent=silent)
    return CV(TF, silent=silent)</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.TEI.getDirector"><code class="name flex">
<span>def <span class="ident">getDirector</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Factory for the director function.</p>
<p>The <code><a title="tf.convert.walker" href="walker.html">tf.convert.walker</a></code> relies on a corpus dependent <code>director</code> function
that walks through the source data and spits out actions that
produces the TF dataset.</p>
<p>The director function that walks through the TEI input must be conditioned
by the properties defined in the TEI schema and the customised schema, if any,
that describes the source.</p>
<p>Also some special additions need to be programmed, such as an extra section
level, word boundaries, etc.</p>
<p>We collect all needed data, store it, and define a local director function
that has access to this data.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>function</code></dt>
<dd>The local director function that has been constructed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/331baa8460d48d644338cf8e085d696cb9cbdbb0/tf/convert/tei.py#L2410-L4023" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getDirector(self):
    &#34;&#34;&#34;Factory for the director function.

    The `tf.convert.walker` relies on a corpus dependent `director` function
    that walks through the source data and spits out actions that
    produces the TF dataset.

    The director function that walks through the TEI input must be conditioned
    by the properties defined in the TEI schema and the customised schema, if any,
    that describes the source.

    Also some special additions need to be programmed, such as an extra section
    level, word boundaries, etc.

    We collect all needed data, store it, and define a local director function
    that has access to this data.

    Returns
    -------
    function
        The local director function that has been constructed.
    &#34;&#34;&#34;
    if not self.importOK():
        return

    if not self.good:
        return

    TEI_HEADER = &#34;teiHeader&#34;

    TEXT_ANCESTOR = &#34;text&#34;
    TEXT_ANCESTORS = set(
        &#34;&#34;&#34;
        front
        body
        back
        group
        &#34;&#34;&#34;.strip().split()
    )
    CHUNK_PARENTS = TEXT_ANCESTORS | {TEI_HEADER}

    CHUNK_ELEMS = set(
        &#34;&#34;&#34;
        facsimile
        fsdDecl
        sourceDoc
        standOff
        &#34;&#34;&#34;.strip().split()
    )

    PASS_THROUGH = set(
        &#34;&#34;&#34;
        TEI
        &#34;&#34;&#34;.strip().split()
    )

    # CHECKING

    HY = &#34;\u2010&#34;  # hyphen

    IN_WORD_HYPHENS = {HY, &#34;-&#34;}

    procins = self.procins
    verbose = self.verbose
    teiPath = self.teiPath
    wordAsSlot = self.wordAsSlot
    tokenAsSlot = self.tokenAsSlot
    parentEdges = self.parentEdges
    siblingEdges = self.siblingEdges
    featureMeta = self.featureMeta
    intFeatures = self.intFeatures
    transform = getattr(self, &#34;transformCustom&#34;, None)
    chunkLevel = self.chunkLevel
    modelInv = self.modelInv
    modelInfo = self.modelInfo
    modelXsd = self.modelXsd
    A = self.A
    etree = self.etree

    transformFunc = (
        (lambda x: BytesIO(x.encode(&#34;utf-8&#34;)))
        if transform is None
        else lambda x: BytesIO(transform(x).encode(&#34;utf-8&#34;))
    )

    parser = self.getParser()

    baseSchema = modelInfo[None]
    overrides = [
        override for (model, override) in modelInfo.items() if model is not None
    ]
    baseSchema = modelXsd[None]
    overrides = [
        override for (model, override) in modelXsd.items() if model is not None
    ]
    A.getElementInfo(baseSchema, overrides, verbose=-1)

    refs = collections.defaultdict(lambda: collections.defaultdict(set))
    ids = collections.defaultdict(dict)

    # WALKERS

    WHITE_TRIM_RE = re.compile(r&#34;\s+&#34;, re.S)
    NON_NAME_RE = re.compile(r&#34;[^a-zA-Z0-9_ ]+&#34;, re.S)

    NOTE_LIKE = set(
        &#34;&#34;&#34;
        note
        &#34;&#34;&#34;.strip().split()
    )
    EMPTY_ELEMENTS = set(
        &#34;&#34;&#34;
        addSpan
        alt
        anchor
        anyElement
        attRef
        binary
        caesura
        catRef
        cb
        citeData
        classRef
        conversion
        damageSpan
        dataFacet
        default
        delSpan
        elementRef
        empty
        equiv
        fsdLink
        gb
        handShift
        iff
        lacunaEnd
        lacunaStart
        lb
        link
        localProp
        macroRef
        milestone
        move
        numeric
        param
        path
        pause
        pb
        ptr
        redo
        refState
        specDesc
        specGrpRef
        symbol
        textNode
        then
        undo
        unicodeProp
        unihanProp
        variantEncoding
        when
        witEnd
        witStart
        &#34;&#34;&#34;.strip().split()
    )
    NEWLINE_ELEMENTS = set(
        &#34;&#34;&#34;
        ab
        addrLine
        cb
        l
        lb
        lg
        list
        p
        pb
        seg
        table
        u
        &#34;&#34;&#34;.strip().split()
    )
    CONTINUOUS_ELEMENTS = set(
        &#34;&#34;&#34;
        choice
        &#34;&#34;&#34;.strip().split()
    )

    def makeNameLike(x):
        return NON_NAME_RE.sub(&#34;_&#34;, x).strip(&#34;_&#34;)

    def walkNode(cv, cur, xnode):
        &#34;&#34;&#34;Internal function to deal with a single element.

        Will be called recursively.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.

            The subdictionary `cur[&#34;node&#34;]` is used to store the currently generated
            nodes by node type.
        xnode: object
            An LXML element node.
        &#34;&#34;&#34;
        if procins and isinstance(xnode, etree._ProcessingInstruction):
            target = xnode.target
            tag = f&#34;?{target}&#34;
        else:
            tag = etree.QName(xnode.tag).localname

        atts = {etree.QName(k).localname: v for (k, v) in xnode.attrib.items()}

        beforeTag(cv, cur, xnode, tag, atts)

        cur[XNEST].append((tag, atts))

        curNode = beforeChildren(cv, cur, xnode, tag, atts)

        if curNode is not None:
            if parentEdges:
                if len(cur[TNEST]):
                    parentNode = cur[TNEST][-1]
                    cv.edge(curNode, parentNode, parent=None)

            cur[TNEST].append(curNode)

            if siblingEdges:
                if len(cur[TSIB]):
                    siblings = cur[TSIB][-1]

                    nSiblings = len(siblings)
                    for i, sib in enumerate(siblings):
                        cv.edge(sib, curNode, sibling=nSiblings - i)
                    siblings.append(curNode)

                cur[TSIB].append([])

        for child in xnode.iterchildren(
            tag=(etree.Element, etree.ProcessingInstruction)
            if procins
            else etree.Element
        ):
            walkNode(cv, cur, child)

        afterChildren(cv, cur, xnode, tag, atts)

        if curNode is not None:
            xmlFile = cur[&#34;xmlFile&#34;]

            for refAtt, targetFile, targetId in getRefs(tag, atts, xmlFile):
                refs[refAtt][(targetFile, targetId)].add(curNode)

            idVal = atts.get(&#34;id&#34;, None)
            if idVal is not None:
                ids[xmlFile][idVal] = curNode

            if len(cur[TNEST]):
                cur[TNEST].pop()
            if siblingEdges:
                if len(cur[TSIB]):
                    cur[TSIB].pop()

        cur[XNEST].pop()
        afterTag(cv, cur, xnode, tag, atts)

    def isChapter(cur):
        &#34;&#34;&#34;Whether the current element counts as a chapter node.

        ## Model I

        Not relevant: there are no chapter nodes inside an XML file.

        ## Model II

        Chapters are the highest section level (the only lower level is chunks).

        Chapters come in two kinds:

        *   the TEI header;
        *   the immediate children of `&lt;text&gt;`
            except `&lt;front&gt;`, `&lt;body&gt;`, `&lt;back&gt;`, `&lt;group&gt;`;
        *   the immediate children of
            `&lt;front&gt;`, `&lt;body&gt;`, `&lt;back&gt;`, `&lt;group&gt;`.

        Parameters
        ----------
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.

        Returns
        -------
        boolean
        &#34;&#34;&#34;
        sectionModel = self.sectionModel

        if sectionModel == &#34;II&#34;:
            nest = cur[XNEST]
            nNest = len(nest)

            if nNest &gt; 0 and nest[-1][0] in EMPTY_ELEMENTS:
                return False

            outcome = nNest &gt; 0 and (
                nest[-1][0] == TEI_HEADER
                or (
                    nNest &gt; 1
                    and (
                        nest[-2][0] in TEXT_ANCESTORS
                        or nest[-2][0] == TEXT_ANCESTOR
                        and nest[-1][0] not in TEXT_ANCESTORS
                    )
                )
            )
            if outcome:
                cur[&#34;chapterElems&#34;].add(nest[-1][0])

            return outcome

        return False

    def isChunk(cur):
        &#34;&#34;&#34;Whether the current element counts as a chunk node.

        It depends on the section model, but also on the template.

        Note that we only can have distinct templates if we deal with
        multiple files, so only when we are in section model I.

        ## Model I

        Chunks are the lowest section level (the higher levels are folders
        and then files)

        The default is that chunks are the immediate children of the
        `&lt;teiHeader&gt;` and the `&lt;body&gt;`
        elements; a few other elements also count as chunks.

        However, if `drillDownDivs` is True and if the chunk appears to be
        a `&lt;div&gt;` element, we drill further down, until we arrive at a
        non-`&lt;div&gt;` element.

        But in specific templates we have different rules:

        ### `bibliolist`:

        *   The TEI Header is a chunk, and nothing inside the TEI header is a chunk;
        *   Everything at level 5, except `&lt;listBibl&gt;` is a chunk;
        *   The children of `&lt;listBibl&gt;` are chunks (the `&lt;bibl&gt;` elements
            and a few others), provided they are at level 6.

        ### `artworklist`

        *   The TEI Header is a chunk, and nothing inside the TEI header is a chunk;
        *   Everything at level 5 is a chunk.

        ## Model II

        Chunks are the lowest section level (the only higher level is chapters).

        Chunks are the immediate children of the chapters, and they come in two
        kinds: the ones that are `&lt;p&gt;` elements, and the rest.

        Deviation from this rule:

        *   If a chapter is a mixed content node, then it is also a chunk.
            and its subelements are not chunks

        Parameters
        ----------
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.

        Returns
        -------
        boolean
        &#34;&#34;&#34;
        sectionModel = self.sectionModel

        nest = cur[XNEST]
        nNest = len(nest)
        model = cur[&#34;model&#34;]

        if nNest == 0:
            return False

        thisTag = nest[-1][0]

        if sectionModel == &#34;II&#34;:
            if nNest == 1:
                outcome = False
            else:
                parentTag = nest[-2][0]
                meChptChnk = (
                    isChapter(cur) and thisTag not in cur[&#34;pureElems&#34;][model]
                )

                if meChptChnk:
                    outcome = True
                elif parentTag == TEI_HEADER:
                    outcome = True
                elif nNest &lt;= 2:
                    outcome = False
                elif parentTag not in cur[&#34;pureElems&#34;][model]:
                    outcome = False
                else:
                    grandParentTag = nest[-3][0]
                    outcome = (
                        grandParentTag in TEXT_ANCESTORS
                        and thisTag not in EMPTY_ELEMENTS
                    ) or (
                        grandParentTag == TEXT_ANCESTOR
                        and parentTag not in TEXT_ANCESTORS
                    )

        elif sectionModel == &#34;I&#34;:
            template = cur[&#34;template&#34;]

            if template == &#34;biolist&#34;:
                if thisTag == TEI_HEADER:
                    outcome = True
                elif any(n[0] == TEI_HEADER for n in nest[0:-1]):
                    outcome = False
                elif nNest not in {5, 6}:
                    outcome = False
                else:
                    parentTag = nest[-2][0]
                    if nNest == 5:
                        outcome = thisTag != &#34;listPerson&#34;
                    else:
                        outcome = parentTag == &#34;listPerson&#34;

            elif template == &#34;bibliolist&#34;:
                if thisTag == TEI_HEADER:
                    outcome = True
                elif any(n[0] == TEI_HEADER for n in nest[0:-1]):
                    outcome = False
                elif nNest not in {5, 6}:
                    outcome = False
                else:
                    parentTag = nest[-2][0]
                    if nNest == 5:
                        outcome = thisTag != &#34;listBibl&#34;
                    else:
                        outcome = parentTag == &#34;listBibl&#34;

            elif template == &#34;artworklist&#34;:
                if thisTag == TEI_HEADER:
                    outcome = True
                elif any(n[0] == TEI_HEADER for n in nest[0:-1]):
                    outcome = False
                else:
                    outcome = nNest == 5

            else:
                if thisTag in CHUNK_ELEMS:
                    outcome = True
                elif nNest == 1:
                    outcome = False
                else:
                    sectionProperties = self.sectionProperties
                    drillDownDivs = sectionProperties[&#34;drillDownDivs&#34;]

                    parentTag = nest[-2][0]
                    if drillDownDivs:
                        if thisTag == &#34;div&#34;:
                            outcome = False
                        else:
                            dParentTag = None
                            for ancestor in reversed(nest[0:-1]):
                                if ancestor[0] != &#34;div&#34;:
                                    dParentTag = ancestor[0]
                                    break
                            outcome = (
                                dParentTag in CHUNK_PARENTS
                                and thisTag not in EMPTY_ELEMENTS
                            ) or (
                                dParentTag == TEXT_ANCESTOR
                                and thisTag not in TEXT_ANCESTORS
                            )
                    else:
                        outcome = (
                            parentTag in CHUNK_PARENTS
                            and thisTag not in EMPTY_ELEMENTS
                        ) or (
                            parentTag == TEXT_ANCESTOR
                            and thisTag not in TEXT_ANCESTORS
                        )

        if outcome:
            cur[&#34;chunkElems&#34;].add(nest[-1][0])

        return outcome

    def isPure(cur):
        &#34;&#34;&#34;Whether the current tag has pure content.

        Parameters
        ----------
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.

        Returns
        -------
        boolean
        &#34;&#34;&#34;
        nest = cur[XNEST]
        model = cur[&#34;model&#34;]
        return (
            len(nest) == 0
            or len(nest) &gt; 0
            and nest[-1][0] in cur[&#34;pureElems&#34;][model]
        )

    def isEndInPure(cur):
        &#34;&#34;&#34;Whether the current end tag occurs in an element with pure content.

        If that is the case, then it is very likely that the end tag also
        marks the end of the current word.

        And we should not strip spaces after it.

        Parameters
        ----------
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.

        Returns
        -------
        boolean
        &#34;&#34;&#34;
        nest = cur[XNEST]
        model = cur[&#34;model&#34;]
        return len(nest) &gt; 1 and nest[-2][0] in cur[&#34;pureElems&#34;][model]

    def hasMixedAncestor(cur):
        &#34;&#34;&#34;Whether the current tag has an ancestor with mixed content.

        We use this in case a tag ends in an element with pure content.
        We should then add white-space to separate it from the next
        element of its parent.

        If the whole stack of element has pure content, we add
        a newline, because then we are probably in the TEI header,
        and things are most clear if they are on separate lines.

        But if one of the ancestors has mixed content, we are typically
        in some structured piece of information within running text,
        such as change markup. In this case we want to add merely a space.

        And we should not strip spaces after it.

        Parameters
        ----------
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.

        Returns
        -------
        boolean
        &#34;&#34;&#34;
        nest = cur[XNEST]
        model = cur[&#34;model&#34;]
        return any(n[0] in cur[&#34;mixedElems&#34;][model] for n in nest[0:-1])

    def hasContinuousAncestor(cur):
        &#34;&#34;&#34;Whether an ancestor tag is a continuous pure element.

        A continuous pure element is an element whose child elements do not
        imply word separation, e.g. `&lt;choice&gt;`.

        Parameters
        ----------
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.

        Returns
        -------
        boolean
        &#34;&#34;&#34;
        nest = cur[XNEST]
        return any(n[0] in CONTINUOUS_ELEMENTS for n in nest[0:-1])

    def startWord(cv, cur, ch):
        &#34;&#34;&#34;Start a word node if necessary.

        Whenever we encounter a character, we determine
        whether it starts or ends a word, and if it starts
        one, this function takes care of the necessary actions.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        ch: string
            A single character, the next character in the result data.
        &#34;&#34;&#34;
        curWord = cur[NODE][WORD]

        if not curWord:
            prevWord = cur[&#34;prevWord&#34;]
            if prevWord is not None:
                cv.feature(prevWord, after=cur[&#34;afterStr&#34;])
            if ch is not None:
                if wordAsSlot:
                    curWord = cv.slot()
                else:
                    curWord = cv.node(WORD)
                cur[NODE][WORD] = curWord
                addSlotFeatures(cv, cur, curWord)

        if ch is not None:
            cur[&#34;wordStr&#34;] += ch

    def finishWord(cv, cur, ch, spaceChar):
        &#34;&#34;&#34;Terminate a word node if necessary.

        Whenever we encounter a character, we determine
        whether it starts or ends a word, and if it ends
        one, this function takes care of the necessary actions.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        ch: string
            A single character, the next slot in the result data.
        spaceChar: string | void
            If None, no extra space or newline will be added.
            Otherwise, the `spaceChar` (a single space or newline will be added).
        &#34;&#34;&#34;
        curWord = cur[NODE][WORD]
        if curWord:
            cv.feature(curWord, str=cur[&#34;wordStr&#34;])
            if not wordAsSlot:
                cv.terminate(curWord)
            cur[NODE][WORD] = None
            cur[&#34;wordStr&#34;] = &#34;&#34;
            cur[&#34;prevWord&#34;] = curWord
            cur[&#34;afterStr&#34;] = &#34;&#34;

        if ch is not None:
            cur[&#34;afterStr&#34;] += ch
        if spaceChar is not None:
            cur[&#34;afterStr&#34;] = cur[&#34;afterStr&#34;].rstrip() + spaceChar
            if not wordAsSlot:
                addSpace(cv, cur, spaceChar)
            cur[&#34;afterSpace&#34;] = True
        else:
            cur[&#34;afterSpace&#34;] = False

    def addSlotFeatures(cv, cur, s):
        &#34;&#34;&#34;Add generic features to a slot.

        Whenever we encounter a character, we add it as a new slot, unless
        `wordAsSlot` is in force. In that case we suppress the triggering of a
        slot node.
        If needed, we start / terminate word nodes as well.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        s: slot
            A previously added (slot) node
        &#34;&#34;&#34;
        if cur[&#34;inHeader&#34;]:
            cv.feature(s, is_meta=1)
        if cur[&#34;inNote&#34;]:
            cv.feature(s, is_note=1)
        for r, stack in cur.get(&#34;rend&#34;, {}).items():
            if len(stack) &gt; 0:
                cv.feature(s, **{f&#34;rend_{r}&#34;: 1})

    def addTokens(cv, cur, text):
        &#34;&#34;&#34;Adds text as a series of tokens.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        text: string
            The text to be added.

        Only meant for the case where slots are tokens.
        &#34;&#34;&#34;
        (beforew, material, afterw) = getWhites(text)

        if beforew:
            makeSpace(cv, cur)

        s = None

        for tx, after in tokenize(material):
            s = cv.slot()
            cv.feature(s, str=tx, after=after)
            addSlotFeatures(cv, cur, s)

        if afterw:
            if s is None:
                makeSpace(cv, cur)
            else:
                cv.feature(s, after=&#34; &#34;)

    def addSlot(cv, cur, ch):
        &#34;&#34;&#34;Add a slot.

        Whenever we encounter a character, we add it as a new slot, unless
        `wordAsSlot` is in force. In that case we suppress the triggering of a
        slot node.
        If needed, we start / terminate word nodes as well.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        ch: string
            A single character, the next slot in the result data.
        &#34;&#34;&#34;
        if ch in {&#34;_&#34;, None} or ch.isalnum() or ch in IN_WORD_HYPHENS:
            startWord(cv, cur, ch)
        else:
            finishWord(cv, cur, ch, None)

        if wordAsSlot:
            s = cur[NODE][WORD]
        elif ch is None:
            s = None
        else:
            s = cv.slot()
            cv.feature(s, ch=ch)
        if s is not None:
            addSlotFeatures(cv, cur, s)

    def addEmpty(cv, cur):
        &#34;&#34;&#34;Add an empty slot.

        We also terminate the current word.
        If words are slots, the empty slot is a word on its own.

        Returns
        -------
        node
            The empty slot
        &#34;&#34;&#34;
        if tokenAsSlot:
            emptyNode = cv.slot()
            cv.feature(emptyNode, str=ZWSP, after=&#34;&#34;, empty=1)
        else:
            finishWord(cv, cur, None, None)
            startWord(cv, cur, ZWSP)
            emptyNode = cur[NODE][WORD]
            cv.feature(emptyNode, empty=1)

            if not wordAsSlot:
                emptyNode = cv.slot()
                cv.feature(emptyNode, ch=ZWSP, empty=1)

            finishWord(cv, cur, None, None)

        return emptyNode

    def addSpace(cv, cur, spaceChar):
        &#34;&#34;&#34;Adds a space or a new line.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        spaceChar: string
            The character to add (supposed to be either a space or a newline).

        Only meant for the case where slots are characters or tokens.

        Suppressed when not in a lowest-level section.
        &#34;&#34;&#34;
        if chunkLevel in cv.activeTypes():
            s = cv.slot()
            if tokenAsSlot:
                cv.feature(s, str=&#34;&#34;, after=spaceChar, extraspace=1)
            else:
                cv.feature(s, ch=spaceChar, extraspace=1)
            addSlotFeatures(cv, cur, s)

    def makeSpace(cv, cur):
        &#34;&#34;&#34;Adds a space.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.

        Only meant for the case where slots are tokens.
        &#34;&#34;&#34;
        s = cv.slot()
        cv.feature(s, str=&#34;&#34;, after=&#34; &#34;, extraspace=1)
        addSlotFeatures(cv, cur, s)

    def endLine(cv, cur):
        &#34;&#34;&#34;Ends a line node.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        &#34;&#34;&#34;
        lineProperties = self.lineProperties
        lineType = lineProperties[&#34;nodeType&#34;]

        slots = cv.linked(cur[NODE][lineType])
        empty = len(slots) == 0

        if empty:
            lastSlot = addEmpty(cv, cur)
            if cur[&#34;inNote&#34;]:
                cv.feature(lastSlot, is_note=1)
        else:
            lastSlot = (T, slots[-1])

        if not wordAsSlot:
            after = cv.get(&#34;after&#34;, lastSlot)
            if after is not None and &#34;\n&#34; not in after:
                cv.feature(lastSlot, after=f&#34;{after.rstrip()}\n&#34;)
        cv.terminate(cur[NODE][lineType])

    def endPage(cv, cur):
        &#34;&#34;&#34;Ends a page node.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        &#34;&#34;&#34;
        pageProperties = self.pageProperties
        pageType = pageProperties[&#34;nodeType&#34;]

        slots = cv.linked(cur[NODE][pageType])
        empty = len(slots) == 0

        if empty:
            lastSlot = addEmpty(cv, cur)
            if cur[&#34;inNote&#34;]:
                cv.feature(lastSlot, is_note=1)
        cv.terminate(cur[NODE][pageType])

    def beforeTag(cv, cur, xnode, tag, atts):
        &#34;&#34;&#34;Actions before dealing with the element&#39;s tag.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        xnode: object
            An LXML element node.
        tag: string
            The tag of the LXML node.
        &#34;&#34;&#34;
        beforeTagCustom = getattr(self, &#34;beforeTagCustom&#34;, None)
        if beforeTagCustom is not None:
            beforeTagCustom(cv, cur, xnode, tag, atts)

    def beforeChildren(cv, cur, xnode, tag, atts):
        &#34;&#34;&#34;Actions before dealing with the element&#39;s children.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        xnode: object
            An LXML element node.
        tag: string
            The tag of the LXML node.
        atts: string
            The attributes of the LXML node, with namespaces stripped.
        &#34;&#34;&#34;
        makeLineElems = self.makeLineElems

        if makeLineElems:
            lineProperties = self.lineProperties
            lineElem = lineProperties[&#34;element&#34;]
            lineType = lineProperties[&#34;nodeType&#34;]
            isLineContainer = tag == lineElem
            inLine = cur[&#34;inLine&#34;]

            if isLineContainer:
                cur[&#34;inLine&#34;] = True

                # the line starts with the container
                cur[NODE][lineType] = cv.node(lineType)

        makePageElems = self.makePageElems

        if makePageElems:
            pageProperties = self.pageProperties
            pageType = pageProperties[&#34;nodeType&#34;]
            isPageContainer = matchModel(pageProperties, tag, atts)
            inPage = cur[&#34;inPage&#34;]

            pbAtTop = pageProperties[&#34;pbAtTop&#34;]

            if isPageContainer:
                cur[&#34;inPage&#34;] = True

                if pbAtTop:
                    # material before the first pb in the container is not in a page
                    pass
                else:
                    # the page starts with the container
                    cur[NODE][pageType] = cv.node(pageType)

        sectionModel = self.sectionModel
        sectionProperties = self.sectionProperties

        if sectionModel == &#34;II&#34;:
            chapterSection = self.chapterSection
            chunkSection = self.chunkSection

            if isChapter(cur):
                cur[&#34;chapterNum&#34;] += 1
                cur[&#34;prevChapter&#34;] = cur[NODE].get(chapterSection, None)
                cur[NODE][chapterSection] = cv.node(chapterSection)
                cv.link(cur[NODE][chapterSection], cur[&#34;danglingSlots&#34;])

                value = {chapterSection: f&#34;{cur[&#39;chapterNum&#39;]} {tag}&#34;}
                cv.feature(cur[NODE][chapterSection], **value)
                cur[&#34;chunkPNum&#34;] = 0
                cur[&#34;chunkONum&#34;] = 0
                cur[&#34;prevChunk&#34;] = cur[NODE].get(chunkSection, None)
                cur[NODE][chunkSection] = cv.node(chunkSection)
                cv.link(cur[NODE][chunkSection], cur[&#34;danglingSlots&#34;])
                cur[&#34;danglingSlots&#34;] = set()
                cur[&#34;infirstChunk&#34;] = True

            # N.B. A node can count both as chapter and as chunk,
            # e.g. a &lt;trailer&gt; sibling of the chapter &lt;div&gt;s
            # A trailer has mixed content, so its subelements aren&#39;t typical chunks.
            if isChunk(cur):
                if cur[&#34;infirstChunk&#34;]:
                    cur[&#34;infirstChunk&#34;] = False
                else:
                    cur[NODE][chunkSection] = cv.node(chunkSection)
                    cv.link(cur[NODE][chunkSection], cur[&#34;danglingSlots&#34;])
                    cur[&#34;danglingSlots&#34;] = set()
                if tag == &#34;p&#34;:
                    cur[&#34;chunkPNum&#34;] += 1
                    cn = cur[&#34;chunkPNum&#34;]
                else:
                    cur[&#34;chunkONum&#34;] -= 1
                    cn = cur[&#34;chunkONum&#34;]
                value = {chunkSection: cn}
                cv.feature(cur[NODE][chunkSection], **value)

            if matchModel(sectionProperties, tag, atts):
                heading = etree.tostring(
                    xnode, encoding=&#34;unicode&#34;, method=&#34;text&#34;, with_tail=False
                ).replace(&#34;\n&#34;, &#34; &#34;)
                value = {chapterSection: heading}
                cv.feature(cur[NODE][chapterSection], **value)
                chapterNum = cur[&#34;chapterNum&#34;]
                if verbose &gt;= 0:
                    console(
                        f&#34;\rchapter {chapterNum:&gt;4} {heading:&lt;50}&#34;, newline=False
                    )
        else:
            chunkSection = self.chunkSection

            if isChunk(cur):
                cur[&#34;chunkNum&#34;] += 1
                cur[&#34;prevChunk&#34;] = cur[NODE].get(chunkSection, None)
                cur[NODE][chunkSection] = cv.node(chunkSection)
                cv.link(cur[NODE][chunkSection], cur[&#34;danglingSlots&#34;])
                cur[&#34;danglingSlots&#34;] = set()
                value = {chunkSection: cur[&#34;chunkNum&#34;]}
                cv.feature(cur[NODE][chunkSection], **value)

        if tag == TEI_HEADER:
            cur[&#34;inHeader&#34;] = True
            if sectionModel == &#34;II&#34;:
                value = {chapterSection: &#34;TEI header&#34;}
                cv.feature(cur[NODE][chapterSection], **value)
        if tag in NOTE_LIKE:
            cur[&#34;inNote&#34;] = True
            if not tokenAsSlot:
                finishWord(cv, cur, None, None)

        curNode = None

        if makeLineElems:
            if inLine and tag == &#34;lb&#34;:
                if cur[NODE][lineType] is not None:
                    if cur[&#34;lineAtts&#34;] is not None and len(cur[&#34;lineAtts&#34;]):
                        cv.feature(cur[NODE][lineType], **cur[&#34;lineAtts&#34;])
                    endLine(cv, cur)
                cur[NODE][lineType] = cv.node(lineType)
                cur[&#34;lineAtts&#34;] = atts

        if makePageElems:
            if inPage and tag == &#34;pb&#34;:
                if pbAtTop:
                    if cur[NODE][pageType] is not None:
                        endPage(cv, cur)
                    cur[NODE][pageType] = cv.node(pageType)
                    if len(atts):
                        cv.feature(cur[NODE][pageType], **atts)
                else:
                    if cur[NODE][pageType] is not None:
                        if cur[&#34;pageAtts&#34;] is not None and len(cur[&#34;pageAtts&#34;]):
                            cv.feature(cur[NODE][pageType], **cur[&#34;pageAtts&#34;])
                        endPage(cv, cur)
                    cur[NODE][pageType] = cv.node(pageType)
                    cur[&#34;pageAtts&#34;] = atts

        isBoundaryElem = (
            makeLineElems and tag == &#34;lb&#34; or makePageElems and tag == &#34;pb&#34;
        )

        if tag not in PASS_THROUGH and not isBoundaryElem:
            cur[&#34;afterSpace&#34;] = False
            cur[NODE][tag] = cv.node(tag)
            curNode = cur[NODE][tag]
            if wordAsSlot:
                if cur[NODE][WORD]:
                    cv.link(curNode, [cur[NODE][WORD][1]])
            if len(atts):
                cv.feature(curNode, **atts)
                if &#34;rend&#34; in atts:
                    rValue = atts[&#34;rend&#34;]
                    r = makeNameLike(rValue)
                    if r:
                        for q in r.split():
                            cur.setdefault(&#34;rend&#34;, {}).setdefault(q, []).append(
                                True
                            )

        beforeChildrenCustom = getattr(self, &#34;beforeChildrenCustom&#34;, None)
        if beforeChildrenCustom is not None:
            beforeChildrenCustom(cv, cur, xnode, tag, atts)

        if not hasattr(xnode, &#34;target&#34;) and xnode.text:
            textMaterial = WHITE_TRIM_RE.sub(&#34; &#34;, xnode.text)
            if isPure(cur):
                if textMaterial and textMaterial != &#34; &#34;:
                    console(
                        (
                            &#34;WARNING: Text material at the start of &#34;
                            f&#34;pure-content element &lt;{tag}&gt;&#34;
                        ),
                        error=True,
                    )
                    stack = &#34;-&#34;.join(n[0] for n in cur[XNEST])
                    console(f&#34;\tElement stack: {stack}&#34;, error=True)
                    console(f&#34;\tMaterial: `{textMaterial}`&#34;, error=True)
            else:
                if tokenAsSlot:
                    addTokens(cv, cur, textMaterial)
                else:
                    for ch in textMaterial:
                        addSlot(cv, cur, ch)

        return curNode

    def afterChildren(cv, cur, xnode, tag, atts):
        &#34;&#34;&#34;Node actions after dealing with the children, but before the end tag.

        Here we make sure that the newline elements will get their last slot
        having a newline at the end of their `after` feature.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        xnode: object
            An LXML element node.
        tag: string
            The tag of the LXML node.
        atts: string
            The attributes of the LXML node, with namespaces stripped.
        &#34;&#34;&#34;
        chunkSection = self.chunkSection
        makeLineElems = self.makeLineElems

        if makeLineElems:
            lineProperties = self.lineProperties
            lineType = lineProperties[&#34;nodeType&#34;]
            lineElem = lineProperties[&#34;element&#34;]
            lineProperties = self.lineProperties

        makePageElems = self.makePageElems

        if makePageElems:
            pageProperties = self.pageProperties
            pageType = pageProperties[&#34;nodeType&#34;]
            pageProperties = self.pageProperties

        sectionModel = self.sectionModel

        if sectionModel == &#34;II&#34;:
            chapterSection = self.chapterSection

        extraInstructions = self.extraInstructions

        if len(extraInstructions):
            lookupSource(cv, cur, tokenAsSlot, extraInstructions)

        isChap = isChapter(cur)
        isChnk = isChunk(cur)

        afterChildrenCustom = getattr(self, &#34;afterChildrenCustom&#34;, None)
        if afterChildrenCustom is not None:
            afterChildrenCustom(cv, cur, xnode, tag, atts)

        if makeLineElems:
            isLineContainer = tag == lineElem
            inLine = cur[&#34;inLine&#34;]

        if makePageElems:
            isPageContainer = matchModel(pageProperties, tag, atts)
            inPage = cur[&#34;inPage&#34;]

        hasFinishedWord = False

        if makeLineElems and inLine and tag == &#34;lb&#34;:
            pass

        if makePageElems and inPage and tag == &#34;pb&#34;:
            pass

        isBoundaryElem = (
            makeLineElems and tag == &#34;lb&#34; or makePageElems and tag == &#34;pb&#34;
        )

        if makeLineElems and isLineContainer:
            # the page ends with the container
            if cur[NODE][lineType] is not None:
                endLine(cv, cur)
            cur[&#34;inLine&#34;] = False

        if makePageElems and isPageContainer:
            pbAtTop = pageProperties[&#34;pbAtTop&#34;]
            if pbAtTop:
                # the page ends with the container
                if cur[NODE][pageType] is not None:
                    endPage(cv, cur)
            else:
                # material after the last pb is not in a page
                if cur[NODE][pageType] is not None:
                    cv.delete(cur[NODE][pageType])
            cur[&#34;inPage&#34;] = False

        if tag not in PASS_THROUGH and not isBoundaryElem:
            curNode = cur[TNEST][-1]
            slots = cv.linked(curNode)
            empty = len(slots) == 0

            newLineTag = tag in NEWLINE_ELEMENTS

            if (
                newLineTag
                or isEndInPure(cur)
                and not hasContinuousAncestor(cur)
                and not cur[&#34;afterSpace&#34;]
            ) and not empty:
                spaceChar = &#34;\n&#34; if newLineTag or not hasMixedAncestor(cur) else &#34; &#34;
                if tokenAsSlot:
                    cv.feature((T, slots[-1]), after=spaceChar)
                else:
                    finishWord(cv, cur, None, spaceChar)
                    hasFinishedWord = True

            slots = cv.linked(curNode)
            empty = len(slots) == 0

            if empty:
                lastSlot = addEmpty(cv, cur)
                if cur[&#34;inHeader&#34;]:
                    cv.feature(lastSlot, is_meta=1)
                if cur[&#34;inNote&#34;]:
                    cv.feature(lastSlot, is_note=1)
                # take care that this empty slot falls under all sections
                # for folders and files this is already guaranteed
                # We need only to watch out for chapters and chunks
                if cur[NODE].get(chunkSection, None) is None:
                    prevChunk = cur.get(&#34;prevChunk&#34;, None)
                    if prevChunk is None:
                        cur[&#34;danglingSlots&#34;].add(lastSlot[1])
                    else:
                        cv.link(prevChunk, lastSlot)
                if sectionModel == &#34;II&#34;:
                    if cur[NODE].get(chapterSection, None) is None:
                        prevChapter = cur.get(&#34;prevChapter&#34;, None)
                        if prevChapter is None:
                            cur[&#34;danglingSlots&#34;].add(lastSlot[1])
                        else:
                            cv.link(prevChapter, lastSlot)

            cv.terminate(curNode)

        if isChnk:
            if tokenAsSlot:
                addSpace(cv, cur, &#34;\n&#34;)
            else:
                if not hasFinishedWord:
                    finishWord(cv, cur, None, &#34;\n&#34;)
            cv.terminate(cur[NODE][chunkSection])

        if sectionModel == &#34;II&#34;:
            if isChap:
                if tokenAsSlot:
                    addSpace(cv, cur, &#34;\n&#34;)
                else:
                    if not hasFinishedWord:
                        finishWord(cv, cur, None, &#34;\n&#34;)
                cv.terminate(cur[NODE][chapterSection])

    def afterTag(cv, cur, xnode, tag, atts):
        &#34;&#34;&#34;Node actions after dealing with the children and after the end tag.

        This is the place where we process the `tail` of an LXML node: the
        text material after the element and before the next open/close
        tag of any element.

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        cur: dict
            Various pieces of data collected during walking
            and relevant for some next steps in the walk.
        xnode: object
            An LXML element node.
        tag: string
            The tag of the LXML node.
        atts: string
            The attributes of the LXML node, with namespaces stripped.
        &#34;&#34;&#34;
        if tag == TEI_HEADER:
            cur[&#34;inHeader&#34;] = False
        elif tag in NOTE_LIKE:
            cur[&#34;inNote&#34;] = False

        if tag not in PASS_THROUGH:
            if &#34;rend&#34; in atts:
                rValue = atts[&#34;rend&#34;]
                r = makeNameLike(rValue)
                if r:
                    for q in r.split():
                        cur[&#34;rend&#34;][q].pop()

        if xnode.tail:
            if tag == &#34;lb&#34; and self.makeLineElems:
                tail = xnode.tail.lstrip()
                if not wordAsSlot:
                    pass
            else:
                tail = xnode.tail

            tailMaterial = WHITE_TRIM_RE.sub(&#34; &#34;, tail)
            if isPure(cur):
                if tailMaterial and tailMaterial != &#34; &#34;:
                    elem = cur[XNEST][-1][0]
                    console(
                        (
                            &#34;WARNING: Text material after &#34;
                            f&#34;&lt;{tag}&gt; in pure-content element &lt;{elem}&gt;&#34;
                        ),
                        error=True,
                    )
                    stack = &#34;-&#34;.join(cur[XNEST][0])
                    console(f&#34;\tElement stack: {stack}-{tag}&#34;, error=True)
                    console(f&#34;\tMaterial: `{tailMaterial}`&#34;, error=True)
            else:
                if tokenAsSlot:
                    addTokens(cv, cur, tailMaterial)
                else:
                    for ch in tailMaterial:
                        addSlot(cv, cur, ch)

        afterTagCustom = getattr(self, &#34;afterTagCustom&#34;, None)
        if afterTagCustom is not None:
            afterTagCustom(cv, cur, xnode, tag, atts)

    def director(cv):
        &#34;&#34;&#34;Director function.

        Here we program a walk through the TEI sources.
        At every step of the walk we fire some actions that build TF nodes
        and assign features for them.

        Because everything is rather dynamic, we generate fairly standard
        metadata for the features, namely a link to the
        [TEI website](https://tei-c.org).

        Parameters
        ----------
        cv: object
            The converter object, needed to issue actions.
        &#34;&#34;&#34;
        makeLineElems = self.makeLineElems

        if makeLineElems:
            lineProperties = self.lineProperties
            lineType = lineProperties[&#34;nodeType&#34;]

        makePageElems = self.makePageElems

        if makePageElems:
            pageProperties = self.pageProperties
            pageType = pageProperties[&#34;nodeType&#34;]

        sectionModel = self.sectionModel
        A = self.A
        elementDefs = A.elementDefs

        cur = {}
        cur[&#34;pureElems&#34;] = {
            modelInv[schemaOverride]: {
                x for (x, (typ, mixed)) in eDefs.items() if not mixed
            }
            for (schemaOverride, eDefs) in elementDefs.items()
        }
        cur[&#34;mixedElems&#34;] = {
            modelInv[schemaOverride]: {
                x for (x, (typ, mixed)) in eDefs.items() if mixed
            }
            for (schemaOverride, eDefs) in elementDefs.items()
        }
        cur[NODE] = {}

        if sectionModel == &#34;I&#34;:
            folderSection = self.folderSection
            fileSection = self.fileSection

            i = 0
            for xmlFolder, xmlFiles in self.getXML():
                msg = &#34;Start &#34; if verbose &gt;= 0 else &#34;\t&#34;
                console(f&#34;{msg}folder {xmlFolder}:&#34;)

                cur[NODE][folderSection] = cv.node(folderSection)
                value = {folderSection: xmlFolder}
                cv.feature(cur[NODE][folderSection], **value)

                j = 0
                cr = &#34;&#34;
                nl = True

                for xmlFile in xmlFiles:
                    i += 1
                    j += 1
                    if j &gt; PROGRESS_LIMIT:
                        cr = &#34;\r&#34;
                        nl = False

                    cur[&#34;xmlFile&#34;] = xmlFile
                    xmlPath = f&#34;{teiPath}/{xmlFolder}/{xmlFile}&#34;
                    (model, adapt, tpl) = self.getSwitches(xmlPath)
                    cur[&#34;model&#34;] = model
                    cur[&#34;template&#34;] = tpl
                    cur[&#34;adaptation&#34;] = adapt
                    modelRep = model or &#34;TEI&#34;
                    tplRep = tpl or &#34;&#34;
                    adRep = adapt or &#34;&#34;
                    label = f&#34;{modelRep:&lt;12} {adRep:&lt;12} {tplRep:&lt;12}&#34;
                    if verbose &gt;= 0:
                        console(
                            f&#34;{cr}{i:&gt;4} {label} {xmlFile:&lt;50}&#34;,
                            newline=nl,
                        )

                    cur[NODE][fileSection] = cv.node(fileSection)
                    ids[xmlFile][&#34;&#34;] = cur[NODE][fileSection]
                    value = {fileSection: xmlFile.removesuffix(&#34;.xml&#34;)}
                    cv.feature(cur[NODE][fileSection], **value)
                    if tpl:
                        cur[NODE][tpl] = cv.node(tpl)
                        cv.feature(cur[NODE][tpl], **value)

                    with fileOpen(xmlPath) as fh:
                        text = fh.read()
                        if transformFunc is not None:
                            text = transformFunc(text)
                        tree = etree.parse(text, parser)
                        root = tree.getroot()

                        if makeLineElems:
                            cur[NODE][lineType] = None
                            cur[&#34;inLine&#34;] = False
                            cur[&#34;lineAtts&#34;] = None

                        if makePageElems:
                            cur[NODE][pageType] = None
                            cur[&#34;inPage&#34;] = False
                            cur[&#34;pageAtts&#34;] = None

                        if not tokenAsSlot:
                            cur[NODE][WORD] = None
                        cur[&#34;inHeader&#34;] = False
                        cur[&#34;inNote&#34;] = False
                        cur[XNEST] = []
                        cur[TNEST] = []
                        cur[TSIB] = []
                        cur[&#34;chunkNum&#34;] = 0
                        cur[&#34;prevChunk&#34;] = None
                        cur[&#34;danglingSlots&#34;] = set()
                        cur[&#34;prevWord&#34;] = None
                        cur[&#34;wordStr&#34;] = &#34;&#34;
                        cur[&#34;afterStr&#34;] = &#34;&#34;
                        cur[&#34;afterSpace&#34;] = True
                        cur[&#34;chunkElems&#34;] = set()
                        walkNode(cv, cur, root)

                    if not tokenAsSlot:
                        addSlot(cv, cur, None)
                    if tpl:
                        cv.terminate(cur[NODE][tpl])
                    cv.terminate(cur[NODE][fileSection])

                if verbose &gt;= 0:
                    console(&#34;&#34;)
                    console(f&#34;End   folder {xmlFolder}&#34;)

                cv.terminate(cur[NODE][folderSection])

        elif sectionModel == &#34;II&#34;:
            xmlFile = self.getXML()
            if xmlFile is None:
                console(&#34;No XML files found!&#34;, error=True)
                return False

            xmlPath = f&#34;{teiPath}/{xmlFile}&#34;
            (cur[&#34;model&#34;], cur[&#34;adaptation&#34;], cur[&#34;template&#34;]) = self.getSwitches(
                xmlPath
            )

            with fileOpen(f&#34;{teiPath}/{xmlFile}&#34;) as fh:
                cur[&#34;xmlFile&#34;] = xmlFile
                text = fh.read()
                if transformFunc is not None:
                    text = transformFunc(text)
                tree = etree.parse(text, parser)
                root = tree.getroot()

                if makeLineElems:
                    cur[NODE][lineType] = None
                    cur[&#34;inLine&#34;] = False
                    cur[&#34;lineAtts&#34;] = None

                if makePageElems:
                    cur[NODE][pageType] = None
                    cur[&#34;inPage&#34;] = False
                    cur[&#34;pageAtts&#34;] = None

                if not tokenAsSlot:
                    cur[NODE][WORD] = None
                cur[&#34;inHeader&#34;] = False
                cur[&#34;inNote&#34;] = False
                cur[XNEST] = []
                cur[TNEST] = []
                cur[TSIB] = []
                cur[&#34;chapterNum&#34;] = 0
                cur[&#34;chunkPNum&#34;] = 0
                cur[&#34;chunkONum&#34;] = 0
                cur[&#34;prevChunk&#34;] = None
                cur[&#34;prevChapter&#34;] = None
                cur[&#34;danglingSlots&#34;] = set()
                cur[&#34;prevWord&#34;] = None
                cur[&#34;wordStr&#34;] = &#34;&#34;
                cur[&#34;afterStr&#34;] = &#34;&#34;
                cur[&#34;afterSpace&#34;] = True
                cur[&#34;chunkElems&#34;] = set()
                cur[&#34;chapterElems&#34;] = set()
                for child in root.iterchildren(tag=etree.Element):
                    walkNode(cv, cur, child)

            if not tokenAsSlot:
                addSlot(cv, cur, None)

        if verbose &gt;= 0:
            console(&#34;&#34;)

        if verbose &gt;= 0:
            console(&#34;Resolving links into edges ...&#34;)

        unresolvedRefs = {}
        unresolved = 0
        unresolvedUnique = 0
        resolved = 0
        resolvedUnique = 0

        for att, attRefs in refs.items():
            feature = f&#34;link_{att}&#34;
            edgeFeat = {feature: None}

            for (targetFile, targetId), sourceNodes in attRefs.items():
                nSourceNodes = len(sourceNodes)
                targetNode = ids[targetFile].get(targetId, None)
                if targetNode is None:
                    unresolvedRefs.setdefault(targetFile, set()).add(targetId)
                    unresolvedUnique += 1
                    unresolved += nSourceNodes
                else:
                    for sourceNode in sourceNodes:
                        cv.edge(sourceNode, targetNode, **edgeFeat)
                    resolvedUnique += 1
                    resolved += nSourceNodes

        if verbose &gt;= 0:
            console(f&#34;\t{resolvedUnique} in {resolved} reference(s) resolved&#34;)
            if unresolvedRefs:
                console(
                    f&#34;\t{unresolvedUnique} in {unresolved} reference(s): &#34;
                    &#34;could not be resolved&#34;
                )
                if verbose == 1:
                    for targetFile, targetIds in sorted(unresolvedRefs.items()):
                        examples = &#34; &#34;.join(sorted(targetIds)[0:3])
                        console(f&#34;\t\t{targetFile}: {len(targetIds)} x: {examples}&#34;)

        for fName in featureMeta:
            if not cv.occurs(fName):
                cv.meta(fName)
        for fName in cv.features():
            if fName not in featureMeta:
                if fName.startswith(&#34;rend_&#34;):
                    r = fName[5:]
                    cv.meta(
                        fName,
                        description=f&#34;whether text is to be rendered as {r}&#34;,
                        valueType=&#34;int&#34;,
                        conversionMethod=CM_LITC,
                        conversionCode=CONVERSION_METHODS[CM_LITC],
                    )
                    intFeatures.add(fName)
                elif fName.startswith(&#34;link_&#34;):
                    r = fName[5:]
                    cv.meta(
                        fName,
                        description=(
                            f&#34;links to node identified by xml:id in attribute {r}&#34;
                        ),
                        valueType=&#34;str&#34;,
                        conversionMethod=CM_LITP,
                        conversionCode=CONVERSION_METHODS[CM_LITP],
                    )
                else:
                    cv.meta(
                        fName,
                        description=f&#34;this is TEI attribute {fName}&#34;,
                        valueType=&#34;str&#34;,
                        conversionMethod=CM_LIT,
                        conversionCode=CONVERSION_METHODS[CM_LIT],
                    )

        levelConstraints = [&#34;note &lt; chunk, p&#34;, &#34;salute &lt; opener, closer&#34;]
        if &#34;chapterElems&#34; in cur:
            for elem in cur[&#34;chapterElems&#34;]:
                levelConstraints.append(f&#34;{elem} &lt; chapter&#34;)
        if &#34;chunkElems&#34; in cur:
            for elem in cur[&#34;chunkElems&#34;]:
                levelConstraints.append(f&#34;{elem} &lt; chunk&#34;)

        levelConstraints = &#34;; &#34;.join(levelConstraints)

        cv.meta(&#34;otext&#34;, levelConstraints=levelConstraints)

        if verbose == 1:
            console(&#34;source reading done&#34;)
        return True

    return director</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.TEI.getParser"><code class="name flex">
<span>def <span class="ident">getParser</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Configure the LXML parser.</p>
<p>See <a href="https://lxml.de/parsing.html#parser-options">parser options</a>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object</code></dt>
<dd>A configured LXML parse object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/331baa8460d48d644338cf8e085d696cb9cbdbb0/tf/convert/tei.py#L1589-L1611" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getParser(self):
    &#34;&#34;&#34;Configure the LXML parser.

    See [parser options](https://lxml.de/parsing.html#parser-options).

    Returns
    -------
    object
        A configured LXML parse object.
    &#34;&#34;&#34;
    if not self.importOK():
        return None

    etree = self.etree
    procins = self.procins

    return etree.XMLParser(
        remove_blank_text=False,
        collect_ids=False,
        remove_comments=True,
        remove_pis=not procins,
        huge_tree=True,
    )</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.TEI.getSwitches"><code class="name flex">
<span>def <span class="ident">getSwitches</span></span>(<span>self, xmlPath)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/331baa8460d48d644338cf8e085d696cb9cbdbb0/tf/convert/tei.py#L1547-L1587" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getSwitches(self, xmlPath):
    verbose = self.verbose
    models = self.models
    adaptations = self.adaptations
    templates = self.templates
    triggers = self.triggers
    A = self.A

    text = None

    found = {}

    for kind, allOfKind in (
        (&#34;model&#34;, models),
        (&#34;adaptation&#34;, adaptations),
        (&#34;template&#34;, templates),
    ):
        if text is None:
            with fileOpen(xmlPath) as fh:
                text = fh.read()

        found[kind] = None

        if kind == &#34;model&#34;:
            result = A.getModel(text)
            if result is None or result == &#34;tei_all&#34;:
                result = None
        else:
            result = None
            triggerRe = triggers[kind]
            if triggerRe is not None:
                match = triggerRe.search(text)
                result = match.group(1) if match else None

        if result is not None and result not in allOfKind:
            if verbose &gt;= 0:
                console(f&#34;unavailable {kind} {result} in {ux(xmlPath)}&#34;)
            result = None
        found[kind] = result

    return (found[&#34;model&#34;], found[&#34;adaptation&#34;], found[&#34;template&#34;])</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.TEI.getXML"><code class="name flex">
<span>def <span class="ident">getXML</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Make an inventory of the TEI source files.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code>tuple | string</code></dt>
<dd>
<p>If section model I is in force:</p>
<p>The outer tuple has sorted entries corresponding to folders under the
TEI input directory.
Each such entry consists of the folder name and an inner tuple
that contains the file names in that folder, sorted.</p>
<p>If section model II is in force:</p>
<p>It is the name of the single XML file.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/331baa8460d48d644338cf8e085d696cb9cbdbb0/tf/convert/tei.py#L1613-L1686" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getXML(self):
    &#34;&#34;&#34;Make an inventory of the TEI source files.

    Returns
    -------
    tuple of tuple | string
        If section model I is in force:

        The outer tuple has sorted entries corresponding to folders under the
        TEI input directory.
        Each such entry consists of the folder name and an inner tuple
        that contains the file names in that folder, sorted.

        If section model II is in force:

        It is the name of the single XML file.
    &#34;&#34;&#34;
    verbose = self.verbose
    teiPath = self.teiPath
    sectionModel = self.sectionModel
    if verbose == 1:
        console(f&#34;Section model {sectionModel}&#34;)

    if sectionModel == &#34;I&#34;:
        backMatter = self.backMatter

        IGNORE = &#34;__ignore__&#34;

        xmlFilesRaw = collections.defaultdict(list)

        with scanDir(teiPath) as dh:
            for folder in dh:
                folderName = folder.name
                if folderName == IGNORE:
                    continue
                if not folder.is_dir():
                    continue
                with scanDir(f&#34;{teiPath}/{folderName}&#34;) as fh:
                    for file in fh:
                        fileName = file.name
                        if not (
                            fileName.lower().endswith(&#34;.xml&#34;) and file.is_file()
                        ):
                            continue
                        xmlFilesRaw[folderName].append(fileName)

        xmlFiles = []
        hasBackMatter = False

        for folderName in sorted(xmlFilesRaw, key=versionSort):
            if folderName == backMatter:
                hasBackMatter = True
            else:
                fileNames = xmlFilesRaw[folderName]
                xmlFiles.append((folderName, tuple(sorted(fileNames))))

        if hasBackMatter:
            fileNames = xmlFilesRaw[backMatter]
            xmlFiles.append((backMatter, tuple(sorted(fileNames))))

        xmlFiles = tuple(xmlFiles)

        return xmlFiles

    if sectionModel == &#34;II&#34;:
        xmlFile = None
        with scanDir(teiPath) as fh:
            for file in fh:
                fileName = file.name
                if not (fileName.lower().endswith(&#34;.xml&#34;) and file.is_file()):
                    continue
                xmlFile = fileName
                break
        return xmlFile</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.TEI.loadTask"><code class="name flex">
<span>def <span class="ident">loadTask</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of the "load" task.</p>
<p>It loads the TF data that resides in the directory where the "convert" task
deliver its results.</p>
<p>During loading there are additional checks. If they succeed, we have evidence
that we have a valid TF dataset.</p>
<p>Also, during the first load intensive pre-computation of TF data takes place,
the results of which will be cached in the invisible <code>.<a title="tf" href="../index.html">tf</a></code> directory there.</p>
<p>That makes the TF data ready to be loaded fast, next time it is needed.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>Whether the loading was successful.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/331baa8460d48d644338cf8e085d696cb9cbdbb0/tf/convert/tei.py#L4096-L4141" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def loadTask(self):
    &#34;&#34;&#34;Implementation of the &#34;load&#34; task.

    It loads the TF data that resides in the directory where the &#34;convert&#34; task
    deliver its results.

    During loading there are additional checks. If they succeed, we have evidence
    that we have a valid TF dataset.

    Also, during the first load intensive pre-computation of TF data takes place,
    the results of which will be cached in the invisible `.tf` directory there.

    That makes the TF data ready to be loaded fast, next time it is needed.

    Returns
    -------
    boolean
        Whether the loading was successful.
    &#34;&#34;&#34;
    if not self.importOK():
        return

    if not self.good:
        return

    tfPath = self.tfPath
    verbose = self.verbose
    silent = AUTO if verbose == 1 else TERSE if verbose == 0 else DEEP

    if not dirExists(tfPath):
        console(f&#34;Directory {ux(tfPath)} does not exist.&#34;, error=True)
        console(&#34;No TF found, nothing to load&#34;, error=True)
        self.good = False
        return

    TF = Fabric(locations=[tfPath], silent=silent)
    allFeatures = TF.explore(silent=True, show=True)
    loadableFeatures = allFeatures[&#34;nodes&#34;] + allFeatures[&#34;edges&#34;]
    api = TF.load(loadableFeatures, silent=silent)
    if api:
        if verbose &gt;= 0:
            console(f&#34;max node = {api.F.otype.maxNode}&#34;)
        self.good = True
        return

    self.good = False</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.TEI.readSchemas"><code class="name flex">
<span>def <span class="ident">readSchemas</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/331baa8460d48d644338cf8e085d696cb9cbdbb0/tf/convert/tei.py#L1504-L1545" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readSchemas(self):
    schemaDir = self.schemaDir
    models = self.models
    A = self.A

    schemaFiles = dict(rng={}, xsd={})
    self.schemaFiles = schemaFiles
    modelInfo = {}
    self.modelInfo = modelInfo
    modelXsd = {}
    self.modelXsd = modelXsd
    modelInv = {}
    self.modelInv = modelInv

    for model in [None] + models:
        for kind in (&#34;rng&#34;, &#34;xsd&#34;):
            schemaFile = (
                A.getBaseSchema()[kind]
                if model is None
                else f&#34;{schemaDir}/{model}.{kind}&#34;
            )
            if fileExists(schemaFile):
                schemaFiles[kind][model] = schemaFile
                if (
                    kind == &#34;rng&#34;
                    or kind == &#34;xsd&#34;
                    and model not in schemaFiles[&#34;rng&#34;]
                ):
                    modelInfo[model] = schemaFile
        if model in schemaFiles[&#34;rng&#34;] and model not in schemaFiles[&#34;xsd&#34;]:
            schemaFileXsd = f&#34;{schemaDir}/{model}.xsd&#34;
            A.fromrelax(schemaFiles[&#34;rng&#34;][model], schemaFileXsd)
            schemaFiles[&#34;xsd&#34;][model] = schemaFileXsd

    baseSchema = schemaFiles[&#34;xsd&#34;][None]
    modelXsd[None] = baseSchema
    modelInv[(baseSchema, None)] = None

    for model in models:
        override = schemaFiles[&#34;xsd&#34;][model]
        modelXsd[model] = override
        modelInv[(baseSchema, override)] = model</code></pre>
</details>
</dd>
<dt id="tf.convert.tei.TEI.task"><code class="name flex">
<span>def <span class="ident">task</span></span>(<span>self, check=False, convert=False, load=False, app=False, apptoken=False, browse=False, verbose=None, validate=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Carry out any task, possibly modified by any flag.</p>
<p>This is a higher level function that can execute a selection of tasks.</p>
<p>The tasks will be executed in a fixed order:
<code>check</code>, <code>convert</code>, <code>load</code>, <code>app</code>, <code>apptoken</code>, <code>browse</code>.
But you can select which one(s) must be executed.</p>
<p>If multiple tasks must be executed and one fails, the subsequent tasks
will not be executed.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>check</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to carry out the <code>check</code> task.</dd>
<dt><strong><code>convert</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to carry out the <code>convert</code> task.</dd>
<dt><strong><code>load</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to carry out the <code>load</code> task.</dd>
<dt><strong><code>app</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to carry out the <code>app</code> task.</dd>
<dt><strong><code>apptoken</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to carry out the <code>apptoken</code> task.</dd>
<dt><strong><code>browse</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to carry out the <code>browse</code> task"</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>integer</code>, optional <code>-1</code></dt>
<dd>Produce no (-1), some (0) or many (1) progress and reporting messages</dd>
<dt><strong><code>validate</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>Whether to perform XML validation during the check task</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>Whether all tasks have executed successfully.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/331baa8460d48d644338cf8e085d696cb9cbdbb0/tf/convert/tei.py#L4555-L4629" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def task(
    self,
    check=False,
    convert=False,
    load=False,
    app=False,
    apptoken=False,
    browse=False,
    verbose=None,
    validate=None,
):
    &#34;&#34;&#34;Carry out any task, possibly modified by any flag.

    This is a higher level function that can execute a selection of tasks.

    The tasks will be executed in a fixed order:
    `check`, `convert`, `load`, `app`, `apptoken`, `browse`.
    But you can select which one(s) must be executed.

    If multiple tasks must be executed and one fails, the subsequent tasks
    will not be executed.

    Parameters
    ----------
    check: boolean, optional False
        Whether to carry out the `check` task.
    convert: boolean, optional False
        Whether to carry out the `convert` task.
    load: boolean, optional False
        Whether to carry out the `load` task.
    app: boolean, optional False
        Whether to carry out the `app` task.
    apptoken: boolean, optional False
        Whether to carry out the `apptoken` task.
    browse: boolean, optional False
        Whether to carry out the `browse` task&#34;
    verbose: integer, optional -1
        Produce no (-1), some (0) or many (1) progress and reporting messages
    validate: boolean, optional True
        Whether to perform XML validation during the check task

    Returns
    -------
    boolean
        Whether all tasks have executed successfully.
    &#34;&#34;&#34;
    if not self.importOK():
        return

    if verbose is not None:
        verboseSav = self.verbose
        self.verbose = verbose

    if validate is not None:
        self.validate = validate

    if not self.good:
        return False

    for condition, method, kwargs in (
        (check, self.checkTask, {}),
        (convert, self.convertTask, {}),
        (load, self.loadTask, {}),
        (app, self.appTask, {}),
        (apptoken, self.appTask, dict(tokenBased=True)),
        (browse, self.browseTask, {}),
    ):
        if condition:
            method(**kwargs)
            if not self.good:
                break

    if verbose is not None:
        self.verbose = verboseSav
    return self.good</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tf.capable.CheckImport" href="../capable.html#tf.capable.CheckImport">CheckImport</a></b></code>:
<ul class="hlist">
<li><code><a title="tf.capable.CheckImport.importGet" href="../capable.html#tf.capable.CheckImport.importGet">importGet</a></code></li>
<li><code><a title="tf.capable.CheckImport.importOK" href="../capable.html#tf.capable.CheckImport.importOK">importOK</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#tei-import">TEI import</a></li>
<li><a href="#configuration-and-customization">Configuration and customization</a><ul>
<li><a href="#keys-and-values-of-the-teiyaml-file">Keys and values of the tei.yaml file</a><ul>
<li><a href="#generic">generic</a></li>
<li><a href="#extra">extra</a></li>
<li><a href="#models">models</a></li>
<li><a href="#templates">templates</a></li>
<li><a href="#adaptations">adaptations</a></li>
<li><a href="#prelim">prelim</a></li>
<li><a href="#granularity">granularity</a></li>
<li><a href="#parentedges">parentEdges</a></li>
<li><a href="#siblingedges">siblingEdges</a></li>
<li><a href="#procins">procins</a></li>
<li><a href="#linemodel">lineModel</a></li>
<li><a href="#pagemodel">pageModel</a></li>
<li><a href="#sectionmodel">sectionModel</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#usage">Usage</a><ul>
<li><a href="#command-line">Command-line</a></li>
<li><a href="#from-python">From Python</a></li>
<li><a href="#tasks">Tasks</a></li>
<li><a href="#note-on-versions">Note on versions</a></li>
<li><a href="#examples">Examples</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.convert" href="index.html">tf.convert</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tf.convert.tei.getRefs" href="#tf.convert.tei.getRefs">getRefs</a></code></li>
<li><code><a title="tf.convert.tei.main" href="#tf.convert.tei.main">main</a></code></li>
<li><code><a title="tf.convert.tei.makeCssInfo" href="#tf.convert.tei.makeCssInfo">makeCssInfo</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.convert.tei.TEI" href="#tf.convert.tei.TEI">TEI</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.convert.tei.TEI.appTask" href="#tf.convert.tei.TEI.appTask">appTask</a></code></li>
<li><code><a title="tf.convert.tei.TEI.browseTask" href="#tf.convert.tei.TEI.browseTask">browseTask</a></code></li>
<li><code><a title="tf.convert.tei.TEI.checkTask" href="#tf.convert.tei.TEI.checkTask">checkTask</a></code></li>
<li><code><a title="tf.convert.tei.TEI.convertTask" href="#tf.convert.tei.TEI.convertTask">convertTask</a></code></li>
<li><code><a title="tf.convert.tei.TEI.getConverter" href="#tf.convert.tei.TEI.getConverter">getConverter</a></code></li>
<li><code><a title="tf.convert.tei.TEI.getDirector" href="#tf.convert.tei.TEI.getDirector">getDirector</a></code></li>
<li><code><a title="tf.convert.tei.TEI.getParser" href="#tf.convert.tei.TEI.getParser">getParser</a></code></li>
<li><code><a title="tf.convert.tei.TEI.getSwitches" href="#tf.convert.tei.TEI.getSwitches">getSwitches</a></code></li>
<li><code><a title="tf.convert.tei.TEI.getXML" href="#tf.convert.tei.TEI.getXML">getXML</a></code></li>
<li><code><a title="tf.convert.tei.TEI.loadTask" href="#tf.convert.tei.TEI.loadTask">loadTask</a></code></li>
<li><code><a title="tf.convert.tei.TEI.readSchemas" href="#tf.convert.tei.TEI.readSchemas">readSchemas</a></code></li>
<li><code><a title="tf.convert.tei.TEI.task" href="#tf.convert.tei.TEI.task">task</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>