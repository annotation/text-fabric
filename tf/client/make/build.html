<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>tf.client.make.build API documentation</title>
<meta name="description" content="Usage …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.client.make.build</code></h1>
</header>
<section id="section-intro">
<h1 id="usage">Usage</h1>
<p>After installing Text-Fabric, you have a new command <code>text-fabric-make</code>.
You can use this on the command line to build new search interfaces for existing
Text-Fabric apps.</p>
<p>Such a search interface is a static HTML page, powered by a Javascript program
that reads the corpus data from Javascript variables.</p>
<p>You can build the interface and deploy the HTML page to GitHub Pages,
after which it is usable for everyone.</p>
<h2 id="prerequisites">Prerequisites</h2>
<ol>
<li>A Text-Fabric dataset that is registered as a TF-App, e.g. <code>nena</code> in
<a href="https://github.com/annotation/app-nena">github.com/annotation/app-nena</a>.
This is the normative example for now.</li>
<li>Within that app's repo, a subdirectory
<a href="https://github.com/annotation/app-nena/tree/master/layeredsearch">layeredsearch</a>
with definitions of search interfaces
(you can define multiple search interfaces for one dataset).
Within this directory:<ol>
<li><code>config.yaml</code>: common metadata of all defined search interfaces</li>
<li>for each search interface a folder
whose name is the name of the search interface, containing<ol>
<li><code>config.yaml</code>: definition of this specific search interface</li>
<li><code>logo.png</code>: a logo</li>
<li><code>custom.css</code>: additional styling (may be empty)</li>
<li>
<p><code>mkdata.py</code>: a module containing a few functions that wrap the
corpus data into Javascript variables:</p>
<ol>
<li><code>makeLegends(maker)</code>: produce abbreviation lists for some layers</li>
<li><code>record(maker)</code>: produce all the search data: full texts of layers and
mappings between nodes and positions in those texts</li>
</ol>
<p>The <code>maker</code> argument is passed by the builder, and contains
the definition of the layers and the api of a loaded Text-Fabric dataset.</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="commands">Commands</h2>
<p>See
also:</p>
<ul>
<li><code><a title="tf.client.make.help" href="help.html">tf.client.make.help</a></code></li>
<li><code><a title="tf.about.clientmanual" href="../../about/clientmanual.html">tf.about.clientmanual</a></code></li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L0-L1292" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# Usage

After installing Text-Fabric, you have a new command `text-fabric-make`.
You can use this on the command line to build new search interfaces for existing
Text-Fabric apps.

Such a search interface is a static HTML page, powered by a Javascript program
that reads the corpus data from Javascript variables.

You can build the interface and deploy the HTML page to GitHub Pages,
after which it is usable for everyone.

## Prerequisites

1.  A Text-Fabric dataset that is registered as a TF-App, e.g. `nena` in
    [github.com/annotation/app-nena](https://github.com/annotation/app-nena).
    This is the normative example for now.
1.  Within that app&#39;s repo, a subdirectory
    [layeredsearch](https://github.com/annotation/app-nena/tree/master/layeredsearch)
    with definitions of search interfaces
    (you can define multiple search interfaces for one dataset).
    Within this directory:
    1.  `config.yaml`: common metadata of all defined search interfaces
    1.  for each search interface a folder
        whose name is the name of the search interface, containing
        1.  `config.yaml`: definition of this specific search interface
        1.  `logo.png`: a logo
        1.  `custom.css`: additional styling (may be empty)
        1.  `mkdata.py`: a module containing a few functions that wrap the
            corpus data into Javascript variables:
            1.  `makeLegends(maker)`: produce abbreviation lists for some layers
            2.  `record(maker)`: produce all the search data: full texts of layers and
                mappings between nodes and positions in those texts

            The `maker` argument is passed by the builder, and contains
            the definition of the layers and the api of a loaded Text-Fabric dataset.

## Commands

See  also:

*   `tf.client.make.help`
*   `tf.about.clientmanual`
&#34;&#34;&#34;

import sys
import os
import re
import types
import yaml
import json
import webbrowser

from shutil import copy
from datetime import datetime as dt
from subprocess import Popen, PIPE
from time import sleep
from zipfile import ZIP_DEFLATED, ZipFile
from importlib import util

# from tf.fabric import Fabric
from tf.app import use
from tf.fabric import Fabric
from tf.core.helpers import specFromRanges, rangesFromSet

from .gh import deploy
from .help import HELP

ZIP_OPTIONS = dict(compression=ZIP_DEFLATED, compresslevel=6)
T_F = &#34;text-fabric&#34;
LS = &#34;layeredsearch&#34;
CONFIG_FILE = f&#34;{os.path.dirname(os.path.abspath(__file__))}/config.yaml&#34;
STATIC_DIR = f&#34;{os.path.dirname(os.path.dirname(os.path.abspath(__file__)))}/static&#34;


def console(*args, error=False):
    device = sys.stderr if error else sys.stdout
    device.write(&#34; &#34;.join(args) + &#34;\n&#34;)
    device.flush()


def invertMap(legend):
    return (
        None
        if legend is None
        else {v: k for (k, v) in legend.items()}
        if type(legend) is dict
        else legend
    )


def readArgs():
    class Args:
        pass

    Args.dataset = None
    Args.client = None
    Args.command = None

    args = sys.argv[1:]

    if not len(args) or args[0] in {&#34;-h&#34;, &#34;--help&#34;, &#34;help&#34;}:
        console(HELP)
        console(&#34;Missing dataset&#34;)
        return None

    dataset = args[0]
    Args.dataset = dataset
    args = args[1:]

    if not len(args):
        console(HELP)
        console(&#34;Missing client or command&#34;)
        return None

    if args[0] in {&#34;-h&#34;, &#34;--help&#34;, &#34;help&#34;}:
        console(HELP)
        return None

    if args[0] in {&#34;serve&#34;, &#34;ship&#34;, &#34;make&#34;}:
        client = None
        command = args[0]
        args = args[1:]
    else:
        client = args[0]
        args = args[1:]

        if not len(args) or args[0] in {&#34;-h&#34;, &#34;--help&#34;, &#34;help&#34;}:
            console(HELP)
            if not len(args):
                console(&#34;No command given&#34;)
            return None

        command = args[0]
        args = args[1:]

    Args.client = client
    Args.command = command
    Args.folder = None
    Args.appFolder = None
    Args.debugState = None

    if command not in {
        &#34;serve&#34;,
        &#34;v&#34;,
        &#34;i&#34;,
        &#34;config&#34;,
        &#34;corpus&#34;,
        &#34;client&#34;,
        &#34;clientdebug&#34;,
        &#34;debug&#34;,
        &#34;publish&#34;,
        &#34;ship&#34;,
        &#34;make&#34;,
    }:
        console(HELP)
        console(f&#34;Wrong arguments: «{&#39; &#39;.join(args)}»&#34;)
        return None

    if command == &#34;serve&#34;:
        if len(args) &lt; 1:
            Args.folder = None
        else:
            Args.folder = args[0]

    elif command == &#34;make&#34;:
        if len(args) &lt; 1:
            console(HELP)
            console(&#34;Missing output folder argument&#34;)
            return None
        else:
            Args.folder = args[1] if len(args) &gt; 1 else args[0]
            Args.appFolder = args[0] if len(args) &gt; 1 else None

    elif command == &#34;debug&#34;:
        if len(args) &lt; 1 or args[0] not in {&#34;on&#34;, &#34;off&#34;}:
            console(&#34;say on or off&#34;)
            return None

        Args.debugState = args[0]
    return Args


class Make:
    def __init__(
        self, dataset, client, A=None, folder=None, appFolder=None, debugState=None
    ):
        if A is not None:
            self.A = A

        class C:
            pass

        self.C = C
        self.dataset = dataset
        self.client = client
        self.folder = folder
        self.appFolder = appFolder
        self.debugState = debugState
        self.good = True

        if dataset:
            if not self.config():
                self.good = False

    def doCommand(self, command):
        if command == &#34;serve&#34;:
            self.serve()
        elif command == &#34;v&#34;:
            self.showVersion()
        elif command == &#34;i&#34;:
            self.adjustVersion()
        elif command == &#34;debug&#34;:
            self.adjustDebug()
        elif command == &#34;config&#34;:
            self.makeConfig()
        elif command == &#34;corpus&#34;:
            self.makeCorpus()
        elif command == &#34;client&#34;:
            self.makeClient()
        elif command == &#34;clientdebug&#34;:
            self.debugState = &#34;on&#34;
            self.makeClient()
            self.adjustDebug()
        elif command == &#34;publish&#34;:
            self.publish()
        elif command == &#34;ship&#34;:
            self.ship()
        elif command == &#34;make&#34;:
            self.make()

    def config(self):
        C = self.C
        dataset = self.dataset
        client = self.client
        folder = self.folder
        appFolder = self.appFolder
        versionFile = f&#34;{STATIC_DIR}/version.yaml&#34;
        self.versionFile = versionFile

        with open(versionFile) as fh:
            settings = yaml.load(fh, Loader=yaml.FullLoader)
            lsVersion = settings[&#34;lsVersion&#34;]

        with open(CONFIG_FILE) as fh:
            mainConfig = yaml.load(fh, Loader=yaml.FullLoader)

        c = dict(
            dataset=dataset,
            client=client,
            lsVersion=lsVersion,
            mainConfig=mainConfig,
            gh=os.path.expanduser(&#34;~/github&#34;),
            ghUrl=&#34;https://github.com&#34;,
            nbUrl=&#34;https://nbviewer.jupyter.org/github&#34;,
            ghPages=&#34;github.io&#34;,
            nbTutUrl=&#34;«nbUrl»/annotation/tutorials/tree/master&#34;,
            lsDocUrl=f&#34;https://«org».«ghPages»/{T_F}/tf/about/clientmanual.html&#34;,
            lsDocSimpleUrl=f&#34;https://«org».«ghPages»/{T_F}/tf/about/manual.html&#34;,
            org=&#34;annotation&#34;,
            repo=&#34;app-«dataset»&#34;,
            rel=&#34;site&#34;,
            generatorUrl=f&#34;https://«org».«ghPages»/{T_F}/tf/client/make/build.html&#34;,
            sourceUrl=&#34;«ghUrl»/«org»/«repo»/tree/master/layeredsearch&#34;,
            issueUrl=&#34;«ghUrl»/«org»/«repo»/issues&#34;,
            tutUrl=&#34;«nbTutUrl»/«dataset»/start.ipynb&#34;,
            staticDir=STATIC_DIR,
            appDir=&#34;«gh»/«org»/«repo»&#34;,
            configDir=f&#34;«appDir»/{LS}&#34; if appFolder is None else f&#34;{appFolder}/{LS}&#34;,
            lsConfig=&#34;«configDir»/config.yaml&#34;,
            clientConfigFile=&#34;«configDir»/«client»/config.yaml&#34;,
            clientMake=&#34;mkdata&#34;,
            clientMakeDir=&#34;«configDir»/«client»&#34;,
            clientMakeFile=&#34;«clientMakeDir»/«clientMake».py&#34;,
            clientCss=&#34;«configDir»/«client»/custom.css&#34;,
            clientLogo=&#34;«configDir»/«client»/logo.png&#34;,
            pngInDir=&#34;«staticDir»/png&#34;,
            cssInDir=&#34;«staticDir»/css&#34;,
            htmlInDir=&#34;«staticDir»/html&#34;,
            jsInDir=&#34;«staticDir»/js&#34;,
            jslibInDir=&#34;«staticDir»/jslib&#34;,
            template=&#34;«htmlInDir»/template.html&#34;,
            index=&#34;«htmlInDir»/index.html&#34;,
            siteDir=&#34;«appDir»/«rel»&#34; if folder is None else folder,
            appClientDir=&#34;«siteDir»/«client»&#34;,
            pngOutDir=&#34;«appClientDir»/png&#34;,
            cssOutDir=&#34;«appClientDir»/css&#34;,
            htmlOutDir=&#34;«siteDir»&#34;,
            jsOutDir=&#34;«appClientDir»/js&#34;,
            jslibOutDir=&#34;«appClientDir»/jslib&#34;,
            jsCorpusDir=&#34;«appClientDir»/corpus&#34;,
            jsInit=&#34;«jsCorpusDir»/init.js&#34;,
            jsApp=&#34;app.js&#34;,
            jsDefs=&#34;defs.js&#34;,
            jsAll=&#34;all.js&#34;,
            jsAllPath=&#34;«appClientDir»/«jsAll»&#34;,
            htmlIndex=&#34;«siteDir»/index.html&#34;,
            htmlClient=&#34;«appClientDir»/index.html&#34;,
            htmlLocalFile=&#34;index-local.html&#34;,
            htmlLocal=&#34;«appClientDir»/«htmlLocalFile»&#34;,
            favicon=&#34;favicon.ico&#34;,
            packageUrl=&#34;../«client».zip&#34;,
        )

        fillRe = re.compile(r&#34;«([a-zA-Z0-9_.]+)»&#34;)

        def fillSub(match):
            k = match.group(1)
            parts = k.split(&#34;.&#34;, 1)
            return (
                c.get(parts[0], {}).get(parts[1], &#34;&#34;)
                if len(parts) == 2
                else c.get(parts[0], &#34;&#34;)
            )

        def fillin(src, k, v):
            if type(v) is str:
                while fillRe.search(v):
                    v = fillRe.sub(fillSub, v)
                src[k] = v
            if type(v) is dict:
                for (m, w) in v.items():
                    fillin(src[k], m, w)
            if type(v) in {list, tuple}:
                if type(v) is tuple:
                    src[k] = list(v)
                for (m, w) in enumerate(v):
                    fillin(src[k], m, w)

        for (k, v) in c.items():
            fillin(c, k, v)

        lsConfig = c[&#34;lsConfig&#34;]
        if not os.path.exists(lsConfig):
            console(f&#34;No config.yaml found for {dataset}: {lsConfig}&#34;)
            return None

        with open(lsConfig) as fh:
            settings = yaml.load(fh, Loader=yaml.FullLoader)
            for (k, v) in settings.items():
                c[k] = v
                fillin(c, k, v)

        if client is not None:
            clientConfigFile = c[&#34;clientConfigFile&#34;]
            if not os.path.exists(clientConfigFile):
                console(
                    f&#34;No config.yaml found for {dataset}:{client}: {clientConfigFile}&#34;
                )
                return None

            with open(clientConfigFile) as fh:
                settings = yaml.load(fh, Loader=yaml.FullLoader)
                for (k, v) in settings.items():
                    c[k] = v
                    fillin(c, k, v)

            self.importMake(c=c)

            d = dict(
                dataLocation=&#34;«gh»/«data.org»/«data.repo»/«data.rel»&#34;,
                dataUrl=&#34;«ghUrl»/«data.org»/«data.repo»/tree/master/«data.rel»/«data.version»&#34;,
                writingUrl=&#34;https://«org».«ghPages»/text-fabric/tf/writing/«writing».html&#34;,
                urls=dict(
                    cheatsheet=(
                        &#34;regexp cheatsheet&#34;,
                        (
                            &#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/&#34;
                            &#34;Regular_Expressions/Cheatsheet&#34;
                        ),
                        &#34;cheatsheet of regular expressions&#34;,
                    ),
                    license=(
                        &#34;MIT&#34;,
                        &#34;https://mit-license.org&#34;,
                        &#34;website of MIT license&#34;,
                    ),
                    maker=(
                        None,
                        &#34;https://dans.knaw.nl/en/front-page?set_language=en&#34;,
                        &#34;Website of DANS = Data Archiving and Networked Services&#34;,
                    ),
                    corpus=(
                        None,
                        &#34;«corpus.url»&#34;,
                        &#34;«corpus.tip»&#34;,
                    ),
                    corpus2=(
                        &#34;«corpus.text»&#34;,
                        &#34;«corpus.url»&#34;,
                        &#34;«corpus.tip»&#34;,
                    ),
                    author=(
                        &#34;Dirk Roorda&#34;,
                        &#34;https://pure.knaw.nl/portal/en/persons/dirk-roorda&#34;,
                        &#34;profile of the author&#34;,
                    ),
                    author1=(
                        &#34;«author1.text»&#34;,
                        &#34;«author1.url»&#34;,
                        &#34;«author1.tip»&#34;,
                    ),
                    author2=(
                        &#34;«author2.text»&#34;,
                        &#34;«author2.url»&#34;,
                        &#34;«author2.tip»&#34;,
                    ),
                    tf=(
                        None,
                        &#34;https://«org».«ghPages»/text-fabric/tf/&#34;,
                        &#34;Text-Fabric documentation website&#34;,
                    ),
                    lsdoc=(
                        &#34;user manual (full)&#34;,
                        &#34;«lsDocUrl»&#34;,
                        &#34;user manual for the full search interface&#34;,
                    ),
                    lsdocsimple=(
                        &#34;user manual (simple)&#34;,
                        &#34;«lsDocSimpleUrl»&#34;,
                        &#34;user manual for the simplified search interface&#34;,
                    ),
                    datadoc=(
                        &#34;data (feature) documentation&#34;,
                        &#34;«data.docUrl»&#34;,
                        &#34;explanation of the features in the dataset&#34;,
                    ),
                    data=(
                        &#34;based on text-fabric data version «data.version»&#34;,
                        &#34;«dataUrl»&#34;,
                        &#34;online repository of the underlying text-fabric data&#34;,
                    ),
                    generator=(
                        f&#34;{T_F}/client&#34;,
                        &#34;«generatorUrl»&#34;,
                        &#34;the generator of this search interface&#34;,
                    ),
                    source=(
                        &#34;«repo»&#34;,
                        &#34;«sourceUrl»&#34;,
                        &#34;source code of the definition of this search interface&#34;,
                    ),
                    issue=(
                        &#34;Report an issue&#34;,
                        &#34;«issueUrl»&#34;,
                        &#34;report issues&#34;,
                    ),
                    package=(
                        &#34;download&#34;,
                        &#34;«packageUrl»&#34;,
                        &#34;zip file for offline use&#34;,
                    ),
                    writing=(
                        &#34;«writing»&#34;,
                        &#34;«writingUrl»&#34;,
                        &#34;characters and transliteration for «writing»&#34;,
                    ),
                    related=(
                        &#34;text-fabric «dataset»&#34;,
                        &#34;«tutUrl»&#34;,
                        &#34;using Text-Fabric on the same corpus&#34;,
                    ),
                ),
            )

            for (k, v) in d.items():
                c[k] = v
                fillin(c, k, v)

            setattr(
                C,
                &#34;debugConfig&#34;,
                dict(
                    setup=dict(
                        file=f&#34;{c[&#39;jsOutDir&#39;]}/{c[&#39;jsDefs&#39;]}&#34;,
                        re=re.compile(r&#34;&#34;&#34;export const DEBUG = ([a-z]+)&#34;&#34;&#34;),
                        mask=&#34;export const DEBUG = {}&#34;,
                    ),
                ),
            )

        for (k, v) in c.items():
            setattr(C, k, v)

        for (setting, default) in (
            (&#34;linkLevelMin&#34;, 1),
            (&#34;linkLevelMax&#34;, 3),
            (&#34;memSavingMethod&#34;, 0),
        ):
            if getattr(C, setting, None) is None:
                setattr(C, setting, default)

        return True

    def importMake(self, c=None):
        client = self.client
        dataset = self.dataset

        if c is None:
            C = self.C
            clientMake = C.clientMake
            clientMakeDir = C.clientMakeDir
            clientMakeFile = C.clientMakeFile
        else:
            clientMake = c[&#34;clientMake&#34;]
            clientMakeDir = c[&#34;clientMakeDir&#34;]
            clientMakeFile = c[&#34;clientMakeFile&#34;]

        try:
            moduleName = f&#34;tf.client.ls.{dataset}.{client}.{clientMake}&#34;
            spec = util.spec_from_file_location(moduleName, clientMakeFile)
            code = util.module_from_spec(spec)
            sys.path.insert(0, clientMakeDir)
            spec.loader.exec_module(code)
            sys.path.pop(0)
            self.makeLegends = types.MethodType(code.makeLegends, self)
            self.record = types.MethodType(code.record, self)

        except Exception as e:
            console(f&#34;Cannot make data for {dataset}:{client}: {str(e)}&#34;)
            return None

    def makeClientSettings(self):
        C = self.C
        layerSettings = C.layerSettings
        A = self.A
        api = A.api
        Cp = api.C

        self.makeLegends()

        typeSeq = list(layerSettings)
        typesLower = {}

        for (i, tp) in enumerate(typeSeq):
            typesLower[tp] = typeSeq[0 : i + 1]

        # set up the configuration that informs the client code
        # and the code that generates the data for the client

        clientConfig = dict(
            memSavingMethod=C.memSavingMethod,
            mainConfig=C.mainConfig,
            defs=dict(
                lsVersion=C.lsVersion,
                dataset=C.dataset,
                client=C.client,
                org=C.org,
                repo=C.repo,
                urls=C.urls,
                description=C.description,
            ),
            ntypes=typeSeq,
            typesLower=typesLower,
            defaultSettings=C.defaultSettings,
            defaultFlags=C.defaultFlags,
            keyboard=getattr(C, &#34;keyboard&#34;, None),
        )

        # check visible- and focus- attributes

        theFocuses = []
        theVisibles = []

        for (nType, typeInfo) in layerSettings.items():
            if typeInfo.get(&#34;focus&#34;, False):
                theFocuses.append(nType)

            for (name, layerInfo) in layerSettings[nType].get(&#34;layers&#34;, {}).items():
                if layerInfo.get(&#34;visible&#34;, False):
                    theVisibles.append((nType, name))
                theMap = layerInfo.get(&#34;legend&#34;, None)
                if theMap is not None and type(theMap) is dict:
                    default = layerInfo.get(&#34;default&#34;, None)
                    if default is not None:
                        theMap[&#34;&#34;] = default

        if len(theFocuses) == 0:
            focusType = None
            console(&#34;No node type is declared as result focus\n&#34;)
        else:
            focusType = theFocuses[0]
            if len(theFocuses) &gt; 1:
                console(&#34;Multiple node types declared as result focus:\n&#34;)
                console(&#34;\t&#34; + (&#34;, &#34;.join(theFocuses)) + &#34;\n&#34;)
            else:
                console(&#34;Node type declared as result focus:\n&#34;)
                console(f&#34;\t{focusType}\n&#34;)

        clientConfig[&#34;focusType&#34;] = focusType

        if len(theVisibles) == 0:
            console(&#34;No layer type is declared as visible in the result (&#39;visible&#39;)\n&#34;)
        else:
            console(&#34;Layers declared as visible in the result (&#39;visible&#39;):\n&#34;)
            console(&#34;\t&#34; + (&#34;, &#34;.join(&#34;/&#34;.join(s) for s in theVisibles)) + &#34;\n&#34;)

        visible = {}
        layers = {}
        levels = {}

        ntypesinitTF = {level[0]: level[2] for level in Cp.levels.data}
        ntypessizeTF = {level[0]: level[3] - level[2] + 1 for level in Cp.levels.data}
        ntypesinit = {}
        ntypessize = {}

        for (level, typeInfo) in layerSettings.items():
            nType = typeInfo.get(&#34;nType&#34;, level)
            ntypesinit[level] = ntypesinitTF[nType]
            ntypessize[level] = ntypessizeTF[nType]
            levels[level] = typeInfo.get(&#34;description&#34;, &#34;&#34;)

            ti = typeInfo.get(&#34;layers&#34;, None)
            if ti is None:
                continue

            visible[level] = {layer: ti[layer].get(&#34;visible&#34;, False) for layer in ti}
            layers[level] = {
                layer: dict(
                    valueMap=invertMap(ti[layer].get(&#34;legend&#34;, None)),
                    tip=ti[layer].get(&#34;tip&#34;, False),
                    pos=ti[layer][&#34;pos&#34;] or layer,
                    pattern=ti[layer].get(&#34;example&#34;, &#34;&#34;),
                    description=ti[layer].get(&#34;description&#34;, &#34;&#34;),
                )
                for layer in ti
            }

        for (k, v) in (
            (&#34;ntypesinit&#34;, ntypesinit),
            (&#34;ntypessize&#34;, ntypessize),
            (&#34;dtypeOf&#34;, {typeSeq[i + 1]: tp for (i, tp) in enumerate(typeSeq[0:-1])}),
            (&#34;utypeOf&#34;, {tp: typeSeq[i + 1] for (i, tp) in enumerate(typeSeq[0:-1])}),
            (&#34;visible&#34;, visible),
            (&#34;levels&#34;, levels),
            (&#34;layers&#34;, layers),
        ):
            clientConfig[k] = v
        self.clientConfig = clientConfig

    def loadTf(self):
        C = self.C
        dataset = C.dataset
        version = C.data[&#34;version&#34;]
        A = use(f&#34;{dataset}:clone&#34;, checkout=&#34;clone&#34;, version=version)
        self.A = A

    def makeConfig(self):
        if not getattr(self, &#34;A&#34;, None):
            self.loadTf()
        if not getattr(self, &#34;clientConfig&#34;, None):
            self.makeClientSettings()
        self.dumpConfig()

    def makeLinks(self):
        C = self.C
        A = self.A
        api = A.api
        T = api.T
        F = api.F

        linkLevelMin = C.linkLevelMin
        linkLevelMax = C.linkLevelMax
        sTypes = T.sectionTypes[linkLevelMin - 1 : linkLevelMax]
        A.info(f&#34;links for types {&#39;, &#39;.join(sTypes)}&#34;)
        links = {
            sType: {n: A.webLink(n, urlOnly=True) for n in F.otype.s(sType)}
            for sType in sTypes
        }
        for (sType, sLinks) in links.items():
            A.info(f&#34;{sType:&lt;20}: {len(sLinks):&gt;6} links&#34;, tm=False)
        A.info(&#34;done&#34;)
        self.links = links

    def makeCorpus(self):
        if not getattr(self, &#34;A&#34;, None):
            self.loadTf()
        if not getattr(self, &#34;clientConfig&#34;, None):
            self.makeClientSettings()
        A = self.A

        A.info(&#34;Make links ...&#34;)
        self.makeLinks()

        A.info(&#34;Recording ...&#34;)
        self.record()

        A.info(&#34;Dumping ...&#34;)
        return self.dumpCorpus()

    def dumpConfig(self):
        C = self.C
        A = self.A
        clientConfig = self.clientConfig

        destData = C.jsCorpusDir
        if not os.path.exists(destData):
            os.makedirs(destData, exist_ok=True)

        fileNameConfig = f&#34;{destData}/config.js&#34;

        with open(fileNameConfig, &#34;w&#34;) as fh:
            fh.write(&#34;const configData = &#34;)
            json.dump(clientConfig, fh, ensure_ascii=False, indent=1)
        A.info(f&#34;Config written to file {fileNameConfig}&#34;)

    def compress(self, data):
        sets = {}

        compressed = []

        for n in sorted(data):
            sets.setdefault(data[n], []).append(n)

        for (value, nset) in sorted(sets.items(), key=lambda x: (x[1][0], x[1][-1])):
            nSpec = (
                list(nset)[0] if len(nset) == 1 else specFromRanges(rangesFromSet(nset))
            )
            compressed.append(f&#34;{nSpec}\t{value}&#34;)

        return compressed

    def dumpCorpus(self):
        C = self.C
        A = self.A
        layerSettings = C.layerSettings
        memSavingMethod = C.memSavingMethod

        up = self.up
        recorders = self.recorders
        accumulators = self.accumulators

        texts = {}
        posinfo = {}

        for (level, typeInfo) in layerSettings.items():
            ti = typeInfo.get(&#34;layers&#34;, None)
            if ti is None:
                continue

            texts[level] = {layer: None for layer in ti}
            posinfo[level] = {layer: None for layer in ti if ti[layer][&#34;pos&#34;] is None}

        A.info(&#34;wrap recorders for delivery&#34;)
        good = True

        for (level, typeInfo) in recorders.items():
            A.info(f&#34;\t{level}&#34;)
            for (layer, x) in typeInfo.items():
                A.info(f&#34;\t\t{layer}&#34;)
                texts[level][layer] = x.text()
                if memSavingMethod == 0:
                    posinfo[level][layer] = x.positions(simple=True)
                elif memSavingMethod == 1:
                    posResult = x.rPositions(acceptMaterialOutsideNodes=True)
                    if type(posResult) is str:
                        A.error(&#34;Memory optimization cannot be applied to this layer&#34;)
                        A.error(&#34;because of violation of the assumptions:&#34;)
                        A.error(posResult)
                        good = False
                    posinfo[level][layer] = posResult

        A.info(&#34;wrap accumulators for delivery&#34;)
        for (level, typeInfo) in accumulators.items():
            A.info(f&#34;\t{level}&#34;)
            for (layer, x) in typeInfo.items():
                A.info(f&#34;\t\t{layer}&#34;)
                texts[level][layer] = &#34;&#34;.join(x)

        data = dict(
            texts=texts,
            posinfo=posinfo,
            up=self.compress(up),
        )
        data[&#34;links&#34;] = self.links

        A.indent(reset=True)
        A.info(&#34;Dumping data to compact json files&#34;)

        destData = C.jsCorpusDir
        if not os.path.exists(destData):
            os.makedirs(destData, exist_ok=True)

        def writeDataFile(name, address, thisData, asString=False):
            path = f&#34;{destData}/{name.lower()}.js&#34;
            heading = f&#34;corpusData[{address}] = &#34;
            with open(path, &#34;w&#34;) as fh:
                fh.write(heading)
                if asString:
                    fh.write(&#34;`&#34;)
                    fh.write(thisData)
                    fh.write(&#34;`&#34;)
                else:
                    json.dump(
                        thisData,
                        fh,
                        ensure_ascii=False,
                        indent=None,
                        separators=(&#34;,&#34;, &#34;:&#34;),
                    )
                A.info(f&#34;Data {name} stored in {path}&#34;)

        init = [&#34;var corpusData = {}\n&#34;]

        for (partName, partData) in data.items():
            if partName in {&#34;texts&#34;, &#34;posinfo&#34;}:
                init.append(f&#39;corpusData[&#34;{partName}&#34;] = {{}}\n&#39;)
                for (nType, tpData) in partData.items():
                    init.append(f&#39;corpusData[&#34;{partName}&#34;][&#34;{nType}&#34;] = {{}}\n&#39;)
                    for (layer, lrData) in tpData.items():
                        writeDataFile(
                            f&#34;{partName}-{nType}-{layer}&#34;,
                            f&#39;&#34;{partName}&#34;][&#34;{nType}&#34;][&#34;{layer}&#34;&#39;,
                            lrData,
                        )
            else:
                writeDataFile(partName, f&#39;&#34;{partName}&#34;&#39;, partData)
        with open(C.jsInit, &#34;w&#34;) as fh:
            fh.write(&#34;&#34;.join(init))

        return good

    def makeCombined(self):
        C = self.C

        commentRe = re.compile(r&#34;&#34;&#34;[ \t]*/\*.*?\*/[ \t]*&#34;&#34;&#34;, re.S)
        importRe = re.compile(r&#39;&#39;&#39;import\s+\{.*?\}\s+from\s+&#34;[^&#34;]*\.js&#34;&#39;&#39;&#39;, re.S)
        exportRe = re.compile(r&#34;&#34;&#34;^export[ ]+&#34;&#34;&#34;, re.M)
        whiteRe = re.compile(r&#34;&#34;&#34;^\s+$&#34;&#34;&#34;, re.M)
        nlRe = re.compile(r&#34;&#34;&#34;\n\n+&#34;&#34;&#34;)

        def getModule(module):
            with open(f&#34;{C.jsOutDir}/{module}&#34;) as fh:
                text = fh.read()
            text = importRe.sub(&#34;&#34;, text)
            text = exportRe.sub(&#34;&#34;, text)
            text = commentRe.sub(&#34;&#34;, text)
            text = whiteRe.sub(&#34;&#34;, text)
            text = nlRe.sub(&#34;\n&#34;, text)
            return text

        modules = []

        with os.scandir(C.jsOutDir) as it:
            for entry in it:
                name = entry.name
                if (
                    not entry.is_file()
                    or name.startswith(&#34;.&#34;)
                    or not name.endswith(&#34;.js&#34;)
                ):
                    continue
                modules.append(entry.name)
        console(&#34;, &#34;.join(module[0:-3] for module in modules))

        content = {module: getModule(module) for module in modules}

        header = &#34;&#34;&#34;\
/*eslint-env jquery*/
/* global configData */
/* global corpusData */

    &#34;&#34;&#34;
        combined = (
            header
            + content[C.jsDefs]
            + &#34;\n\n&#34;
            + &#34;\n\n&#34;.join(
                text
                for (name, text) in content.items()
                if name not in {C.jsDefs, C.jsApp}
            )
            + &#34;\n\n&#34;
            + content[C.jsApp]
        )
        with open(C.jsAllPath, &#34;w&#34;) as fh:
            fh.write(combined)
        console(f&#34;Combined js file written to {C.jsAllPath}&#34;)

    def makeHtml(self):
        C = self.C
        lsVersion = C.lsVersion

        # index of all clients

        clients = {}

        for thisClient in self.getAllClients():
            thisConfig = f&#34;{C.configDir}/{thisClient}/config.yaml&#34;
            if os.path.exists(thisConfig):
                with open(thisConfig) as fh:
                    desc = yaml.load(fh, Loader=yaml.FullLoader).get(&#34;short&#34;, &#34;&#34;)
            else:
                desc = &#34;&#34;
            clients[thisClient] = desc

        with open(C.index) as fh:
            template = fh.read()
            htmlIndex = template.replace(&#34;«dataset»&#34;, C.dataset)
            htmlIndex = htmlIndex.replace(&#34;«client»&#34;, C.client)

            html = []
            for (thisClient, desc) in clients.items():
                html.append(
                    f&#34;&#34;&#34;
&lt;dt&gt;&lt;a href=&#34;{thisClient}/index.html&#34;&gt;{thisClient}&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;{desc}&lt;/dd&gt;
&#34;&#34;&#34;
                )

            htmlIndex = htmlIndex.replace(&#34;«clients»&#34;, &#34;&#34;.join(html))

        with open(C.htmlIndex, &#34;w&#34;) as fh:
            fh.write(htmlIndex)
        console(f&#34;html file written to {C.htmlIndex}&#34;)

        # client and client-local

        with os.scandir(C.jsCorpusDir) as it:
            scripts = []
            for entry in it:
                file = entry.name
                if not file.endswith(&#34;.js&#34;):
                    continue
                if file.startswith(&#34;texts-&#34;) or file.startswith(&#34;posinfo-&#34;):
                    scripts.append(f&#39;&lt;script defer src=&#34;corpus/{file}«v»&#34;&gt;&lt;/script&gt;&#39;)
            corpusScripts = &#34;\n&#34;.join(scripts)

        with open(C.template) as fh:
            template = fh.read()
            htmlNormal = template.replace(
                &#34;«js»&#34;, &#39;&#39;&#39;type=&#34;module&#34; src=&#34;js/app.js«v»&#34;&#39;&#39;&#39;
            )
            htmlNormal = htmlNormal.replace(&#34;«corpus»&#34;, corpusScripts)
            htmlNormal = htmlNormal.replace(&#34;«v»&#34;, f&#34;?v={lsVersion}&#34;)
            htmlNormal = htmlNormal.replace(&#34;«dataset»&#34;, C.dataset)
            htmlNormal = htmlNormal.replace(&#34;«client»&#34;, C.client)
            htmlLocal = template.replace(&#34;«js»&#34;, f&#39;&#39;&#39;defer src=&#34;{C.jsAll}&#34;&#39;&#39;&#39;)
            htmlLocal = htmlLocal.replace(&#34;«corpus»&#34;, corpusScripts)
            htmlLocal = htmlLocal.replace(&#34;«v»&#34;, &#34;&#34;)
            htmlLocal = htmlLocal.replace(&#34;«dataset»&#34;, C.dataset)
            htmlLocal = htmlLocal.replace(&#34;«client»&#34;, C.client)

        with open(C.htmlClient, &#34;w&#34;) as fh:
            fh.write(htmlNormal)
        console(f&#34;html file written to {C.htmlClient}&#34;)

        with open(C.htmlLocal, &#34;w&#34;) as fh:
            fh.write(htmlLocal)
        console(f&#34;html file (for use with file://) written to {C.htmlLocal}&#34;)

    def makeClient(self):
        &#34;&#34;&#34;
        We create a client app in the target directory.

        The client consists of HTML/CSS/PNG files plus a modular Javascript program.

        Module loading does not work when you open the HTML file locally
        (i.e. when the HTML is not served by a server).

        N.B. There is a difference between a local web server serving at `localhost`
        and opening the file directly into your browser by double clicking on it.

        In the first case, you see in your un the URL bar of your browser
        something that starts with
        `http://` or `https://`, in the second case you see `file://` instead.

        Modular Javascript does not work with `file://` origins.

        For that case, we bundle the modules into one,
        and let a «client»-local.html include it

        We also zip the client into {C.client}.zip so that users can download it easily

        However, if the debugState is on, we skip all steps that are unneccesary
        to see the updated client working.
        &#34;&#34;&#34;

        # copy over the static files

        C = self.C
        debug = self.debugState == &#34;on&#34;

        for (srcDir, dstDir) in (
            (C.pngInDir, C.pngOutDir),
            (C.cssInDir, C.cssOutDir),
            (C.jsInDir, C.jsOutDir),
            (C.jslibInDir, C.jslibOutDir),
            (C.htmlInDir, C.htmlOutDir),
        ):
            if not os.path.exists(dstDir):
                os.makedirs(dstDir, exist_ok=True)

            with os.scandir(srcDir) as it:
                for entry in it:
                    name = entry.name
                    if not entry.is_file() or name.startswith(&#34;.&#34;):
                        continue
                    srcFile = f&#34;{srcDir}/{name}&#34;
                    if srcFile != C.template:
                        copy(srcFile, f&#34;{dstDir}/{name}&#34;)
        copy(f&#34;{C.staticDir}/{C.favicon}&#34;, f&#34;{C.siteDir}/{C.favicon}&#34;)

        # move the custom files in place

        for (srcFile, dstFile) in (
            (C.clientCss, f&#34;{C.cssOutDir}/{C.client}.css&#34;),
            (C.clientLogo, f&#34;{C.pngOutDir}/{C.client}.png&#34;),
        ):
            copy(srcFile, dstFile)

        console(&#34;Copied static files&#34;)

        # create combined javascript file

        if not debug:
            self.makeCombined()

        self.makeHtml()

        if not debug:
            self.zipApp()

    def zipApp(self):
        C = self.C
        items = set(
            &#34;&#34;&#34;
            css
            corpus
            jslib
            png
            favicon.ico
        &#34;&#34;&#34;.strip().split()
        )
        items.add(C.htmlLocalFile)
        items.add(C.jsAll)

        zipped = f&#34;{C.siteDir}/{C.client}.zip&#34;

        with ZipFile(zipped, &#34;w&#34;, **ZIP_OPTIONS) as zipFile:
            with os.scandir(C.appClientDir) as it:
                for entry in it:
                    file = entry.name
                    if file not in items:
                        continue
                    if entry.is_file():
                        zipFile.write(f&#34;{C.appClientDir}/{file}&#34;, arcname=file)
                        console(f&#34;adding {file}&#34;)
                    else:
                        with os.scandir(f&#34;{C.appClientDir}/{file}&#34;) as sit:
                            for sentry in sit:
                                sfile = sentry.name
                                if sentry.is_file and not sfile.startswith(&#34;.&#34;):
                                    sfile = f&#34;{file}/{sfile}&#34;
                                    zipFile.write(
                                        f&#34;{C.appClientDir}/{sfile}&#34;, arcname=sfile
                                    )
                                    console(f&#34;adding {sfile}&#34;)
        console(f&#34;Packaged client into {zipped}&#34;)

    def publish(self, allClients=True):
        C = self.C
        appDir = C.appDir
        siteDir = C.siteDir
        dataset = self.dataset
        client = self.client
        clients = self.getAllClients() if allClients or client is None else [client]
        console(f&#34;Publishing {dataset}:{&#39;,&#39;.join(clients)} from {siteDir} ...&#34;)
        os.chdir(appDir)
        deploy(C.org, C.repo)

    def ship(self, publish=True):
        self.adjustVersion()
        self.makeConfig()
        good = self.makeCorpus()
        if good:
            self.makeClient()
            self.adjustDebug()
            if publish:
                self.publish()

    def make(self):
        self.makeConfig()
        good = self.makeCorpus()
        if good:
            self.makeClient()
            self.adjustDebug()

    def serve(self):
        C = self.C
        os.chdir(C.siteDir)

        console(f&#34;HTTP serving files in {C.siteDir}&#34;)
        server = Popen(
            [&#34;python3&#34;, &#34;-m&#34;, &#34;http.server&#34;], stdout=PIPE, bufsize=1, encoding=&#34;utf-8&#34;
        )
        sleep(1)
        webbrowser.open(&#34;http://localhost:8000/index.html&#34;, new=2, autoraise=True)
        stopped = server.poll()
        if not stopped:
            try:
                console(&#34;Press &lt;Ctrl+C&gt; to stop the HTTP server&#34;)
                if server:
                    for line in server.stdout:
                        console(line)
            except KeyboardInterrupt:
                console(&#34;&#34;)
                if server:
                    server.terminate()
                    console(&#34;Http server has stopped&#34;)

    def incVersion(self):
        C = self.C
        lsVersion = C.lsVersion
        parts = lsVersion.split(&#34;@&#34;, 1)
        v = int(parts[0].lstrip(&#34;v&#34;).lstrip(&#34;0&#34;), base=10)
        now = dt.utcnow().isoformat(timespec=&#34;seconds&#34;)
        self.lsVersion = f&#34;v{v + 1:&gt;03}@{now}&#34;
        C.lsVersion = self.lsVersion

    def showVersion(self):
        C = self.C
        lsVersion = C.lsVersion
        versionFile = self.versionFile
        console(f&#34;{lsVersion} (according to {versionFile})&#34;)

    def adjustVersion(self):
        C = self.C
        versionFile = self.versionFile

        currentVersion = C.lsVersion
        self.incVersion()
        newVersion = C.lsVersion

        with open(versionFile, &#34;w&#34;) as fh:
            yaml.dump(dict(lsVersion=newVersion), fh)

        console(f&#34;Version went from `{currentVersion}` to `{newVersion}`&#34;)

    def replaceDebug(self, mask, value):
        def subVersion(match):
            return mask.format(value)

        return subVersion

    def getDebugs(self):
        C = self.C

        debugs = {}
        good = True

        for (key, c) in C.debugConfig.items():
            cfile = c[&#34;file&#34;]
            with open(cfile) as fh:
                text = fh.read()
            match = c[&#34;re&#34;].search(text)
            if not match:
                console(f&#34;No debug found in {cfile}&#34;)
                good = False
                continue
            debug = match.group(1)
            debugs[cfile] = debug

        if not good:
            return False
        return debugs

    def showDebug(self):
        debugInfo = self.getDebugs()
        if debugInfo is None:
            return False
        return True

        for (source, debug) in debugInfo.items():
            console(f&#34;{debug} (according to {source})&#34;)

    def adjustDebug(self):
        C = self.C
        debugState = self.debugState

        if not self.showDebug():
            return

        newValue = &#34;true&#34; if debugState == &#34;on&#34; else &#34;false&#34;

        for (key, c) in C.debugConfig.items():
            console(f&#39;Adjusting debug in {c[&#34;file&#34;]}&#39;)
            with open(c[&#34;file&#34;]) as fh:
                text = fh.read()
            text = c[&#34;re&#34;].sub(self.replaceDebug(c[&#34;mask&#34;], newValue), text)
            with open(c[&#34;file&#34;], &#34;w&#34;) as fh:
                fh.write(text)

        console(f&#34;Debug set to {newValue}&#34;)
        if not self.showDebug():
            return

    def getAllClients(self):
        C = self.C
        configDir = C.configDir

        clients = []

        with os.scandir(configDir) as it:
            for entry in it:
                client = entry.name
                if not entry.is_dir() or client.startswith(&#34;.&#34;):
                    continue
                clients.append(client)
        return clients


def makeSearchClients(dataset, folder, appFolder, dataDir=None):
    DEBUG_STATE = &#34;off&#34;

    Mk = Make(
        dataset, None, folder=folder, appFolder=appFolder, debugState=DEBUG_STATE
    )
    clients = Mk.getAllClients()
    # version = Mk.C.data[&#34;version&#34;]

    def getDataFromDir():
        TF = Fabric(locations=dataDir, modules=[&#34;&#34;])
        api = TF.loadAll()
        A = use(appFolder, api=api)
        return A

    A = None if dataDir is None else getDataFromDir()
    for client in clients:
        print(f&#34;\n\no-o-o-o-o-o-o {client} o-o-o-o-o-o-o-o\n\n&#34;)
        ThisMk = Make(
            dataset,
            client,
            A=A,
            folder=folder,
            appFolder=appFolder,
            debugState=DEBUG_STATE,
        )
        ThisMk.make()
        A = ThisMk.A


def main():
    Args = readArgs()
    if Args is None:
        return 0

    dataset = Args.dataset
    client = Args.client
    command = Args.command
    folder = Args.folder
    appFolder = Args.appFolder
    debugState = Args.debugState

    if not dataset:
        return

    if not client:
        if command not in {&#34;serve&#34;, &#34;ship&#34;, &#34;make&#34;}:
            return

    Mk = Make(
        Args.dataset,
        Args.client,
        folder=folder,
        appFolder=appFolder,
        debugState=debugState,
    )

    if command in {&#34;ship&#34;, &#34;make&#34;} and client is None:
        clients = Mk.getAllClients()
        for client in clients:
            ThisMk = Make(
                dataset,
                client,
                folder=folder,
                appFolder=appFolder,
                debugState=debugState,
            )
            if command == &#34;ship&#34;:
                ThisMk.ship(publish=False)
            else:
                ThisMk.make()
        if command == &#34;ship&#34;:
            Mk.publish()
        return

    return Mk.doCommand(command)


if __name__ == &#34;__main__&#34;:
    sys.exit(main())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.client.make.build.console"><code class="name flex">
<span>def <span class="ident">console</span></span>(<span>*args, error=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L77-L80" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def console(*args, error=False):
    device = sys.stderr if error else sys.stdout
    device.write(&#34; &#34;.join(args) + &#34;\n&#34;)
    device.flush()</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.invertMap"><code class="name flex">
<span>def <span class="ident">invertMap</span></span>(<span>legend)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L83-L90" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def invertMap(legend):
    return (
        None
        if legend is None
        else {v: k for (k, v) in legend.items()}
        if type(legend) is dict
        else legend
    )</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L1244-L1289" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def main():
    Args = readArgs()
    if Args is None:
        return 0

    dataset = Args.dataset
    client = Args.client
    command = Args.command
    folder = Args.folder
    appFolder = Args.appFolder
    debugState = Args.debugState

    if not dataset:
        return

    if not client:
        if command not in {&#34;serve&#34;, &#34;ship&#34;, &#34;make&#34;}:
            return

    Mk = Make(
        Args.dataset,
        Args.client,
        folder=folder,
        appFolder=appFolder,
        debugState=debugState,
    )

    if command in {&#34;ship&#34;, &#34;make&#34;} and client is None:
        clients = Mk.getAllClients()
        for client in clients:
            ThisMk = Make(
                dataset,
                client,
                folder=folder,
                appFolder=appFolder,
                debugState=debugState,
            )
            if command == &#34;ship&#34;:
                ThisMk.ship(publish=False)
            else:
                ThisMk.make()
        if command == &#34;ship&#34;:
            Mk.publish()
        return

    return Mk.doCommand(command)</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.makeSearchClients"><code class="name flex">
<span>def <span class="ident">makeSearchClients</span></span>(<span>dataset, folder, appFolder, dataDir=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L1214-L1241" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeSearchClients(dataset, folder, appFolder, dataDir=None):
    DEBUG_STATE = &#34;off&#34;

    Mk = Make(
        dataset, None, folder=folder, appFolder=appFolder, debugState=DEBUG_STATE
    )
    clients = Mk.getAllClients()
    # version = Mk.C.data[&#34;version&#34;]

    def getDataFromDir():
        TF = Fabric(locations=dataDir, modules=[&#34;&#34;])
        api = TF.loadAll()
        A = use(appFolder, api=api)
        return A

    A = None if dataDir is None else getDataFromDir()
    for client in clients:
        print(f&#34;\n\no-o-o-o-o-o-o {client} o-o-o-o-o-o-o-o\n\n&#34;)
        ThisMk = Make(
            dataset,
            client,
            A=A,
            folder=folder,
            appFolder=appFolder,
            debugState=DEBUG_STATE,
        )
        ThisMk.make()
        A = ThisMk.A</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.readArgs"><code class="name flex">
<span>def <span class="ident">readArgs</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L93-L182" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readArgs():
    class Args:
        pass

    Args.dataset = None
    Args.client = None
    Args.command = None

    args = sys.argv[1:]

    if not len(args) or args[0] in {&#34;-h&#34;, &#34;--help&#34;, &#34;help&#34;}:
        console(HELP)
        console(&#34;Missing dataset&#34;)
        return None

    dataset = args[0]
    Args.dataset = dataset
    args = args[1:]

    if not len(args):
        console(HELP)
        console(&#34;Missing client or command&#34;)
        return None

    if args[0] in {&#34;-h&#34;, &#34;--help&#34;, &#34;help&#34;}:
        console(HELP)
        return None

    if args[0] in {&#34;serve&#34;, &#34;ship&#34;, &#34;make&#34;}:
        client = None
        command = args[0]
        args = args[1:]
    else:
        client = args[0]
        args = args[1:]

        if not len(args) or args[0] in {&#34;-h&#34;, &#34;--help&#34;, &#34;help&#34;}:
            console(HELP)
            if not len(args):
                console(&#34;No command given&#34;)
            return None

        command = args[0]
        args = args[1:]

    Args.client = client
    Args.command = command
    Args.folder = None
    Args.appFolder = None
    Args.debugState = None

    if command not in {
        &#34;serve&#34;,
        &#34;v&#34;,
        &#34;i&#34;,
        &#34;config&#34;,
        &#34;corpus&#34;,
        &#34;client&#34;,
        &#34;clientdebug&#34;,
        &#34;debug&#34;,
        &#34;publish&#34;,
        &#34;ship&#34;,
        &#34;make&#34;,
    }:
        console(HELP)
        console(f&#34;Wrong arguments: «{&#39; &#39;.join(args)}»&#34;)
        return None

    if command == &#34;serve&#34;:
        if len(args) &lt; 1:
            Args.folder = None
        else:
            Args.folder = args[0]

    elif command == &#34;make&#34;:
        if len(args) &lt; 1:
            console(HELP)
            console(&#34;Missing output folder argument&#34;)
            return None
        else:
            Args.folder = args[1] if len(args) &gt; 1 else args[0]
            Args.appFolder = args[0] if len(args) &gt; 1 else None

    elif command == &#34;debug&#34;:
        if len(args) &lt; 1 or args[0] not in {&#34;on&#34;, &#34;off&#34;}:
            console(&#34;say on or off&#34;)
            return None

        Args.debugState = args[0]
    return Args</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.client.make.build.Make"><code class="flex name class">
<span>class <span class="ident">Make</span></span>
<span>(</span><span>dataset, client, A=None, folder=None, appFolder=None, debugState=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L185-L1211" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Make:
    def __init__(
        self, dataset, client, A=None, folder=None, appFolder=None, debugState=None
    ):
        if A is not None:
            self.A = A

        class C:
            pass

        self.C = C
        self.dataset = dataset
        self.client = client
        self.folder = folder
        self.appFolder = appFolder
        self.debugState = debugState
        self.good = True

        if dataset:
            if not self.config():
                self.good = False

    def doCommand(self, command):
        if command == &#34;serve&#34;:
            self.serve()
        elif command == &#34;v&#34;:
            self.showVersion()
        elif command == &#34;i&#34;:
            self.adjustVersion()
        elif command == &#34;debug&#34;:
            self.adjustDebug()
        elif command == &#34;config&#34;:
            self.makeConfig()
        elif command == &#34;corpus&#34;:
            self.makeCorpus()
        elif command == &#34;client&#34;:
            self.makeClient()
        elif command == &#34;clientdebug&#34;:
            self.debugState = &#34;on&#34;
            self.makeClient()
            self.adjustDebug()
        elif command == &#34;publish&#34;:
            self.publish()
        elif command == &#34;ship&#34;:
            self.ship()
        elif command == &#34;make&#34;:
            self.make()

    def config(self):
        C = self.C
        dataset = self.dataset
        client = self.client
        folder = self.folder
        appFolder = self.appFolder
        versionFile = f&#34;{STATIC_DIR}/version.yaml&#34;
        self.versionFile = versionFile

        with open(versionFile) as fh:
            settings = yaml.load(fh, Loader=yaml.FullLoader)
            lsVersion = settings[&#34;lsVersion&#34;]

        with open(CONFIG_FILE) as fh:
            mainConfig = yaml.load(fh, Loader=yaml.FullLoader)

        c = dict(
            dataset=dataset,
            client=client,
            lsVersion=lsVersion,
            mainConfig=mainConfig,
            gh=os.path.expanduser(&#34;~/github&#34;),
            ghUrl=&#34;https://github.com&#34;,
            nbUrl=&#34;https://nbviewer.jupyter.org/github&#34;,
            ghPages=&#34;github.io&#34;,
            nbTutUrl=&#34;«nbUrl»/annotation/tutorials/tree/master&#34;,
            lsDocUrl=f&#34;https://«org».«ghPages»/{T_F}/tf/about/clientmanual.html&#34;,
            lsDocSimpleUrl=f&#34;https://«org».«ghPages»/{T_F}/tf/about/manual.html&#34;,
            org=&#34;annotation&#34;,
            repo=&#34;app-«dataset»&#34;,
            rel=&#34;site&#34;,
            generatorUrl=f&#34;https://«org».«ghPages»/{T_F}/tf/client/make/build.html&#34;,
            sourceUrl=&#34;«ghUrl»/«org»/«repo»/tree/master/layeredsearch&#34;,
            issueUrl=&#34;«ghUrl»/«org»/«repo»/issues&#34;,
            tutUrl=&#34;«nbTutUrl»/«dataset»/start.ipynb&#34;,
            staticDir=STATIC_DIR,
            appDir=&#34;«gh»/«org»/«repo»&#34;,
            configDir=f&#34;«appDir»/{LS}&#34; if appFolder is None else f&#34;{appFolder}/{LS}&#34;,
            lsConfig=&#34;«configDir»/config.yaml&#34;,
            clientConfigFile=&#34;«configDir»/«client»/config.yaml&#34;,
            clientMake=&#34;mkdata&#34;,
            clientMakeDir=&#34;«configDir»/«client»&#34;,
            clientMakeFile=&#34;«clientMakeDir»/«clientMake».py&#34;,
            clientCss=&#34;«configDir»/«client»/custom.css&#34;,
            clientLogo=&#34;«configDir»/«client»/logo.png&#34;,
            pngInDir=&#34;«staticDir»/png&#34;,
            cssInDir=&#34;«staticDir»/css&#34;,
            htmlInDir=&#34;«staticDir»/html&#34;,
            jsInDir=&#34;«staticDir»/js&#34;,
            jslibInDir=&#34;«staticDir»/jslib&#34;,
            template=&#34;«htmlInDir»/template.html&#34;,
            index=&#34;«htmlInDir»/index.html&#34;,
            siteDir=&#34;«appDir»/«rel»&#34; if folder is None else folder,
            appClientDir=&#34;«siteDir»/«client»&#34;,
            pngOutDir=&#34;«appClientDir»/png&#34;,
            cssOutDir=&#34;«appClientDir»/css&#34;,
            htmlOutDir=&#34;«siteDir»&#34;,
            jsOutDir=&#34;«appClientDir»/js&#34;,
            jslibOutDir=&#34;«appClientDir»/jslib&#34;,
            jsCorpusDir=&#34;«appClientDir»/corpus&#34;,
            jsInit=&#34;«jsCorpusDir»/init.js&#34;,
            jsApp=&#34;app.js&#34;,
            jsDefs=&#34;defs.js&#34;,
            jsAll=&#34;all.js&#34;,
            jsAllPath=&#34;«appClientDir»/«jsAll»&#34;,
            htmlIndex=&#34;«siteDir»/index.html&#34;,
            htmlClient=&#34;«appClientDir»/index.html&#34;,
            htmlLocalFile=&#34;index-local.html&#34;,
            htmlLocal=&#34;«appClientDir»/«htmlLocalFile»&#34;,
            favicon=&#34;favicon.ico&#34;,
            packageUrl=&#34;../«client».zip&#34;,
        )

        fillRe = re.compile(r&#34;«([a-zA-Z0-9_.]+)»&#34;)

        def fillSub(match):
            k = match.group(1)
            parts = k.split(&#34;.&#34;, 1)
            return (
                c.get(parts[0], {}).get(parts[1], &#34;&#34;)
                if len(parts) == 2
                else c.get(parts[0], &#34;&#34;)
            )

        def fillin(src, k, v):
            if type(v) is str:
                while fillRe.search(v):
                    v = fillRe.sub(fillSub, v)
                src[k] = v
            if type(v) is dict:
                for (m, w) in v.items():
                    fillin(src[k], m, w)
            if type(v) in {list, tuple}:
                if type(v) is tuple:
                    src[k] = list(v)
                for (m, w) in enumerate(v):
                    fillin(src[k], m, w)

        for (k, v) in c.items():
            fillin(c, k, v)

        lsConfig = c[&#34;lsConfig&#34;]
        if not os.path.exists(lsConfig):
            console(f&#34;No config.yaml found for {dataset}: {lsConfig}&#34;)
            return None

        with open(lsConfig) as fh:
            settings = yaml.load(fh, Loader=yaml.FullLoader)
            for (k, v) in settings.items():
                c[k] = v
                fillin(c, k, v)

        if client is not None:
            clientConfigFile = c[&#34;clientConfigFile&#34;]
            if not os.path.exists(clientConfigFile):
                console(
                    f&#34;No config.yaml found for {dataset}:{client}: {clientConfigFile}&#34;
                )
                return None

            with open(clientConfigFile) as fh:
                settings = yaml.load(fh, Loader=yaml.FullLoader)
                for (k, v) in settings.items():
                    c[k] = v
                    fillin(c, k, v)

            self.importMake(c=c)

            d = dict(
                dataLocation=&#34;«gh»/«data.org»/«data.repo»/«data.rel»&#34;,
                dataUrl=&#34;«ghUrl»/«data.org»/«data.repo»/tree/master/«data.rel»/«data.version»&#34;,
                writingUrl=&#34;https://«org».«ghPages»/text-fabric/tf/writing/«writing».html&#34;,
                urls=dict(
                    cheatsheet=(
                        &#34;regexp cheatsheet&#34;,
                        (
                            &#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/&#34;
                            &#34;Regular_Expressions/Cheatsheet&#34;
                        ),
                        &#34;cheatsheet of regular expressions&#34;,
                    ),
                    license=(
                        &#34;MIT&#34;,
                        &#34;https://mit-license.org&#34;,
                        &#34;website of MIT license&#34;,
                    ),
                    maker=(
                        None,
                        &#34;https://dans.knaw.nl/en/front-page?set_language=en&#34;,
                        &#34;Website of DANS = Data Archiving and Networked Services&#34;,
                    ),
                    corpus=(
                        None,
                        &#34;«corpus.url»&#34;,
                        &#34;«corpus.tip»&#34;,
                    ),
                    corpus2=(
                        &#34;«corpus.text»&#34;,
                        &#34;«corpus.url»&#34;,
                        &#34;«corpus.tip»&#34;,
                    ),
                    author=(
                        &#34;Dirk Roorda&#34;,
                        &#34;https://pure.knaw.nl/portal/en/persons/dirk-roorda&#34;,
                        &#34;profile of the author&#34;,
                    ),
                    author1=(
                        &#34;«author1.text»&#34;,
                        &#34;«author1.url»&#34;,
                        &#34;«author1.tip»&#34;,
                    ),
                    author2=(
                        &#34;«author2.text»&#34;,
                        &#34;«author2.url»&#34;,
                        &#34;«author2.tip»&#34;,
                    ),
                    tf=(
                        None,
                        &#34;https://«org».«ghPages»/text-fabric/tf/&#34;,
                        &#34;Text-Fabric documentation website&#34;,
                    ),
                    lsdoc=(
                        &#34;user manual (full)&#34;,
                        &#34;«lsDocUrl»&#34;,
                        &#34;user manual for the full search interface&#34;,
                    ),
                    lsdocsimple=(
                        &#34;user manual (simple)&#34;,
                        &#34;«lsDocSimpleUrl»&#34;,
                        &#34;user manual for the simplified search interface&#34;,
                    ),
                    datadoc=(
                        &#34;data (feature) documentation&#34;,
                        &#34;«data.docUrl»&#34;,
                        &#34;explanation of the features in the dataset&#34;,
                    ),
                    data=(
                        &#34;based on text-fabric data version «data.version»&#34;,
                        &#34;«dataUrl»&#34;,
                        &#34;online repository of the underlying text-fabric data&#34;,
                    ),
                    generator=(
                        f&#34;{T_F}/client&#34;,
                        &#34;«generatorUrl»&#34;,
                        &#34;the generator of this search interface&#34;,
                    ),
                    source=(
                        &#34;«repo»&#34;,
                        &#34;«sourceUrl»&#34;,
                        &#34;source code of the definition of this search interface&#34;,
                    ),
                    issue=(
                        &#34;Report an issue&#34;,
                        &#34;«issueUrl»&#34;,
                        &#34;report issues&#34;,
                    ),
                    package=(
                        &#34;download&#34;,
                        &#34;«packageUrl»&#34;,
                        &#34;zip file for offline use&#34;,
                    ),
                    writing=(
                        &#34;«writing»&#34;,
                        &#34;«writingUrl»&#34;,
                        &#34;characters and transliteration for «writing»&#34;,
                    ),
                    related=(
                        &#34;text-fabric «dataset»&#34;,
                        &#34;«tutUrl»&#34;,
                        &#34;using Text-Fabric on the same corpus&#34;,
                    ),
                ),
            )

            for (k, v) in d.items():
                c[k] = v
                fillin(c, k, v)

            setattr(
                C,
                &#34;debugConfig&#34;,
                dict(
                    setup=dict(
                        file=f&#34;{c[&#39;jsOutDir&#39;]}/{c[&#39;jsDefs&#39;]}&#34;,
                        re=re.compile(r&#34;&#34;&#34;export const DEBUG = ([a-z]+)&#34;&#34;&#34;),
                        mask=&#34;export const DEBUG = {}&#34;,
                    ),
                ),
            )

        for (k, v) in c.items():
            setattr(C, k, v)

        for (setting, default) in (
            (&#34;linkLevelMin&#34;, 1),
            (&#34;linkLevelMax&#34;, 3),
            (&#34;memSavingMethod&#34;, 0),
        ):
            if getattr(C, setting, None) is None:
                setattr(C, setting, default)

        return True

    def importMake(self, c=None):
        client = self.client
        dataset = self.dataset

        if c is None:
            C = self.C
            clientMake = C.clientMake
            clientMakeDir = C.clientMakeDir
            clientMakeFile = C.clientMakeFile
        else:
            clientMake = c[&#34;clientMake&#34;]
            clientMakeDir = c[&#34;clientMakeDir&#34;]
            clientMakeFile = c[&#34;clientMakeFile&#34;]

        try:
            moduleName = f&#34;tf.client.ls.{dataset}.{client}.{clientMake}&#34;
            spec = util.spec_from_file_location(moduleName, clientMakeFile)
            code = util.module_from_spec(spec)
            sys.path.insert(0, clientMakeDir)
            spec.loader.exec_module(code)
            sys.path.pop(0)
            self.makeLegends = types.MethodType(code.makeLegends, self)
            self.record = types.MethodType(code.record, self)

        except Exception as e:
            console(f&#34;Cannot make data for {dataset}:{client}: {str(e)}&#34;)
            return None

    def makeClientSettings(self):
        C = self.C
        layerSettings = C.layerSettings
        A = self.A
        api = A.api
        Cp = api.C

        self.makeLegends()

        typeSeq = list(layerSettings)
        typesLower = {}

        for (i, tp) in enumerate(typeSeq):
            typesLower[tp] = typeSeq[0 : i + 1]

        # set up the configuration that informs the client code
        # and the code that generates the data for the client

        clientConfig = dict(
            memSavingMethod=C.memSavingMethod,
            mainConfig=C.mainConfig,
            defs=dict(
                lsVersion=C.lsVersion,
                dataset=C.dataset,
                client=C.client,
                org=C.org,
                repo=C.repo,
                urls=C.urls,
                description=C.description,
            ),
            ntypes=typeSeq,
            typesLower=typesLower,
            defaultSettings=C.defaultSettings,
            defaultFlags=C.defaultFlags,
            keyboard=getattr(C, &#34;keyboard&#34;, None),
        )

        # check visible- and focus- attributes

        theFocuses = []
        theVisibles = []

        for (nType, typeInfo) in layerSettings.items():
            if typeInfo.get(&#34;focus&#34;, False):
                theFocuses.append(nType)

            for (name, layerInfo) in layerSettings[nType].get(&#34;layers&#34;, {}).items():
                if layerInfo.get(&#34;visible&#34;, False):
                    theVisibles.append((nType, name))
                theMap = layerInfo.get(&#34;legend&#34;, None)
                if theMap is not None and type(theMap) is dict:
                    default = layerInfo.get(&#34;default&#34;, None)
                    if default is not None:
                        theMap[&#34;&#34;] = default

        if len(theFocuses) == 0:
            focusType = None
            console(&#34;No node type is declared as result focus\n&#34;)
        else:
            focusType = theFocuses[0]
            if len(theFocuses) &gt; 1:
                console(&#34;Multiple node types declared as result focus:\n&#34;)
                console(&#34;\t&#34; + (&#34;, &#34;.join(theFocuses)) + &#34;\n&#34;)
            else:
                console(&#34;Node type declared as result focus:\n&#34;)
                console(f&#34;\t{focusType}\n&#34;)

        clientConfig[&#34;focusType&#34;] = focusType

        if len(theVisibles) == 0:
            console(&#34;No layer type is declared as visible in the result (&#39;visible&#39;)\n&#34;)
        else:
            console(&#34;Layers declared as visible in the result (&#39;visible&#39;):\n&#34;)
            console(&#34;\t&#34; + (&#34;, &#34;.join(&#34;/&#34;.join(s) for s in theVisibles)) + &#34;\n&#34;)

        visible = {}
        layers = {}
        levels = {}

        ntypesinitTF = {level[0]: level[2] for level in Cp.levels.data}
        ntypessizeTF = {level[0]: level[3] - level[2] + 1 for level in Cp.levels.data}
        ntypesinit = {}
        ntypessize = {}

        for (level, typeInfo) in layerSettings.items():
            nType = typeInfo.get(&#34;nType&#34;, level)
            ntypesinit[level] = ntypesinitTF[nType]
            ntypessize[level] = ntypessizeTF[nType]
            levels[level] = typeInfo.get(&#34;description&#34;, &#34;&#34;)

            ti = typeInfo.get(&#34;layers&#34;, None)
            if ti is None:
                continue

            visible[level] = {layer: ti[layer].get(&#34;visible&#34;, False) for layer in ti}
            layers[level] = {
                layer: dict(
                    valueMap=invertMap(ti[layer].get(&#34;legend&#34;, None)),
                    tip=ti[layer].get(&#34;tip&#34;, False),
                    pos=ti[layer][&#34;pos&#34;] or layer,
                    pattern=ti[layer].get(&#34;example&#34;, &#34;&#34;),
                    description=ti[layer].get(&#34;description&#34;, &#34;&#34;),
                )
                for layer in ti
            }

        for (k, v) in (
            (&#34;ntypesinit&#34;, ntypesinit),
            (&#34;ntypessize&#34;, ntypessize),
            (&#34;dtypeOf&#34;, {typeSeq[i + 1]: tp for (i, tp) in enumerate(typeSeq[0:-1])}),
            (&#34;utypeOf&#34;, {tp: typeSeq[i + 1] for (i, tp) in enumerate(typeSeq[0:-1])}),
            (&#34;visible&#34;, visible),
            (&#34;levels&#34;, levels),
            (&#34;layers&#34;, layers),
        ):
            clientConfig[k] = v
        self.clientConfig = clientConfig

    def loadTf(self):
        C = self.C
        dataset = C.dataset
        version = C.data[&#34;version&#34;]
        A = use(f&#34;{dataset}:clone&#34;, checkout=&#34;clone&#34;, version=version)
        self.A = A

    def makeConfig(self):
        if not getattr(self, &#34;A&#34;, None):
            self.loadTf()
        if not getattr(self, &#34;clientConfig&#34;, None):
            self.makeClientSettings()
        self.dumpConfig()

    def makeLinks(self):
        C = self.C
        A = self.A
        api = A.api
        T = api.T
        F = api.F

        linkLevelMin = C.linkLevelMin
        linkLevelMax = C.linkLevelMax
        sTypes = T.sectionTypes[linkLevelMin - 1 : linkLevelMax]
        A.info(f&#34;links for types {&#39;, &#39;.join(sTypes)}&#34;)
        links = {
            sType: {n: A.webLink(n, urlOnly=True) for n in F.otype.s(sType)}
            for sType in sTypes
        }
        for (sType, sLinks) in links.items():
            A.info(f&#34;{sType:&lt;20}: {len(sLinks):&gt;6} links&#34;, tm=False)
        A.info(&#34;done&#34;)
        self.links = links

    def makeCorpus(self):
        if not getattr(self, &#34;A&#34;, None):
            self.loadTf()
        if not getattr(self, &#34;clientConfig&#34;, None):
            self.makeClientSettings()
        A = self.A

        A.info(&#34;Make links ...&#34;)
        self.makeLinks()

        A.info(&#34;Recording ...&#34;)
        self.record()

        A.info(&#34;Dumping ...&#34;)
        return self.dumpCorpus()

    def dumpConfig(self):
        C = self.C
        A = self.A
        clientConfig = self.clientConfig

        destData = C.jsCorpusDir
        if not os.path.exists(destData):
            os.makedirs(destData, exist_ok=True)

        fileNameConfig = f&#34;{destData}/config.js&#34;

        with open(fileNameConfig, &#34;w&#34;) as fh:
            fh.write(&#34;const configData = &#34;)
            json.dump(clientConfig, fh, ensure_ascii=False, indent=1)
        A.info(f&#34;Config written to file {fileNameConfig}&#34;)

    def compress(self, data):
        sets = {}

        compressed = []

        for n in sorted(data):
            sets.setdefault(data[n], []).append(n)

        for (value, nset) in sorted(sets.items(), key=lambda x: (x[1][0], x[1][-1])):
            nSpec = (
                list(nset)[0] if len(nset) == 1 else specFromRanges(rangesFromSet(nset))
            )
            compressed.append(f&#34;{nSpec}\t{value}&#34;)

        return compressed

    def dumpCorpus(self):
        C = self.C
        A = self.A
        layerSettings = C.layerSettings
        memSavingMethod = C.memSavingMethod

        up = self.up
        recorders = self.recorders
        accumulators = self.accumulators

        texts = {}
        posinfo = {}

        for (level, typeInfo) in layerSettings.items():
            ti = typeInfo.get(&#34;layers&#34;, None)
            if ti is None:
                continue

            texts[level] = {layer: None for layer in ti}
            posinfo[level] = {layer: None for layer in ti if ti[layer][&#34;pos&#34;] is None}

        A.info(&#34;wrap recorders for delivery&#34;)
        good = True

        for (level, typeInfo) in recorders.items():
            A.info(f&#34;\t{level}&#34;)
            for (layer, x) in typeInfo.items():
                A.info(f&#34;\t\t{layer}&#34;)
                texts[level][layer] = x.text()
                if memSavingMethod == 0:
                    posinfo[level][layer] = x.positions(simple=True)
                elif memSavingMethod == 1:
                    posResult = x.rPositions(acceptMaterialOutsideNodes=True)
                    if type(posResult) is str:
                        A.error(&#34;Memory optimization cannot be applied to this layer&#34;)
                        A.error(&#34;because of violation of the assumptions:&#34;)
                        A.error(posResult)
                        good = False
                    posinfo[level][layer] = posResult

        A.info(&#34;wrap accumulators for delivery&#34;)
        for (level, typeInfo) in accumulators.items():
            A.info(f&#34;\t{level}&#34;)
            for (layer, x) in typeInfo.items():
                A.info(f&#34;\t\t{layer}&#34;)
                texts[level][layer] = &#34;&#34;.join(x)

        data = dict(
            texts=texts,
            posinfo=posinfo,
            up=self.compress(up),
        )
        data[&#34;links&#34;] = self.links

        A.indent(reset=True)
        A.info(&#34;Dumping data to compact json files&#34;)

        destData = C.jsCorpusDir
        if not os.path.exists(destData):
            os.makedirs(destData, exist_ok=True)

        def writeDataFile(name, address, thisData, asString=False):
            path = f&#34;{destData}/{name.lower()}.js&#34;
            heading = f&#34;corpusData[{address}] = &#34;
            with open(path, &#34;w&#34;) as fh:
                fh.write(heading)
                if asString:
                    fh.write(&#34;`&#34;)
                    fh.write(thisData)
                    fh.write(&#34;`&#34;)
                else:
                    json.dump(
                        thisData,
                        fh,
                        ensure_ascii=False,
                        indent=None,
                        separators=(&#34;,&#34;, &#34;:&#34;),
                    )
                A.info(f&#34;Data {name} stored in {path}&#34;)

        init = [&#34;var corpusData = {}\n&#34;]

        for (partName, partData) in data.items():
            if partName in {&#34;texts&#34;, &#34;posinfo&#34;}:
                init.append(f&#39;corpusData[&#34;{partName}&#34;] = {{}}\n&#39;)
                for (nType, tpData) in partData.items():
                    init.append(f&#39;corpusData[&#34;{partName}&#34;][&#34;{nType}&#34;] = {{}}\n&#39;)
                    for (layer, lrData) in tpData.items():
                        writeDataFile(
                            f&#34;{partName}-{nType}-{layer}&#34;,
                            f&#39;&#34;{partName}&#34;][&#34;{nType}&#34;][&#34;{layer}&#34;&#39;,
                            lrData,
                        )
            else:
                writeDataFile(partName, f&#39;&#34;{partName}&#34;&#39;, partData)
        with open(C.jsInit, &#34;w&#34;) as fh:
            fh.write(&#34;&#34;.join(init))

        return good

    def makeCombined(self):
        C = self.C

        commentRe = re.compile(r&#34;&#34;&#34;[ \t]*/\*.*?\*/[ \t]*&#34;&#34;&#34;, re.S)
        importRe = re.compile(r&#39;&#39;&#39;import\s+\{.*?\}\s+from\s+&#34;[^&#34;]*\.js&#34;&#39;&#39;&#39;, re.S)
        exportRe = re.compile(r&#34;&#34;&#34;^export[ ]+&#34;&#34;&#34;, re.M)
        whiteRe = re.compile(r&#34;&#34;&#34;^\s+$&#34;&#34;&#34;, re.M)
        nlRe = re.compile(r&#34;&#34;&#34;\n\n+&#34;&#34;&#34;)

        def getModule(module):
            with open(f&#34;{C.jsOutDir}/{module}&#34;) as fh:
                text = fh.read()
            text = importRe.sub(&#34;&#34;, text)
            text = exportRe.sub(&#34;&#34;, text)
            text = commentRe.sub(&#34;&#34;, text)
            text = whiteRe.sub(&#34;&#34;, text)
            text = nlRe.sub(&#34;\n&#34;, text)
            return text

        modules = []

        with os.scandir(C.jsOutDir) as it:
            for entry in it:
                name = entry.name
                if (
                    not entry.is_file()
                    or name.startswith(&#34;.&#34;)
                    or not name.endswith(&#34;.js&#34;)
                ):
                    continue
                modules.append(entry.name)
        console(&#34;, &#34;.join(module[0:-3] for module in modules))

        content = {module: getModule(module) for module in modules}

        header = &#34;&#34;&#34;\
/*eslint-env jquery*/
/* global configData */
/* global corpusData */

    &#34;&#34;&#34;
        combined = (
            header
            + content[C.jsDefs]
            + &#34;\n\n&#34;
            + &#34;\n\n&#34;.join(
                text
                for (name, text) in content.items()
                if name not in {C.jsDefs, C.jsApp}
            )
            + &#34;\n\n&#34;
            + content[C.jsApp]
        )
        with open(C.jsAllPath, &#34;w&#34;) as fh:
            fh.write(combined)
        console(f&#34;Combined js file written to {C.jsAllPath}&#34;)

    def makeHtml(self):
        C = self.C
        lsVersion = C.lsVersion

        # index of all clients

        clients = {}

        for thisClient in self.getAllClients():
            thisConfig = f&#34;{C.configDir}/{thisClient}/config.yaml&#34;
            if os.path.exists(thisConfig):
                with open(thisConfig) as fh:
                    desc = yaml.load(fh, Loader=yaml.FullLoader).get(&#34;short&#34;, &#34;&#34;)
            else:
                desc = &#34;&#34;
            clients[thisClient] = desc

        with open(C.index) as fh:
            template = fh.read()
            htmlIndex = template.replace(&#34;«dataset»&#34;, C.dataset)
            htmlIndex = htmlIndex.replace(&#34;«client»&#34;, C.client)

            html = []
            for (thisClient, desc) in clients.items():
                html.append(
                    f&#34;&#34;&#34;
&lt;dt&gt;&lt;a href=&#34;{thisClient}/index.html&#34;&gt;{thisClient}&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;{desc}&lt;/dd&gt;
&#34;&#34;&#34;
                )

            htmlIndex = htmlIndex.replace(&#34;«clients»&#34;, &#34;&#34;.join(html))

        with open(C.htmlIndex, &#34;w&#34;) as fh:
            fh.write(htmlIndex)
        console(f&#34;html file written to {C.htmlIndex}&#34;)

        # client and client-local

        with os.scandir(C.jsCorpusDir) as it:
            scripts = []
            for entry in it:
                file = entry.name
                if not file.endswith(&#34;.js&#34;):
                    continue
                if file.startswith(&#34;texts-&#34;) or file.startswith(&#34;posinfo-&#34;):
                    scripts.append(f&#39;&lt;script defer src=&#34;corpus/{file}«v»&#34;&gt;&lt;/script&gt;&#39;)
            corpusScripts = &#34;\n&#34;.join(scripts)

        with open(C.template) as fh:
            template = fh.read()
            htmlNormal = template.replace(
                &#34;«js»&#34;, &#39;&#39;&#39;type=&#34;module&#34; src=&#34;js/app.js«v»&#34;&#39;&#39;&#39;
            )
            htmlNormal = htmlNormal.replace(&#34;«corpus»&#34;, corpusScripts)
            htmlNormal = htmlNormal.replace(&#34;«v»&#34;, f&#34;?v={lsVersion}&#34;)
            htmlNormal = htmlNormal.replace(&#34;«dataset»&#34;, C.dataset)
            htmlNormal = htmlNormal.replace(&#34;«client»&#34;, C.client)
            htmlLocal = template.replace(&#34;«js»&#34;, f&#39;&#39;&#39;defer src=&#34;{C.jsAll}&#34;&#39;&#39;&#39;)
            htmlLocal = htmlLocal.replace(&#34;«corpus»&#34;, corpusScripts)
            htmlLocal = htmlLocal.replace(&#34;«v»&#34;, &#34;&#34;)
            htmlLocal = htmlLocal.replace(&#34;«dataset»&#34;, C.dataset)
            htmlLocal = htmlLocal.replace(&#34;«client»&#34;, C.client)

        with open(C.htmlClient, &#34;w&#34;) as fh:
            fh.write(htmlNormal)
        console(f&#34;html file written to {C.htmlClient}&#34;)

        with open(C.htmlLocal, &#34;w&#34;) as fh:
            fh.write(htmlLocal)
        console(f&#34;html file (for use with file://) written to {C.htmlLocal}&#34;)

    def makeClient(self):
        &#34;&#34;&#34;
        We create a client app in the target directory.

        The client consists of HTML/CSS/PNG files plus a modular Javascript program.

        Module loading does not work when you open the HTML file locally
        (i.e. when the HTML is not served by a server).

        N.B. There is a difference between a local web server serving at `localhost`
        and opening the file directly into your browser by double clicking on it.

        In the first case, you see in your un the URL bar of your browser
        something that starts with
        `http://` or `https://`, in the second case you see `file://` instead.

        Modular Javascript does not work with `file://` origins.

        For that case, we bundle the modules into one,
        and let a «client»-local.html include it

        We also zip the client into {C.client}.zip so that users can download it easily

        However, if the debugState is on, we skip all steps that are unneccesary
        to see the updated client working.
        &#34;&#34;&#34;

        # copy over the static files

        C = self.C
        debug = self.debugState == &#34;on&#34;

        for (srcDir, dstDir) in (
            (C.pngInDir, C.pngOutDir),
            (C.cssInDir, C.cssOutDir),
            (C.jsInDir, C.jsOutDir),
            (C.jslibInDir, C.jslibOutDir),
            (C.htmlInDir, C.htmlOutDir),
        ):
            if not os.path.exists(dstDir):
                os.makedirs(dstDir, exist_ok=True)

            with os.scandir(srcDir) as it:
                for entry in it:
                    name = entry.name
                    if not entry.is_file() or name.startswith(&#34;.&#34;):
                        continue
                    srcFile = f&#34;{srcDir}/{name}&#34;
                    if srcFile != C.template:
                        copy(srcFile, f&#34;{dstDir}/{name}&#34;)
        copy(f&#34;{C.staticDir}/{C.favicon}&#34;, f&#34;{C.siteDir}/{C.favicon}&#34;)

        # move the custom files in place

        for (srcFile, dstFile) in (
            (C.clientCss, f&#34;{C.cssOutDir}/{C.client}.css&#34;),
            (C.clientLogo, f&#34;{C.pngOutDir}/{C.client}.png&#34;),
        ):
            copy(srcFile, dstFile)

        console(&#34;Copied static files&#34;)

        # create combined javascript file

        if not debug:
            self.makeCombined()

        self.makeHtml()

        if not debug:
            self.zipApp()

    def zipApp(self):
        C = self.C
        items = set(
            &#34;&#34;&#34;
            css
            corpus
            jslib
            png
            favicon.ico
        &#34;&#34;&#34;.strip().split()
        )
        items.add(C.htmlLocalFile)
        items.add(C.jsAll)

        zipped = f&#34;{C.siteDir}/{C.client}.zip&#34;

        with ZipFile(zipped, &#34;w&#34;, **ZIP_OPTIONS) as zipFile:
            with os.scandir(C.appClientDir) as it:
                for entry in it:
                    file = entry.name
                    if file not in items:
                        continue
                    if entry.is_file():
                        zipFile.write(f&#34;{C.appClientDir}/{file}&#34;, arcname=file)
                        console(f&#34;adding {file}&#34;)
                    else:
                        with os.scandir(f&#34;{C.appClientDir}/{file}&#34;) as sit:
                            for sentry in sit:
                                sfile = sentry.name
                                if sentry.is_file and not sfile.startswith(&#34;.&#34;):
                                    sfile = f&#34;{file}/{sfile}&#34;
                                    zipFile.write(
                                        f&#34;{C.appClientDir}/{sfile}&#34;, arcname=sfile
                                    )
                                    console(f&#34;adding {sfile}&#34;)
        console(f&#34;Packaged client into {zipped}&#34;)

    def publish(self, allClients=True):
        C = self.C
        appDir = C.appDir
        siteDir = C.siteDir
        dataset = self.dataset
        client = self.client
        clients = self.getAllClients() if allClients or client is None else [client]
        console(f&#34;Publishing {dataset}:{&#39;,&#39;.join(clients)} from {siteDir} ...&#34;)
        os.chdir(appDir)
        deploy(C.org, C.repo)

    def ship(self, publish=True):
        self.adjustVersion()
        self.makeConfig()
        good = self.makeCorpus()
        if good:
            self.makeClient()
            self.adjustDebug()
            if publish:
                self.publish()

    def make(self):
        self.makeConfig()
        good = self.makeCorpus()
        if good:
            self.makeClient()
            self.adjustDebug()

    def serve(self):
        C = self.C
        os.chdir(C.siteDir)

        console(f&#34;HTTP serving files in {C.siteDir}&#34;)
        server = Popen(
            [&#34;python3&#34;, &#34;-m&#34;, &#34;http.server&#34;], stdout=PIPE, bufsize=1, encoding=&#34;utf-8&#34;
        )
        sleep(1)
        webbrowser.open(&#34;http://localhost:8000/index.html&#34;, new=2, autoraise=True)
        stopped = server.poll()
        if not stopped:
            try:
                console(&#34;Press &lt;Ctrl+C&gt; to stop the HTTP server&#34;)
                if server:
                    for line in server.stdout:
                        console(line)
            except KeyboardInterrupt:
                console(&#34;&#34;)
                if server:
                    server.terminate()
                    console(&#34;Http server has stopped&#34;)

    def incVersion(self):
        C = self.C
        lsVersion = C.lsVersion
        parts = lsVersion.split(&#34;@&#34;, 1)
        v = int(parts[0].lstrip(&#34;v&#34;).lstrip(&#34;0&#34;), base=10)
        now = dt.utcnow().isoformat(timespec=&#34;seconds&#34;)
        self.lsVersion = f&#34;v{v + 1:&gt;03}@{now}&#34;
        C.lsVersion = self.lsVersion

    def showVersion(self):
        C = self.C
        lsVersion = C.lsVersion
        versionFile = self.versionFile
        console(f&#34;{lsVersion} (according to {versionFile})&#34;)

    def adjustVersion(self):
        C = self.C
        versionFile = self.versionFile

        currentVersion = C.lsVersion
        self.incVersion()
        newVersion = C.lsVersion

        with open(versionFile, &#34;w&#34;) as fh:
            yaml.dump(dict(lsVersion=newVersion), fh)

        console(f&#34;Version went from `{currentVersion}` to `{newVersion}`&#34;)

    def replaceDebug(self, mask, value):
        def subVersion(match):
            return mask.format(value)

        return subVersion

    def getDebugs(self):
        C = self.C

        debugs = {}
        good = True

        for (key, c) in C.debugConfig.items():
            cfile = c[&#34;file&#34;]
            with open(cfile) as fh:
                text = fh.read()
            match = c[&#34;re&#34;].search(text)
            if not match:
                console(f&#34;No debug found in {cfile}&#34;)
                good = False
                continue
            debug = match.group(1)
            debugs[cfile] = debug

        if not good:
            return False
        return debugs

    def showDebug(self):
        debugInfo = self.getDebugs()
        if debugInfo is None:
            return False
        return True

        for (source, debug) in debugInfo.items():
            console(f&#34;{debug} (according to {source})&#34;)

    def adjustDebug(self):
        C = self.C
        debugState = self.debugState

        if not self.showDebug():
            return

        newValue = &#34;true&#34; if debugState == &#34;on&#34; else &#34;false&#34;

        for (key, c) in C.debugConfig.items():
            console(f&#39;Adjusting debug in {c[&#34;file&#34;]}&#39;)
            with open(c[&#34;file&#34;]) as fh:
                text = fh.read()
            text = c[&#34;re&#34;].sub(self.replaceDebug(c[&#34;mask&#34;], newValue), text)
            with open(c[&#34;file&#34;], &#34;w&#34;) as fh:
                fh.write(text)

        console(f&#34;Debug set to {newValue}&#34;)
        if not self.showDebug():
            return

    def getAllClients(self):
        C = self.C
        configDir = C.configDir

        clients = []

        with os.scandir(configDir) as it:
            for entry in it:
                client = entry.name
                if not entry.is_dir() or client.startswith(&#34;.&#34;):
                    continue
                clients.append(client)
        return clients</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tf.client.make.build.Make.adjustDebug"><code class="name flex">
<span>def <span class="ident">adjustDebug</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L1178-L1197" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def adjustDebug(self):
    C = self.C
    debugState = self.debugState

    if not self.showDebug():
        return

    newValue = &#34;true&#34; if debugState == &#34;on&#34; else &#34;false&#34;

    for (key, c) in C.debugConfig.items():
        console(f&#39;Adjusting debug in {c[&#34;file&#34;]}&#39;)
        with open(c[&#34;file&#34;]) as fh:
            text = fh.read()
        text = c[&#34;re&#34;].sub(self.replaceDebug(c[&#34;mask&#34;], newValue), text)
        with open(c[&#34;file&#34;], &#34;w&#34;) as fh:
            fh.write(text)

    console(f&#34;Debug set to {newValue}&#34;)
    if not self.showDebug():
        return</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.adjustVersion"><code class="name flex">
<span>def <span class="ident">adjustVersion</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L1128-L1139" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def adjustVersion(self):
    C = self.C
    versionFile = self.versionFile

    currentVersion = C.lsVersion
    self.incVersion()
    newVersion = C.lsVersion

    with open(versionFile, &#34;w&#34;) as fh:
        yaml.dump(dict(lsVersion=newVersion), fh)

    console(f&#34;Version went from `{currentVersion}` to `{newVersion}`&#34;)</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.compress"><code class="name flex">
<span>def <span class="ident">compress</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L708-L722" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def compress(self, data):
    sets = {}

    compressed = []

    for n in sorted(data):
        sets.setdefault(data[n], []).append(n)

    for (value, nset) in sorted(sets.items(), key=lambda x: (x[1][0], x[1][-1])):
        nSpec = (
            list(nset)[0] if len(nset) == 1 else specFromRanges(rangesFromSet(nset))
        )
        compressed.append(f&#34;{nSpec}\t{value}&#34;)

    return compressed</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.config"><code class="name flex">
<span>def <span class="ident">config</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L233-L494" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def config(self):
    C = self.C
    dataset = self.dataset
    client = self.client
    folder = self.folder
    appFolder = self.appFolder
    versionFile = f&#34;{STATIC_DIR}/version.yaml&#34;
    self.versionFile = versionFile

    with open(versionFile) as fh:
        settings = yaml.load(fh, Loader=yaml.FullLoader)
        lsVersion = settings[&#34;lsVersion&#34;]

    with open(CONFIG_FILE) as fh:
        mainConfig = yaml.load(fh, Loader=yaml.FullLoader)

    c = dict(
        dataset=dataset,
        client=client,
        lsVersion=lsVersion,
        mainConfig=mainConfig,
        gh=os.path.expanduser(&#34;~/github&#34;),
        ghUrl=&#34;https://github.com&#34;,
        nbUrl=&#34;https://nbviewer.jupyter.org/github&#34;,
        ghPages=&#34;github.io&#34;,
        nbTutUrl=&#34;«nbUrl»/annotation/tutorials/tree/master&#34;,
        lsDocUrl=f&#34;https://«org».«ghPages»/{T_F}/tf/about/clientmanual.html&#34;,
        lsDocSimpleUrl=f&#34;https://«org».«ghPages»/{T_F}/tf/about/manual.html&#34;,
        org=&#34;annotation&#34;,
        repo=&#34;app-«dataset»&#34;,
        rel=&#34;site&#34;,
        generatorUrl=f&#34;https://«org».«ghPages»/{T_F}/tf/client/make/build.html&#34;,
        sourceUrl=&#34;«ghUrl»/«org»/«repo»/tree/master/layeredsearch&#34;,
        issueUrl=&#34;«ghUrl»/«org»/«repo»/issues&#34;,
        tutUrl=&#34;«nbTutUrl»/«dataset»/start.ipynb&#34;,
        staticDir=STATIC_DIR,
        appDir=&#34;«gh»/«org»/«repo»&#34;,
        configDir=f&#34;«appDir»/{LS}&#34; if appFolder is None else f&#34;{appFolder}/{LS}&#34;,
        lsConfig=&#34;«configDir»/config.yaml&#34;,
        clientConfigFile=&#34;«configDir»/«client»/config.yaml&#34;,
        clientMake=&#34;mkdata&#34;,
        clientMakeDir=&#34;«configDir»/«client»&#34;,
        clientMakeFile=&#34;«clientMakeDir»/«clientMake».py&#34;,
        clientCss=&#34;«configDir»/«client»/custom.css&#34;,
        clientLogo=&#34;«configDir»/«client»/logo.png&#34;,
        pngInDir=&#34;«staticDir»/png&#34;,
        cssInDir=&#34;«staticDir»/css&#34;,
        htmlInDir=&#34;«staticDir»/html&#34;,
        jsInDir=&#34;«staticDir»/js&#34;,
        jslibInDir=&#34;«staticDir»/jslib&#34;,
        template=&#34;«htmlInDir»/template.html&#34;,
        index=&#34;«htmlInDir»/index.html&#34;,
        siteDir=&#34;«appDir»/«rel»&#34; if folder is None else folder,
        appClientDir=&#34;«siteDir»/«client»&#34;,
        pngOutDir=&#34;«appClientDir»/png&#34;,
        cssOutDir=&#34;«appClientDir»/css&#34;,
        htmlOutDir=&#34;«siteDir»&#34;,
        jsOutDir=&#34;«appClientDir»/js&#34;,
        jslibOutDir=&#34;«appClientDir»/jslib&#34;,
        jsCorpusDir=&#34;«appClientDir»/corpus&#34;,
        jsInit=&#34;«jsCorpusDir»/init.js&#34;,
        jsApp=&#34;app.js&#34;,
        jsDefs=&#34;defs.js&#34;,
        jsAll=&#34;all.js&#34;,
        jsAllPath=&#34;«appClientDir»/«jsAll»&#34;,
        htmlIndex=&#34;«siteDir»/index.html&#34;,
        htmlClient=&#34;«appClientDir»/index.html&#34;,
        htmlLocalFile=&#34;index-local.html&#34;,
        htmlLocal=&#34;«appClientDir»/«htmlLocalFile»&#34;,
        favicon=&#34;favicon.ico&#34;,
        packageUrl=&#34;../«client».zip&#34;,
    )

    fillRe = re.compile(r&#34;«([a-zA-Z0-9_.]+)»&#34;)

    def fillSub(match):
        k = match.group(1)
        parts = k.split(&#34;.&#34;, 1)
        return (
            c.get(parts[0], {}).get(parts[1], &#34;&#34;)
            if len(parts) == 2
            else c.get(parts[0], &#34;&#34;)
        )

    def fillin(src, k, v):
        if type(v) is str:
            while fillRe.search(v):
                v = fillRe.sub(fillSub, v)
            src[k] = v
        if type(v) is dict:
            for (m, w) in v.items():
                fillin(src[k], m, w)
        if type(v) in {list, tuple}:
            if type(v) is tuple:
                src[k] = list(v)
            for (m, w) in enumerate(v):
                fillin(src[k], m, w)

    for (k, v) in c.items():
        fillin(c, k, v)

    lsConfig = c[&#34;lsConfig&#34;]
    if not os.path.exists(lsConfig):
        console(f&#34;No config.yaml found for {dataset}: {lsConfig}&#34;)
        return None

    with open(lsConfig) as fh:
        settings = yaml.load(fh, Loader=yaml.FullLoader)
        for (k, v) in settings.items():
            c[k] = v
            fillin(c, k, v)

    if client is not None:
        clientConfigFile = c[&#34;clientConfigFile&#34;]
        if not os.path.exists(clientConfigFile):
            console(
                f&#34;No config.yaml found for {dataset}:{client}: {clientConfigFile}&#34;
            )
            return None

        with open(clientConfigFile) as fh:
            settings = yaml.load(fh, Loader=yaml.FullLoader)
            for (k, v) in settings.items():
                c[k] = v
                fillin(c, k, v)

        self.importMake(c=c)

        d = dict(
            dataLocation=&#34;«gh»/«data.org»/«data.repo»/«data.rel»&#34;,
            dataUrl=&#34;«ghUrl»/«data.org»/«data.repo»/tree/master/«data.rel»/«data.version»&#34;,
            writingUrl=&#34;https://«org».«ghPages»/text-fabric/tf/writing/«writing».html&#34;,
            urls=dict(
                cheatsheet=(
                    &#34;regexp cheatsheet&#34;,
                    (
                        &#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/&#34;
                        &#34;Regular_Expressions/Cheatsheet&#34;
                    ),
                    &#34;cheatsheet of regular expressions&#34;,
                ),
                license=(
                    &#34;MIT&#34;,
                    &#34;https://mit-license.org&#34;,
                    &#34;website of MIT license&#34;,
                ),
                maker=(
                    None,
                    &#34;https://dans.knaw.nl/en/front-page?set_language=en&#34;,
                    &#34;Website of DANS = Data Archiving and Networked Services&#34;,
                ),
                corpus=(
                    None,
                    &#34;«corpus.url»&#34;,
                    &#34;«corpus.tip»&#34;,
                ),
                corpus2=(
                    &#34;«corpus.text»&#34;,
                    &#34;«corpus.url»&#34;,
                    &#34;«corpus.tip»&#34;,
                ),
                author=(
                    &#34;Dirk Roorda&#34;,
                    &#34;https://pure.knaw.nl/portal/en/persons/dirk-roorda&#34;,
                    &#34;profile of the author&#34;,
                ),
                author1=(
                    &#34;«author1.text»&#34;,
                    &#34;«author1.url»&#34;,
                    &#34;«author1.tip»&#34;,
                ),
                author2=(
                    &#34;«author2.text»&#34;,
                    &#34;«author2.url»&#34;,
                    &#34;«author2.tip»&#34;,
                ),
                tf=(
                    None,
                    &#34;https://«org».«ghPages»/text-fabric/tf/&#34;,
                    &#34;Text-Fabric documentation website&#34;,
                ),
                lsdoc=(
                    &#34;user manual (full)&#34;,
                    &#34;«lsDocUrl»&#34;,
                    &#34;user manual for the full search interface&#34;,
                ),
                lsdocsimple=(
                    &#34;user manual (simple)&#34;,
                    &#34;«lsDocSimpleUrl»&#34;,
                    &#34;user manual for the simplified search interface&#34;,
                ),
                datadoc=(
                    &#34;data (feature) documentation&#34;,
                    &#34;«data.docUrl»&#34;,
                    &#34;explanation of the features in the dataset&#34;,
                ),
                data=(
                    &#34;based on text-fabric data version «data.version»&#34;,
                    &#34;«dataUrl»&#34;,
                    &#34;online repository of the underlying text-fabric data&#34;,
                ),
                generator=(
                    f&#34;{T_F}/client&#34;,
                    &#34;«generatorUrl»&#34;,
                    &#34;the generator of this search interface&#34;,
                ),
                source=(
                    &#34;«repo»&#34;,
                    &#34;«sourceUrl»&#34;,
                    &#34;source code of the definition of this search interface&#34;,
                ),
                issue=(
                    &#34;Report an issue&#34;,
                    &#34;«issueUrl»&#34;,
                    &#34;report issues&#34;,
                ),
                package=(
                    &#34;download&#34;,
                    &#34;«packageUrl»&#34;,
                    &#34;zip file for offline use&#34;,
                ),
                writing=(
                    &#34;«writing»&#34;,
                    &#34;«writingUrl»&#34;,
                    &#34;characters and transliteration for «writing»&#34;,
                ),
                related=(
                    &#34;text-fabric «dataset»&#34;,
                    &#34;«tutUrl»&#34;,
                    &#34;using Text-Fabric on the same corpus&#34;,
                ),
            ),
        )

        for (k, v) in d.items():
            c[k] = v
            fillin(c, k, v)

        setattr(
            C,
            &#34;debugConfig&#34;,
            dict(
                setup=dict(
                    file=f&#34;{c[&#39;jsOutDir&#39;]}/{c[&#39;jsDefs&#39;]}&#34;,
                    re=re.compile(r&#34;&#34;&#34;export const DEBUG = ([a-z]+)&#34;&#34;&#34;),
                    mask=&#34;export const DEBUG = {}&#34;,
                ),
            ),
        )

    for (k, v) in c.items():
        setattr(C, k, v)

    for (setting, default) in (
        (&#34;linkLevelMin&#34;, 1),
        (&#34;linkLevelMax&#34;, 3),
        (&#34;memSavingMethod&#34;, 0),
    ):
        if getattr(C, setting, None) is None:
            setattr(C, setting, default)

    return True</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.doCommand"><code class="name flex">
<span>def <span class="ident">doCommand</span></span>(<span>self, command)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L207-L231" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def doCommand(self, command):
    if command == &#34;serve&#34;:
        self.serve()
    elif command == &#34;v&#34;:
        self.showVersion()
    elif command == &#34;i&#34;:
        self.adjustVersion()
    elif command == &#34;debug&#34;:
        self.adjustDebug()
    elif command == &#34;config&#34;:
        self.makeConfig()
    elif command == &#34;corpus&#34;:
        self.makeCorpus()
    elif command == &#34;client&#34;:
        self.makeClient()
    elif command == &#34;clientdebug&#34;:
        self.debugState = &#34;on&#34;
        self.makeClient()
        self.adjustDebug()
    elif command == &#34;publish&#34;:
        self.publish()
    elif command == &#34;ship&#34;:
        self.ship()
    elif command == &#34;make&#34;:
        self.make()</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.dumpConfig"><code class="name flex">
<span>def <span class="ident">dumpConfig</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L692-L706" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dumpConfig(self):
    C = self.C
    A = self.A
    clientConfig = self.clientConfig

    destData = C.jsCorpusDir
    if not os.path.exists(destData):
        os.makedirs(destData, exist_ok=True)

    fileNameConfig = f&#34;{destData}/config.js&#34;

    with open(fileNameConfig, &#34;w&#34;) as fh:
        fh.write(&#34;const configData = &#34;)
        json.dump(clientConfig, fh, ensure_ascii=False, indent=1)
    A.info(f&#34;Config written to file {fileNameConfig}&#34;)</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.dumpCorpus"><code class="name flex">
<span>def <span class="ident">dumpCorpus</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L724-L822" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dumpCorpus(self):
    C = self.C
    A = self.A
    layerSettings = C.layerSettings
    memSavingMethod = C.memSavingMethod

    up = self.up
    recorders = self.recorders
    accumulators = self.accumulators

    texts = {}
    posinfo = {}

    for (level, typeInfo) in layerSettings.items():
        ti = typeInfo.get(&#34;layers&#34;, None)
        if ti is None:
            continue

        texts[level] = {layer: None for layer in ti}
        posinfo[level] = {layer: None for layer in ti if ti[layer][&#34;pos&#34;] is None}

    A.info(&#34;wrap recorders for delivery&#34;)
    good = True

    for (level, typeInfo) in recorders.items():
        A.info(f&#34;\t{level}&#34;)
        for (layer, x) in typeInfo.items():
            A.info(f&#34;\t\t{layer}&#34;)
            texts[level][layer] = x.text()
            if memSavingMethod == 0:
                posinfo[level][layer] = x.positions(simple=True)
            elif memSavingMethod == 1:
                posResult = x.rPositions(acceptMaterialOutsideNodes=True)
                if type(posResult) is str:
                    A.error(&#34;Memory optimization cannot be applied to this layer&#34;)
                    A.error(&#34;because of violation of the assumptions:&#34;)
                    A.error(posResult)
                    good = False
                posinfo[level][layer] = posResult

    A.info(&#34;wrap accumulators for delivery&#34;)
    for (level, typeInfo) in accumulators.items():
        A.info(f&#34;\t{level}&#34;)
        for (layer, x) in typeInfo.items():
            A.info(f&#34;\t\t{layer}&#34;)
            texts[level][layer] = &#34;&#34;.join(x)

    data = dict(
        texts=texts,
        posinfo=posinfo,
        up=self.compress(up),
    )
    data[&#34;links&#34;] = self.links

    A.indent(reset=True)
    A.info(&#34;Dumping data to compact json files&#34;)

    destData = C.jsCorpusDir
    if not os.path.exists(destData):
        os.makedirs(destData, exist_ok=True)

    def writeDataFile(name, address, thisData, asString=False):
        path = f&#34;{destData}/{name.lower()}.js&#34;
        heading = f&#34;corpusData[{address}] = &#34;
        with open(path, &#34;w&#34;) as fh:
            fh.write(heading)
            if asString:
                fh.write(&#34;`&#34;)
                fh.write(thisData)
                fh.write(&#34;`&#34;)
            else:
                json.dump(
                    thisData,
                    fh,
                    ensure_ascii=False,
                    indent=None,
                    separators=(&#34;,&#34;, &#34;:&#34;),
                )
            A.info(f&#34;Data {name} stored in {path}&#34;)

    init = [&#34;var corpusData = {}\n&#34;]

    for (partName, partData) in data.items():
        if partName in {&#34;texts&#34;, &#34;posinfo&#34;}:
            init.append(f&#39;corpusData[&#34;{partName}&#34;] = {{}}\n&#39;)
            for (nType, tpData) in partData.items():
                init.append(f&#39;corpusData[&#34;{partName}&#34;][&#34;{nType}&#34;] = {{}}\n&#39;)
                for (layer, lrData) in tpData.items():
                    writeDataFile(
                        f&#34;{partName}-{nType}-{layer}&#34;,
                        f&#39;&#34;{partName}&#34;][&#34;{nType}&#34;][&#34;{layer}&#34;&#39;,
                        lrData,
                    )
        else:
            writeDataFile(partName, f&#39;&#34;{partName}&#34;&#39;, partData)
    with open(C.jsInit, &#34;w&#34;) as fh:
        fh.write(&#34;&#34;.join(init))

    return good</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.getAllClients"><code class="name flex">
<span>def <span class="ident">getAllClients</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L1199-L1211" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getAllClients(self):
    C = self.C
    configDir = C.configDir

    clients = []

    with os.scandir(configDir) as it:
        for entry in it:
            client = entry.name
            if not entry.is_dir() or client.startswith(&#34;.&#34;):
                continue
            clients.append(client)
    return clients</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.getDebugs"><code class="name flex">
<span>def <span class="ident">getDebugs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L1147-L1167" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getDebugs(self):
    C = self.C

    debugs = {}
    good = True

    for (key, c) in C.debugConfig.items():
        cfile = c[&#34;file&#34;]
        with open(cfile) as fh:
            text = fh.read()
        match = c[&#34;re&#34;].search(text)
        if not match:
            console(f&#34;No debug found in {cfile}&#34;)
            good = False
            continue
        debug = match.group(1)
        debugs[cfile] = debug

    if not good:
        return False
    return debugs</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.importMake"><code class="name flex">
<span>def <span class="ident">importMake</span></span>(<span>self, c=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L496-L522" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def importMake(self, c=None):
    client = self.client
    dataset = self.dataset

    if c is None:
        C = self.C
        clientMake = C.clientMake
        clientMakeDir = C.clientMakeDir
        clientMakeFile = C.clientMakeFile
    else:
        clientMake = c[&#34;clientMake&#34;]
        clientMakeDir = c[&#34;clientMakeDir&#34;]
        clientMakeFile = c[&#34;clientMakeFile&#34;]

    try:
        moduleName = f&#34;tf.client.ls.{dataset}.{client}.{clientMake}&#34;
        spec = util.spec_from_file_location(moduleName, clientMakeFile)
        code = util.module_from_spec(spec)
        sys.path.insert(0, clientMakeDir)
        spec.loader.exec_module(code)
        sys.path.pop(0)
        self.makeLegends = types.MethodType(code.makeLegends, self)
        self.record = types.MethodType(code.record, self)

    except Exception as e:
        console(f&#34;Cannot make data for {dataset}:{client}: {str(e)}&#34;)
        return None</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.incVersion"><code class="name flex">
<span>def <span class="ident">incVersion</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L1113-L1120" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def incVersion(self):
    C = self.C
    lsVersion = C.lsVersion
    parts = lsVersion.split(&#34;@&#34;, 1)
    v = int(parts[0].lstrip(&#34;v&#34;).lstrip(&#34;0&#34;), base=10)
    now = dt.utcnow().isoformat(timespec=&#34;seconds&#34;)
    self.lsVersion = f&#34;v{v + 1:&gt;03}@{now}&#34;
    C.lsVersion = self.lsVersion</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.loadTf"><code class="name flex">
<span>def <span class="ident">loadTf</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L642-L647" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def loadTf(self):
    C = self.C
    dataset = C.dataset
    version = C.data[&#34;version&#34;]
    A = use(f&#34;{dataset}:clone&#34;, checkout=&#34;clone&#34;, version=version)
    self.A = A</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.make"><code class="name flex">
<span>def <span class="ident">make</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L1083-L1088" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def make(self):
    self.makeConfig()
    good = self.makeCorpus()
    if good:
        self.makeClient()
        self.adjustDebug()</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.makeClient"><code class="name flex">
<span>def <span class="ident">makeClient</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>We create a client app in the target directory.</p>
<p>The client consists of HTML/CSS/PNG files plus a modular Javascript program.</p>
<p>Module loading does not work when you open the HTML file locally
(i.e. when the HTML is not served by a server).</p>
<p>N.B. There is a difference between a local web server serving at <code>localhost</code>
and opening the file directly into your browser by double clicking on it.</p>
<p>In the first case, you see in your un the URL bar of your browser
something that starts with
<code>http://</code> or <code>https://</code>, in the second case you see <code>file://</code> instead.</p>
<p>Modular Javascript does not work with <code>file://</code> origins.</p>
<p>For that case, we bundle the modules into one,
and let a «client»-local.html include it</p>
<p>We also zip the client into {C.client}.zip so that users can download it easily</p>
<p>However, if the debugState is on, we skip all steps that are unneccesary
to see the updated client working.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L953-L1023" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeClient(self):
    &#34;&#34;&#34;
    We create a client app in the target directory.

    The client consists of HTML/CSS/PNG files plus a modular Javascript program.

    Module loading does not work when you open the HTML file locally
    (i.e. when the HTML is not served by a server).

    N.B. There is a difference between a local web server serving at `localhost`
    and opening the file directly into your browser by double clicking on it.

    In the first case, you see in your un the URL bar of your browser
    something that starts with
    `http://` or `https://`, in the second case you see `file://` instead.

    Modular Javascript does not work with `file://` origins.

    For that case, we bundle the modules into one,
    and let a «client»-local.html include it

    We also zip the client into {C.client}.zip so that users can download it easily

    However, if the debugState is on, we skip all steps that are unneccesary
    to see the updated client working.
    &#34;&#34;&#34;

    # copy over the static files

    C = self.C
    debug = self.debugState == &#34;on&#34;

    for (srcDir, dstDir) in (
        (C.pngInDir, C.pngOutDir),
        (C.cssInDir, C.cssOutDir),
        (C.jsInDir, C.jsOutDir),
        (C.jslibInDir, C.jslibOutDir),
        (C.htmlInDir, C.htmlOutDir),
    ):
        if not os.path.exists(dstDir):
            os.makedirs(dstDir, exist_ok=True)

        with os.scandir(srcDir) as it:
            for entry in it:
                name = entry.name
                if not entry.is_file() or name.startswith(&#34;.&#34;):
                    continue
                srcFile = f&#34;{srcDir}/{name}&#34;
                if srcFile != C.template:
                    copy(srcFile, f&#34;{dstDir}/{name}&#34;)
    copy(f&#34;{C.staticDir}/{C.favicon}&#34;, f&#34;{C.siteDir}/{C.favicon}&#34;)

    # move the custom files in place

    for (srcFile, dstFile) in (
        (C.clientCss, f&#34;{C.cssOutDir}/{C.client}.css&#34;),
        (C.clientLogo, f&#34;{C.pngOutDir}/{C.client}.png&#34;),
    ):
        copy(srcFile, dstFile)

    console(&#34;Copied static files&#34;)

    # create combined javascript file

    if not debug:
        self.makeCombined()

    self.makeHtml()

    if not debug:
        self.zipApp()</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.makeClientSettings"><code class="name flex">
<span>def <span class="ident">makeClientSettings</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L524-L640" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeClientSettings(self):
    C = self.C
    layerSettings = C.layerSettings
    A = self.A
    api = A.api
    Cp = api.C

    self.makeLegends()

    typeSeq = list(layerSettings)
    typesLower = {}

    for (i, tp) in enumerate(typeSeq):
        typesLower[tp] = typeSeq[0 : i + 1]

    # set up the configuration that informs the client code
    # and the code that generates the data for the client

    clientConfig = dict(
        memSavingMethod=C.memSavingMethod,
        mainConfig=C.mainConfig,
        defs=dict(
            lsVersion=C.lsVersion,
            dataset=C.dataset,
            client=C.client,
            org=C.org,
            repo=C.repo,
            urls=C.urls,
            description=C.description,
        ),
        ntypes=typeSeq,
        typesLower=typesLower,
        defaultSettings=C.defaultSettings,
        defaultFlags=C.defaultFlags,
        keyboard=getattr(C, &#34;keyboard&#34;, None),
    )

    # check visible- and focus- attributes

    theFocuses = []
    theVisibles = []

    for (nType, typeInfo) in layerSettings.items():
        if typeInfo.get(&#34;focus&#34;, False):
            theFocuses.append(nType)

        for (name, layerInfo) in layerSettings[nType].get(&#34;layers&#34;, {}).items():
            if layerInfo.get(&#34;visible&#34;, False):
                theVisibles.append((nType, name))
            theMap = layerInfo.get(&#34;legend&#34;, None)
            if theMap is not None and type(theMap) is dict:
                default = layerInfo.get(&#34;default&#34;, None)
                if default is not None:
                    theMap[&#34;&#34;] = default

    if len(theFocuses) == 0:
        focusType = None
        console(&#34;No node type is declared as result focus\n&#34;)
    else:
        focusType = theFocuses[0]
        if len(theFocuses) &gt; 1:
            console(&#34;Multiple node types declared as result focus:\n&#34;)
            console(&#34;\t&#34; + (&#34;, &#34;.join(theFocuses)) + &#34;\n&#34;)
        else:
            console(&#34;Node type declared as result focus:\n&#34;)
            console(f&#34;\t{focusType}\n&#34;)

    clientConfig[&#34;focusType&#34;] = focusType

    if len(theVisibles) == 0:
        console(&#34;No layer type is declared as visible in the result (&#39;visible&#39;)\n&#34;)
    else:
        console(&#34;Layers declared as visible in the result (&#39;visible&#39;):\n&#34;)
        console(&#34;\t&#34; + (&#34;, &#34;.join(&#34;/&#34;.join(s) for s in theVisibles)) + &#34;\n&#34;)

    visible = {}
    layers = {}
    levels = {}

    ntypesinitTF = {level[0]: level[2] for level in Cp.levels.data}
    ntypessizeTF = {level[0]: level[3] - level[2] + 1 for level in Cp.levels.data}
    ntypesinit = {}
    ntypessize = {}

    for (level, typeInfo) in layerSettings.items():
        nType = typeInfo.get(&#34;nType&#34;, level)
        ntypesinit[level] = ntypesinitTF[nType]
        ntypessize[level] = ntypessizeTF[nType]
        levels[level] = typeInfo.get(&#34;description&#34;, &#34;&#34;)

        ti = typeInfo.get(&#34;layers&#34;, None)
        if ti is None:
            continue

        visible[level] = {layer: ti[layer].get(&#34;visible&#34;, False) for layer in ti}
        layers[level] = {
            layer: dict(
                valueMap=invertMap(ti[layer].get(&#34;legend&#34;, None)),
                tip=ti[layer].get(&#34;tip&#34;, False),
                pos=ti[layer][&#34;pos&#34;] or layer,
                pattern=ti[layer].get(&#34;example&#34;, &#34;&#34;),
                description=ti[layer].get(&#34;description&#34;, &#34;&#34;),
            )
            for layer in ti
        }

    for (k, v) in (
        (&#34;ntypesinit&#34;, ntypesinit),
        (&#34;ntypessize&#34;, ntypessize),
        (&#34;dtypeOf&#34;, {typeSeq[i + 1]: tp for (i, tp) in enumerate(typeSeq[0:-1])}),
        (&#34;utypeOf&#34;, {tp: typeSeq[i + 1] for (i, tp) in enumerate(typeSeq[0:-1])}),
        (&#34;visible&#34;, visible),
        (&#34;levels&#34;, levels),
        (&#34;layers&#34;, layers),
    ):
        clientConfig[k] = v
    self.clientConfig = clientConfig</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.makeCombined"><code class="name flex">
<span>def <span class="ident">makeCombined</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L824-L879" class="git-link">Browse git</a>
</summary>
<pre><code class="python">    def makeCombined(self):
        C = self.C

        commentRe = re.compile(r&#34;&#34;&#34;[ \t]*/\*.*?\*/[ \t]*&#34;&#34;&#34;, re.S)
        importRe = re.compile(r&#39;&#39;&#39;import\s+\{.*?\}\s+from\s+&#34;[^&#34;]*\.js&#34;&#39;&#39;&#39;, re.S)
        exportRe = re.compile(r&#34;&#34;&#34;^export[ ]+&#34;&#34;&#34;, re.M)
        whiteRe = re.compile(r&#34;&#34;&#34;^\s+$&#34;&#34;&#34;, re.M)
        nlRe = re.compile(r&#34;&#34;&#34;\n\n+&#34;&#34;&#34;)

        def getModule(module):
            with open(f&#34;{C.jsOutDir}/{module}&#34;) as fh:
                text = fh.read()
            text = importRe.sub(&#34;&#34;, text)
            text = exportRe.sub(&#34;&#34;, text)
            text = commentRe.sub(&#34;&#34;, text)
            text = whiteRe.sub(&#34;&#34;, text)
            text = nlRe.sub(&#34;\n&#34;, text)
            return text

        modules = []

        with os.scandir(C.jsOutDir) as it:
            for entry in it:
                name = entry.name
                if (
                    not entry.is_file()
                    or name.startswith(&#34;.&#34;)
                    or not name.endswith(&#34;.js&#34;)
                ):
                    continue
                modules.append(entry.name)
        console(&#34;, &#34;.join(module[0:-3] for module in modules))

        content = {module: getModule(module) for module in modules}

        header = &#34;&#34;&#34;\
/*eslint-env jquery*/
/* global configData */
/* global corpusData */

    &#34;&#34;&#34;
        combined = (
            header
            + content[C.jsDefs]
            + &#34;\n\n&#34;
            + &#34;\n\n&#34;.join(
                text
                for (name, text) in content.items()
                if name not in {C.jsDefs, C.jsApp}
            )
            + &#34;\n\n&#34;
            + content[C.jsApp]
        )
        with open(C.jsAllPath, &#34;w&#34;) as fh:
            fh.write(combined)
        console(f&#34;Combined js file written to {C.jsAllPath}&#34;)</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.makeConfig"><code class="name flex">
<span>def <span class="ident">makeConfig</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L649-L654" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeConfig(self):
    if not getattr(self, &#34;A&#34;, None):
        self.loadTf()
    if not getattr(self, &#34;clientConfig&#34;, None):
        self.makeClientSettings()
    self.dumpConfig()</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.makeCorpus"><code class="name flex">
<span>def <span class="ident">makeCorpus</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L676-L690" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeCorpus(self):
    if not getattr(self, &#34;A&#34;, None):
        self.loadTf()
    if not getattr(self, &#34;clientConfig&#34;, None):
        self.makeClientSettings()
    A = self.A

    A.info(&#34;Make links ...&#34;)
    self.makeLinks()

    A.info(&#34;Recording ...&#34;)
    self.record()

    A.info(&#34;Dumping ...&#34;)
    return self.dumpCorpus()</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.makeHtml"><code class="name flex">
<span>def <span class="ident">makeHtml</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L881-L951" class="git-link">Browse git</a>
</summary>
<pre><code class="python">    def makeHtml(self):
        C = self.C
        lsVersion = C.lsVersion

        # index of all clients

        clients = {}

        for thisClient in self.getAllClients():
            thisConfig = f&#34;{C.configDir}/{thisClient}/config.yaml&#34;
            if os.path.exists(thisConfig):
                with open(thisConfig) as fh:
                    desc = yaml.load(fh, Loader=yaml.FullLoader).get(&#34;short&#34;, &#34;&#34;)
            else:
                desc = &#34;&#34;
            clients[thisClient] = desc

        with open(C.index) as fh:
            template = fh.read()
            htmlIndex = template.replace(&#34;«dataset»&#34;, C.dataset)
            htmlIndex = htmlIndex.replace(&#34;«client»&#34;, C.client)

            html = []
            for (thisClient, desc) in clients.items():
                html.append(
                    f&#34;&#34;&#34;
&lt;dt&gt;&lt;a href=&#34;{thisClient}/index.html&#34;&gt;{thisClient}&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;{desc}&lt;/dd&gt;
&#34;&#34;&#34;
                )

            htmlIndex = htmlIndex.replace(&#34;«clients»&#34;, &#34;&#34;.join(html))

        with open(C.htmlIndex, &#34;w&#34;) as fh:
            fh.write(htmlIndex)
        console(f&#34;html file written to {C.htmlIndex}&#34;)

        # client and client-local

        with os.scandir(C.jsCorpusDir) as it:
            scripts = []
            for entry in it:
                file = entry.name
                if not file.endswith(&#34;.js&#34;):
                    continue
                if file.startswith(&#34;texts-&#34;) or file.startswith(&#34;posinfo-&#34;):
                    scripts.append(f&#39;&lt;script defer src=&#34;corpus/{file}«v»&#34;&gt;&lt;/script&gt;&#39;)
            corpusScripts = &#34;\n&#34;.join(scripts)

        with open(C.template) as fh:
            template = fh.read()
            htmlNormal = template.replace(
                &#34;«js»&#34;, &#39;&#39;&#39;type=&#34;module&#34; src=&#34;js/app.js«v»&#34;&#39;&#39;&#39;
            )
            htmlNormal = htmlNormal.replace(&#34;«corpus»&#34;, corpusScripts)
            htmlNormal = htmlNormal.replace(&#34;«v»&#34;, f&#34;?v={lsVersion}&#34;)
            htmlNormal = htmlNormal.replace(&#34;«dataset»&#34;, C.dataset)
            htmlNormal = htmlNormal.replace(&#34;«client»&#34;, C.client)
            htmlLocal = template.replace(&#34;«js»&#34;, f&#39;&#39;&#39;defer src=&#34;{C.jsAll}&#34;&#39;&#39;&#39;)
            htmlLocal = htmlLocal.replace(&#34;«corpus»&#34;, corpusScripts)
            htmlLocal = htmlLocal.replace(&#34;«v»&#34;, &#34;&#34;)
            htmlLocal = htmlLocal.replace(&#34;«dataset»&#34;, C.dataset)
            htmlLocal = htmlLocal.replace(&#34;«client»&#34;, C.client)

        with open(C.htmlClient, &#34;w&#34;) as fh:
            fh.write(htmlNormal)
        console(f&#34;html file written to {C.htmlClient}&#34;)

        with open(C.htmlLocal, &#34;w&#34;) as fh:
            fh.write(htmlLocal)
        console(f&#34;html file (for use with file://) written to {C.htmlLocal}&#34;)</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.makeLinks"><code class="name flex">
<span>def <span class="ident">makeLinks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L656-L674" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeLinks(self):
    C = self.C
    A = self.A
    api = A.api
    T = api.T
    F = api.F

    linkLevelMin = C.linkLevelMin
    linkLevelMax = C.linkLevelMax
    sTypes = T.sectionTypes[linkLevelMin - 1 : linkLevelMax]
    A.info(f&#34;links for types {&#39;, &#39;.join(sTypes)}&#34;)
    links = {
        sType: {n: A.webLink(n, urlOnly=True) for n in F.otype.s(sType)}
        for sType in sTypes
    }
    for (sType, sLinks) in links.items():
        A.info(f&#34;{sType:&lt;20}: {len(sLinks):&gt;6} links&#34;, tm=False)
    A.info(&#34;done&#34;)
    self.links = links</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.publish"><code class="name flex">
<span>def <span class="ident">publish</span></span>(<span>self, allClients=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L1062-L1071" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def publish(self, allClients=True):
    C = self.C
    appDir = C.appDir
    siteDir = C.siteDir
    dataset = self.dataset
    client = self.client
    clients = self.getAllClients() if allClients or client is None else [client]
    console(f&#34;Publishing {dataset}:{&#39;,&#39;.join(clients)} from {siteDir} ...&#34;)
    os.chdir(appDir)
    deploy(C.org, C.repo)</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.replaceDebug"><code class="name flex">
<span>def <span class="ident">replaceDebug</span></span>(<span>self, mask, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L1141-L1145" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def replaceDebug(self, mask, value):
    def subVersion(match):
        return mask.format(value)

    return subVersion</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.serve"><code class="name flex">
<span>def <span class="ident">serve</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L1090-L1111" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def serve(self):
    C = self.C
    os.chdir(C.siteDir)

    console(f&#34;HTTP serving files in {C.siteDir}&#34;)
    server = Popen(
        [&#34;python3&#34;, &#34;-m&#34;, &#34;http.server&#34;], stdout=PIPE, bufsize=1, encoding=&#34;utf-8&#34;
    )
    sleep(1)
    webbrowser.open(&#34;http://localhost:8000/index.html&#34;, new=2, autoraise=True)
    stopped = server.poll()
    if not stopped:
        try:
            console(&#34;Press &lt;Ctrl+C&gt; to stop the HTTP server&#34;)
            if server:
                for line in server.stdout:
                    console(line)
        except KeyboardInterrupt:
            console(&#34;&#34;)
            if server:
                server.terminate()
                console(&#34;Http server has stopped&#34;)</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.ship"><code class="name flex">
<span>def <span class="ident">ship</span></span>(<span>self, publish=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L1073-L1081" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ship(self, publish=True):
    self.adjustVersion()
    self.makeConfig()
    good = self.makeCorpus()
    if good:
        self.makeClient()
        self.adjustDebug()
        if publish:
            self.publish()</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.showDebug"><code class="name flex">
<span>def <span class="ident">showDebug</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L1169-L1176" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def showDebug(self):
    debugInfo = self.getDebugs()
    if debugInfo is None:
        return False
    return True

    for (source, debug) in debugInfo.items():
        console(f&#34;{debug} (according to {source})&#34;)</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.showVersion"><code class="name flex">
<span>def <span class="ident">showVersion</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L1122-L1126" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def showVersion(self):
    C = self.C
    lsVersion = C.lsVersion
    versionFile = self.versionFile
    console(f&#34;{lsVersion} (according to {versionFile})&#34;)</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.zipApp"><code class="name flex">
<span>def <span class="ident">zipApp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ddca21c94de7262b96ce824bde671bd040e2cb20/tf/client/make/build.py#L1025-L1060" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def zipApp(self):
    C = self.C
    items = set(
        &#34;&#34;&#34;
        css
        corpus
        jslib
        png
        favicon.ico
    &#34;&#34;&#34;.strip().split()
    )
    items.add(C.htmlLocalFile)
    items.add(C.jsAll)

    zipped = f&#34;{C.siteDir}/{C.client}.zip&#34;

    with ZipFile(zipped, &#34;w&#34;, **ZIP_OPTIONS) as zipFile:
        with os.scandir(C.appClientDir) as it:
            for entry in it:
                file = entry.name
                if file not in items:
                    continue
                if entry.is_file():
                    zipFile.write(f&#34;{C.appClientDir}/{file}&#34;, arcname=file)
                    console(f&#34;adding {file}&#34;)
                else:
                    with os.scandir(f&#34;{C.appClientDir}/{file}&#34;) as sit:
                        for sentry in sit:
                            sfile = sentry.name
                            if sentry.is_file and not sfile.startswith(&#34;.&#34;):
                                sfile = f&#34;{file}/{sfile}&#34;
                                zipFile.write(
                                    f&#34;{C.appClientDir}/{sfile}&#34;, arcname=sfile
                                )
                                console(f&#34;adding {sfile}&#34;)
    console(f&#34;Packaged client into {zipped}&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../../tf/index.html">tf home</a> -
<a href="../../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#usage">Usage</a><ul>
<li><a href="#prerequisites">Prerequisites</a></li>
<li><a href="#commands">Commands</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.client.make" href="index.html">tf.client.make</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tf.client.make.build.console" href="#tf.client.make.build.console">console</a></code></li>
<li><code><a title="tf.client.make.build.invertMap" href="#tf.client.make.build.invertMap">invertMap</a></code></li>
<li><code><a title="tf.client.make.build.main" href="#tf.client.make.build.main">main</a></code></li>
<li><code><a title="tf.client.make.build.makeSearchClients" href="#tf.client.make.build.makeSearchClients">makeSearchClients</a></code></li>
<li><code><a title="tf.client.make.build.readArgs" href="#tf.client.make.build.readArgs">readArgs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.client.make.build.Make" href="#tf.client.make.build.Make">Make</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.client.make.build.Make.adjustDebug" href="#tf.client.make.build.Make.adjustDebug">adjustDebug</a></code></li>
<li><code><a title="tf.client.make.build.Make.adjustVersion" href="#tf.client.make.build.Make.adjustVersion">adjustVersion</a></code></li>
<li><code><a title="tf.client.make.build.Make.compress" href="#tf.client.make.build.Make.compress">compress</a></code></li>
<li><code><a title="tf.client.make.build.Make.config" href="#tf.client.make.build.Make.config">config</a></code></li>
<li><code><a title="tf.client.make.build.Make.doCommand" href="#tf.client.make.build.Make.doCommand">doCommand</a></code></li>
<li><code><a title="tf.client.make.build.Make.dumpConfig" href="#tf.client.make.build.Make.dumpConfig">dumpConfig</a></code></li>
<li><code><a title="tf.client.make.build.Make.dumpCorpus" href="#tf.client.make.build.Make.dumpCorpus">dumpCorpus</a></code></li>
<li><code><a title="tf.client.make.build.Make.getAllClients" href="#tf.client.make.build.Make.getAllClients">getAllClients</a></code></li>
<li><code><a title="tf.client.make.build.Make.getDebugs" href="#tf.client.make.build.Make.getDebugs">getDebugs</a></code></li>
<li><code><a title="tf.client.make.build.Make.importMake" href="#tf.client.make.build.Make.importMake">importMake</a></code></li>
<li><code><a title="tf.client.make.build.Make.incVersion" href="#tf.client.make.build.Make.incVersion">incVersion</a></code></li>
<li><code><a title="tf.client.make.build.Make.loadTf" href="#tf.client.make.build.Make.loadTf">loadTf</a></code></li>
<li><code><a title="tf.client.make.build.Make.make" href="#tf.client.make.build.Make.make">make</a></code></li>
<li><code><a title="tf.client.make.build.Make.makeClient" href="#tf.client.make.build.Make.makeClient">makeClient</a></code></li>
<li><code><a title="tf.client.make.build.Make.makeClientSettings" href="#tf.client.make.build.Make.makeClientSettings">makeClientSettings</a></code></li>
<li><code><a title="tf.client.make.build.Make.makeCombined" href="#tf.client.make.build.Make.makeCombined">makeCombined</a></code></li>
<li><code><a title="tf.client.make.build.Make.makeConfig" href="#tf.client.make.build.Make.makeConfig">makeConfig</a></code></li>
<li><code><a title="tf.client.make.build.Make.makeCorpus" href="#tf.client.make.build.Make.makeCorpus">makeCorpus</a></code></li>
<li><code><a title="tf.client.make.build.Make.makeHtml" href="#tf.client.make.build.Make.makeHtml">makeHtml</a></code></li>
<li><code><a title="tf.client.make.build.Make.makeLinks" href="#tf.client.make.build.Make.makeLinks">makeLinks</a></code></li>
<li><code><a title="tf.client.make.build.Make.publish" href="#tf.client.make.build.Make.publish">publish</a></code></li>
<li><code><a title="tf.client.make.build.Make.replaceDebug" href="#tf.client.make.build.Make.replaceDebug">replaceDebug</a></code></li>
<li><code><a title="tf.client.make.build.Make.serve" href="#tf.client.make.build.Make.serve">serve</a></code></li>
<li><code><a title="tf.client.make.build.Make.ship" href="#tf.client.make.build.Make.ship">ship</a></code></li>
<li><code><a title="tf.client.make.build.Make.showDebug" href="#tf.client.make.build.Make.showDebug">showDebug</a></code></li>
<li><code><a title="tf.client.make.build.Make.showVersion" href="#tf.client.make.build.Make.showVersion">showVersion</a></code></li>
<li><code><a title="tf.client.make.build.Make.zipApp" href="#tf.client.make.build.Make.zipApp">zipApp</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://www.dans.knaw.nl"><img alt="DANS" src="../../../tf/images/DANS-logo.png" width="200" alt="DANS"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>