<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>tf.client.make.build API documentation</title>
<meta name="description" content="Usage …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.client.make.build</code></h1>
</header>
<section id="section-intro">
<h1 id="usage">Usage</h1>
<p>After installation, you have a new command <code>text-fabric-make</code>.
You can use this on the command line to build new search interfaces for existing
Text-Fabric apps.</p>
<p>Such a search interface is a static html page, powered by a Javascript program,
loaded with the corpus data into Javascript variables.</p>
<p>You can build the interface and ship the html page to GitHub Pages,
after which it is usable for everyone.</p>
<h2 id="prerequisites">Prerequisites</h2>
<ol>
<li>A Text-Fabric dataset that is registered as a TF-App, e.g. <code>nena</code> in
<a href="https://github.com/annotation/app-nena">github.com/annotation/app-nena</a>.
This is the normative example for now.</li>
<li>Within that app's repo, a subdirectory
<a href="https://github.com/annotation/app-nena/tree/master/layeredsearch">layeredsearch</a>
with definitions of search interfaces
(you can define multiple search interfaces for one dataset).
Within this directory:<ol>
<li><code>config.yaml</code>: common metadata of all defined search interfaces</li>
<li>for each search interface a folder
whose name is the name of the search interface, containing<ol>
<li><code>config.yaml</code>: definition of this specific search interface</li>
<li><code>logo.png</code>: a logo</li>
<li><code>custom.css</code>: additional styling (may be empty)</li>
<li>
<p><code>mkdata.py</code>: a module containing a few functions that produce the
corpus configuration data and the corpus search data:</p>
<ol>
<li><code>makeLegends(maker)</code>: produce abbreviation lists for some layers</li>
<li><code>record(maker)</code>: produce all the search data: full texts of layers and
mappings between nodes and positions in those texts</li>
</ol>
<p>The <code>maker</code> argument is passed by the builder, and contains
the definition of the layers and the api of a loaded Text-Fabric dataset.</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="commands">Commands</h2>
<p>See
also:</p>
<ul>
<li><code><a title="tf.client.make.help" href="help.html">tf.client.make.help</a></code></li>
<li><code><a title="tf.about.clientmanual" href="../../about/clientmanual.html">tf.about.clientmanual</a></code></li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L0-L960" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# Usage

After installation, you have a new command `text-fabric-make`.
You can use this on the command line to build new search interfaces for existing
Text-Fabric apps.

Such a search interface is a static html page, powered by a Javascript program,
loaded with the corpus data into Javascript variables.

You can build the interface and ship the html page to GitHub Pages,
after which it is usable for everyone.

## Prerequisites

1.  A Text-Fabric dataset that is registered as a TF-App, e.g. `nena` in
    [github.com/annotation/app-nena](https://github.com/annotation/app-nena).
    This is the normative example for now.
1.  Within that app&#39;s repo, a subdirectory
    [layeredsearch](https://github.com/annotation/app-nena/tree/master/layeredsearch)
    with definitions of search interfaces
    (you can define multiple search interfaces for one dataset).
    Within this directory:
    1.  `config.yaml`: common metadata of all defined search interfaces
    1.  for each search interface a folder
        whose name is the name of the search interface, containing
        1.  `config.yaml`: definition of this specific search interface
        1.  `logo.png`: a logo
        1.  `custom.css`: additional styling (may be empty)
        1.  `mkdata.py`: a module containing a few functions that produce the
            corpus configuration data and the corpus search data:
            1.  `makeLegends(maker)`: produce abbreviation lists for some layers
            2.  `record(maker)`: produce all the search data: full texts of layers and
                mappings between nodes and positions in those texts

            The `maker` argument is passed by the builder, and contains
            the definition of the layers and the api of a loaded Text-Fabric dataset.

## Commands

See  also:

*   `tf.client.make.help`
*   `tf.about.clientmanual`
&#34;&#34;&#34;

import sys
import os
import re
import types
import yaml
import json
import webbrowser

from shutil import copy
from datetime import datetime as dt
from subprocess import Popen, PIPE
from time import sleep
from zipfile import ZIP_DEFLATED, ZipFile
from importlib import util

from tf.fabric import Fabric
from tf.core.helpers import specFromRanges, rangesFromSet

from .gh import deploy
from.help import HELP

ZIP_OPTIONS = dict(compression=ZIP_DEFLATED, compresslevel=6)
T_F = &#34;text-fabric&#34;
LS = &#34;layeredsearch&#34;
STATIC_DIR = f&#34;{os.path.dirname(os.path.dirname(os.path.abspath(__file__)))}/static&#34;


def console(*args):
    sys.stderr.write(&#34; &#34;.join(args) + &#34;\n&#34;)
    sys.stderr.flush()


def invertMap(legend):
    return None if legend is None else {v: k for (k, v) in legend.items()}


def compress(data):
    sets = {}

    compressed = []

    for n in sorted(data):
        sets.setdefault(data[n], []).append(n)

    for (value, nset) in sorted(sets.items(), key=lambda x: (x[1][0], x[1][-1])):
        nSpec = list(nset)[0] if len(nset) == 1 else specFromRanges(rangesFromSet(nset))
        compressed.append(f&#34;{nSpec}\t{value}&#34;)

    return compressed


class Make:
    def __init__(self):
        class C:
            pass

        self.C = C

    def readArgs(self):
        args = sys.argv[1:]
        if not len(args) or args[0] in {&#34;-h&#34;, &#34;--help&#34;, &#34;help&#34;}:
            console(HELP)
            console(&#34;Missing dataset and client&#34;)
            quit()

        dataset = args[0]
        self.dataset = dataset
        args = args[1:]

        if not len(args) or args[0] in {&#34;-h&#34;, &#34;--help&#34;, &#34;help&#34;}:
            console(HELP)
            console(&#34;Missing client&#34;)
            quit()

        client = args[0]
        self.client = client
        args = args[1:]

        if not len(args) or args[0] in {&#34;-h&#34;, &#34;--help&#34;, &#34;help&#34;}:
            console(HELP)
            if not len(args):
                console(&#34;No command given&#34;)
            quit()

        command = args[0]
        self.command = command
        self.page = None
        self.message = None
        self.debugState = None
        self.remaining = []

        if command not in {
            &#34;serve&#34;,
            &#34;v&#34;,
            &#34;i&#34;,
            &#34;config&#34;,
            &#34;corpus&#34;,
            &#34;client&#34;,
            &#34;clientdebug&#34;,
            &#34;debug&#34;,
            &#34;publish&#34;,
            &#34;ship&#34;,
        }:
            console(HELP)
            console(f&#34;Wrong arguments: «{&#39; &#39;.join(args)}»&#34;)
            quit()

        if command in {&#34;serve&#34;}:
            if len(args) &lt; 2:
                self.page = client
            else:
                self.page = args[1]
                self.remaining = args[2:]

        elif command in {&#34;debug&#34;}:
            if len(args) &lt; 2 or args[1] not in {&#34;on&#34;, &#34;off&#34;}:
                console(&#34;say on or off&#34;)
                quit()

            self.debugState = args[1]
            self.remaining = args[2:]

    def config(self):
        C = self.C
        dataset = self.dataset
        client = self.client
        versionFile = f&#34;{STATIC_DIR}/version.yaml&#34;
        self.versionFile = versionFile

        with open(versionFile) as fh:
            settings = yaml.load(fh, Loader=yaml.FullLoader)
            lsVersion = settings[&#34;lsVersion&#34;]

        c = dict(
            dataset=dataset,
            client=client,
            lsVersion=lsVersion,
            gh=os.path.expanduser(&#34;~/github&#34;),
            ghUrl=&#34;https://github.com&#34;,
            nbUrl=&#34;https://nbviewer.jupyter.org/github&#34;,
            ghPages=&#34;github.io&#34;,
            nbTutUrl=&#34;«nbUrl»/annotation/tutorials/tree/master&#34;,
            lsDocUrl=f&#34;https://«org».«ghPages»/{T_F}/tf/about/clientmanual.html&#34;,
            org=&#34;annotation&#34;,
            repo=&#34;app-«dataset»&#34;,
            rel=&#34;site&#34;,
            generatorUrl=f&#34;«ghUrl»/«org»/{T_F}/tree/master/tf/client&#34;,
            sourceUrl=&#34;«ghUrl»/«org»/«repo»&#34;,
            issueUrl=&#34;«sourceUrl»/issues&#34;,
            tutUrl=&#34;«nbTutUrl»/«dataset»/start.ipynb&#34;,
            staticDir=STATIC_DIR,
            clientDir=&#34;«gh»/«org»/«repo»&#34;,
            configDir=f&#34;«clientDir»/{LS}&#34;,
            lsConfig=&#34;«configDir»/config.yaml&#34;,
            clientConfig=&#34;«configDir»/«client»/config.yaml&#34;,
            clientMake=&#34;mkdata&#34;,
            clientMakeDir=&#34;«configDir»/«client»&#34;,
            clientMakeFile=&#34;«clientMakeDir»/«clientMake».py&#34;,
            clientCss=&#34;«configDir»/«client»/custom.css&#34;,
            clientLogo=&#34;«configDir»/«client»/logo.png&#34;,
            pngInDir=&#34;«staticDir»/png&#34;,
            cssInDir=&#34;«staticDir»/css&#34;,
            htmlInDir=&#34;«staticDir»/html&#34;,
            jsInDir=&#34;«staticDir»/js&#34;,
            jslibInDir=&#34;«staticDir»/jslib&#34;,
            template=&#34;«htmlInDir»/template.html&#34;,
            index=&#34;«htmlInDir»/index.html&#34;,
            siteDir=&#34;«clientDir»/«rel»&#34;,
            pngOutDir=&#34;«siteDir»/png&#34;,
            cssOutDir=&#34;«siteDir»/css&#34;,
            htmlOutDir=&#34;«siteDir»&#34;,
            jsOutDir=&#34;«siteDir»/js&#34;,
            jslibOutDir=&#34;«siteDir»/jslib&#34;,
            jsCorpusDir=&#34;«siteDir»/corpus&#34;,
            jsApp=&#34;app.js&#34;,
            jsDefs=&#34;defs.js&#34;,
            jsDest=&#34;«jsCorpusDir»/«client»-all.js&#34;,
            htmlIndex=&#34;«siteDir»/index.html&#34;,
            htmlClient=&#34;«siteDir»/«client».html&#34;,
            htmlLocalFile=&#34;«client»-local.html&#34;,
            htmlLocal=&#34;«siteDir»/«htmlLocalFile»&#34;,
            favicon=&#34;favicon.ico&#34;,
            packageUrl=&#34;https://«org».«ghPages»/«repo»/«client».zip&#34;,
        )

        fillRe = re.compile(r&#34;«([a-zA-Z0-9_.]+)»&#34;)

        def fillSub(match):
            k = match.group(1)
            parts = k.split(&#34;.&#34;, 1)
            return (
                c.get(parts[0], {}).get(parts[1], &#34;&#34;)
                if len(parts) == 2
                else c.get(parts[0], &#34;&#34;)
            )

        def fillin(src, k, v):
            if type(v) is str:
                while fillRe.search(v):
                    v = fillRe.sub(fillSub, v)
                src[k] = v
            if type(v) is dict:
                for (m, w) in v.items():
                    fillin(src[k], m, w)
            if type(v) in {list, tuple}:
                if type(v) is tuple:
                    src[k] = list(v)
                for (m, w) in enumerate(v):
                    fillin(src[k], m, w)

        for (k, v) in c.items():
            fillin(c, k, v)

        lsConfig = c[&#34;lsConfig&#34;]
        if not os.path.exists(lsConfig):
            console(f&#34;No config.yaml found for {dataset}: {lsConfig}&#34;)
            quit()

        with open(lsConfig) as fh:
            settings = yaml.load(fh, Loader=yaml.FullLoader)
            for (k, v) in settings.items():
                c[k] = v
                fillin(c, k, v)

        clientConfig = c[&#34;clientConfig&#34;]
        if not os.path.exists(clientConfig):
            console(f&#34;No config.yaml found for {dataset}:{client}: {clientConfig}&#34;)
            quit()

        with open(clientConfig) as fh:
            settings = yaml.load(fh, Loader=yaml.FullLoader)
            for (k, v) in settings.items():
                c[k] = v
                fillin(c, k, v)

        clientMake = c[&#34;clientMake&#34;]
        clientMakeDir = c[&#34;clientMakeDir&#34;]
        clientMakeFile = c[&#34;clientMakeFile&#34;]

        try:
            moduleName = f&#34;ls.{dataset}.{client}.{clientMake}&#34;
            spec = util.spec_from_file_location(moduleName, clientMakeFile)
            code = util.module_from_spec(spec)
            sys.path.insert(0, clientMakeDir)
            spec.loader.exec_module(code)
            sys.path.pop(0)
            self.makeLegends = types.MethodType(code.makeLegends, self)
            self.record = types.MethodType(code.record, self)

        except Exception as e:
            console(f&#34;Cannot make data for {dataset}:{client}: {str(e)}&#34;)
            quit()

        d = dict(
            dataLocation=&#34;«gh»/«data.org»/«data.repo»/«data.rel»&#34;,
            dataUrl=&#34;«ghUrl»/«data.org»/«data.repo»/tree/master/tf/«data.version»&#34;,
            writingUrl=&#34;https://«org».«ghPages»/text-fabric/tf/writing/«writing».html&#34;,
            urls=dict(
                cheatsheet=(
                    &#34;regexp cheatsheet&#34;,
                    (
                        &#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/&#34;
                        &#34;Regular_Expressions/Cheatsheet&#34;
                    ),
                    &#34;cheatsheet of regular expressions&#34;,
                ),
                license=(
                    &#34;license&#34;,
                    &#34;https://mit-license.org&#34;,
                    &#34;website of MIT license&#34;,
                ),
                maker=(
                    None,
                    &#34;https://dans.knaw.nl/en/front-page?set_language=en&#34;,
                    &#34;Website of DANS = Data Archiving and Networked Services&#34;,
                ),
                corpus=(
                    None,
                    &#34;«corpus.url»&#34;,
                    &#34;«corpus.tip»&#34;,
                ),
                corpus2=(
                    &#34;«corpus.text»&#34;,
                    &#34;«corpus.url»&#34;,
                    &#34;«corpus.tip»&#34;,
                ),
                author=(
                    &#34;Dirk Roorda&#34;,
                    &#34;https://pure.knaw.nl/portal/en/persons/dirk-roorda&#34;,
                    &#34;profile of the author&#34;,
                ),
                author1=(
                    &#34;«author1.text»&#34;,
                    &#34;«author1.url»&#34;,
                    &#34;«author1.tip»&#34;,
                ),
                author2=(
                    &#34;«author2.text»&#34;,
                    &#34;«author2.url»&#34;,
                    &#34;«author2.tip»&#34;,
                ),
                tf=(
                    None,
                    &#34;https://«org».«ghPages»/text-fabric/tf/&#34;,
                    &#34;Text-Fabric documentation website&#34;,
                ),
                lsdoc=(
                    &#34;user manual&#34;,
                    &#34;«lsDocUrl»&#34;,
                    &#34;user manual for this search interface&#34;,
                ),
                datadoc=(
                    &#34;data (feature) documentation&#34;,
                    &#34;«data.docUrl»&#34;,
                    &#34;explanation of the features in the dataset&#34;,
                ),
                data=(
                    &#34;based on text-fabric data version «data.version»&#34;,
                    &#34;«dataUrl»&#34;,
                    &#34;online repository of the underlying text-fabric data&#34;,
                ),
                generator=(
                    f&#34;{T_F}/client&#34;,
                    &#34;«generatorUrl»&#34;,
                    &#34;source code of the generator of this search interface&#34;,
                ),
                source=(
                    &#34;«repo»&#34;,
                    &#34;«sourceUrl»&#34;,
                    &#34;source code of the definition of this search interface&#34;,
                ),
                issue=(
                    &#34;Report an issue&#34;,
                    &#34;«issueUrl»&#34;,
                    &#34;report issues&#34;,
                ),
                package=(
                    &#34;download&#34;,
                    &#34;«packageUrl»&#34;,
                    &#34;zip file for offline use&#34;,
                ),
                writing=(
                    &#34;«writing»&#34;,
                    &#34;«writingUrl»&#34;,
                    &#34;characters and transliteration for «writing»&#34;,
                ),
                related=(
                    &#34;text-fabric «dataset»&#34;,
                    &#34;«tutUrl»&#34;,
                    &#34;using Text-Fabric on the same corpus&#34;,
                ),
            ),
        )

        for (k, v) in d.items():
            c[k] = v
            fillin(c, k, v)

        setattr(
            C,
            &#34;debugConfig&#34;,
            dict(
                setup=dict(
                    file=f&#34;{c[&#39;jsOutDir&#39;]}/{c[&#39;jsDefs&#39;]}&#34;,
                    re=re.compile(r&#34;&#34;&#34;export const DEBUG = ([a-z]+)&#34;&#34;&#34;),
                    mask=&#34;export const DEBUG = {}&#34;,
                ),
            ),
        )
        for (k, v) in c.items():
            setattr(C, k, v)

    def makeClientSettings(self):
        C = self.C
        layerSettings = C.layerSettings
        api = self.api
        Cp = api.C

        self.makeLegends()

        typeSeq = list(layerSettings)
        typesLower = {}

        for (i, tp) in enumerate(typeSeq):
            typesLower[tp] = typeSeq[0 : i + 1]

        # set up the configuration that informs the client code
        # and the code that generates the data for the client

        clientConfig = dict(
            defs=dict(
                lsVersion=C.lsVersion,
                dataset=C.dataset,
                client=C.client,
                org=C.org,
                repo=C.repo,
                urls=C.urls,
                description=C.description,
            ),
            ntypes=typeSeq,
            typesLower=typesLower,
        )

        # check visible- and focus- attributes

        theFocuses = []
        theVisibles = []

        for (nType, typeInfo) in layerSettings.items():
            if typeInfo.get(&#34;focus&#34;, False):
                theFocuses.append(nType)

            for (name, layerInfo) in layerSettings[nType].get(&#34;layers&#34;, {}).items():
                if layerInfo.get(&#34;visible&#34;, False):
                    theVisibles.append((nType, name))
                theMap = layerInfo.get(&#34;legend&#34;, None)
                if theMap is not None:
                    default = layerInfo.get(&#34;default&#34;, None)
                    if default is not None:
                        theMap[&#34;&#34;] = default

        if len(theFocuses) == 0:
            focusType = None
            console(&#34;No node type is declared as result focus\n&#34;)
        else:
            focusType = theFocuses[0]
            if len(theFocuses) &gt; 1:
                console(
                    &#34;Multiple node types declared as result focus:\n&#34;
                )
                console(&#34;\t&#34; + (&#34;, &#34;.join(theFocuses)) + &#34;\n&#34;)
            else:
                console(&#34;Node type declared as result focus:\n&#34;)
                console(f&#34;\t{focusType}\n&#34;)

        clientConfig[&#34;focusType&#34;] = focusType

        if len(theVisibles) == 0:
            console(&#34;No layer type is declared as visible in the result (&#39;visible&#39;)\n&#34;)
        else:
            console(&#34;Layers declared as visible in the result (&#39;visible&#39;):\n&#34;)
            console(&#34;\t&#34; + (&#34;, &#34;.join(&#34;/&#34;.join(s) for s in theVisibles)) + &#34;\n&#34;)

        visible = {}
        layers = {}
        levels = {}

        for (nType, typeInfo) in layerSettings.items():
            levels[nType] = typeInfo.get(&#34;description&#34;, &#34;&#34;)
            ti = typeInfo.get(&#34;layers&#34;, None)
            if ti is None:
                continue

            visible[nType] = {name: ti[name].get(&#34;visible&#34;, False) for name in ti}
            layers[nType] = {
                name: dict(
                    valueMap=invertMap(ti[name].get(&#34;legend&#34;, None)),
                    tip=ti[name].get(&#34;tip&#34;, False),
                    pos=ti[name][&#34;pos&#34;] or name,
                    pattern=ti[name].get(&#34;example&#34;, &#34;&#34;),
                    description=ti[name].get(&#34;description&#34;, &#34;&#34;),
                )
                for name in ti
            }

        clientConfig |= dict(
            ntypesinit={level[0]: level[2] for level in Cp.levels.data},
            ntypessize={level[0]: level[3] - level[2] + 1 for level in Cp.levels.data},
            dtypeOf={typeSeq[i + 1]: tp for (i, tp) in enumerate(typeSeq[0:-1])},
            utypeOf={tp: typeSeq[i + 1] for (i, tp) in enumerate(typeSeq[0:-1])},
            visible=visible,
            levels=levels,
            layers=layers,
        )
        self.clientConfig = clientConfig

    def main(self):
        self.readArgs()

        command = self.command

        if not command:
            quit()

        self.config()

        if command == &#34;serve&#34;:
            self.serve()
        elif command == &#34;v&#34;:
            self.showVersion()
        elif command == &#34;i&#34;:
            self.adjustVersion()
        elif command == &#34;debug&#34;:
            self.adjustDebug()
        elif command == &#34;config&#34;:
            self.makeConfig()
        elif command == &#34;corpus&#34;:
            self.makeCorpus()
        elif command == &#34;client&#34;:
            self.makeClient()
        elif command == &#34;clientdebug&#34;:
            self.makeClient()
            self.debugState = &#34;on&#34;
            self.adjustDebug()
        elif command == &#34;publish&#34;:
            self.publish()
        elif command == &#34;ship&#34;:
            self.ship()

    def loadTf(self):
        C = self.C
        TF = Fabric(locations=C.dataLocation, modules=[C.data[&#34;version&#34;]])
        allFeatures = TF.explore(silent=True, show=True)
        loadableFeatures = allFeatures[&#34;nodes&#34;] + allFeatures[&#34;edges&#34;]
        self.api = TF.load(loadableFeatures, silent=True)

    def makeConfig(self):
        if not getattr(self, &#34;api&#34;, None):
            self.loadTf()
        if not getattr(self, &#34;clientConfig&#34;, None):
            self.makeClientSettings()
        self.dumpConfig()

    def makeCorpus(self):
        if not getattr(self, &#34;api&#34;, None):
            self.loadTf()
        if not getattr(self, &#34;clientConfig&#34;, None):
            self.makeClientSettings()
        TF = self.api.TF

        TF.info(&#34;Recording ...&#34;)
        self.record()

        TF.info(&#34;Dumping ...&#34;)
        self.dumpCorpus()

    def dumpConfig(self):
        C = self.C
        api = self.api
        TF = api.TF
        clientConfig = self.clientConfig

        destData = C.jsCorpusDir
        if not os.path.exists(destData):
            os.makedirs(destData, exist_ok=True)

        fileNameConfig = f&#34;{destData}/{C.client}-configdata.js&#34;

        with open(fileNameConfig, &#34;w&#34;) as fh:
            fh.write(&#34;const configData = &#34;)
            json.dump(clientConfig, fh, ensure_ascii=False, indent=1)
        TF.info(f&#34;Config written to file {fileNameConfig}&#34;)

    def dumpCorpus(self):
        C = self.C
        api = self.api
        TF = api.TF

        data = self.data
        data[&#34;up&#34;] = compress(data[&#34;up&#34;])

        TF.indent(reset=True)
        TF.info(&#34;Dumping data to a single compact json file&#34;)

        destData = C.jsCorpusDir
        if not os.path.exists(destData):
            os.makedirs(destData, exist_ok=True)

        fileNameData = f&#34;{destData}/{C.client}-corpusdata.js&#34;

        with open(fileNameData, &#34;w&#34;) as fh:
            fh.write(&#34;const corpusData = &#34;)
            json.dump(data, fh, ensure_ascii=False, indent=None, separators=(&#34;,&#34;, &#34;:&#34;))
        TF.info(f&#34;Data written to file {fileNameData}&#34;)

    def makeClient(self):
        &#34;&#34;&#34;
        We create a client app in the target directory.

        The client consists of HTML/CSS/PNG files plus a modular Javascript program.

        Module loading does not work when you open the HTML file locally
        (i.e. when the HTML is not served by a server).

        N.B. There is a difference between a local web server serving at `localhost`
        and opening the file directly into your browser by double clicking on it.

        In the first case, you see in your un the URL bar of your browser
        something that starts with
        `http://` or `https://`, in the second case you see `file://` instead.

        Modular Javascript does not work with `file://` origins.

        For that case, we bundle the modules into one,
        and let a «client»-local.html include it

        We also zip the client into {C.client}.zip so that users can download it easily
        &#34;&#34;&#34;

        # copy over the static files

        C = self.C
        lsVersion = C.lsVersion

        for (srcDir, dstDir) in (
            (C.pngInDir, C.pngOutDir),
            (C.cssInDir, C.cssOutDir),
            (C.jsInDir, C.jsOutDir),
            (C.jslibInDir, C.jslibOutDir),
            (C.htmlInDir, C.htmlOutDir),
        ):
            if not os.path.exists(dstDir):
                os.makedirs(dstDir, exist_ok=True)

            with os.scandir(srcDir) as it:
                for entry in it:
                    name = entry.name
                    if not entry.is_file() or name.startswith(&#34;.&#34;):
                        continue
                    srcFile = f&#34;{srcDir}/{name}&#34;
                    if srcFile != C.template:
                        copy(srcFile, f&#34;{dstDir}/{name}&#34;)
        copy(f&#34;{C.staticDir}/{C.favicon}&#34;, f&#34;{C.siteDir}/{C.favicon}&#34;)

        # move the custom files in place

        for (srcFile, dstFile) in (
            (C.clientCss, f&#34;{C.cssOutDir}/{C.client}.css&#34;),
            (C.clientLogo, f&#34;{C.pngOutDir}/{C.client}.png&#34;),
        ):
            copy(srcFile, dstFile)

        # create combined javascript file

        commentRe = re.compile(r&#34;&#34;&#34;[ \t]*/\*.*?\*/[ \t]*&#34;&#34;&#34;, re.S)
        importRe = re.compile(r&#39;&#39;&#39;import\s+\{.*?\}\s+from\s+&#34;[^&#34;]*\.js&#34;&#39;&#39;&#39;, re.S)
        exportRe = re.compile(r&#34;&#34;&#34;^export[ ]+&#34;&#34;&#34;, re.M)
        whiteRe = re.compile(r&#34;&#34;&#34;^\s+$&#34;&#34;&#34;, re.M)
        nlRe = re.compile(r&#34;&#34;&#34;\n\n+&#34;&#34;&#34;)

        def getModule(module):
            with open(f&#34;{C.jsOutDir}/{module}&#34;) as fh:
                text = fh.read()
            text = importRe.sub(&#34;&#34;, text)
            text = exportRe.sub(&#34;&#34;, text)
            text = commentRe.sub(&#34;&#34;, text)
            text = whiteRe.sub(&#34;&#34;, text)
            text = nlRe.sub(&#34;\n&#34;, text)
            return text

        modules = []

        with os.scandir(C.jsOutDir) as it:
            for entry in it:
                name = entry.name
                if (
                    not entry.is_file()
                    or name.startswith(&#34;.&#34;)
                    or not name.endswith(&#34;.js&#34;)
                ):
                    continue
                modules.append(entry.name)
        console(&#34;, &#34;.join(module[0:-3] for module in modules))

        content = {module: getModule(module) for module in modules}

        header = &#34;&#34;&#34;\
/*eslint-env jquery*/
/* global configData */
/* global corpusData */

    &#34;&#34;&#34;
        combined = (
            header
            + content[C.jsDefs]
            + &#34;\n\n&#34;
            + &#34;\n\n&#34;.join(
                text
                for (name, text) in content.items()
                if name not in {C.jsDefs, C.jsApp}
            )
            + &#34;\n\n&#34;
            + content[C.jsApp]
        )
        with open(C.jsDest, &#34;w&#34;) as fh:
            fh.write(combined)
        console(f&#34;Combined js file written to {C.jsDest}&#34;)

        # fill in the html templates

        # index of all clients

        clients = {}

        with os.scandir(C.configDir) as it:
            for entry in it:
                if entry.is_dir():
                    thisClient = entry.name
                    thisConfig = f&#34;{C.configDir}/{thisClient}/config.yaml&#34;
                    if os.path.exists(thisConfig):
                        with open(thisConfig) as fh:
                            desc = yaml.load(fh, Loader=yaml.FullLoader).get(&#34;short&#34;, &#34;&#34;)
                    else:
                        desc = &#34;&#34;
                    clients[thisClient] = desc

        with open(C.index) as fh:
            template = fh.read()
            htmlIndex = template.replace(&#34;«dataset»&#34;, C.dataset)
            htmlIndex = htmlIndex.replace(&#34;«client»&#34;, C.client)

            html = []
            for (thisClient, desc) in clients.items():
                html.append(
                    f&#34;&#34;&#34;
&lt;dt&gt;&lt;a href=&#34;{thisClient}.html&#34;&gt;{thisClient}&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;{desc}&lt;/dd&gt;
&#34;&#34;&#34;
                )

            htmlIndex = htmlIndex.replace(&#34;«clients»&#34;, &#34;&#34;.join(html))

        with open(C.htmlIndex, &#34;w&#34;) as fh:
            fh.write(htmlIndex)
        console(f&#34;html file written to {C.htmlIndex}&#34;)

        # client and client-local

        with open(C.template) as fh:
            template = fh.read()
            htmlNormal = template.replace(
                &#34;«js»&#34;, &#39;&#39;&#39;type=&#34;module&#34; src=&#34;js/app.js«v»&#34;&#39;&#39;&#39;
            )
            htmlNormal = htmlNormal.replace(&#34;«v»&#34;, f&#34;?v={lsVersion}&#34;)
            htmlNormal = htmlNormal.replace(&#34;«dataset»&#34;, C.dataset)
            htmlNormal = htmlNormal.replace(&#34;«client»&#34;, C.client)
            htmlLocal = template.replace(
                &#34;«js»&#34;, f&#39;&#39;&#39;defer src=&#34;corpus/{C.client}/all.js«v»&#34;&#39;&#39;&#39;
            )
            htmlLocal = htmlLocal.replace(&#34;«v»&#34;, f&#34;?v={lsVersion}&#34;)
            htmlLocal = htmlLocal.replace(&#34;«dataset»&#34;, C.dataset)
            htmlLocal = htmlLocal.replace(&#34;«client»&#34;, C.client)

        with open(C.htmlClient, &#34;w&#34;) as fh:
            fh.write(htmlNormal)
        console(f&#34;html file written to {C.htmlClient}&#34;)

        with open(C.htmlLocal, &#34;w&#34;) as fh:
            fh.write(htmlLocal)
        console(f&#34;html file (for use with file://) written to {C.htmlLocal}&#34;)

        # zip the standalone client

        self.zipApp()

    def zipApp(self):
        C = self.C
        items = set(
            &#34;&#34;&#34;
            css
            corpus
            jslib
            png
            favicon.ico
        &#34;&#34;&#34;.strip().split()
        )
        items.add(C.htmlLocalFile)

        zipped = f&#34;{C.siteDir}/{C.client}.zip&#34;

        with ZipFile(zipped, &#34;w&#34;, **ZIP_OPTIONS) as zipFile:
            with os.scandir(C.siteDir) as it:
                for entry in it:
                    file = entry.name
                    if file not in items:
                        continue
                    if entry.is_file():
                        zipFile.write(f&#34;{C.siteDir}/{file}&#34;, arcname=file)
                        console(f&#34;adding {file}&#34;)
                    else:
                        with os.scandir(f&#34;{C.siteDir}/{file}&#34;) as sit:
                            for sentry in sit:
                                sfile = sentry.name
                                if sentry.is_file and not sfile.startswith(&#34;.&#34;):
                                    sfile = f&#34;{file}/{sfile}&#34;
                                    zipFile.write(f&#34;{C.siteDir}/{sfile}&#34;, arcname=sfile)
                                    console(f&#34;adding {sfile}&#34;)
        console(f&#34;Packaged client into {zipped}&#34;)

    def publish(self):
        C = self.C
        os.chdir(C.clientDir)
        deploy(C.org, C.repo)

    def ship(self):
        self.adjustVersion()
        self.adjustDebug()
        self.makeConfig()
        self.makeCorpus()
        self.makeClient()
        self.publish()

    def serve(self):
        C = self.C
        page = self.page
        os.chdir(C.siteDir)

        server = Popen(
            [&#34;python3&#34;, &#34;-m&#34;, &#34;http.server&#34;], stdout=PIPE, bufsize=1, encoding=&#34;utf-8&#34;
        )
        sleep(1)
        webbrowser.open(f&#34;http://localhost:8000/{page}.html&#34;, new=2, autoraise=True)
        stopped = server.poll()
        if not stopped:
            try:
                console(&#34;Press &lt;Ctrl+C&gt; to stop the HTTP server&#34;)
                if server:
                    for line in server.stdout:
                        console(line)
            except KeyboardInterrupt:
                console(&#34;&#34;)
                if server:
                    server.terminate()
                    console(&#34;Http server has stopped&#34;)

    def incVersion(self):
        C = self.C
        lsVersion = C.lsVersion
        parts = lsVersion.split(&#34;@&#34;, 1)
        v = int(parts[0].lstrip(&#34;v&#34;).lstrip(&#34;0&#34;), base=10)
        now = dt.utcnow().isoformat(timespec=&#34;seconds&#34;)
        self.lsVersion = f&#34;v{v + 1:&gt;03}@{now}&#34;
        C.lsVersion = self.lsVersion

    def showVersion(self):
        C = self.C
        lsVersion = C.lsVersion
        versionFile = self.versionFile
        console(f&#34;{lsVersion} (according to {versionFile})&#34;)

    def adjustVersion(self):
        C = self.C
        versionFile = self.versionFile

        currentVersion = C.lsVersion
        self.incVersion()
        newVersion = C.lsVersion

        with open(versionFile, &#34;w&#34;) as fh:
            yaml.dump(dict(lsVersion=newVersion), fh)

        console(f&#34;Version went from `{currentVersion}` to `{newVersion}`&#34;)

    def replaceDebug(self, mask, value):
        def subVersion(match):
            return mask.format(value)

        return subVersion

    def getDebugs(self):
        C = self.C

        debugs = {}
        good = True

        for (key, c) in C.debugConfig.items():
            cfile = c[&#34;file&#34;]
            with open(cfile) as fh:
                text = fh.read()
            match = c[&#34;re&#34;].search(text)
            if not match:
                console(f&#34;No debug found in {cfile}&#34;)
                good = False
                continue
            debug = match.group(1)
            debugs[cfile] = debug

        if not good:
            quit()
        return debugs

    def showDebug(self):
        debugInfo = self.getDebugs()

        for (source, debug) in debugInfo.items():
            console(f&#34;{debug} (according to {source})&#34;)

    def adjustDebug(self):
        C = self.C
        debugState = self.debugState

        self.showDebug()

        newValue = &#34;true&#34; if debugState == &#34;on&#34; else &#34;false&#34;

        for (key, c) in C.debugConfig.items():
            console(f&#39;Adjusting debug in {c[&#34;file&#34;]}&#39;)
            with open(c[&#34;file&#34;]) as fh:
                text = fh.read()
            text = c[&#34;re&#34;].sub(self.replaceDebug(c[&#34;mask&#34;], newValue), text)
            with open(c[&#34;file&#34;], &#34;w&#34;) as fh:
                fh.write(text)

        console(f&#34;Debug set to {newValue}&#34;)
        self.showDebug()


def main():
    Mk = Make()
    return Mk.main()


if __name__ == &#34;__main__&#34;:

    sys.exit(main())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.client.make.build.compress"><code class="name flex">
<span>def <span class="ident">compress</span></span>(<span>data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L83-L95" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def compress(data):
    sets = {}

    compressed = []

    for n in sorted(data):
        sets.setdefault(data[n], []).append(n)

    for (value, nset) in sorted(sets.items(), key=lambda x: (x[1][0], x[1][-1])):
        nSpec = list(nset)[0] if len(nset) == 1 else specFromRanges(rangesFromSet(nset))
        compressed.append(f&#34;{nSpec}\t{value}&#34;)

    return compressed</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.console"><code class="name flex">
<span>def <span class="ident">console</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L74-L76" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def console(*args):
    sys.stderr.write(&#34; &#34;.join(args) + &#34;\n&#34;)
    sys.stderr.flush()</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.invertMap"><code class="name flex">
<span>def <span class="ident">invertMap</span></span>(<span>legend)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L79-L80" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def invertMap(legend):
    return None if legend is None else {v: k for (k, v) in legend.items()}</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L954-L956" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def main():
    Mk = Make()
    return Mk.main()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.client.make.build.Make"><code class="flex name class">
<span>class <span class="ident">Make</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L98-L951" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Make:
    def __init__(self):
        class C:
            pass

        self.C = C

    def readArgs(self):
        args = sys.argv[1:]
        if not len(args) or args[0] in {&#34;-h&#34;, &#34;--help&#34;, &#34;help&#34;}:
            console(HELP)
            console(&#34;Missing dataset and client&#34;)
            quit()

        dataset = args[0]
        self.dataset = dataset
        args = args[1:]

        if not len(args) or args[0] in {&#34;-h&#34;, &#34;--help&#34;, &#34;help&#34;}:
            console(HELP)
            console(&#34;Missing client&#34;)
            quit()

        client = args[0]
        self.client = client
        args = args[1:]

        if not len(args) or args[0] in {&#34;-h&#34;, &#34;--help&#34;, &#34;help&#34;}:
            console(HELP)
            if not len(args):
                console(&#34;No command given&#34;)
            quit()

        command = args[0]
        self.command = command
        self.page = None
        self.message = None
        self.debugState = None
        self.remaining = []

        if command not in {
            &#34;serve&#34;,
            &#34;v&#34;,
            &#34;i&#34;,
            &#34;config&#34;,
            &#34;corpus&#34;,
            &#34;client&#34;,
            &#34;clientdebug&#34;,
            &#34;debug&#34;,
            &#34;publish&#34;,
            &#34;ship&#34;,
        }:
            console(HELP)
            console(f&#34;Wrong arguments: «{&#39; &#39;.join(args)}»&#34;)
            quit()

        if command in {&#34;serve&#34;}:
            if len(args) &lt; 2:
                self.page = client
            else:
                self.page = args[1]
                self.remaining = args[2:]

        elif command in {&#34;debug&#34;}:
            if len(args) &lt; 2 or args[1] not in {&#34;on&#34;, &#34;off&#34;}:
                console(&#34;say on or off&#34;)
                quit()

            self.debugState = args[1]
            self.remaining = args[2:]

    def config(self):
        C = self.C
        dataset = self.dataset
        client = self.client
        versionFile = f&#34;{STATIC_DIR}/version.yaml&#34;
        self.versionFile = versionFile

        with open(versionFile) as fh:
            settings = yaml.load(fh, Loader=yaml.FullLoader)
            lsVersion = settings[&#34;lsVersion&#34;]

        c = dict(
            dataset=dataset,
            client=client,
            lsVersion=lsVersion,
            gh=os.path.expanduser(&#34;~/github&#34;),
            ghUrl=&#34;https://github.com&#34;,
            nbUrl=&#34;https://nbviewer.jupyter.org/github&#34;,
            ghPages=&#34;github.io&#34;,
            nbTutUrl=&#34;«nbUrl»/annotation/tutorials/tree/master&#34;,
            lsDocUrl=f&#34;https://«org».«ghPages»/{T_F}/tf/about/clientmanual.html&#34;,
            org=&#34;annotation&#34;,
            repo=&#34;app-«dataset»&#34;,
            rel=&#34;site&#34;,
            generatorUrl=f&#34;«ghUrl»/«org»/{T_F}/tree/master/tf/client&#34;,
            sourceUrl=&#34;«ghUrl»/«org»/«repo»&#34;,
            issueUrl=&#34;«sourceUrl»/issues&#34;,
            tutUrl=&#34;«nbTutUrl»/«dataset»/start.ipynb&#34;,
            staticDir=STATIC_DIR,
            clientDir=&#34;«gh»/«org»/«repo»&#34;,
            configDir=f&#34;«clientDir»/{LS}&#34;,
            lsConfig=&#34;«configDir»/config.yaml&#34;,
            clientConfig=&#34;«configDir»/«client»/config.yaml&#34;,
            clientMake=&#34;mkdata&#34;,
            clientMakeDir=&#34;«configDir»/«client»&#34;,
            clientMakeFile=&#34;«clientMakeDir»/«clientMake».py&#34;,
            clientCss=&#34;«configDir»/«client»/custom.css&#34;,
            clientLogo=&#34;«configDir»/«client»/logo.png&#34;,
            pngInDir=&#34;«staticDir»/png&#34;,
            cssInDir=&#34;«staticDir»/css&#34;,
            htmlInDir=&#34;«staticDir»/html&#34;,
            jsInDir=&#34;«staticDir»/js&#34;,
            jslibInDir=&#34;«staticDir»/jslib&#34;,
            template=&#34;«htmlInDir»/template.html&#34;,
            index=&#34;«htmlInDir»/index.html&#34;,
            siteDir=&#34;«clientDir»/«rel»&#34;,
            pngOutDir=&#34;«siteDir»/png&#34;,
            cssOutDir=&#34;«siteDir»/css&#34;,
            htmlOutDir=&#34;«siteDir»&#34;,
            jsOutDir=&#34;«siteDir»/js&#34;,
            jslibOutDir=&#34;«siteDir»/jslib&#34;,
            jsCorpusDir=&#34;«siteDir»/corpus&#34;,
            jsApp=&#34;app.js&#34;,
            jsDefs=&#34;defs.js&#34;,
            jsDest=&#34;«jsCorpusDir»/«client»-all.js&#34;,
            htmlIndex=&#34;«siteDir»/index.html&#34;,
            htmlClient=&#34;«siteDir»/«client».html&#34;,
            htmlLocalFile=&#34;«client»-local.html&#34;,
            htmlLocal=&#34;«siteDir»/«htmlLocalFile»&#34;,
            favicon=&#34;favicon.ico&#34;,
            packageUrl=&#34;https://«org».«ghPages»/«repo»/«client».zip&#34;,
        )

        fillRe = re.compile(r&#34;«([a-zA-Z0-9_.]+)»&#34;)

        def fillSub(match):
            k = match.group(1)
            parts = k.split(&#34;.&#34;, 1)
            return (
                c.get(parts[0], {}).get(parts[1], &#34;&#34;)
                if len(parts) == 2
                else c.get(parts[0], &#34;&#34;)
            )

        def fillin(src, k, v):
            if type(v) is str:
                while fillRe.search(v):
                    v = fillRe.sub(fillSub, v)
                src[k] = v
            if type(v) is dict:
                for (m, w) in v.items():
                    fillin(src[k], m, w)
            if type(v) in {list, tuple}:
                if type(v) is tuple:
                    src[k] = list(v)
                for (m, w) in enumerate(v):
                    fillin(src[k], m, w)

        for (k, v) in c.items():
            fillin(c, k, v)

        lsConfig = c[&#34;lsConfig&#34;]
        if not os.path.exists(lsConfig):
            console(f&#34;No config.yaml found for {dataset}: {lsConfig}&#34;)
            quit()

        with open(lsConfig) as fh:
            settings = yaml.load(fh, Loader=yaml.FullLoader)
            for (k, v) in settings.items():
                c[k] = v
                fillin(c, k, v)

        clientConfig = c[&#34;clientConfig&#34;]
        if not os.path.exists(clientConfig):
            console(f&#34;No config.yaml found for {dataset}:{client}: {clientConfig}&#34;)
            quit()

        with open(clientConfig) as fh:
            settings = yaml.load(fh, Loader=yaml.FullLoader)
            for (k, v) in settings.items():
                c[k] = v
                fillin(c, k, v)

        clientMake = c[&#34;clientMake&#34;]
        clientMakeDir = c[&#34;clientMakeDir&#34;]
        clientMakeFile = c[&#34;clientMakeFile&#34;]

        try:
            moduleName = f&#34;ls.{dataset}.{client}.{clientMake}&#34;
            spec = util.spec_from_file_location(moduleName, clientMakeFile)
            code = util.module_from_spec(spec)
            sys.path.insert(0, clientMakeDir)
            spec.loader.exec_module(code)
            sys.path.pop(0)
            self.makeLegends = types.MethodType(code.makeLegends, self)
            self.record = types.MethodType(code.record, self)

        except Exception as e:
            console(f&#34;Cannot make data for {dataset}:{client}: {str(e)}&#34;)
            quit()

        d = dict(
            dataLocation=&#34;«gh»/«data.org»/«data.repo»/«data.rel»&#34;,
            dataUrl=&#34;«ghUrl»/«data.org»/«data.repo»/tree/master/tf/«data.version»&#34;,
            writingUrl=&#34;https://«org».«ghPages»/text-fabric/tf/writing/«writing».html&#34;,
            urls=dict(
                cheatsheet=(
                    &#34;regexp cheatsheet&#34;,
                    (
                        &#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/&#34;
                        &#34;Regular_Expressions/Cheatsheet&#34;
                    ),
                    &#34;cheatsheet of regular expressions&#34;,
                ),
                license=(
                    &#34;license&#34;,
                    &#34;https://mit-license.org&#34;,
                    &#34;website of MIT license&#34;,
                ),
                maker=(
                    None,
                    &#34;https://dans.knaw.nl/en/front-page?set_language=en&#34;,
                    &#34;Website of DANS = Data Archiving and Networked Services&#34;,
                ),
                corpus=(
                    None,
                    &#34;«corpus.url»&#34;,
                    &#34;«corpus.tip»&#34;,
                ),
                corpus2=(
                    &#34;«corpus.text»&#34;,
                    &#34;«corpus.url»&#34;,
                    &#34;«corpus.tip»&#34;,
                ),
                author=(
                    &#34;Dirk Roorda&#34;,
                    &#34;https://pure.knaw.nl/portal/en/persons/dirk-roorda&#34;,
                    &#34;profile of the author&#34;,
                ),
                author1=(
                    &#34;«author1.text»&#34;,
                    &#34;«author1.url»&#34;,
                    &#34;«author1.tip»&#34;,
                ),
                author2=(
                    &#34;«author2.text»&#34;,
                    &#34;«author2.url»&#34;,
                    &#34;«author2.tip»&#34;,
                ),
                tf=(
                    None,
                    &#34;https://«org».«ghPages»/text-fabric/tf/&#34;,
                    &#34;Text-Fabric documentation website&#34;,
                ),
                lsdoc=(
                    &#34;user manual&#34;,
                    &#34;«lsDocUrl»&#34;,
                    &#34;user manual for this search interface&#34;,
                ),
                datadoc=(
                    &#34;data (feature) documentation&#34;,
                    &#34;«data.docUrl»&#34;,
                    &#34;explanation of the features in the dataset&#34;,
                ),
                data=(
                    &#34;based on text-fabric data version «data.version»&#34;,
                    &#34;«dataUrl»&#34;,
                    &#34;online repository of the underlying text-fabric data&#34;,
                ),
                generator=(
                    f&#34;{T_F}/client&#34;,
                    &#34;«generatorUrl»&#34;,
                    &#34;source code of the generator of this search interface&#34;,
                ),
                source=(
                    &#34;«repo»&#34;,
                    &#34;«sourceUrl»&#34;,
                    &#34;source code of the definition of this search interface&#34;,
                ),
                issue=(
                    &#34;Report an issue&#34;,
                    &#34;«issueUrl»&#34;,
                    &#34;report issues&#34;,
                ),
                package=(
                    &#34;download&#34;,
                    &#34;«packageUrl»&#34;,
                    &#34;zip file for offline use&#34;,
                ),
                writing=(
                    &#34;«writing»&#34;,
                    &#34;«writingUrl»&#34;,
                    &#34;characters and transliteration for «writing»&#34;,
                ),
                related=(
                    &#34;text-fabric «dataset»&#34;,
                    &#34;«tutUrl»&#34;,
                    &#34;using Text-Fabric on the same corpus&#34;,
                ),
            ),
        )

        for (k, v) in d.items():
            c[k] = v
            fillin(c, k, v)

        setattr(
            C,
            &#34;debugConfig&#34;,
            dict(
                setup=dict(
                    file=f&#34;{c[&#39;jsOutDir&#39;]}/{c[&#39;jsDefs&#39;]}&#34;,
                    re=re.compile(r&#34;&#34;&#34;export const DEBUG = ([a-z]+)&#34;&#34;&#34;),
                    mask=&#34;export const DEBUG = {}&#34;,
                ),
            ),
        )
        for (k, v) in c.items():
            setattr(C, k, v)

    def makeClientSettings(self):
        C = self.C
        layerSettings = C.layerSettings
        api = self.api
        Cp = api.C

        self.makeLegends()

        typeSeq = list(layerSettings)
        typesLower = {}

        for (i, tp) in enumerate(typeSeq):
            typesLower[tp] = typeSeq[0 : i + 1]

        # set up the configuration that informs the client code
        # and the code that generates the data for the client

        clientConfig = dict(
            defs=dict(
                lsVersion=C.lsVersion,
                dataset=C.dataset,
                client=C.client,
                org=C.org,
                repo=C.repo,
                urls=C.urls,
                description=C.description,
            ),
            ntypes=typeSeq,
            typesLower=typesLower,
        )

        # check visible- and focus- attributes

        theFocuses = []
        theVisibles = []

        for (nType, typeInfo) in layerSettings.items():
            if typeInfo.get(&#34;focus&#34;, False):
                theFocuses.append(nType)

            for (name, layerInfo) in layerSettings[nType].get(&#34;layers&#34;, {}).items():
                if layerInfo.get(&#34;visible&#34;, False):
                    theVisibles.append((nType, name))
                theMap = layerInfo.get(&#34;legend&#34;, None)
                if theMap is not None:
                    default = layerInfo.get(&#34;default&#34;, None)
                    if default is not None:
                        theMap[&#34;&#34;] = default

        if len(theFocuses) == 0:
            focusType = None
            console(&#34;No node type is declared as result focus\n&#34;)
        else:
            focusType = theFocuses[0]
            if len(theFocuses) &gt; 1:
                console(
                    &#34;Multiple node types declared as result focus:\n&#34;
                )
                console(&#34;\t&#34; + (&#34;, &#34;.join(theFocuses)) + &#34;\n&#34;)
            else:
                console(&#34;Node type declared as result focus:\n&#34;)
                console(f&#34;\t{focusType}\n&#34;)

        clientConfig[&#34;focusType&#34;] = focusType

        if len(theVisibles) == 0:
            console(&#34;No layer type is declared as visible in the result (&#39;visible&#39;)\n&#34;)
        else:
            console(&#34;Layers declared as visible in the result (&#39;visible&#39;):\n&#34;)
            console(&#34;\t&#34; + (&#34;, &#34;.join(&#34;/&#34;.join(s) for s in theVisibles)) + &#34;\n&#34;)

        visible = {}
        layers = {}
        levels = {}

        for (nType, typeInfo) in layerSettings.items():
            levels[nType] = typeInfo.get(&#34;description&#34;, &#34;&#34;)
            ti = typeInfo.get(&#34;layers&#34;, None)
            if ti is None:
                continue

            visible[nType] = {name: ti[name].get(&#34;visible&#34;, False) for name in ti}
            layers[nType] = {
                name: dict(
                    valueMap=invertMap(ti[name].get(&#34;legend&#34;, None)),
                    tip=ti[name].get(&#34;tip&#34;, False),
                    pos=ti[name][&#34;pos&#34;] or name,
                    pattern=ti[name].get(&#34;example&#34;, &#34;&#34;),
                    description=ti[name].get(&#34;description&#34;, &#34;&#34;),
                )
                for name in ti
            }

        clientConfig |= dict(
            ntypesinit={level[0]: level[2] for level in Cp.levels.data},
            ntypessize={level[0]: level[3] - level[2] + 1 for level in Cp.levels.data},
            dtypeOf={typeSeq[i + 1]: tp for (i, tp) in enumerate(typeSeq[0:-1])},
            utypeOf={tp: typeSeq[i + 1] for (i, tp) in enumerate(typeSeq[0:-1])},
            visible=visible,
            levels=levels,
            layers=layers,
        )
        self.clientConfig = clientConfig

    def main(self):
        self.readArgs()

        command = self.command

        if not command:
            quit()

        self.config()

        if command == &#34;serve&#34;:
            self.serve()
        elif command == &#34;v&#34;:
            self.showVersion()
        elif command == &#34;i&#34;:
            self.adjustVersion()
        elif command == &#34;debug&#34;:
            self.adjustDebug()
        elif command == &#34;config&#34;:
            self.makeConfig()
        elif command == &#34;corpus&#34;:
            self.makeCorpus()
        elif command == &#34;client&#34;:
            self.makeClient()
        elif command == &#34;clientdebug&#34;:
            self.makeClient()
            self.debugState = &#34;on&#34;
            self.adjustDebug()
        elif command == &#34;publish&#34;:
            self.publish()
        elif command == &#34;ship&#34;:
            self.ship()

    def loadTf(self):
        C = self.C
        TF = Fabric(locations=C.dataLocation, modules=[C.data[&#34;version&#34;]])
        allFeatures = TF.explore(silent=True, show=True)
        loadableFeatures = allFeatures[&#34;nodes&#34;] + allFeatures[&#34;edges&#34;]
        self.api = TF.load(loadableFeatures, silent=True)

    def makeConfig(self):
        if not getattr(self, &#34;api&#34;, None):
            self.loadTf()
        if not getattr(self, &#34;clientConfig&#34;, None):
            self.makeClientSettings()
        self.dumpConfig()

    def makeCorpus(self):
        if not getattr(self, &#34;api&#34;, None):
            self.loadTf()
        if not getattr(self, &#34;clientConfig&#34;, None):
            self.makeClientSettings()
        TF = self.api.TF

        TF.info(&#34;Recording ...&#34;)
        self.record()

        TF.info(&#34;Dumping ...&#34;)
        self.dumpCorpus()

    def dumpConfig(self):
        C = self.C
        api = self.api
        TF = api.TF
        clientConfig = self.clientConfig

        destData = C.jsCorpusDir
        if not os.path.exists(destData):
            os.makedirs(destData, exist_ok=True)

        fileNameConfig = f&#34;{destData}/{C.client}-configdata.js&#34;

        with open(fileNameConfig, &#34;w&#34;) as fh:
            fh.write(&#34;const configData = &#34;)
            json.dump(clientConfig, fh, ensure_ascii=False, indent=1)
        TF.info(f&#34;Config written to file {fileNameConfig}&#34;)

    def dumpCorpus(self):
        C = self.C
        api = self.api
        TF = api.TF

        data = self.data
        data[&#34;up&#34;] = compress(data[&#34;up&#34;])

        TF.indent(reset=True)
        TF.info(&#34;Dumping data to a single compact json file&#34;)

        destData = C.jsCorpusDir
        if not os.path.exists(destData):
            os.makedirs(destData, exist_ok=True)

        fileNameData = f&#34;{destData}/{C.client}-corpusdata.js&#34;

        with open(fileNameData, &#34;w&#34;) as fh:
            fh.write(&#34;const corpusData = &#34;)
            json.dump(data, fh, ensure_ascii=False, indent=None, separators=(&#34;,&#34;, &#34;:&#34;))
        TF.info(f&#34;Data written to file {fileNameData}&#34;)

    def makeClient(self):
        &#34;&#34;&#34;
        We create a client app in the target directory.

        The client consists of HTML/CSS/PNG files plus a modular Javascript program.

        Module loading does not work when you open the HTML file locally
        (i.e. when the HTML is not served by a server).

        N.B. There is a difference between a local web server serving at `localhost`
        and opening the file directly into your browser by double clicking on it.

        In the first case, you see in your un the URL bar of your browser
        something that starts with
        `http://` or `https://`, in the second case you see `file://` instead.

        Modular Javascript does not work with `file://` origins.

        For that case, we bundle the modules into one,
        and let a «client»-local.html include it

        We also zip the client into {C.client}.zip so that users can download it easily
        &#34;&#34;&#34;

        # copy over the static files

        C = self.C
        lsVersion = C.lsVersion

        for (srcDir, dstDir) in (
            (C.pngInDir, C.pngOutDir),
            (C.cssInDir, C.cssOutDir),
            (C.jsInDir, C.jsOutDir),
            (C.jslibInDir, C.jslibOutDir),
            (C.htmlInDir, C.htmlOutDir),
        ):
            if not os.path.exists(dstDir):
                os.makedirs(dstDir, exist_ok=True)

            with os.scandir(srcDir) as it:
                for entry in it:
                    name = entry.name
                    if not entry.is_file() or name.startswith(&#34;.&#34;):
                        continue
                    srcFile = f&#34;{srcDir}/{name}&#34;
                    if srcFile != C.template:
                        copy(srcFile, f&#34;{dstDir}/{name}&#34;)
        copy(f&#34;{C.staticDir}/{C.favicon}&#34;, f&#34;{C.siteDir}/{C.favicon}&#34;)

        # move the custom files in place

        for (srcFile, dstFile) in (
            (C.clientCss, f&#34;{C.cssOutDir}/{C.client}.css&#34;),
            (C.clientLogo, f&#34;{C.pngOutDir}/{C.client}.png&#34;),
        ):
            copy(srcFile, dstFile)

        # create combined javascript file

        commentRe = re.compile(r&#34;&#34;&#34;[ \t]*/\*.*?\*/[ \t]*&#34;&#34;&#34;, re.S)
        importRe = re.compile(r&#39;&#39;&#39;import\s+\{.*?\}\s+from\s+&#34;[^&#34;]*\.js&#34;&#39;&#39;&#39;, re.S)
        exportRe = re.compile(r&#34;&#34;&#34;^export[ ]+&#34;&#34;&#34;, re.M)
        whiteRe = re.compile(r&#34;&#34;&#34;^\s+$&#34;&#34;&#34;, re.M)
        nlRe = re.compile(r&#34;&#34;&#34;\n\n+&#34;&#34;&#34;)

        def getModule(module):
            with open(f&#34;{C.jsOutDir}/{module}&#34;) as fh:
                text = fh.read()
            text = importRe.sub(&#34;&#34;, text)
            text = exportRe.sub(&#34;&#34;, text)
            text = commentRe.sub(&#34;&#34;, text)
            text = whiteRe.sub(&#34;&#34;, text)
            text = nlRe.sub(&#34;\n&#34;, text)
            return text

        modules = []

        with os.scandir(C.jsOutDir) as it:
            for entry in it:
                name = entry.name
                if (
                    not entry.is_file()
                    or name.startswith(&#34;.&#34;)
                    or not name.endswith(&#34;.js&#34;)
                ):
                    continue
                modules.append(entry.name)
        console(&#34;, &#34;.join(module[0:-3] for module in modules))

        content = {module: getModule(module) for module in modules}

        header = &#34;&#34;&#34;\
/*eslint-env jquery*/
/* global configData */
/* global corpusData */

    &#34;&#34;&#34;
        combined = (
            header
            + content[C.jsDefs]
            + &#34;\n\n&#34;
            + &#34;\n\n&#34;.join(
                text
                for (name, text) in content.items()
                if name not in {C.jsDefs, C.jsApp}
            )
            + &#34;\n\n&#34;
            + content[C.jsApp]
        )
        with open(C.jsDest, &#34;w&#34;) as fh:
            fh.write(combined)
        console(f&#34;Combined js file written to {C.jsDest}&#34;)

        # fill in the html templates

        # index of all clients

        clients = {}

        with os.scandir(C.configDir) as it:
            for entry in it:
                if entry.is_dir():
                    thisClient = entry.name
                    thisConfig = f&#34;{C.configDir}/{thisClient}/config.yaml&#34;
                    if os.path.exists(thisConfig):
                        with open(thisConfig) as fh:
                            desc = yaml.load(fh, Loader=yaml.FullLoader).get(&#34;short&#34;, &#34;&#34;)
                    else:
                        desc = &#34;&#34;
                    clients[thisClient] = desc

        with open(C.index) as fh:
            template = fh.read()
            htmlIndex = template.replace(&#34;«dataset»&#34;, C.dataset)
            htmlIndex = htmlIndex.replace(&#34;«client»&#34;, C.client)

            html = []
            for (thisClient, desc) in clients.items():
                html.append(
                    f&#34;&#34;&#34;
&lt;dt&gt;&lt;a href=&#34;{thisClient}.html&#34;&gt;{thisClient}&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;{desc}&lt;/dd&gt;
&#34;&#34;&#34;
                )

            htmlIndex = htmlIndex.replace(&#34;«clients»&#34;, &#34;&#34;.join(html))

        with open(C.htmlIndex, &#34;w&#34;) as fh:
            fh.write(htmlIndex)
        console(f&#34;html file written to {C.htmlIndex}&#34;)

        # client and client-local

        with open(C.template) as fh:
            template = fh.read()
            htmlNormal = template.replace(
                &#34;«js»&#34;, &#39;&#39;&#39;type=&#34;module&#34; src=&#34;js/app.js«v»&#34;&#39;&#39;&#39;
            )
            htmlNormal = htmlNormal.replace(&#34;«v»&#34;, f&#34;?v={lsVersion}&#34;)
            htmlNormal = htmlNormal.replace(&#34;«dataset»&#34;, C.dataset)
            htmlNormal = htmlNormal.replace(&#34;«client»&#34;, C.client)
            htmlLocal = template.replace(
                &#34;«js»&#34;, f&#39;&#39;&#39;defer src=&#34;corpus/{C.client}/all.js«v»&#34;&#39;&#39;&#39;
            )
            htmlLocal = htmlLocal.replace(&#34;«v»&#34;, f&#34;?v={lsVersion}&#34;)
            htmlLocal = htmlLocal.replace(&#34;«dataset»&#34;, C.dataset)
            htmlLocal = htmlLocal.replace(&#34;«client»&#34;, C.client)

        with open(C.htmlClient, &#34;w&#34;) as fh:
            fh.write(htmlNormal)
        console(f&#34;html file written to {C.htmlClient}&#34;)

        with open(C.htmlLocal, &#34;w&#34;) as fh:
            fh.write(htmlLocal)
        console(f&#34;html file (for use with file://) written to {C.htmlLocal}&#34;)

        # zip the standalone client

        self.zipApp()

    def zipApp(self):
        C = self.C
        items = set(
            &#34;&#34;&#34;
            css
            corpus
            jslib
            png
            favicon.ico
        &#34;&#34;&#34;.strip().split()
        )
        items.add(C.htmlLocalFile)

        zipped = f&#34;{C.siteDir}/{C.client}.zip&#34;

        with ZipFile(zipped, &#34;w&#34;, **ZIP_OPTIONS) as zipFile:
            with os.scandir(C.siteDir) as it:
                for entry in it:
                    file = entry.name
                    if file not in items:
                        continue
                    if entry.is_file():
                        zipFile.write(f&#34;{C.siteDir}/{file}&#34;, arcname=file)
                        console(f&#34;adding {file}&#34;)
                    else:
                        with os.scandir(f&#34;{C.siteDir}/{file}&#34;) as sit:
                            for sentry in sit:
                                sfile = sentry.name
                                if sentry.is_file and not sfile.startswith(&#34;.&#34;):
                                    sfile = f&#34;{file}/{sfile}&#34;
                                    zipFile.write(f&#34;{C.siteDir}/{sfile}&#34;, arcname=sfile)
                                    console(f&#34;adding {sfile}&#34;)
        console(f&#34;Packaged client into {zipped}&#34;)

    def publish(self):
        C = self.C
        os.chdir(C.clientDir)
        deploy(C.org, C.repo)

    def ship(self):
        self.adjustVersion()
        self.adjustDebug()
        self.makeConfig()
        self.makeCorpus()
        self.makeClient()
        self.publish()

    def serve(self):
        C = self.C
        page = self.page
        os.chdir(C.siteDir)

        server = Popen(
            [&#34;python3&#34;, &#34;-m&#34;, &#34;http.server&#34;], stdout=PIPE, bufsize=1, encoding=&#34;utf-8&#34;
        )
        sleep(1)
        webbrowser.open(f&#34;http://localhost:8000/{page}.html&#34;, new=2, autoraise=True)
        stopped = server.poll()
        if not stopped:
            try:
                console(&#34;Press &lt;Ctrl+C&gt; to stop the HTTP server&#34;)
                if server:
                    for line in server.stdout:
                        console(line)
            except KeyboardInterrupt:
                console(&#34;&#34;)
                if server:
                    server.terminate()
                    console(&#34;Http server has stopped&#34;)

    def incVersion(self):
        C = self.C
        lsVersion = C.lsVersion
        parts = lsVersion.split(&#34;@&#34;, 1)
        v = int(parts[0].lstrip(&#34;v&#34;).lstrip(&#34;0&#34;), base=10)
        now = dt.utcnow().isoformat(timespec=&#34;seconds&#34;)
        self.lsVersion = f&#34;v{v + 1:&gt;03}@{now}&#34;
        C.lsVersion = self.lsVersion

    def showVersion(self):
        C = self.C
        lsVersion = C.lsVersion
        versionFile = self.versionFile
        console(f&#34;{lsVersion} (according to {versionFile})&#34;)

    def adjustVersion(self):
        C = self.C
        versionFile = self.versionFile

        currentVersion = C.lsVersion
        self.incVersion()
        newVersion = C.lsVersion

        with open(versionFile, &#34;w&#34;) as fh:
            yaml.dump(dict(lsVersion=newVersion), fh)

        console(f&#34;Version went from `{currentVersion}` to `{newVersion}`&#34;)

    def replaceDebug(self, mask, value):
        def subVersion(match):
            return mask.format(value)

        return subVersion

    def getDebugs(self):
        C = self.C

        debugs = {}
        good = True

        for (key, c) in C.debugConfig.items():
            cfile = c[&#34;file&#34;]
            with open(cfile) as fh:
                text = fh.read()
            match = c[&#34;re&#34;].search(text)
            if not match:
                console(f&#34;No debug found in {cfile}&#34;)
                good = False
                continue
            debug = match.group(1)
            debugs[cfile] = debug

        if not good:
            quit()
        return debugs

    def showDebug(self):
        debugInfo = self.getDebugs()

        for (source, debug) in debugInfo.items():
            console(f&#34;{debug} (according to {source})&#34;)

    def adjustDebug(self):
        C = self.C
        debugState = self.debugState

        self.showDebug()

        newValue = &#34;true&#34; if debugState == &#34;on&#34; else &#34;false&#34;

        for (key, c) in C.debugConfig.items():
            console(f&#39;Adjusting debug in {c[&#34;file&#34;]}&#39;)
            with open(c[&#34;file&#34;]) as fh:
                text = fh.read()
            text = c[&#34;re&#34;].sub(self.replaceDebug(c[&#34;mask&#34;], newValue), text)
            with open(c[&#34;file&#34;], &#34;w&#34;) as fh:
                fh.write(text)

        console(f&#34;Debug set to {newValue}&#34;)
        self.showDebug()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tf.client.make.build.Make.adjustDebug"><code class="name flex">
<span>def <span class="ident">adjustDebug</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L934-L951" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def adjustDebug(self):
    C = self.C
    debugState = self.debugState

    self.showDebug()

    newValue = &#34;true&#34; if debugState == &#34;on&#34; else &#34;false&#34;

    for (key, c) in C.debugConfig.items():
        console(f&#39;Adjusting debug in {c[&#34;file&#34;]}&#39;)
        with open(c[&#34;file&#34;]) as fh:
            text = fh.read()
        text = c[&#34;re&#34;].sub(self.replaceDebug(c[&#34;mask&#34;], newValue), text)
        with open(c[&#34;file&#34;], &#34;w&#34;) as fh:
            fh.write(text)

    console(f&#34;Debug set to {newValue}&#34;)
    self.showDebug()</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.adjustVersion"><code class="name flex">
<span>def <span class="ident">adjustVersion</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L887-L898" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def adjustVersion(self):
    C = self.C
    versionFile = self.versionFile

    currentVersion = C.lsVersion
    self.incVersion()
    newVersion = C.lsVersion

    with open(versionFile, &#34;w&#34;) as fh:
        yaml.dump(dict(lsVersion=newVersion), fh)

    console(f&#34;Version went from `{currentVersion}` to `{newVersion}`&#34;)</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.config"><code class="name flex">
<span>def <span class="ident">config</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L169-L417" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def config(self):
    C = self.C
    dataset = self.dataset
    client = self.client
    versionFile = f&#34;{STATIC_DIR}/version.yaml&#34;
    self.versionFile = versionFile

    with open(versionFile) as fh:
        settings = yaml.load(fh, Loader=yaml.FullLoader)
        lsVersion = settings[&#34;lsVersion&#34;]

    c = dict(
        dataset=dataset,
        client=client,
        lsVersion=lsVersion,
        gh=os.path.expanduser(&#34;~/github&#34;),
        ghUrl=&#34;https://github.com&#34;,
        nbUrl=&#34;https://nbviewer.jupyter.org/github&#34;,
        ghPages=&#34;github.io&#34;,
        nbTutUrl=&#34;«nbUrl»/annotation/tutorials/tree/master&#34;,
        lsDocUrl=f&#34;https://«org».«ghPages»/{T_F}/tf/about/clientmanual.html&#34;,
        org=&#34;annotation&#34;,
        repo=&#34;app-«dataset»&#34;,
        rel=&#34;site&#34;,
        generatorUrl=f&#34;«ghUrl»/«org»/{T_F}/tree/master/tf/client&#34;,
        sourceUrl=&#34;«ghUrl»/«org»/«repo»&#34;,
        issueUrl=&#34;«sourceUrl»/issues&#34;,
        tutUrl=&#34;«nbTutUrl»/«dataset»/start.ipynb&#34;,
        staticDir=STATIC_DIR,
        clientDir=&#34;«gh»/«org»/«repo»&#34;,
        configDir=f&#34;«clientDir»/{LS}&#34;,
        lsConfig=&#34;«configDir»/config.yaml&#34;,
        clientConfig=&#34;«configDir»/«client»/config.yaml&#34;,
        clientMake=&#34;mkdata&#34;,
        clientMakeDir=&#34;«configDir»/«client»&#34;,
        clientMakeFile=&#34;«clientMakeDir»/«clientMake».py&#34;,
        clientCss=&#34;«configDir»/«client»/custom.css&#34;,
        clientLogo=&#34;«configDir»/«client»/logo.png&#34;,
        pngInDir=&#34;«staticDir»/png&#34;,
        cssInDir=&#34;«staticDir»/css&#34;,
        htmlInDir=&#34;«staticDir»/html&#34;,
        jsInDir=&#34;«staticDir»/js&#34;,
        jslibInDir=&#34;«staticDir»/jslib&#34;,
        template=&#34;«htmlInDir»/template.html&#34;,
        index=&#34;«htmlInDir»/index.html&#34;,
        siteDir=&#34;«clientDir»/«rel»&#34;,
        pngOutDir=&#34;«siteDir»/png&#34;,
        cssOutDir=&#34;«siteDir»/css&#34;,
        htmlOutDir=&#34;«siteDir»&#34;,
        jsOutDir=&#34;«siteDir»/js&#34;,
        jslibOutDir=&#34;«siteDir»/jslib&#34;,
        jsCorpusDir=&#34;«siteDir»/corpus&#34;,
        jsApp=&#34;app.js&#34;,
        jsDefs=&#34;defs.js&#34;,
        jsDest=&#34;«jsCorpusDir»/«client»-all.js&#34;,
        htmlIndex=&#34;«siteDir»/index.html&#34;,
        htmlClient=&#34;«siteDir»/«client».html&#34;,
        htmlLocalFile=&#34;«client»-local.html&#34;,
        htmlLocal=&#34;«siteDir»/«htmlLocalFile»&#34;,
        favicon=&#34;favicon.ico&#34;,
        packageUrl=&#34;https://«org».«ghPages»/«repo»/«client».zip&#34;,
    )

    fillRe = re.compile(r&#34;«([a-zA-Z0-9_.]+)»&#34;)

    def fillSub(match):
        k = match.group(1)
        parts = k.split(&#34;.&#34;, 1)
        return (
            c.get(parts[0], {}).get(parts[1], &#34;&#34;)
            if len(parts) == 2
            else c.get(parts[0], &#34;&#34;)
        )

    def fillin(src, k, v):
        if type(v) is str:
            while fillRe.search(v):
                v = fillRe.sub(fillSub, v)
            src[k] = v
        if type(v) is dict:
            for (m, w) in v.items():
                fillin(src[k], m, w)
        if type(v) in {list, tuple}:
            if type(v) is tuple:
                src[k] = list(v)
            for (m, w) in enumerate(v):
                fillin(src[k], m, w)

    for (k, v) in c.items():
        fillin(c, k, v)

    lsConfig = c[&#34;lsConfig&#34;]
    if not os.path.exists(lsConfig):
        console(f&#34;No config.yaml found for {dataset}: {lsConfig}&#34;)
        quit()

    with open(lsConfig) as fh:
        settings = yaml.load(fh, Loader=yaml.FullLoader)
        for (k, v) in settings.items():
            c[k] = v
            fillin(c, k, v)

    clientConfig = c[&#34;clientConfig&#34;]
    if not os.path.exists(clientConfig):
        console(f&#34;No config.yaml found for {dataset}:{client}: {clientConfig}&#34;)
        quit()

    with open(clientConfig) as fh:
        settings = yaml.load(fh, Loader=yaml.FullLoader)
        for (k, v) in settings.items():
            c[k] = v
            fillin(c, k, v)

    clientMake = c[&#34;clientMake&#34;]
    clientMakeDir = c[&#34;clientMakeDir&#34;]
    clientMakeFile = c[&#34;clientMakeFile&#34;]

    try:
        moduleName = f&#34;ls.{dataset}.{client}.{clientMake}&#34;
        spec = util.spec_from_file_location(moduleName, clientMakeFile)
        code = util.module_from_spec(spec)
        sys.path.insert(0, clientMakeDir)
        spec.loader.exec_module(code)
        sys.path.pop(0)
        self.makeLegends = types.MethodType(code.makeLegends, self)
        self.record = types.MethodType(code.record, self)

    except Exception as e:
        console(f&#34;Cannot make data for {dataset}:{client}: {str(e)}&#34;)
        quit()

    d = dict(
        dataLocation=&#34;«gh»/«data.org»/«data.repo»/«data.rel»&#34;,
        dataUrl=&#34;«ghUrl»/«data.org»/«data.repo»/tree/master/tf/«data.version»&#34;,
        writingUrl=&#34;https://«org».«ghPages»/text-fabric/tf/writing/«writing».html&#34;,
        urls=dict(
            cheatsheet=(
                &#34;regexp cheatsheet&#34;,
                (
                    &#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/&#34;
                    &#34;Regular_Expressions/Cheatsheet&#34;
                ),
                &#34;cheatsheet of regular expressions&#34;,
            ),
            license=(
                &#34;license&#34;,
                &#34;https://mit-license.org&#34;,
                &#34;website of MIT license&#34;,
            ),
            maker=(
                None,
                &#34;https://dans.knaw.nl/en/front-page?set_language=en&#34;,
                &#34;Website of DANS = Data Archiving and Networked Services&#34;,
            ),
            corpus=(
                None,
                &#34;«corpus.url»&#34;,
                &#34;«corpus.tip»&#34;,
            ),
            corpus2=(
                &#34;«corpus.text»&#34;,
                &#34;«corpus.url»&#34;,
                &#34;«corpus.tip»&#34;,
            ),
            author=(
                &#34;Dirk Roorda&#34;,
                &#34;https://pure.knaw.nl/portal/en/persons/dirk-roorda&#34;,
                &#34;profile of the author&#34;,
            ),
            author1=(
                &#34;«author1.text»&#34;,
                &#34;«author1.url»&#34;,
                &#34;«author1.tip»&#34;,
            ),
            author2=(
                &#34;«author2.text»&#34;,
                &#34;«author2.url»&#34;,
                &#34;«author2.tip»&#34;,
            ),
            tf=(
                None,
                &#34;https://«org».«ghPages»/text-fabric/tf/&#34;,
                &#34;Text-Fabric documentation website&#34;,
            ),
            lsdoc=(
                &#34;user manual&#34;,
                &#34;«lsDocUrl»&#34;,
                &#34;user manual for this search interface&#34;,
            ),
            datadoc=(
                &#34;data (feature) documentation&#34;,
                &#34;«data.docUrl»&#34;,
                &#34;explanation of the features in the dataset&#34;,
            ),
            data=(
                &#34;based on text-fabric data version «data.version»&#34;,
                &#34;«dataUrl»&#34;,
                &#34;online repository of the underlying text-fabric data&#34;,
            ),
            generator=(
                f&#34;{T_F}/client&#34;,
                &#34;«generatorUrl»&#34;,
                &#34;source code of the generator of this search interface&#34;,
            ),
            source=(
                &#34;«repo»&#34;,
                &#34;«sourceUrl»&#34;,
                &#34;source code of the definition of this search interface&#34;,
            ),
            issue=(
                &#34;Report an issue&#34;,
                &#34;«issueUrl»&#34;,
                &#34;report issues&#34;,
            ),
            package=(
                &#34;download&#34;,
                &#34;«packageUrl»&#34;,
                &#34;zip file for offline use&#34;,
            ),
            writing=(
                &#34;«writing»&#34;,
                &#34;«writingUrl»&#34;,
                &#34;characters and transliteration for «writing»&#34;,
            ),
            related=(
                &#34;text-fabric «dataset»&#34;,
                &#34;«tutUrl»&#34;,
                &#34;using Text-Fabric on the same corpus&#34;,
            ),
        ),
    )

    for (k, v) in d.items():
        c[k] = v
        fillin(c, k, v)

    setattr(
        C,
        &#34;debugConfig&#34;,
        dict(
            setup=dict(
                file=f&#34;{c[&#39;jsOutDir&#39;]}/{c[&#39;jsDefs&#39;]}&#34;,
                re=re.compile(r&#34;&#34;&#34;export const DEBUG = ([a-z]+)&#34;&#34;&#34;),
                mask=&#34;export const DEBUG = {}&#34;,
            ),
        ),
    )
    for (k, v) in c.items():
        setattr(C, k, v)</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.dumpConfig"><code class="name flex">
<span>def <span class="ident">dumpConfig</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L583-L598" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dumpConfig(self):
    C = self.C
    api = self.api
    TF = api.TF
    clientConfig = self.clientConfig

    destData = C.jsCorpusDir
    if not os.path.exists(destData):
        os.makedirs(destData, exist_ok=True)

    fileNameConfig = f&#34;{destData}/{C.client}-configdata.js&#34;

    with open(fileNameConfig, &#34;w&#34;) as fh:
        fh.write(&#34;const configData = &#34;)
        json.dump(clientConfig, fh, ensure_ascii=False, indent=1)
    TF.info(f&#34;Config written to file {fileNameConfig}&#34;)</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.dumpCorpus"><code class="name flex">
<span>def <span class="ident">dumpCorpus</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L600-L620" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dumpCorpus(self):
    C = self.C
    api = self.api
    TF = api.TF

    data = self.data
    data[&#34;up&#34;] = compress(data[&#34;up&#34;])

    TF.indent(reset=True)
    TF.info(&#34;Dumping data to a single compact json file&#34;)

    destData = C.jsCorpusDir
    if not os.path.exists(destData):
        os.makedirs(destData, exist_ok=True)

    fileNameData = f&#34;{destData}/{C.client}-corpusdata.js&#34;

    with open(fileNameData, &#34;w&#34;) as fh:
        fh.write(&#34;const corpusData = &#34;)
        json.dump(data, fh, ensure_ascii=False, indent=None, separators=(&#34;,&#34;, &#34;:&#34;))
    TF.info(f&#34;Data written to file {fileNameData}&#34;)</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.getDebugs"><code class="name flex">
<span>def <span class="ident">getDebugs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L906-L926" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getDebugs(self):
    C = self.C

    debugs = {}
    good = True

    for (key, c) in C.debugConfig.items():
        cfile = c[&#34;file&#34;]
        with open(cfile) as fh:
            text = fh.read()
        match = c[&#34;re&#34;].search(text)
        if not match:
            console(f&#34;No debug found in {cfile}&#34;)
            good = False
            continue
        debug = match.group(1)
        debugs[cfile] = debug

    if not good:
        quit()
    return debugs</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.incVersion"><code class="name flex">
<span>def <span class="ident">incVersion</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L872-L879" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def incVersion(self):
    C = self.C
    lsVersion = C.lsVersion
    parts = lsVersion.split(&#34;@&#34;, 1)
    v = int(parts[0].lstrip(&#34;v&#34;).lstrip(&#34;0&#34;), base=10)
    now = dt.utcnow().isoformat(timespec=&#34;seconds&#34;)
    self.lsVersion = f&#34;v{v + 1:&gt;03}@{now}&#34;
    C.lsVersion = self.lsVersion</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.loadTf"><code class="name flex">
<span>def <span class="ident">loadTf</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L556-L561" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def loadTf(self):
    C = self.C
    TF = Fabric(locations=C.dataLocation, modules=[C.data[&#34;version&#34;]])
    allFeatures = TF.explore(silent=True, show=True)
    loadableFeatures = allFeatures[&#34;nodes&#34;] + allFeatures[&#34;edges&#34;]
    self.api = TF.load(loadableFeatures, silent=True)</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L523-L554" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def main(self):
    self.readArgs()

    command = self.command

    if not command:
        quit()

    self.config()

    if command == &#34;serve&#34;:
        self.serve()
    elif command == &#34;v&#34;:
        self.showVersion()
    elif command == &#34;i&#34;:
        self.adjustVersion()
    elif command == &#34;debug&#34;:
        self.adjustDebug()
    elif command == &#34;config&#34;:
        self.makeConfig()
    elif command == &#34;corpus&#34;:
        self.makeCorpus()
    elif command == &#34;client&#34;:
        self.makeClient()
    elif command == &#34;clientdebug&#34;:
        self.makeClient()
        self.debugState = &#34;on&#34;
        self.adjustDebug()
    elif command == &#34;publish&#34;:
        self.publish()
    elif command == &#34;ship&#34;:
        self.ship()</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.makeClient"><code class="name flex">
<span>def <span class="ident">makeClient</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>We create a client app in the target directory.</p>
<p>The client consists of HTML/CSS/PNG files plus a modular Javascript program.</p>
<p>Module loading does not work when you open the HTML file locally
(i.e. when the HTML is not served by a server).</p>
<p>N.B. There is a difference between a local web server serving at <code>localhost</code>
and opening the file directly into your browser by double clicking on it.</p>
<p>In the first case, you see in your un the URL bar of your browser
something that starts with
<code>http://</code> or <code>https://</code>, in the second case you see <code>file://</code> instead.</p>
<p>Modular Javascript does not work with <code>file://</code> origins.</p>
<p>For that case, we bundle the modules into one,
and let a «client»-local.html include it</p>
<p>We also zip the client into {C.client}.zip so that users can download it easily</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L622-L800" class="git-link">Browse git</a>
</summary>
<pre><code class="python">    def makeClient(self):
        &#34;&#34;&#34;
        We create a client app in the target directory.

        The client consists of HTML/CSS/PNG files plus a modular Javascript program.

        Module loading does not work when you open the HTML file locally
        (i.e. when the HTML is not served by a server).

        N.B. There is a difference between a local web server serving at `localhost`
        and opening the file directly into your browser by double clicking on it.

        In the first case, you see in your un the URL bar of your browser
        something that starts with
        `http://` or `https://`, in the second case you see `file://` instead.

        Modular Javascript does not work with `file://` origins.

        For that case, we bundle the modules into one,
        and let a «client»-local.html include it

        We also zip the client into {C.client}.zip so that users can download it easily
        &#34;&#34;&#34;

        # copy over the static files

        C = self.C
        lsVersion = C.lsVersion

        for (srcDir, dstDir) in (
            (C.pngInDir, C.pngOutDir),
            (C.cssInDir, C.cssOutDir),
            (C.jsInDir, C.jsOutDir),
            (C.jslibInDir, C.jslibOutDir),
            (C.htmlInDir, C.htmlOutDir),
        ):
            if not os.path.exists(dstDir):
                os.makedirs(dstDir, exist_ok=True)

            with os.scandir(srcDir) as it:
                for entry in it:
                    name = entry.name
                    if not entry.is_file() or name.startswith(&#34;.&#34;):
                        continue
                    srcFile = f&#34;{srcDir}/{name}&#34;
                    if srcFile != C.template:
                        copy(srcFile, f&#34;{dstDir}/{name}&#34;)
        copy(f&#34;{C.staticDir}/{C.favicon}&#34;, f&#34;{C.siteDir}/{C.favicon}&#34;)

        # move the custom files in place

        for (srcFile, dstFile) in (
            (C.clientCss, f&#34;{C.cssOutDir}/{C.client}.css&#34;),
            (C.clientLogo, f&#34;{C.pngOutDir}/{C.client}.png&#34;),
        ):
            copy(srcFile, dstFile)

        # create combined javascript file

        commentRe = re.compile(r&#34;&#34;&#34;[ \t]*/\*.*?\*/[ \t]*&#34;&#34;&#34;, re.S)
        importRe = re.compile(r&#39;&#39;&#39;import\s+\{.*?\}\s+from\s+&#34;[^&#34;]*\.js&#34;&#39;&#39;&#39;, re.S)
        exportRe = re.compile(r&#34;&#34;&#34;^export[ ]+&#34;&#34;&#34;, re.M)
        whiteRe = re.compile(r&#34;&#34;&#34;^\s+$&#34;&#34;&#34;, re.M)
        nlRe = re.compile(r&#34;&#34;&#34;\n\n+&#34;&#34;&#34;)

        def getModule(module):
            with open(f&#34;{C.jsOutDir}/{module}&#34;) as fh:
                text = fh.read()
            text = importRe.sub(&#34;&#34;, text)
            text = exportRe.sub(&#34;&#34;, text)
            text = commentRe.sub(&#34;&#34;, text)
            text = whiteRe.sub(&#34;&#34;, text)
            text = nlRe.sub(&#34;\n&#34;, text)
            return text

        modules = []

        with os.scandir(C.jsOutDir) as it:
            for entry in it:
                name = entry.name
                if (
                    not entry.is_file()
                    or name.startswith(&#34;.&#34;)
                    or not name.endswith(&#34;.js&#34;)
                ):
                    continue
                modules.append(entry.name)
        console(&#34;, &#34;.join(module[0:-3] for module in modules))

        content = {module: getModule(module) for module in modules}

        header = &#34;&#34;&#34;\
/*eslint-env jquery*/
/* global configData */
/* global corpusData */

    &#34;&#34;&#34;
        combined = (
            header
            + content[C.jsDefs]
            + &#34;\n\n&#34;
            + &#34;\n\n&#34;.join(
                text
                for (name, text) in content.items()
                if name not in {C.jsDefs, C.jsApp}
            )
            + &#34;\n\n&#34;
            + content[C.jsApp]
        )
        with open(C.jsDest, &#34;w&#34;) as fh:
            fh.write(combined)
        console(f&#34;Combined js file written to {C.jsDest}&#34;)

        # fill in the html templates

        # index of all clients

        clients = {}

        with os.scandir(C.configDir) as it:
            for entry in it:
                if entry.is_dir():
                    thisClient = entry.name
                    thisConfig = f&#34;{C.configDir}/{thisClient}/config.yaml&#34;
                    if os.path.exists(thisConfig):
                        with open(thisConfig) as fh:
                            desc = yaml.load(fh, Loader=yaml.FullLoader).get(&#34;short&#34;, &#34;&#34;)
                    else:
                        desc = &#34;&#34;
                    clients[thisClient] = desc

        with open(C.index) as fh:
            template = fh.read()
            htmlIndex = template.replace(&#34;«dataset»&#34;, C.dataset)
            htmlIndex = htmlIndex.replace(&#34;«client»&#34;, C.client)

            html = []
            for (thisClient, desc) in clients.items():
                html.append(
                    f&#34;&#34;&#34;
&lt;dt&gt;&lt;a href=&#34;{thisClient}.html&#34;&gt;{thisClient}&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;{desc}&lt;/dd&gt;
&#34;&#34;&#34;
                )

            htmlIndex = htmlIndex.replace(&#34;«clients»&#34;, &#34;&#34;.join(html))

        with open(C.htmlIndex, &#34;w&#34;) as fh:
            fh.write(htmlIndex)
        console(f&#34;html file written to {C.htmlIndex}&#34;)

        # client and client-local

        with open(C.template) as fh:
            template = fh.read()
            htmlNormal = template.replace(
                &#34;«js»&#34;, &#39;&#39;&#39;type=&#34;module&#34; src=&#34;js/app.js«v»&#34;&#39;&#39;&#39;
            )
            htmlNormal = htmlNormal.replace(&#34;«v»&#34;, f&#34;?v={lsVersion}&#34;)
            htmlNormal = htmlNormal.replace(&#34;«dataset»&#34;, C.dataset)
            htmlNormal = htmlNormal.replace(&#34;«client»&#34;, C.client)
            htmlLocal = template.replace(
                &#34;«js»&#34;, f&#39;&#39;&#39;defer src=&#34;corpus/{C.client}/all.js«v»&#34;&#39;&#39;&#39;
            )
            htmlLocal = htmlLocal.replace(&#34;«v»&#34;, f&#34;?v={lsVersion}&#34;)
            htmlLocal = htmlLocal.replace(&#34;«dataset»&#34;, C.dataset)
            htmlLocal = htmlLocal.replace(&#34;«client»&#34;, C.client)

        with open(C.htmlClient, &#34;w&#34;) as fh:
            fh.write(htmlNormal)
        console(f&#34;html file written to {C.htmlClient}&#34;)

        with open(C.htmlLocal, &#34;w&#34;) as fh:
            fh.write(htmlLocal)
        console(f&#34;html file (for use with file://) written to {C.htmlLocal}&#34;)

        # zip the standalone client

        self.zipApp()</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.makeClientSettings"><code class="name flex">
<span>def <span class="ident">makeClientSettings</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L419-L521" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeClientSettings(self):
    C = self.C
    layerSettings = C.layerSettings
    api = self.api
    Cp = api.C

    self.makeLegends()

    typeSeq = list(layerSettings)
    typesLower = {}

    for (i, tp) in enumerate(typeSeq):
        typesLower[tp] = typeSeq[0 : i + 1]

    # set up the configuration that informs the client code
    # and the code that generates the data for the client

    clientConfig = dict(
        defs=dict(
            lsVersion=C.lsVersion,
            dataset=C.dataset,
            client=C.client,
            org=C.org,
            repo=C.repo,
            urls=C.urls,
            description=C.description,
        ),
        ntypes=typeSeq,
        typesLower=typesLower,
    )

    # check visible- and focus- attributes

    theFocuses = []
    theVisibles = []

    for (nType, typeInfo) in layerSettings.items():
        if typeInfo.get(&#34;focus&#34;, False):
            theFocuses.append(nType)

        for (name, layerInfo) in layerSettings[nType].get(&#34;layers&#34;, {}).items():
            if layerInfo.get(&#34;visible&#34;, False):
                theVisibles.append((nType, name))
            theMap = layerInfo.get(&#34;legend&#34;, None)
            if theMap is not None:
                default = layerInfo.get(&#34;default&#34;, None)
                if default is not None:
                    theMap[&#34;&#34;] = default

    if len(theFocuses) == 0:
        focusType = None
        console(&#34;No node type is declared as result focus\n&#34;)
    else:
        focusType = theFocuses[0]
        if len(theFocuses) &gt; 1:
            console(
                &#34;Multiple node types declared as result focus:\n&#34;
            )
            console(&#34;\t&#34; + (&#34;, &#34;.join(theFocuses)) + &#34;\n&#34;)
        else:
            console(&#34;Node type declared as result focus:\n&#34;)
            console(f&#34;\t{focusType}\n&#34;)

    clientConfig[&#34;focusType&#34;] = focusType

    if len(theVisibles) == 0:
        console(&#34;No layer type is declared as visible in the result (&#39;visible&#39;)\n&#34;)
    else:
        console(&#34;Layers declared as visible in the result (&#39;visible&#39;):\n&#34;)
        console(&#34;\t&#34; + (&#34;, &#34;.join(&#34;/&#34;.join(s) for s in theVisibles)) + &#34;\n&#34;)

    visible = {}
    layers = {}
    levels = {}

    for (nType, typeInfo) in layerSettings.items():
        levels[nType] = typeInfo.get(&#34;description&#34;, &#34;&#34;)
        ti = typeInfo.get(&#34;layers&#34;, None)
        if ti is None:
            continue

        visible[nType] = {name: ti[name].get(&#34;visible&#34;, False) for name in ti}
        layers[nType] = {
            name: dict(
                valueMap=invertMap(ti[name].get(&#34;legend&#34;, None)),
                tip=ti[name].get(&#34;tip&#34;, False),
                pos=ti[name][&#34;pos&#34;] or name,
                pattern=ti[name].get(&#34;example&#34;, &#34;&#34;),
                description=ti[name].get(&#34;description&#34;, &#34;&#34;),
            )
            for name in ti
        }

    clientConfig |= dict(
        ntypesinit={level[0]: level[2] for level in Cp.levels.data},
        ntypessize={level[0]: level[3] - level[2] + 1 for level in Cp.levels.data},
        dtypeOf={typeSeq[i + 1]: tp for (i, tp) in enumerate(typeSeq[0:-1])},
        utypeOf={tp: typeSeq[i + 1] for (i, tp) in enumerate(typeSeq[0:-1])},
        visible=visible,
        levels=levels,
        layers=layers,
    )
    self.clientConfig = clientConfig</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.makeConfig"><code class="name flex">
<span>def <span class="ident">makeConfig</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L563-L568" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeConfig(self):
    if not getattr(self, &#34;api&#34;, None):
        self.loadTf()
    if not getattr(self, &#34;clientConfig&#34;, None):
        self.makeClientSettings()
    self.dumpConfig()</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.makeCorpus"><code class="name flex">
<span>def <span class="ident">makeCorpus</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L570-L581" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeCorpus(self):
    if not getattr(self, &#34;api&#34;, None):
        self.loadTf()
    if not getattr(self, &#34;clientConfig&#34;, None):
        self.makeClientSettings()
    TF = self.api.TF

    TF.info(&#34;Recording ...&#34;)
    self.record()

    TF.info(&#34;Dumping ...&#34;)
    self.dumpCorpus()</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.publish"><code class="name flex">
<span>def <span class="ident">publish</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L836-L839" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def publish(self):
    C = self.C
    os.chdir(C.clientDir)
    deploy(C.org, C.repo)</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.readArgs"><code class="name flex">
<span>def <span class="ident">readArgs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L105-L167" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readArgs(self):
    args = sys.argv[1:]
    if not len(args) or args[0] in {&#34;-h&#34;, &#34;--help&#34;, &#34;help&#34;}:
        console(HELP)
        console(&#34;Missing dataset and client&#34;)
        quit()

    dataset = args[0]
    self.dataset = dataset
    args = args[1:]

    if not len(args) or args[0] in {&#34;-h&#34;, &#34;--help&#34;, &#34;help&#34;}:
        console(HELP)
        console(&#34;Missing client&#34;)
        quit()

    client = args[0]
    self.client = client
    args = args[1:]

    if not len(args) or args[0] in {&#34;-h&#34;, &#34;--help&#34;, &#34;help&#34;}:
        console(HELP)
        if not len(args):
            console(&#34;No command given&#34;)
        quit()

    command = args[0]
    self.command = command
    self.page = None
    self.message = None
    self.debugState = None
    self.remaining = []

    if command not in {
        &#34;serve&#34;,
        &#34;v&#34;,
        &#34;i&#34;,
        &#34;config&#34;,
        &#34;corpus&#34;,
        &#34;client&#34;,
        &#34;clientdebug&#34;,
        &#34;debug&#34;,
        &#34;publish&#34;,
        &#34;ship&#34;,
    }:
        console(HELP)
        console(f&#34;Wrong arguments: «{&#39; &#39;.join(args)}»&#34;)
        quit()

    if command in {&#34;serve&#34;}:
        if len(args) &lt; 2:
            self.page = client
        else:
            self.page = args[1]
            self.remaining = args[2:]

    elif command in {&#34;debug&#34;}:
        if len(args) &lt; 2 or args[1] not in {&#34;on&#34;, &#34;off&#34;}:
            console(&#34;say on or off&#34;)
            quit()

        self.debugState = args[1]
        self.remaining = args[2:]</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.replaceDebug"><code class="name flex">
<span>def <span class="ident">replaceDebug</span></span>(<span>self, mask, value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L900-L904" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def replaceDebug(self, mask, value):
    def subVersion(match):
        return mask.format(value)

    return subVersion</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.serve"><code class="name flex">
<span>def <span class="ident">serve</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L849-L870" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def serve(self):
    C = self.C
    page = self.page
    os.chdir(C.siteDir)

    server = Popen(
        [&#34;python3&#34;, &#34;-m&#34;, &#34;http.server&#34;], stdout=PIPE, bufsize=1, encoding=&#34;utf-8&#34;
    )
    sleep(1)
    webbrowser.open(f&#34;http://localhost:8000/{page}.html&#34;, new=2, autoraise=True)
    stopped = server.poll()
    if not stopped:
        try:
            console(&#34;Press &lt;Ctrl+C&gt; to stop the HTTP server&#34;)
            if server:
                for line in server.stdout:
                    console(line)
        except KeyboardInterrupt:
            console(&#34;&#34;)
            if server:
                server.terminate()
                console(&#34;Http server has stopped&#34;)</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.ship"><code class="name flex">
<span>def <span class="ident">ship</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L841-L847" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ship(self):
    self.adjustVersion()
    self.adjustDebug()
    self.makeConfig()
    self.makeCorpus()
    self.makeClient()
    self.publish()</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.showDebug"><code class="name flex">
<span>def <span class="ident">showDebug</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L928-L932" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def showDebug(self):
    debugInfo = self.getDebugs()

    for (source, debug) in debugInfo.items():
        console(f&#34;{debug} (according to {source})&#34;)</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.showVersion"><code class="name flex">
<span>def <span class="ident">showVersion</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L881-L885" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def showVersion(self):
    C = self.C
    lsVersion = C.lsVersion
    versionFile = self.versionFile
    console(f&#34;{lsVersion} (according to {versionFile})&#34;)</code></pre>
</details>
</dd>
<dt id="tf.client.make.build.Make.zipApp"><code class="name flex">
<span>def <span class="ident">zipApp</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/fff46c13a10eed971be059ef7d04e1821a5ded05/tf/client/make/build.py#L802-L834" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def zipApp(self):
    C = self.C
    items = set(
        &#34;&#34;&#34;
        css
        corpus
        jslib
        png
        favicon.ico
    &#34;&#34;&#34;.strip().split()
    )
    items.add(C.htmlLocalFile)

    zipped = f&#34;{C.siteDir}/{C.client}.zip&#34;

    with ZipFile(zipped, &#34;w&#34;, **ZIP_OPTIONS) as zipFile:
        with os.scandir(C.siteDir) as it:
            for entry in it:
                file = entry.name
                if file not in items:
                    continue
                if entry.is_file():
                    zipFile.write(f&#34;{C.siteDir}/{file}&#34;, arcname=file)
                    console(f&#34;adding {file}&#34;)
                else:
                    with os.scandir(f&#34;{C.siteDir}/{file}&#34;) as sit:
                        for sentry in sit:
                            sfile = sentry.name
                            if sentry.is_file and not sfile.startswith(&#34;.&#34;):
                                sfile = f&#34;{file}/{sfile}&#34;
                                zipFile.write(f&#34;{C.siteDir}/{sfile}&#34;, arcname=sfile)
                                console(f&#34;adding {sfile}&#34;)
    console(f&#34;Packaged client into {zipped}&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../../tf/index.html">tf home</a> -
<a href="../../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#usage">Usage</a><ul>
<li><a href="#prerequisites">Prerequisites</a></li>
<li><a href="#commands">Commands</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.client.make" href="index.html">tf.client.make</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tf.client.make.build.compress" href="#tf.client.make.build.compress">compress</a></code></li>
<li><code><a title="tf.client.make.build.console" href="#tf.client.make.build.console">console</a></code></li>
<li><code><a title="tf.client.make.build.invertMap" href="#tf.client.make.build.invertMap">invertMap</a></code></li>
<li><code><a title="tf.client.make.build.main" href="#tf.client.make.build.main">main</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.client.make.build.Make" href="#tf.client.make.build.Make">Make</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.client.make.build.Make.adjustDebug" href="#tf.client.make.build.Make.adjustDebug">adjustDebug</a></code></li>
<li><code><a title="tf.client.make.build.Make.adjustVersion" href="#tf.client.make.build.Make.adjustVersion">adjustVersion</a></code></li>
<li><code><a title="tf.client.make.build.Make.config" href="#tf.client.make.build.Make.config">config</a></code></li>
<li><code><a title="tf.client.make.build.Make.dumpConfig" href="#tf.client.make.build.Make.dumpConfig">dumpConfig</a></code></li>
<li><code><a title="tf.client.make.build.Make.dumpCorpus" href="#tf.client.make.build.Make.dumpCorpus">dumpCorpus</a></code></li>
<li><code><a title="tf.client.make.build.Make.getDebugs" href="#tf.client.make.build.Make.getDebugs">getDebugs</a></code></li>
<li><code><a title="tf.client.make.build.Make.incVersion" href="#tf.client.make.build.Make.incVersion">incVersion</a></code></li>
<li><code><a title="tf.client.make.build.Make.loadTf" href="#tf.client.make.build.Make.loadTf">loadTf</a></code></li>
<li><code><a title="tf.client.make.build.Make.main" href="#tf.client.make.build.Make.main">main</a></code></li>
<li><code><a title="tf.client.make.build.Make.makeClient" href="#tf.client.make.build.Make.makeClient">makeClient</a></code></li>
<li><code><a title="tf.client.make.build.Make.makeClientSettings" href="#tf.client.make.build.Make.makeClientSettings">makeClientSettings</a></code></li>
<li><code><a title="tf.client.make.build.Make.makeConfig" href="#tf.client.make.build.Make.makeConfig">makeConfig</a></code></li>
<li><code><a title="tf.client.make.build.Make.makeCorpus" href="#tf.client.make.build.Make.makeCorpus">makeCorpus</a></code></li>
<li><code><a title="tf.client.make.build.Make.publish" href="#tf.client.make.build.Make.publish">publish</a></code></li>
<li><code><a title="tf.client.make.build.Make.readArgs" href="#tf.client.make.build.Make.readArgs">readArgs</a></code></li>
<li><code><a title="tf.client.make.build.Make.replaceDebug" href="#tf.client.make.build.Make.replaceDebug">replaceDebug</a></code></li>
<li><code><a title="tf.client.make.build.Make.serve" href="#tf.client.make.build.Make.serve">serve</a></code></li>
<li><code><a title="tf.client.make.build.Make.ship" href="#tf.client.make.build.Make.ship">ship</a></code></li>
<li><code><a title="tf.client.make.build.Make.showDebug" href="#tf.client.make.build.Make.showDebug">showDebug</a></code></li>
<li><code><a title="tf.client.make.build.Make.showVersion" href="#tf.client.make.build.Make.showVersion">showVersion</a></code></li>
<li><code><a title="tf.client.make.build.Make.zipApp" href="#tf.client.make.build.Make.zipApp">zipApp</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://www.dans.knaw.nl"><img alt="DANS" src="../../../tf/images/DANS-logo.png" width="200" alt="DANS"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>