<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>tf.ner.scopes API documentation</title>
<meta name="description" content="Scope handling â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.ner.scopes</code></h1>
</header>
<section id="section-intro">
<p>Scope handling</p>
<p>Scopes are a column in entity spreadsheets that limit the effects of entity
triggers. This module defines data structures for scopes and some fundamental
operations on them, such as representing them as string, parsing them from strings,
comparing and sorting them.</p>
<p>A scope specification is a comma-separated list of interval strings.</p>
<p>An interval string is either a section or an interval between two sections.</p>
<p>A section is written as a section heading, an interval as two section headings
with a <code>-</code> in between.</p>
<p>An interval is taken from the start of the first section to the end of the
second section.</p>
<p>A section on its own is taken from its start to its end.</p>
<p>Examples:</p>
<ul>
<li><code>3</code> is the whole of section <code>3</code></li>
<li><code>3-3.4</code> is from the start of section <code>3</code> to the end of section <code>3.4</code></li>
<li><code>3.4-3</code> is from the start of section <code>3.4</code> to the end of section <code>3</code></li>
<li><code>3.4-5</code> is from the start of section <code>3.4</code>, through the rest of section <code>3</code>,
through the whole of section <code>4</code>, till the end of section <code>5</code></li>
</ul>
<p>A section heading is written as it appears when TF represents sections.
If you browse the corpus in the TF browser you'll see how those
sections are represented. Even if section headings are not numeric, TF knows
which sections you mean:</p>
<ul>
<li><code>Genesis 1:5-Deuteronomy 26:6</code> if from the start of book Genesis
chapter 1 verse 5, through the rest of Genesis, through the books of
Exodus and Leviticus, till the end of Deuteronomy chapter 26 verse 6.</li>
</ul>
<p>Even if the headings given at the boundaries of an interval are numeric, TF
knows the exact ordering of all sections, and will fill them in.</p>
<p>Suppose in a corpus you have main sections <code>1</code>, <code>4</code>, <code>3</code>, <code>3b</code>, <code>5</code> in that
order, then:</p>
<ul>
<li><code>1-5</code> is from the start of <code>1</code>, through <code>4</code>, <code>3</code>, <code>3b</code>, to the end of <code>5</code></li>
<li><code>1-4</code> is sections <code>1</code> and <code>4</code> <em>only</em></li>
<li><code>1-3</code> is sections <code>1</code>, <code>4</code>, <code>3</code> <em>only</em></li>
<li><code>3-5</code> is sections <code>3</code>, <code>3b</code> and <code>5</code> <em>only</em></li>
</ul>
<p>Implementation detail: Text-Fabric pre-computes the sequence of all sections
in your corpus, and maps them onto a legal numbering system, where each
section corresponds to a tuple of sequence numbers. For example, in the
<a href="https://github.com/ETCBC/bhsa">Hebrew Bible</a>,
<code>Exodus 3:4</code> is mapped to <code>(2, 3, 4)</code> since <code>Exodus</code> is the
second top level section in that corpus.</p>
<p>In the <a href="https://gitlab.huc.knaw.nl/suriano/letters">Suriano letters</a>,
<code>04@027:5</code> is mapped to <code>(3, 27, 5)</code>, since the main sections start at
<code>02</code>, there is no <code>01</code>.</p>
<p>The inverse mapping is also present in the pre-computed data of the corpus.
These mappings are from section nodes to legal number tuples and back.
The mapping from section node to heading string and back is is done by
TF functions <code><a title="tf.advanced.sections.sectionStrFromNode" href="../advanced/sections.html#tf.advanced.sections.sectionStrFromNode">sectionStrFromNode()</a></code> and
<code><a title="tf.advanced.sections.nodeFromSectionStr" href="../advanced/sections.html#tf.advanced.sections.nodeFromSectionStr">nodeFromSectionStr()</a></code>.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.ner.scopes.getIntvIndex"><code class="name flex">
<span>def <span class="ident">getIntvIndex</span></span>(<span>buckets, instructions, getSeqFromNode)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/6c6706fdc5346174985ffb3075884ce4f7eeb88e/tf/ner/scopes.py#L449-L519" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def getIntvIndex(buckets, instructions, getSeqFromNode):
    &#34;&#34;&#34;Map buckets in the corpus on intervals in a given set of intervals.

    When we are going to look up triggers in the corpus, we do so bucket by bucket.
    The validity of triggers is constrained to their scope. Whenever we leave an
    interval and go to the next, the those scopes change.
    We need a quick way to determine for each bucket in the corpus to which
    interval it belongs.

    Parameters
    ----------
    buckets: iterable of integer
        The nodes corresponding to the lowest level sections in the corpus
    instructions: iterable of tuple of tuple of integer
        This is a sequence of intervals. You may pass the `instructions` member
        of sheet data, since that is a mapping from intervals to search
        instructions for those intervals.
        When treated as an iterbale, such a dict is a sequence of intervals.

        We will sort the intervals before computing the index.
    getSeqFromNode:
        Corpus dependent function that gives the &#34;legal&#34; sequence number for
        sections, passed as nodes. See `tf.ner.corpus.Corpus.getSeqFromNode()`

    Returns
    -------
    dict
        Maps bucket nodes to the interval in the sequence of intervals to which they
        belong.
    &#34;&#34;&#34;
    intervals = _sortIntervals(x for x in instructions if x != ())

    nIntervals = len(intervals)

    if nIntervals == 0:
        return {bucket: () for bucket in buckets}

    intvIndex = {}
    i = 0
    intv = intervals[i]
    (b, e) = intv

    for bucket in buckets:
        hd = getSeqFromNode(bucket)

        assigned = False

        if _locCmp(b, hd) == 1:
            intvIndex[bucket] = ()
            continue

        while i &lt; nIntervals:
            if _locCmp(e, hd) == -1:
                i += 1

                if i &lt; nIntervals:
                    intv = intervals[i]
                    (b, e) = intv
                else:
                    intvIndex[bucket] = ()
                    assigned = True
                    break
            else:
                intvIndex[bucket] = () if _locCmp(b, hd) == 1 else intv
                assigned = True
                break

        if not assigned:
            intvIndex[bucket] = ()

    return intvIndex</code></pre>
</details>
<div class="desc"><p>Map buckets in the corpus on intervals in a given set of intervals.</p>
<p>When we are going to look up triggers in the corpus, we do so bucket by bucket.
The validity of triggers is constrained to their scope. Whenever we leave an
interval and go to the next, the those scopes change.
We need a quick way to determine for each bucket in the corpus to which
interval it belongs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>buckets</code></strong> :&ensp;<code>iterable</code> of <code>integer</code></dt>
<dd>The nodes corresponding to the lowest level sections in the corpus</dd>
<dt><strong><code>instructions</code></strong> :&ensp;<code>iterable</code> of <code>tuple</code> of <code>tuple</code> of <code>integer</code></dt>
<dd>
<p>This is a sequence of intervals. You may pass the <code>instructions</code> member
of sheet data, since that is a mapping from intervals to search
instructions for those intervals.
When treated as an iterbale, such a dict is a sequence of intervals.</p>
<p>We will sort the intervals before computing the index.</p>
</dd>
</dl>
<p>getSeqFromNode:
Corpus dependent function that gives the "legal" sequence number for
sections, passed as nodes. See <code><a title="tf.ner.corpus.Corpus.getSeqFromNode" href="corpus.html#tf.ner.corpus.Corpus.getSeqFromNode">Corpus.getSeqFromNode</a></code></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Maps bucket nodes to the interval in the sequence of intervals to which they
belong.</dd>
</dl></div>
</dd>
<dt id="tf.ner.scopes.locInScope"><code class="name flex">
<span>def <span class="ident">locInScope</span></span>(<span>loc, scope)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/6c6706fdc5346174985ffb3075884ce4f7eeb88e/tf/ner/scopes.py#L339-L357" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def locInScope(loc, scope):
    &#34;&#34;&#34;Whether a location (section) is contained in a scope (sequence of intervals).

    Parameters
    ----------
    loc: tuple of integer
        The location, which is a section given by its sequence numbers
    scope: tuple of tuple of tuple of integer
        The scope, given as a tuple of intervals

    Returns
    -------
    boolean
        Whether the location is contained in the scope
    &#34;&#34;&#34;
    if not len(scope):
        return False

    return any(_locInInterval(loc, intv) for intv in scope)</code></pre>
</details>
<div class="desc"><p>Whether a location (section) is contained in a scope (sequence of intervals).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>loc</code></strong> :&ensp;<code>tuple</code> of <code>integer</code></dt>
<dd>The location, which is a section given by its sequence numbers</dd>
<dt><strong><code>scope</code></strong> :&ensp;<code>tuple</code> of <code>tuple</code> of <code>tuple</code> of <code>integer</code></dt>
<dd>The scope, given as a tuple of intervals</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>Whether the location is contained in the scope</dd>
</dl></div>
</dd>
<dt id="tf.ner.scopes.partitionScopes"><code class="name flex">
<span>def <span class="ident">partitionScopes</span></span>(<span>scopeDict)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/6c6706fdc5346174985ffb3075884ce4f7eeb88e/tf/ner/scopes.py#L360-L446" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def partitionScopes(scopeDict):
    &#34;&#34;&#34;Partition a set of scopes into intervals.

    The idea is to create a set of intervals such that:

    *   there is no scope boundary within any interval;
    *   every interval has at least one scope boundary at its start and one at its end.

    Parameters
    ----------
    scopeDict: dict
        The scopes are given as a mapping from string representations of scopes to
        logical scopes, i.e. the data structures you get when you parse scopes.

    Returns
    -------
    list
        The sorted sequence of resulting intervals
    &#34;&#34;&#34;
    scopeFromStr = {}
    strFromScope = {}
    boundaries = {}
    intervals = []

    for scopeStr, scope in scopeDict.items():
        for intv in scope:
            (b, e) = intv
            boundaries.setdefault(b, {}).setdefault(&#34;b&#34;, set()).add(intv)
            boundaries.setdefault(e, {}).setdefault(&#34;e&#34;, set()).add(intv)

            scopeFromStr.setdefault(scopeStr, set()).add(intv)
            strFromScope.setdefault(intv, set()).add(scopeStr)

    curScopes = set()
    inScope = False

    for x in _sortLocs(boundaries):
        beginScopes = boundaries[x].get(&#34;b&#34;, set())
        endScopes = boundaries[x].get(&#34;e&#34;, set())

        inScope = len(curScopes) &gt; 0

        hasB = len(beginScopes) &gt; 0
        hasE = len(endScopes) &gt; 0

        if hasB and hasE:
            intervals[-1][1] = _prevLoc(x)
            if intervals[-1][1] &lt; intervals[-1][0]:
                intervals.pop()
            curScopes |= beginScopes
            intervals.append([x, x, _sortIntervals(curScopes)])
            curScopes -= endScopes
            inScope = len(curScopes) &gt; 0
            if inScope:
                intervals.append([_nextLoc(x), None, _sortIntervals(curScopes)])
        elif hasB:
            if inScope:
                intervals[-1][1] = _prevLoc(x)
                if intervals[-1][1] &lt; intervals[-1][0]:
                    intervals.pop()
            curScopes |= beginScopes
            intervals.append([x, None, _sortIntervals(curScopes)])
        elif hasE:
            intervals[-1][1] = x
            curScopes -= endScopes
            inScope = len(curScopes) &gt; 0
            if inScope:
                intervals.append([_nextLoc(x), None, _sortIntervals(curScopes)])

    if inScope:
        intervals[-1][1] = x

    for x in intervals:
        newX = []
        seen = set()

        for intv in x[2]:
            for scopeStr in strFromScope[intv]:
                if scopeStr in seen:
                    continue

                seen.add(scopeStr)
                newX.append(scopeStr)

        x[2] = tuple(newX)

    return intervals</code></pre>
</details>
<div class="desc"><p>Partition a set of scopes into intervals.</p>
<p>The idea is to create a set of intervals such that:</p>
<ul>
<li>there is no scope boundary within any interval;</li>
<li>every interval has at least one scope boundary at its start and one at its end.</li>
</ul>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>scopeDict</code></strong> :&ensp;<code>dict</code></dt>
<dd>The scopes are given as a mapping from string representations of scopes to
logical scopes, i.e. the data structures you get when you parse scopes.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>The sorted sequence of resulting intervals</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.ner.scopes.Scopes"><code class="flex name class">
<span>class <span class="ident">Scopes</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/6c6706fdc5346174985ffb3075884ce4f7eeb88e/tf/ner/scopes.py#L522-L862" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Scopes:
    &#34;&#34;&#34;Functions that do scope handling.

    These functions will be added as methods to the class that inherits this class.
    &#34;&#34;&#34;

    def repLoc(self, loc):
        &#34;&#34;&#34;Represent a location as a string.

        A location identifies a section by means of legal number.
        We now want the heading of that section, as given by the features and
        settings of the corpus. We use the corpus dependent function
        `tf.ner.corpus.Corpus.getStrFromSeq()` for that.

        Parameters
        ----------
        loc: tuple of integer
            The &#34;legal&#34; number of a section.

        Returns
        -------
        string
            The section heading of the corresponding section.
        &#34;&#34;&#34;
        getStrFromSeq = self.getStrFromSeq

        return getStrFromSeq(tuple(x for x in loc if x != 0 and x != -1))

    def parseLoc(self, locStr, plain=True):
        &#34;&#34;&#34;Parses a location string.

        A location string is a section heading in the corpus.
        Now we want the &#34;legal&#34; number of that section.
        We use the corpus dependent function
        `tf.ner.corpus.Corpus.getSeqFromStr()` for that.

        Parameters
        ----------
        locStr: string
            The section heading as it appears in the corpus
        plain: boolean, optional True
            Whether to return just the result or additional information as well.

        Returns
        -------
        tuple of integer or dict
            The plain result is a tuple of the numbers that make up the &#34;legal&#34;
            number of the section. This is returned when `plain=False` is passed.
            If there are errors, None is returned.

            But if `plain=True` is passed, a dict is returned, with keys **result**
            for the plain result; **warning** for warnings if the parsing failed; and
            **normal** for a normalized representaiton of the section.
        &#34;&#34;&#34;
        getSeqFromStr = self.getSeqFromStr

        locStr = locStr.strip()

        if not locStr:
            result = ()
            return (
                ()
                if plain
                else dict(result=(), warning=None, normal=self.repLoc(result))
            )

        (error, result) = getSeqFromStr(locStr)

        if error:
            result = None
            normal = None
            warning = error
        else:
            normal = self.repLoc(result)
            warning = None

        return result if plain else dict(result=result, warning=warning, normal=normal)

    def repInterval(self, intv):
        &#34;&#34;&#34;Represent an interval of sections as string.

        Parameters
        ----------
        intv: tuple of tuple of integer
            The interval given as start and end section tuples

        Returns
        -------
        string
            Either a single section heading, if the start and end section are the same,
            or `-` surrounded by the start and end section headings.
        &#34;&#34;&#34;
        if intv is None or len(intv) == 0:
            return &#34;()&#34;

        (b, e) = intv

        return (
            self.repLoc(b) if _sameLoc(b, e) else f&#34;{self.repLoc(b)}-{self.repLoc(e)}&#34;
        )

    def repScope(self, scope):
        &#34;&#34;&#34;Represent a scope as string.

        Parameters
        ----------
        scope: tuple of tuple of tuple of integer
            The scope given as sequence of intervals

        Returns
        -------
        string
            Either a single section heading, if the start and end section are the same,
            or `-` surrounded by the start and end section headings.
        &#34;&#34;&#34;
        return &#34;, &#34;.join(self.repInterval(intv) for intv in scope)

    def parseInterval(self, intvStr, plain=True):
        &#34;&#34;&#34;Parses an interval given as string.

        A interval string is two section headings separated by a `-`.
        We parse it into a 2-tuple of the section headings, both also parsed into
        tuples of integers.

        If the resulting section tuples have less than the maximum number of components,
        we fill them up: the start section will be filled up with `0`-s, and the
        end section will be filled up with `-1`-s. This corresponds to the
        interpretation that the start section represent its start point, and
        the end section represent its end point.

        Parameters
        ----------
        intvStr: string
            The interval string
        plain: boolean, optional True
            Whether to return just the result or additional information as well.

        Returns
        -------
        tuple of integer or dict
            The plain result is a 2-tuple of tuples of integer.
            This is returned when `plain=False` is passed.
            If there are errors, None is returned.

            But if `plain=True` is passed, a dict is returned, with keys **result**
            for the plain result; **warning** for warnings if the parsing failed; and
            **normal** for a normalized representaiton of the section.
        &#34;&#34;&#34;
        result = None
        warnings = []

        intvStr = intvStr.strip()

        if not intvStr:
            result = ((0, 0, 0), (-1, -1, -1))

            return (
                result
                if plain
                else dict(
                    result=result, warning=warnings, normal=self.repInterval(result)
                )
            )

        parts = intvStr.split(&#34;-&#34;, 1)

        if len(parts) == 1:
            info = self.parseLoc(intvStr, plain=False)
            w = info[&#34;warning&#34;]

            if w:
                warnings.append(w)
            else:
                s = info[&#34;result&#34;]
                result = (
                    (s + (0, 0, 0))[0:3],
                    (s + (-1, -1, -1))[0:3],
                )
        else:
            part = parts[0].strip()
            info1 = self.parseLoc(part, plain=False)
            w1 = info1[&#34;warning&#34;]

            part = parts[1].strip()
            info2 = self.parseLoc(part, plain=False)
            w2 = info2[&#34;warning&#34;]

            if w1 or w2:
                if w1:
                    warnings.append(w1)
                if w2:
                    warnings.append(w2)
            else:
                s1 = info1[&#34;result&#34;]
                s2 = info2[&#34;result&#34;]
                result = (
                    (s1 + (0, 0, 0))[0:3],
                    (s2 + (-1, -1, -1))[0:3],
                )

        normal = None if result is None else self.repInterval(result)

        return result if plain else dict(result=result, warning=warnings, normal=normal)

    def parseScope(self, scopeStr, plain=True):
        &#34;&#34;&#34;Parse a scope specification into logical specifiers of regions in the corpus.

        A scope specification is a comma-separated list of interval strings.

        An interval string is either a section or an interval between two sections.

        A section is written as a section heading, an interval as two section headings
        with a `-` in between.

        An interval is taken from the start of the first section to the end of the
        second section.

        A section on its own is taken from its start to its end.

        Parameters
        ----------
        scopeStr: string
            The scope string
        plain: boolean, optional True
            Whether to return just the result or additional information as well.

        Returns
        -------
        tuple of tuple of integer or dict
            The plain result is a tuple of 2-tuple of tuples of integer.
            This is returned when `plain=False` is passed.
            If there are errors, None is returned.

            But if `plain=True` is passed, a dict is returned, with keys **result**
            for the plain result; **warning** for warnings if the parsing failed; and
            **normal** for a normalized representaiton of the section.
        &#34;&#34;&#34;

        results = []
        warnings = []

        if not scopeStr:
            return () if plain else dict(result=(), warning=warnings, normal=&#34;&#34;)

        for intvStr in scopeStr.split(&#34;,&#34;):

            if not intvStr:
                continue

            info = self.parseInterval(intvStr, plain=plain)
            result = info if plain else info[&#34;result&#34;]

            if result is None:
                if not plain:
                    warnings.extend(info[&#34;warning&#34;])
                continue

            results.append(result)

        results = tuple(_sortIntervals(results))

        return (
            results
            if plain
            else dict(result=results, warning=warnings, normal=self.repScope(results))
        )

    def intersectScopes(self, *scopeStrs):
        &#34;&#34;&#34;Produce the intersection of severel scopes.

        We use this function to test whether two triggers have a region where they
        are both in scope.

        Parameters
        ----------
        scopeStrs: iterable
            Sequence of scope specifiers

        Returns
        -------
        tuple of tuple of tuple of integer
            This is a tuple of intervals, forming the intersection of all given scopes
        &#34;&#34;&#34;
        curIntersection = [self.parseInterval(&#34;&#34;)]

        for scopeStr in scopeStrs:
            newIntersection = []
            for bLoc, eLoc in self.parseScope(scopeStr):

                for ibLoc, ieLoc in curIntersection:
                    if _locCmp(ieLoc, bLoc) == -1:
                        # ieLoc &lt; bLoc
                        continue
                    if _locCmp(ibLoc, eLoc) == 1:
                        # ibLoc &gt; eLoc
                        break

                    # now
                    # bLoc &lt;= ieLoc
                    # ibLoc &lt;= eLoc
                    newIbLoc = _locMax(ibLoc, bLoc)
                    newIeLoc = _locMin(ieLoc, eLoc)
                    newIntersection.append((newIbLoc, newIeLoc))

            curIntersection = newIntersection

        return tuple(curIntersection)

    def testPartitioning(self, scopeStrs):
        &#34;&#34;&#34;Test the partitioning of scopes.

        Only for debugging purposes.

        Parameters
        ----------
        scopeStrs: iterable of string
            The scope specifiers

        Returns
        -------
        list
            A list of intervals that make up the resulting partition.
        &#34;&#34;&#34;
        scopeIndex = {}

        for scopeStr in scopeStrs:
            info = self.parseScope(scopeStr, plain=False)
            warning = info[&#34;warning&#34;]

            if len(warning):
                console(f&#34;Errors in {scopeStr}: {&#39;; &#39;.join(warning)}&#34;)
            else:
                scopes = info[&#34;result&#34;]
                normScopeStr = info[&#34;normal&#34;]
                console(
                    f&#34;{scopeStr} =&gt; {normScopeStr}\n&#34;
                    f&#34;\t{self.repScope(_sortIntervals(scopes))}&#34;
                )
                scopeIndex[normScopeStr] = scopes

        partitionScopes(scopeIndex)</code></pre>
</details>
<div class="desc"><p>Functions that do scope handling.</p>
<p>These functions will be added as methods to the class that inherits this class.</p></div>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="tf.ner.sheets.Sheets" href="sheets.html#tf.ner.sheets.Sheets">Sheets</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tf.ner.scopes.Scopes.intersectScopes"><code class="name flex">
<span>def <span class="ident">intersectScopes</span></span>(<span>self, *scopeStrs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/6c6706fdc5346174985ffb3075884ce4f7eeb88e/tf/ner/scopes.py#L789-L828" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def intersectScopes(self, *scopeStrs):
    &#34;&#34;&#34;Produce the intersection of severel scopes.

    We use this function to test whether two triggers have a region where they
    are both in scope.

    Parameters
    ----------
    scopeStrs: iterable
        Sequence of scope specifiers

    Returns
    -------
    tuple of tuple of tuple of integer
        This is a tuple of intervals, forming the intersection of all given scopes
    &#34;&#34;&#34;
    curIntersection = [self.parseInterval(&#34;&#34;)]

    for scopeStr in scopeStrs:
        newIntersection = []
        for bLoc, eLoc in self.parseScope(scopeStr):

            for ibLoc, ieLoc in curIntersection:
                if _locCmp(ieLoc, bLoc) == -1:
                    # ieLoc &lt; bLoc
                    continue
                if _locCmp(ibLoc, eLoc) == 1:
                    # ibLoc &gt; eLoc
                    break

                # now
                # bLoc &lt;= ieLoc
                # ibLoc &lt;= eLoc
                newIbLoc = _locMax(ibLoc, bLoc)
                newIeLoc = _locMin(ieLoc, eLoc)
                newIntersection.append((newIbLoc, newIeLoc))

        curIntersection = newIntersection

    return tuple(curIntersection)</code></pre>
</details>
<div class="desc"><p>Produce the intersection of severel scopes.</p>
<p>We use this function to test whether two triggers have a region where they
are both in scope.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>scopeStrs</code></strong> :&ensp;<code>iterable</code></dt>
<dd>Sequence of scope specifiers</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code>tuple</code> of <code>tuple</code> of <code>integer</code></dt>
<dd>This is a tuple of intervals, forming the intersection of all given scopes</dd>
</dl></div>
</dd>
<dt id="tf.ner.scopes.Scopes.parseInterval"><code class="name flex">
<span>def <span class="ident">parseInterval</span></span>(<span>self, intvStr, plain=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/6c6706fdc5346174985ffb3075884ce4f7eeb88e/tf/ner/scopes.py#L639-L724" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def parseInterval(self, intvStr, plain=True):
    &#34;&#34;&#34;Parses an interval given as string.

    A interval string is two section headings separated by a `-`.
    We parse it into a 2-tuple of the section headings, both also parsed into
    tuples of integers.

    If the resulting section tuples have less than the maximum number of components,
    we fill them up: the start section will be filled up with `0`-s, and the
    end section will be filled up with `-1`-s. This corresponds to the
    interpretation that the start section represent its start point, and
    the end section represent its end point.

    Parameters
    ----------
    intvStr: string
        The interval string
    plain: boolean, optional True
        Whether to return just the result or additional information as well.

    Returns
    -------
    tuple of integer or dict
        The plain result is a 2-tuple of tuples of integer.
        This is returned when `plain=False` is passed.
        If there are errors, None is returned.

        But if `plain=True` is passed, a dict is returned, with keys **result**
        for the plain result; **warning** for warnings if the parsing failed; and
        **normal** for a normalized representaiton of the section.
    &#34;&#34;&#34;
    result = None
    warnings = []

    intvStr = intvStr.strip()

    if not intvStr:
        result = ((0, 0, 0), (-1, -1, -1))

        return (
            result
            if plain
            else dict(
                result=result, warning=warnings, normal=self.repInterval(result)
            )
        )

    parts = intvStr.split(&#34;-&#34;, 1)

    if len(parts) == 1:
        info = self.parseLoc(intvStr, plain=False)
        w = info[&#34;warning&#34;]

        if w:
            warnings.append(w)
        else:
            s = info[&#34;result&#34;]
            result = (
                (s + (0, 0, 0))[0:3],
                (s + (-1, -1, -1))[0:3],
            )
    else:
        part = parts[0].strip()
        info1 = self.parseLoc(part, plain=False)
        w1 = info1[&#34;warning&#34;]

        part = parts[1].strip()
        info2 = self.parseLoc(part, plain=False)
        w2 = info2[&#34;warning&#34;]

        if w1 or w2:
            if w1:
                warnings.append(w1)
            if w2:
                warnings.append(w2)
        else:
            s1 = info1[&#34;result&#34;]
            s2 = info2[&#34;result&#34;]
            result = (
                (s1 + (0, 0, 0))[0:3],
                (s2 + (-1, -1, -1))[0:3],
            )

    normal = None if result is None else self.repInterval(result)

    return result if plain else dict(result=result, warning=warnings, normal=normal)</code></pre>
</details>
<div class="desc"><p>Parses an interval given as string.</p>
<p>A interval string is two section headings separated by a <code>-</code>.
We parse it into a 2-tuple of the section headings, both also parsed into
tuples of integers.</p>
<p>If the resulting section tuples have less than the maximum number of components,
we fill them up: the start section will be filled up with <code>0</code>-s, and the
end section will be filled up with <code>-1</code>-s. This corresponds to the
interpretation that the start section represent its start point, and
the end section represent its end point.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>intvStr</code></strong> :&ensp;<code>string</code></dt>
<dd>The interval string</dd>
<dt><strong><code>plain</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>Whether to return just the result or additional information as well.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code>integer</code> or <code>dict</code></dt>
<dd>
<p>The plain result is a 2-tuple of tuples of integer.
This is returned when <code>plain=False</code> is passed.
If there are errors, None is returned.</p>
<p>But if <code>plain=True</code> is passed, a dict is returned, with keys <strong>result</strong>
for the plain result; <strong>warning</strong> for warnings if the parsing failed; and
<strong>normal</strong> for a normalized representaiton of the section.</p>
</dd>
</dl></div>
</dd>
<dt id="tf.ner.scopes.Scopes.parseLoc"><code class="name flex">
<span>def <span class="ident">parseLoc</span></span>(<span>self, locStr, plain=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/6c6706fdc5346174985ffb3075884ce4f7eeb88e/tf/ner/scopes.py#L550-L598" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def parseLoc(self, locStr, plain=True):
    &#34;&#34;&#34;Parses a location string.

    A location string is a section heading in the corpus.
    Now we want the &#34;legal&#34; number of that section.
    We use the corpus dependent function
    `tf.ner.corpus.Corpus.getSeqFromStr()` for that.

    Parameters
    ----------
    locStr: string
        The section heading as it appears in the corpus
    plain: boolean, optional True
        Whether to return just the result or additional information as well.

    Returns
    -------
    tuple of integer or dict
        The plain result is a tuple of the numbers that make up the &#34;legal&#34;
        number of the section. This is returned when `plain=False` is passed.
        If there are errors, None is returned.

        But if `plain=True` is passed, a dict is returned, with keys **result**
        for the plain result; **warning** for warnings if the parsing failed; and
        **normal** for a normalized representaiton of the section.
    &#34;&#34;&#34;
    getSeqFromStr = self.getSeqFromStr

    locStr = locStr.strip()

    if not locStr:
        result = ()
        return (
            ()
            if plain
            else dict(result=(), warning=None, normal=self.repLoc(result))
        )

    (error, result) = getSeqFromStr(locStr)

    if error:
        result = None
        normal = None
        warning = error
    else:
        normal = self.repLoc(result)
        warning = None

    return result if plain else dict(result=result, warning=warning, normal=normal)</code></pre>
</details>
<div class="desc"><p>Parses a location string.</p>
<p>A location string is a section heading in the corpus.
Now we want the "legal" number of that section.
We use the corpus dependent function
<code><a title="tf.ner.corpus.Corpus.getSeqFromStr" href="corpus.html#tf.ner.corpus.Corpus.getSeqFromStr">Corpus.getSeqFromStr</a></code> for that.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>locStr</code></strong> :&ensp;<code>string</code></dt>
<dd>The section heading as it appears in the corpus</dd>
<dt><strong><code>plain</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>Whether to return just the result or additional information as well.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code>integer</code> or <code>dict</code></dt>
<dd>
<p>The plain result is a tuple of the numbers that make up the "legal"
number of the section. This is returned when <code>plain=False</code> is passed.
If there are errors, None is returned.</p>
<p>But if <code>plain=True</code> is passed, a dict is returned, with keys <strong>result</strong>
for the plain result; <strong>warning</strong> for warnings if the parsing failed; and
<strong>normal</strong> for a normalized representaiton of the section.</p>
</dd>
</dl></div>
</dd>
<dt id="tf.ner.scopes.Scopes.parseScope"><code class="name flex">
<span>def <span class="ident">parseScope</span></span>(<span>self, scopeStr, plain=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/6c6706fdc5346174985ffb3075884ce4f7eeb88e/tf/ner/scopes.py#L726-L787" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def parseScope(self, scopeStr, plain=True):
    &#34;&#34;&#34;Parse a scope specification into logical specifiers of regions in the corpus.

    A scope specification is a comma-separated list of interval strings.

    An interval string is either a section or an interval between two sections.

    A section is written as a section heading, an interval as two section headings
    with a `-` in between.

    An interval is taken from the start of the first section to the end of the
    second section.

    A section on its own is taken from its start to its end.

    Parameters
    ----------
    scopeStr: string
        The scope string
    plain: boolean, optional True
        Whether to return just the result or additional information as well.

    Returns
    -------
    tuple of tuple of integer or dict
        The plain result is a tuple of 2-tuple of tuples of integer.
        This is returned when `plain=False` is passed.
        If there are errors, None is returned.

        But if `plain=True` is passed, a dict is returned, with keys **result**
        for the plain result; **warning** for warnings if the parsing failed; and
        **normal** for a normalized representaiton of the section.
    &#34;&#34;&#34;

    results = []
    warnings = []

    if not scopeStr:
        return () if plain else dict(result=(), warning=warnings, normal=&#34;&#34;)

    for intvStr in scopeStr.split(&#34;,&#34;):

        if not intvStr:
            continue

        info = self.parseInterval(intvStr, plain=plain)
        result = info if plain else info[&#34;result&#34;]

        if result is None:
            if not plain:
                warnings.extend(info[&#34;warning&#34;])
            continue

        results.append(result)

    results = tuple(_sortIntervals(results))

    return (
        results
        if plain
        else dict(result=results, warning=warnings, normal=self.repScope(results))
    )</code></pre>
</details>
<div class="desc"><p>Parse a scope specification into logical specifiers of regions in the corpus.</p>
<p>A scope specification is a comma-separated list of interval strings.</p>
<p>An interval string is either a section or an interval between two sections.</p>
<p>A section is written as a section heading, an interval as two section headings
with a <code>-</code> in between.</p>
<p>An interval is taken from the start of the first section to the end of the
second section.</p>
<p>A section on its own is taken from its start to its end.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>scopeStr</code></strong> :&ensp;<code>string</code></dt>
<dd>The scope string</dd>
<dt><strong><code>plain</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>Whether to return just the result or additional information as well.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code>tuple</code> of <code>integer</code> or <code>dict</code></dt>
<dd>
<p>The plain result is a tuple of 2-tuple of tuples of integer.
This is returned when <code>plain=False</code> is passed.
If there are errors, None is returned.</p>
<p>But if <code>plain=True</code> is passed, a dict is returned, with keys <strong>result</strong>
for the plain result; <strong>warning</strong> for warnings if the parsing failed; and
<strong>normal</strong> for a normalized representaiton of the section.</p>
</dd>
</dl></div>
</dd>
<dt id="tf.ner.scopes.Scopes.repInterval"><code class="name flex">
<span>def <span class="ident">repInterval</span></span>(<span>self, intv)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/6c6706fdc5346174985ffb3075884ce4f7eeb88e/tf/ner/scopes.py#L600-L621" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def repInterval(self, intv):
    &#34;&#34;&#34;Represent an interval of sections as string.

    Parameters
    ----------
    intv: tuple of tuple of integer
        The interval given as start and end section tuples

    Returns
    -------
    string
        Either a single section heading, if the start and end section are the same,
        or `-` surrounded by the start and end section headings.
    &#34;&#34;&#34;
    if intv is None or len(intv) == 0:
        return &#34;()&#34;

    (b, e) = intv

    return (
        self.repLoc(b) if _sameLoc(b, e) else f&#34;{self.repLoc(b)}-{self.repLoc(e)}&#34;
    )</code></pre>
</details>
<div class="desc"><p>Represent an interval of sections as string.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>intv</code></strong> :&ensp;<code>tuple</code> of <code>tuple</code> of <code>integer</code></dt>
<dd>The interval given as start and end section tuples</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>Either a single section heading, if the start and end section are the same,
or <code>-</code> surrounded by the start and end section headings.</dd>
</dl></div>
</dd>
<dt id="tf.ner.scopes.Scopes.repLoc"><code class="name flex">
<span>def <span class="ident">repLoc</span></span>(<span>self, loc)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/6c6706fdc5346174985ffb3075884ce4f7eeb88e/tf/ner/scopes.py#L528-L548" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def repLoc(self, loc):
    &#34;&#34;&#34;Represent a location as a string.

    A location identifies a section by means of legal number.
    We now want the heading of that section, as given by the features and
    settings of the corpus. We use the corpus dependent function
    `tf.ner.corpus.Corpus.getStrFromSeq()` for that.

    Parameters
    ----------
    loc: tuple of integer
        The &#34;legal&#34; number of a section.

    Returns
    -------
    string
        The section heading of the corresponding section.
    &#34;&#34;&#34;
    getStrFromSeq = self.getStrFromSeq

    return getStrFromSeq(tuple(x for x in loc if x != 0 and x != -1))</code></pre>
</details>
<div class="desc"><p>Represent a location as a string.</p>
<p>A location identifies a section by means of legal number.
We now want the heading of that section, as given by the features and
settings of the corpus. We use the corpus dependent function
<code><a title="tf.ner.corpus.Corpus.getStrFromSeq" href="corpus.html#tf.ner.corpus.Corpus.getStrFromSeq">Corpus.getStrFromSeq</a></code> for that.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>loc</code></strong> :&ensp;<code>tuple</code> of <code>integer</code></dt>
<dd>The "legal" number of a section.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>The section heading of the corresponding section.</dd>
</dl></div>
</dd>
<dt id="tf.ner.scopes.Scopes.repScope"><code class="name flex">
<span>def <span class="ident">repScope</span></span>(<span>self, scope)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/6c6706fdc5346174985ffb3075884ce4f7eeb88e/tf/ner/scopes.py#L623-L637" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def repScope(self, scope):
    &#34;&#34;&#34;Represent a scope as string.

    Parameters
    ----------
    scope: tuple of tuple of tuple of integer
        The scope given as sequence of intervals

    Returns
    -------
    string
        Either a single section heading, if the start and end section are the same,
        or `-` surrounded by the start and end section headings.
    &#34;&#34;&#34;
    return &#34;, &#34;.join(self.repInterval(intv) for intv in scope)</code></pre>
</details>
<div class="desc"><p>Represent a scope as string.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>scope</code></strong> :&ensp;<code>tuple</code> of <code>tuple</code> of <code>tuple</code> of <code>integer</code></dt>
<dd>The scope given as sequence of intervals</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>Either a single section heading, if the start and end section are the same,
or <code>-</code> surrounded by the start and end section headings.</dd>
</dl></div>
</dd>
<dt id="tf.ner.scopes.Scopes.testPartitioning"><code class="name flex">
<span>def <span class="ident">testPartitioning</span></span>(<span>self, scopeStrs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/6c6706fdc5346174985ffb3075884ce4f7eeb88e/tf/ner/scopes.py#L830-L862" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def testPartitioning(self, scopeStrs):
    &#34;&#34;&#34;Test the partitioning of scopes.

    Only for debugging purposes.

    Parameters
    ----------
    scopeStrs: iterable of string
        The scope specifiers

    Returns
    -------
    list
        A list of intervals that make up the resulting partition.
    &#34;&#34;&#34;
    scopeIndex = {}

    for scopeStr in scopeStrs:
        info = self.parseScope(scopeStr, plain=False)
        warning = info[&#34;warning&#34;]

        if len(warning):
            console(f&#34;Errors in {scopeStr}: {&#39;; &#39;.join(warning)}&#34;)
        else:
            scopes = info[&#34;result&#34;]
            normScopeStr = info[&#34;normal&#34;]
            console(
                f&#34;{scopeStr} =&gt; {normScopeStr}\n&#34;
                f&#34;\t{self.repScope(_sortIntervals(scopes))}&#34;
            )
            scopeIndex[normScopeStr] = scopes

    partitionScopes(scopeIndex)</code></pre>
</details>
<div class="desc"><p>Test the partitioning of scopes.</p>
<p>Only for debugging purposes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>scopeStrs</code></strong> :&ensp;<code>iterable</code> of <code>string</code></dt>
<dd>The scope specifiers</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>A list of intervals that make up the resulting partition.</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.css" integrity="sha512-b+T2i3P45i1LZM7I00Ci5QquB9szqaxu+uuk5TUSGjZQ4w4n+qujQiIuvTv2BxE7WCGQCifNMksyKILDiHzsOg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.js" integrity="sha512-2B9/byNV1KKRm5nQ2RLViPFD6U4dUjDGwuW1GU+ImJh8YinPU9Zlq1GzdTMO+G2ROrB5o1qasJBy1ttYz0wCug==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.ner" href="index.html">tf.ner</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tf.ner.scopes.getIntvIndex" href="#tf.ner.scopes.getIntvIndex">getIntvIndex</a></code></li>
<li><code><a title="tf.ner.scopes.locInScope" href="#tf.ner.scopes.locInScope">locInScope</a></code></li>
<li><code><a title="tf.ner.scopes.partitionScopes" href="#tf.ner.scopes.partitionScopes">partitionScopes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.ner.scopes.Scopes" href="#tf.ner.scopes.Scopes">Scopes</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.ner.scopes.Scopes.intersectScopes" href="#tf.ner.scopes.Scopes.intersectScopes">intersectScopes</a></code></li>
<li><code><a title="tf.ner.scopes.Scopes.parseInterval" href="#tf.ner.scopes.Scopes.parseInterval">parseInterval</a></code></li>
<li><code><a title="tf.ner.scopes.Scopes.parseLoc" href="#tf.ner.scopes.Scopes.parseLoc">parseLoc</a></code></li>
<li><code><a title="tf.ner.scopes.Scopes.parseScope" href="#tf.ner.scopes.Scopes.parseScope">parseScope</a></code></li>
<li><code><a title="tf.ner.scopes.Scopes.repInterval" href="#tf.ner.scopes.Scopes.repInterval">repInterval</a></code></li>
<li><code><a title="tf.ner.scopes.Scopes.repLoc" href="#tf.ner.scopes.Scopes.repLoc">repLoc</a></code></li>
<li><code><a title="tf.ner.scopes.Scopes.repScope" href="#tf.ner.scopes.Scopes.repScope">repScope</a></code></li>
<li><code><a title="tf.ner.scopes.Scopes.testPartitioning" href="#tf.ner.scopes.Scopes.testPartitioning">testPartitioning</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
