<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>tf.advanced.links API documentation</title>
<meta name="description" content="Produce links to TF data and links from nodes to web resources.">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.advanced.links</code></h1>
</header>
<section id="section-intro">
<p>Produce links to TF data and links from nodes to web resources.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.advanced.links.flexLink"><code class="name flex">
<span>def <span class="ident">flexLink</span></span>(<span>app, kind)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/84d1a8d4a89d011d0121be06cf7cfc9fb376b469/tf/advanced/links.py#L969-L1020" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def flexLink(app, kind):
    &#34;&#34;&#34;Produce documentation links that are heavily dependent on the back-end.

    These are links to tutorials and other documentation.

    If the back-end is GitLab or GitHub, notebooks can be viewed on NBViewer.
    But if the back-end is on-premise, we assume that notebooks are
    converted to HTML and then published on the Pages of the on-premise GitLab.

    What exactly the link to such an on-premise Pages service is, may depend on
    a configuration setting.

    This function resolves all that.

    !!! note &#34;Converting notebooks to HTML&#34;
        There is now a tool in TF to convert a directory of notebooks to
        HTML. See `tf.tools.nbconvert`.

    Parameters
    ----------
    kind: string
        Indicates what kind of URL value should be returned:

        *   `pages`: URL of the repo in the Pages service of the back-end;
        *   `tut`: URL of the start tutorial, either on NB viewer or in the Pages
            service of the back-end.

    Returns
    -------
    string
        The complete URL.
    &#34;&#34;&#34;
    backend = app.backend
    aContext = app.context
    org = aContext.org or &#34;&#34;
    repo = aContext.repo or &#34;&#34;
    branch = aContext.provenanceSpec[&#34;branch&#34;]
    pages = aContext.provenanceSpec[&#34;pages&#34;]

    if kind == &#34;pages&#34;:
        pages = pages or backendRep(backend, kind)
        return f&#34;https://{org}.{pages}/{repo}&#34;

    if kind == &#34;tut&#34;:
        be = backendRep(backend, &#34;norm&#34;)
        onPremise = be not in {GL, GH}

        if onPremise:
            pages = pages or backendRep(backend, &#34;pages&#34;)
            return f&#34;https://{org}.{pages}/{repo}/tutorial/start.html&#34;

        return f&#34;{URL_NB}/{be}/{org}/{repo}/blob/{branch}/tutorial/start.ipynb&#34;</code></pre>
</details>
<div class="desc"><p>Produce documentation links that are heavily dependent on the back-end.</p>
<p>These are links to tutorials and other documentation.</p>
<p>If the back-end is GitLab or GitHub, notebooks can be viewed on NBViewer.
But if the back-end is on-premise, we assume that notebooks are
converted to HTML and then published on the Pages of the on-premise GitLab.</p>
<p>What exactly the link to such an on-premise Pages service is, may depend on
a configuration setting.</p>
<p>This function resolves all that.</p>
<div class="admonition note">
<p class="admonition-title">Converting notebooks to HTML</p>
<p>There is now a tool in TF to convert a directory of notebooks to
HTML. See <code><a title="tf.tools.nbconvert" href="../tools/nbconvert.html">tf.tools.nbconvert</a></code>.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>kind</code></strong> :&ensp;<code>string</code></dt>
<dd>
<p>Indicates what kind of URL value should be returned:</p>
<ul>
<li><code>pages</code>: URL of the repo in the Pages service of the back-end;</li>
<li><code>tut</code>: URL of the start tutorial, either on NB viewer or in the Pages
service of the back-end.</li>
</ul>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>string</code></dt>
<dd>The complete URL.</dd>
</dl></div>
</dd>
<dt id="tf.advanced.links.header"><code class="name flex">
<span>def <span class="ident">header</span></span>(<span>app, allMeta=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/84d1a8d4a89d011d0121be06cf7cfc9fb376b469/tf/advanced/links.py#L189-L270" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def header(app, allMeta=False):
    &#34;&#34;&#34;Generate a colophon of the app.

    This colophon will be displayed after initializing the advanced API,
    and it is packed with provenance and documentation links.

    Parameters
    ----------
    allMeta: boolean, optional False
        If True, includes all metadata of all features. This leads to big
        stretches of largely redundant information in HTML details elements.
        It is not visually cumbersome, but notebooks may grow excessively
        if you load many datasets many times. So, if False, it will suppress
        all that metadata except the description keys.
    &#34;&#34;&#34;

    inNb = app.inNb
    appLink = app.appLink
    dataLink = app.dataLink
    charLink = app.charLink
    featureLink = app.featureLink
    tfsLink = app.tfsLink
    tfLink = app.tfLink
    tutLink = app.tutLink
    _browse = app._browse

    if _browse:
        colophon = dedent(
            f&#34;&#34;&#34;
            &lt;div class=&#34;hdlinks&#34;&gt;
              {dataLink}
              {charLink}
              {featureLink}
              {tfsLink}
              {tutLink}
            &lt;/div&gt;
            &#34;&#34;&#34;
        )
    else:
        colophon = &#34;&#34;

    nodeInfo = _nodeTypeInfo(app)
    featureInfo = _featuresPerModule(app, allMeta=allMeta or _browse)
    settingInfo = showContext(app, withComputed=_browse, asHtml=True)

    if inNb is not None or _browse:
        tfLine = &#34;, &#34;.join(x for x in (tfLink, appLink, tfsLink) if x)
        dataLine = &#34;, &#34;.join(x for x in (dataLink, charLink, featureLink) if x)
        setLine = (
            &#34;, &#34;.join(f&#34;&lt;code&gt;{x}&lt;/code&gt;&#34; for x in (app.sets or {}))
            if app.sets
            else &#34;no custom sets&#34;
        )
        commonHeader = dedent(
            f&#34;&#34;&#34;
            &lt;b&gt;TF:&lt;/b&gt; {tfLine}&lt;br&gt;
            &lt;b&gt;Data:&lt;/b&gt; {dataLine}&lt;br&gt;
            {nodeInfo}
            &lt;b&gt;Sets:&lt;/b&gt; {setLine}&lt;br&gt;
            &lt;b&gt;Features:&lt;/b&gt;&lt;br&gt;{featureInfo}
            &lt;b&gt;Settings:&lt;/b&gt;&lt;br&gt;{settingInfo}
            &#34;&#34;&#34;
        )
        if inNb is not None:
            dh(commonHeader, inNb=inNb)
        else:
            return (
                colophon,
                commonHeader,
                &#39;&lt;img class=&#34;hdlogo&#34; src=&#34;/data/static/logo.png&#34;/&gt;&#39;,
                &#39;&lt;img class=&#34;hdlogo&#34; src=&#34;/browser/static/icon.png&#34;/&gt;&#39;,
            )
    else:
        tfLine = &#34;\n\t&#34;.join(x for x in (tfLink, appLink, tfsLink) if x)
        dataLine = &#34;\n\t&#34;.join(x for x in (dataLink, charLink, featureLink) if x)
        setLine = &#34;, &#34;.join(x for x in (app.sets or {}))
        console(
            f&#34;TF:\n\t{tfLine}\n&#34; f&#34;Data:\n\t{dataLine}\n&#34; f&#34;{nodeInfo}&#34;,
            f&#34;Sets: {setLine}\n&#34;,
            f&#34;Features:\n{featureInfo}\n&#34;,
            newline=False,
        )</code></pre>
</details>
<div class="desc"><p>Generate a colophon of the app.</p>
<p>This colophon will be displayed after initializing the advanced API,
and it is packed with provenance and documentation links.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>allMeta</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If True, includes all metadata of all features. This leads to big
stretches of largely redundant information in HTML details elements.
It is not visually cumbersome, but notebooks may grow excessively
if you load many datasets many times. So, if False, it will suppress
all that metadata except the description keys.</dd>
</dl></div>
</dd>
<dt id="tf.advanced.links.linksApi"><code class="name flex">
<span>def <span class="ident">linksApi</span></span>(<span>app, silent='auto')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/84d1a8d4a89d011d0121be06cf7cfc9fb376b469/tf/advanced/links.py#L35-L186" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def linksApi(app, silent=SILENT_D):
    &#34;&#34;&#34;Produce the link API.

    The link API provides methods to maps nodes to URLs of web resources.
    It also computes several provenance and documentation links from the
    configuration settings of the corpus.


    If a single volume has been loaded, there will be added a provenance notice
    to the provenance data of the work as a whole,
    essentially stating which volume from the work is being used and what top-level
    sections of the work are part of it.

    Parameters
    ----------
    app: obj
        The high-level API object
    silent: string, optional `tf.core.timestamp.SILENT_D`
        See `tf.core.timestamp.Timestamp`
        Normally the silent parameter is taken from the app,
        but when we do an `A.reuse()` we force `silent=&#34;deep&#34;`.
    &#34;&#34;&#34;
    inNb = app.inNb
    _browse = app._browse
    silent = silentConvert(silent)
    backend = app.backend
    app.showProvenance = types.MethodType(showProvenance, app)
    app.header = types.MethodType(header, app)
    app.flexLink = types.MethodType(flexLink, app)
    app.webLink = types.MethodType(webLink, app)
    isCompatible = app.isCompatible

    aContext = app.context
    appName = aContext.appName
    appRelative = aContext.relative.removeprefix(&#34;/&#34;)
    appPath = aContext.appPath
    apiVersion = aContext.apiVersion
    docUrl = aContext.docUrl
    org = aContext.org or &#34;&#34;
    repo = aContext.repo or &#34;&#34;
    version = aContext.version
    branch = aContext.provenanceSpec[&#34;branch&#34;]
    corpus = aContext.corpus
    featureBase = aContext.featureBase
    featurePage = aContext.featurePage
    charUrl = aContext.charUrl
    charText = aContext.charText

    apiVersionRep = &#34;&#34; if apiVersion is None else f&#34; v{apiVersion}&#34;

    dataName = f&#34;{org} - {repo} {version}&#34;
    collectionInfo = app.collectionInfo
    if collectionInfo:
        dataName += f&#34; collection {collectionInfo}&#34;
    else:
        volumeInfo = app.volumeInfo
        if volumeInfo:
            dataName += f&#34; volume {volumeInfo}&#34;

    components = [appPath.rsplit(&#34;/&#34;, 1)[0]]
    if appRelative:
        components.append(appRelative)
    components.append(version)
    dataLink = (
        outLink(
            dataName,
            docUrl,
            f&#34;provenance of {corpus}&#34;,
            asHtml=inNb is not None or _browse,
        )
        if isCompatible and repo is not None and docUrl
        else &#34;/&#34;.join(components)
        if appName.startswith(&#34;app:&#34;)
        else &#34;/&#34;.join((x or &#34;&#34;) for x in (appPath, appName, version))
    )
    charLink = (
        (
            outLink(
                &#34;Character table&#34;,
                charUrl.format(tfDoc=URL_TFDOC),
                charText,
                asHtml=inNb is not None or _browse,
            )
            if isCompatible
            else UNSUPPORTED
        )
        if charUrl
        else &#34;&#34;
    )
    featureLink = (
        (
            outLink(
                &#34;Feature docs&#34;,
                featureBase.replace(&#34;&lt;feature&gt;&#34;, featurePage).format(version=version),
                f&#34;{org} - {repo} feature documentation&#34;,
                asHtml=inNb is not None or _browse,
            )
            if isCompatible and repo is not None and featureBase
            else UNSUPPORTED
        )
        if isCompatible
        else UNSUPPORTED
    )
    extraUrl = f&#34;{backendRep(backend, &#39;url&#39;)}/{org}/{repo}/blob/{branch}/{APP_APP}&#34;
    appLink = (
        outLink(
            f&#34;{org}/{repo}/app {apiVersionRep}&#34;,
            extraUrl,
            f&#34;{appName} app&#34;,
            asHtml=inNb is not None or _browse,
        )
        if isCompatible and repo is not None
        else &#34;no app configured&#34;
    )
    tfLink = outLink(
        f&#34;TF API {app.TF.version}&#34;,
        APIREF,
        &#34;text-fabric api&#34;,
        asHtml=inNb is not None or _browse,
    )
    tfsLink = (
        outLink(
            &#34;Search Reference&#34;,
            SEARCHREF,
            &#34;Search Templates Introduction and Reference&#34;,
            asHtml=inNb is not None or _browse,
        )
        if isCompatible
        else UNSUPPORTED
    )
    tutLink = (
        outLink(
            &#34;Tutorial&#34;,
            flexLink(app, &#34;tut&#34;),
            &#34;Tutorial in Jupyter Notebook&#34;,
            asHtml=inNb is not None or _browse,
        )
        if isCompatible and repo is not None
        else UNSUPPORTED
    )

    app.appLink = appLink
    app.dataLink = dataLink
    app.charLink = charLink
    app.featureLink = featureLink
    app.tfLink = tfLink
    app.tfsLink = tfsLink
    app.tutLink = tutLink

    if not app._browse:
        if silent in {VERBOSE, AUTO, TERSE}:
            header(app, allMeta=silent == VERBOSE)</code></pre>
</details>
<div class="desc"><p>Produce the link API.</p>
<p>The link API provides methods to maps nodes to URLs of web resources.
It also computes several provenance and documentation links from the
configuration settings of the corpus.</p>
<p>If a single volume has been loaded, there will be added a provenance notice
to the provenance data of the work as a whole,
essentially stating which volume from the work is being used and what top-level
sections of the work are part of it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>app</code></strong> :&ensp;<code>obj</code></dt>
<dd>The high-level API object</dd>
<dt><strong><code>silent</code></strong> :&ensp;<code>string</code>, optional <code><a title="tf.core.timestamp.SILENT_D" href="../core/timestamp.html#tf.core.timestamp.SILENT_D">SILENT_D</a></code></dt>
<dd>See <code><a title="tf.core.timestamp.Timestamp" href="../core/timestamp.html#tf.core.timestamp.Timestamp">Timestamp</a></code>
Normally the silent parameter is taken from the app,
but when we do an <code>A.reuse()</code> we force <code>silent="deep"</code>.</dd>
</dl></div>
</dd>
<dt id="tf.advanced.links.outLink"><code class="name flex">
<span>def <span class="ident">outLink</span></span>(<span>text, href, title=None, passage=None, clsName=None, target='_blank', asHtml=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/84d1a8d4a89d011d0121be06cf7cfc9fb376b469/tf/advanced/links.py#L514-L550" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def outLink(
    text, href, title=None, passage=None, clsName=None, target=&#34;_blank&#34;, asHtml=True
):
    &#34;&#34;&#34;Produce a formatted link.

    Parameters
    ----------
    text: string/HTML
        The text of the link.
    href: string/URL
        The URL of the link.
    title: string, optional None
        The hint of the link.
    target: string, optional _blank
        The target window / tab of the link.
    clsName: string, optional default `None`
        A CSS class name to add to the resulting link element
    passage: string, optional None
        A passage indicator, which will end up in the `sec` attribute of the
        link element. Used by the TF browser.
    asHtml: boolean, optional True
        Whether we are in a notebook or in the browser.
        If not, a plain text representation of the link will be made.
    &#34;&#34;&#34;

    titleAtt = &#34;&#34; if title is None else f&#39; title=&#34;{title}&#34;&#39;
    clsAtt = f&#39; class=&#34;{clsName.lower()}&#34;&#39; if clsName else &#34;&#34;
    targetAtt = f&#39; target=&#34;{target}&#34;&#39; if target else &#34;&#34;
    passageAtt = f&#39; sec=&#34;{passage}&#34;&#39; if passage else &#34;&#34;
    return (
        (
            f&#39;&lt;a{clsAtt}{targetAtt} href=&#34;{htmlEsc(href)}&#34;{titleAtt}{passageAtt}&gt;&#39;
            f&#34;{text}&lt;/a&gt;&#34;
        )
        if asHtml
        else f&#34;{text} =&gt; {href}&#34;
    )</code></pre>
</details>
<div class="desc"><p>Produce a formatted link.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>string/HTML</code></dt>
<dd>The text of the link.</dd>
<dt><strong><code>href</code></strong> :&ensp;<code>string/URL</code></dt>
<dd>The URL of the link.</dd>
<dt><strong><code>title</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>The hint of the link.</dd>
<dt><strong><code>target</code></strong> :&ensp;<code>string</code>, optional <code>_blank</code></dt>
<dd>The target window / tab of the link.</dd>
<dt><strong><code>clsName</code></strong> :&ensp;<code>string</code>, optional <code>default </code>None``</dt>
<dd>A CSS class name to add to the resulting link element</dd>
<dt><strong><code>passage</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>A passage indicator, which will end up in the <code>sec</code> attribute of the
link element. Used by the TF browser.</dd>
<dt><strong><code>asHtml</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>Whether we are in a notebook or in the browser.
If not, a plain text representation of the link will be made.</dd>
</dl></div>
</dd>
<dt id="tf.advanced.links.provenanceLink"><code class="name flex">
<span>def <span class="ident">provenanceLink</span></span>(<span>backend, org, repo, version, branch, commit, local, release, relative)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/84d1a8d4a89d011d0121be06cf7cfc9fb376b469/tf/advanced/links.py#L905-L966" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def provenanceLink(
    backend, org, repo, version, branch, commit, local, release, relative
):
    &#34;&#34;&#34;Generate a provenance link for a data source.

    We assume the data source resides somewhere inside a back-end repository.

    Parameters
    ----------
    backend: string
        `github` or `gitlab` or a GitLab instance such as `gitlab.huc.knaw.nl`.
    org: string
        Organization on GitHub or group on GitLab
    repo: string
        Repository on GitHub or project on GitLab
    version: string
        Version of the data source.
        This is not the release or commit of a repo, but the subdirectory
        corresponding with a data version under a `tf` directory with feature files.
    branch: string
        The branch on the back-end of the repository (typically `master` or `main`)
    commit: string
        The commit hash of the repository
    local: boolean
        Whether the data is on the local computer and not necessarily backed up
        by a back-end repository
    release: string
        The release tag of the repository
    &#34;&#34;&#34;

    relative = prefixSlash(relative)
    text = (
        f&#34;data on local machine {relative}&#34;
        if org is None or repo is None
        else (
            f&#34;{org}/{repo}{relative} v:{version}&#34;
            f&#34;({Checkout.toString(commit, release, local, backend)})&#34;
        )
    )
    relativeFlat = relative.removeprefix(&#34;/&#34;).replace(&#34;/&#34;, &#34;-&#34;)
    bUrl = backendRep(backend, &#34;url&#34;)
    url = (
        None
        if org is None or repo is None
        else f&#34;{bUrl}/{org}/{repo}/tree/{branch}{relative}&#34;
        if local
        else (
            (
                (
                    f&#34;{bUrl}/{org}/{repo}/releases/download/{release}&#34;
                    f&#34;/{relativeFlat}-{version}.zip&#34;
                )
                if backend == GH
                else (
                    f&#34;{bUrl}/{org}/{repo}/-/archive/{release}&#34; f&#34;/{repo}-{version}.zip&#34;
                )
            )
            if release
            else f&#34;{bUrl}/{org}/{repo}/tree/{commit}{relative}&#34;
        )
    )
    return (text, url)</code></pre>
</details>
<div class="desc"><p>Generate a provenance link for a data source.</p>
<p>We assume the data source resides somewhere inside a back-end repository.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>backend</code></strong> :&ensp;<code>string</code></dt>
<dd><code>github</code> or <code>gitlab</code> or a GitLab instance such as <code>gitlab.huc.knaw.nl</code>.</dd>
<dt><strong><code>org</code></strong> :&ensp;<code>string</code></dt>
<dd>Organization on GitHub or group on GitLab</dd>
<dt><strong><code>repo</code></strong> :&ensp;<code>string</code></dt>
<dd>Repository on GitHub or project on GitLab</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>string</code></dt>
<dd>Version of the data source.
This is not the release or commit of a repo, but the subdirectory
corresponding with a data version under a <code><a title="tf" href="../index.html">tf</a></code> directory with feature files.</dd>
<dt><strong><code>branch</code></strong> :&ensp;<code>string</code></dt>
<dd>The branch on the back-end of the repository (typically <code>master</code> or <code>main</code>)</dd>
<dt><strong><code>commit</code></strong> :&ensp;<code>string</code></dt>
<dd>The commit hash of the repository</dd>
<dt><strong><code>local</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether the data is on the local computer and not necessarily backed up
by a back-end repository</dd>
<dt><strong><code>release</code></strong> :&ensp;<code>string</code></dt>
<dd>The release tag of the repository</dd>
</dl></div>
</dd>
<dt id="tf.advanced.links.showProvenance"><code class="name flex">
<span>def <span class="ident">showProvenance</span></span>(<span>app, jobName='program code', author='program author')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/84d1a8d4a89d011d0121be06cf7cfc9fb376b469/tf/advanced/links.py#L414-L449" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def showProvenance(app, jobName=&#34;program code&#34;, author=&#34;program author&#34;):
    &#34;&#34;&#34;Shows the provenance that is normally displayed during data loading.

    This comes in handy if you have started with
    `use(&#34;org/repo&#34;, silence=&#39;deep&#39;)` and still need to show the provenance.
    Moreover, the provenance is shown in a formatted way.

    Parameters
    ----------
    jobName: string, optional program code
        E.g. the name of program in which you call this function.
        In the TF browser the name of the job will be entered here.
        This item will be displayed together with the rest of the provenance.

    author: string, optional program author
        E.g. your own name.
        This item will be displayed together with the rest of the provenance.
    &#34;&#34;&#34;

    inNb = app.inNb
    aContext = app.context
    backend = app.backend
    org = aContext.org
    repo = aContext.repo
    commit = aContext.commit
    appProvenance = (
        ((&#34;backend&#34;, backend), (&#34;org&#34;, org), (&#34;repo&#34;, repo), (&#34;commit&#34;, commit)),
    )
    provenance = (appProvenance, app.provenance)
    setNames = (
        tuple(sorted(app.sets.keys()))
        if hasattr(app, &#34;sets&#34;) and type(app.sets) is dict
        else ()
    )
    form = dict(jobName=jobName, author=author)
    dh(wrapProvenance(form, provenance, setNames)[0], inNb=inNb)</code></pre>
</details>
<div class="desc"><p>Shows the provenance that is normally displayed during data loading.</p>
<p>This comes in handy if you have started with
<code>use("org/repo", silence='deep')</code> and still need to show the provenance.
Moreover, the provenance is shown in a formatted way.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>jobName</code></strong> :&ensp;<code>string</code>, optional <code>program code</code></dt>
<dd>E.g. the name of program in which you call this function.
In the TF browser the name of the job will be entered here.
This item will be displayed together with the rest of the provenance.</dd>
<dt><strong><code>author</code></strong> :&ensp;<code>string</code>, optional <code>program author</code></dt>
<dd>E.g. your own name.
This item will be displayed together with the rest of the provenance.</dd>
</dl></div>
</dd>
<dt id="tf.advanced.links.webLink"><code class="name flex">
<span>def <span class="ident">webLink</span></span>(<span>app, n, text=None, clsName=None, urlOnly=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/84d1a8d4a89d011d0121be06cf7cfc9fb376b469/tf/advanced/links.py#L273-L411" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def webLink(
    app, n, text=None, clsName=None, urlOnly=False, _asString=False, _noUrl=False
):
    &#34;&#34;&#34;Maps a node to a web resource.

    Usually called as `A.webLink(...)`

    The mapping is quite sophisticated. It will do sensible things for
    section nodes and lexeme nodes, dependent on how they are configured in
    the app&#39;s `config.yaml`.

    !!! hint &#34;Customisable&#34;
        You can customize the behaviour of `webLink()` to the needs of your corpus
        by providing appropriate values in its `config.yaml`, especially for
        `webBase`, `webLang`, `webOffset`, `webFeature`, `webUrl`, `webUrlLex`, and `webHint`.

    Parameters
    ----------
    n: integer
        A node
    text: string, optional default `None`
        The text of the link. If left out, a suitable text will be derived from
        the node.
    clsName: string, optional default `None`
        A CSS class name to add to the resulting link element
    urlOnly: boolean, optional False
        If True, only the URL will be returned.
    _asString: boolean, optional False
        Whether to deliver the result as a piece of HTML or to display the link
        on the (Jupyter) interface.
    _noUrl: boolean, optional False
        Whether to put the generated URL in the `href` attribute.
        It can be inhibited. This is useful for the TF browser, which may want
        to attach an action to the link and navigate to a location based on
        other attributes.

    See Also
    --------
    tf.advanced.settings: options allowed in `config.yaml`
    &#34;&#34;&#34;

    api = app.api
    TF = api.TF
    T = api.T
    F = api.F
    Fs = api.Fs

    inNb = app.inNb
    _browse = app._browse
    aContext = app.context
    webBase = aContext.webBase
    webLang = aContext.webLang
    webOffset = aContext.webOffset
    webFeature = aContext.webFeature
    webUrl = aContext.webUrl
    webUrlZeros = aContext.webUrlZeros or {}
    webUrlLex = aContext.webUrlLex
    webLexId = aContext.webLexId
    webHint = aContext.webHint
    lexTypes = aContext.lexTypes
    styles = aContext.styles

    nType = F.otype.v(n)
    passageText = None

    if _noUrl:
        href = &#34;#&#34;
    elif nType in lexTypes:
        if webUrlLex and webLexId:
            lid = (
                app.getLexId(n)
                if webLexId is True
                else Fs(webLexId).v(n)
                if webLexId
                else None
            )
            href = webUrlLex.replace(&#34;&lt;lid&gt;&#34;, str(lid))
        elif webBase:
            href = webBase
        else:
            href = None
    else:
        href = None
        if webFeature:
            if TF.isLoaded(webFeature, pretty=False)[webFeature]:
                val = Fs(webFeature).v(n)
                if val is not None:
                    href = f&#34;{webBase}{val}&#34;
        if href is None:
            if webUrl:
                href = webUrl
                headingTuple = T.sectionFromNode(n, lang=webLang, fillup=True)
                for i, heading in enumerate(headingTuple):
                    defaultOffset = 0 if type(heading) is int else &#34;&#34;
                    offset = (
                        defaultOffset
                        if webOffset is None
                        else webOffset.get(i + 1, {}).get(
                            headingTuple[i - 1], defaultOffset
                        )
                        if i &gt; 0
                        else defaultOffset
                    )
                    value = &#34;&#34; if heading is None else str(heading + offset)
                    leadingZeros = webUrlZeros.get(i + 1, 0)
                    if 0 &lt; len(value) &lt; leadingZeros:
                        value = &#34;0&#34; * (leadingZeros - len(value)) + value

                    href = href.replace(f&#34;&lt;{i + 1}&gt;&#34;, value)
            else:
                href = None

    if nType in lexTypes:
        if text is None:
            text = app.getText(False, n, nType, False, True, True, &#34;&#34;, None, None)
    else:
        passageText = app.sectionStrFromNode(n)
        if text is None:
            text = passageText

    style = styles.get(nType, None)
    if style:
        clsName = f&#34;{clsName or &#39;&#39;} {style}&#34;
    if href is None:
        fullResult = text
    else:
        atts = dict(target=&#34;&#34;) if _noUrl else dict(title=webHint)
        fullResult = outLink(
            text,
            href,
            clsName=clsName,
            passage=passageText,
            asHtml=inNb is not None or _browse,
            **atts,
        )
    result = href if urlOnly else fullResult
    if _asString or urlOnly:
        return result
    dh(result, inNb=inNb)</code></pre>
</details>
<div class="desc"><p>Maps a node to a web resource.</p>
<p>Usually called as <code>A.webLink(&hellip;)</code></p>
<p>The mapping is quite sophisticated. It will do sensible things for
section nodes and lexeme nodes, dependent on how they are configured in
the app's <code>config.yaml</code>.</p>
<div class="admonition hint">
<p class="admonition-title">Customisable</p>
<p>You can customize the behaviour of <code><a title="tf.advanced.links.webLink" href="#tf.advanced.links.webLink">webLink()</a></code> to the needs of your corpus
by providing appropriate values in its <code>config.yaml</code>, especially for
<code>webBase</code>, <code>webLang</code>, <code>webOffset</code>, <code>webFeature</code>, <code>webUrl</code>, <code>webUrlLex</code>, and <code>webHint</code>.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>integer</code></dt>
<dd>A node</dd>
<dt><strong><code>text</code></strong> :&ensp;<code>string</code>, optional <code>default </code>None``</dt>
<dd>The text of the link. If left out, a suitable text will be derived from
the node.</dd>
<dt><strong><code>clsName</code></strong> :&ensp;<code>string</code>, optional <code>default </code>None``</dt>
<dd>A CSS class name to add to the resulting link element</dd>
<dt><strong><code>urlOnly</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If True, only the URL will be returned.</dd>
<dt><strong><code>_asString</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to deliver the result as a piece of HTML or to display the link
on the (Jupyter) interface.</dd>
<dt><strong><code>_noUrl</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to put the generated URL in the <code>href</code> attribute.
It can be inhibited. This is useful for the TF browser, which may want
to attach an action to the link and navigate to a location based on
other attributes.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="tf.advanced.settings" href="settings.html">tf.advanced.settings</a></code></dt>
<dd>options allowed in <code>config.yaml</code></dd>
</dl></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.css" integrity="sha512-b+T2i3P45i1LZM7I00Ci5QquB9szqaxu+uuk5TUSGjZQ4w4n+qujQiIuvTv2BxE7WCGQCifNMksyKILDiHzsOg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.js" integrity="sha512-2B9/byNV1KKRm5nQ2RLViPFD6U4dUjDGwuW1GU+ImJh8YinPU9Zlq1GzdTMO+G2ROrB5o1qasJBy1ttYz0wCug==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.advanced" href="index.html">tf.advanced</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="tf.advanced.links.flexLink" href="#tf.advanced.links.flexLink">flexLink</a></code></li>
<li><code><a title="tf.advanced.links.header" href="#tf.advanced.links.header">header</a></code></li>
<li><code><a title="tf.advanced.links.linksApi" href="#tf.advanced.links.linksApi">linksApi</a></code></li>
<li><code><a title="tf.advanced.links.outLink" href="#tf.advanced.links.outLink">outLink</a></code></li>
<li><code><a title="tf.advanced.links.provenanceLink" href="#tf.advanced.links.provenanceLink">provenanceLink</a></code></li>
<li><code><a title="tf.advanced.links.showProvenance" href="#tf.advanced.links.showProvenance">showProvenance</a></code></li>
<li><code><a title="tf.advanced.links.webLink" href="#tf.advanced.links.webLink">webLink</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
