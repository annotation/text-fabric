<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.1" />
<title>tf.advanced.render API documentation</title>
<meta name="description" content="Render â€¦" />
<!-- integrity SRI from https://cdnjs.com/libraries/10up-sanitize.css/11.0.1 -->
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css"
integrity="sha512-kcbluZFacWN57NgWZ4aH6eUMBEaTyErFhIFD3y5qYZbKuuyImH0K/AKsBbfXlivh2z5C+3IDTIhI11YmKomzmA=="
crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css"
integrity="sha512-uVeAgzAmieLUTGba0qr9vXQgVD7fko2kcbYIKIraXUIDg9iJLxveTFUrg3DJhqn3cAf3HFDbgmhq0eGko5wEAA=="
crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.advanced.render</code></h1>
</header>
<section id="section-intro">
<h1 id="render">Render</h1>
<p>Rendering is the process of generating HTML for a node, taking into account
display options (<code><a title="tf.advanced.options" href="options.html">tf.advanced.options</a></code>) and app settings (<code><a title="tf.advanced.settings" href="settings.html">tf.advanced.settings</a></code>).</p>
<p>It is organized as an <em>unravel</em> step (<code><a title="tf.advanced.unravel" href="unravel.html">tf.advanced.unravel</a></code>),
that generates a tree of node fragments
followed by an HTML generating step, that generates HTML for a tree in a recursive way.</p>
<p>The <em>unravel</em> step retrieves all relevant settings and options and stores them
in the tree in such a way that the essential information for rendering a subtree
is readily available at the top of that subtree.</p>
<h2 id="information-shielding">Information shielding</h2>
<p>The recursive render step does not have to consult the <code>app</code> object anymore,
because all information it needs from the <code>app</code> object is stored in the tree,
and all methods that need to be invoked on the <code>app</code> object are also accessible
directly from an attribute in the tree.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/1a69c811d488a4cb523dbbc7a5bba6c07c4c6fd9/tf/advanced/render.py#L1-L742" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# Render

Rendering is the process of generating HTML for a node, taking into account
display options (`tf.advanced.options`) and app settings (`tf.advanced.settings`).

It is organized as an *unravel* step (`tf.advanced.unravel`),
that generates a tree of node fragments
followed by an HTML generating step, that generates HTML for a tree in a recursive way.

The *unravel* step retrieves all relevant settings and options and stores them
in the tree in such a way that the essential information for rendering a subtree
is readily available at the top of that subtree.

## Information shielding

The recursive render step does not have to consult the `app` object anymore,
because all information it needs from the `app` object is stored in the tree,
and all methods that need to be invoked on the `app` object are also accessible
directly from an attribute in the tree.
&#34;&#34;&#34;

import re
from textwrap import dedent

from .helpers import htmlSafe, NB, dh
from .highlight import getEdgeHlAtt
from .unravel import _unravel
from ..core.helpers import NBSP, TO_SYM, FROM_SYM, htmlEsc, flattenToSet


def render(app, isPretty, n, _inTuple, _asString, explain, **options):
    &#34;&#34;&#34;Renders a node, in plain or pretty mode.

    We take care that when a node has graphics, and the node is split into several
    chunks / fragments, the graphics only occurs on the first fragment.
    &#34;&#34;&#34;

    graphicsFetched = set()
    inNb = app.inNb
    display = app.display

    if not display.check(&#34;pretty&#34; if isPretty else &#34;plain&#34;, options):
        return &#34;&#34;

    _browse = app._browse

    dContext = display.distill(options)

    if isPretty:
        tupleFeatures = dContext.tupleFeatures
        extraFeatures = dContext.extraFeatures
        multiFeatures = dContext.multiFeatures
        queryFeatures = dContext.queryFeatures

        dContext.set(
            &#34;features&#34;,
            sorted(
                flattenToSet(extraFeatures[0])
                | (flattenToSet(tupleFeatures) if queryFeatures else set())
            ),
        )
        dContext.set(&#34;featuresIndirect&#34;, extraFeatures[1])
        if multiFeatures:
            api = app.api
            Fall = api.Fall
            Eall = api.Eall
            dContext.set(
                &#34;featuresAll&#34;, tuple(Fall(warp=False)) + tuple(Eall(warp=False))
            )

    tree = _unravel(app, isPretty, dContext, n, _inTuple=_inTuple, explain=explain)
    (chunk, info, subTrees) = tree
    settings = info.settings

    passage = _getPassage(isPretty, info, n)

    html = []

    for subTree in subTrees:
        _render(isPretty, subTree, True, True, 0, passage, html, graphicsFetched)

    rep = &#34;&#34;.join(html)
    ltr = settings.ltr

    elem = &#34;span&#34; if _inTuple else &#34;div&#34;
    ubd = &#34; ubd&#34; if _inTuple else &#34;&#34;
    kindRep = &#34;pr-mode&#34; if isPretty else &#34;pl-mode&#34;
    result = (
        f&#34;&#34;&#34;{passage}&lt;{elem} class=&#34;{ltr} children {kindRep}&#34;&gt;{rep}&lt;/{elem}&gt;&#34;&#34;&#34;
        if isPretty
        else f&#34;&#34;&#34;&lt;{elem} class=&#34;{ltr}{ubd} {kindRep}&#34;&gt;{passage}{rep}&lt;/{elem}&gt;&#34;&#34;&#34;
    )

    if _browse or _asString:
        return result
    dh(result, inNb=inNb)


def _render(
    isPretty,
    tree,
    first,
    last,
    level,
    passage,
    html,
    graphicsFetched,
    switched=False,
    _asString=False,
):
    outer = level == 0
    (chunk, info, children) = tree
    (n, (b, e)) = chunk
    settings = info.settings
    props = info.props
    boundaryCls = info.boundaryCls

    ltr = settings.ltr
    isBaseNonSlot = props.isBaseNonSlot
    plainCustom = props.plainCustom

    if isPretty:
        nodePlain = None
        if isBaseNonSlot:
            nodePlain = _render(
                False,
                tree,
                first,
                last,
                level,
                &#34;&#34;,
                [],
                graphicsFetched,
                switched=True,
                _asString=True,
            )
        (label, featurePart) = _prettyTree(tree, outer, first, last, level, nodePlain)
        (containerB, containerE) = _prettyPre(
            tree,
            outer,
            label,
            featurePart,
            boundaryCls,
            html,
            graphicsFetched,
        )
        cls = props.cls
        childCls = cls[&#34;children&#34;]

        if children and not isBaseNonSlot:
            html.append(f&#39;&lt;div class=&#34;{childCls} {ltr}&#34;&gt;&#39;)
            after = props.after
    else:
        (contribB, contribE) = _plainPre(info, n, boundaryCls, outer, switched)
        contrib = _plainTree(
            contribB,
            contribE,
            tree,
            outer,
            first,
            last,
            level,
            boundaryCls,
            passage,
            graphicsFetched,
        )
        if contrib:
            html.append(contrib)

    lastCh = len(children) - 1

    if not ((isPretty and isBaseNonSlot) or (not isPretty and plainCustom)):
        for i, subTree in enumerate(children):
            thisFirst = first and i == 0
            thisLast = last and i == lastCh
            _render(
                isPretty,
                subTree,
                thisFirst,
                thisLast,
                level + 1,
                &#34;&#34;,
                html,
                graphicsFetched,
            )
            if isPretty and after:
                html.append(after(subTree[0][0]))

    if isPretty:
        if children and not isBaseNonSlot:
            html.append(&#34;&lt;/div&gt;&#34;)
        _prettyPost(label, featurePart, html, containerB, containerE)
    else:
        _plainPost(contribE, html)

    return &#34;&#34;.join(html) if outer or _asString else None


# PLAIN LOW-LEVEL


def _plainPre(info, n, boundaryCls, outer, switched):
    isPretty = False
    options = info.options
    plainGaps = options.plainGaps

    settings = info.settings
    ltr = settings.ltr

    props = info.props
    hlCls = props.hlCls[isPretty]
    hlStyle = props.hlStyle[isPretty]

    nodePart = _getNodePart(False, info, n, outer, switched)

    boundary = boundaryCls if plainGaps else &#34;&#34;
    theHlCls = &#34;&#34; if switched else hlCls
    theHlStyle = &#34;&#34; if switched else hlStyle
    if boundary in {&#34;r&#34;, &#34;l&#34;} or theHlCls or theHlStyle or nodePart or switched:
        clses = f&#34;plain {ltr} {boundary} {theHlCls}&#34;
        contribB = f&#39;&lt;span class=&#34;{clses}&#34; {theHlStyle}&gt;&#39;
        contribE = &#34;&lt;/span&gt;&#34;
    else:
        contribB = &#34;&#34;
        contribE = &#34;&#34;
    if nodePart:
        contribB += nodePart
    return (contribB, contribE)


def _plainPost(contribE, html):
    if contribE:
        html.append(contribE)


SPAN_RE = re.compile(r&#34;^(&lt;span\b[^&gt;]*&gt;)(.*)(&lt;/span&gt;)$&#34;, re.S)


def _plainTree(
    contribB,
    contribE,
    tree,
    outer,
    first,
    last,
    level,
    boundaryCls,
    passage,
    graphicsFetched,
):
    (chunk, info, subTrees) = tree

    options = info.options
    isHtml = options.isHtml
    fmt = options.fmt
    showGraphics = options.showGraphics
    showMath = options.showMath

    settings = info.settings
    textMethod = settings.textMethod
    ltr = settings.ltr
    getText = settings.getText
    getGraphics = settings.getGraphics

    props = info.props
    hasGraphics = props.hasGraphics
    textCls = props.textCls
    nType = props.nType
    isSlotOrDescend = props.isSlotOrDescend
    descend = props.descend
    plainCustom = props.plainCustom

    chunk = tree[0]
    n = chunk[0]

    if showGraphics and hasGraphics and n not in graphicsFetched:
        graphics = getGraphics(False, n, nType, outer)
        graphicsFetched.add(n)
    else:
        graphics = &#34;&#34;

    contrib = &#34;&#34;

    if plainCustom is not None:
        contrib = plainCustom(options, chunk, nType, outer)
        return contribB + contrib + graphics

    if isSlotOrDescend:
        text = textMethod(
            n,
            fmt=fmt,
            descend=descend,
            outer=outer,
            first=first,
            last=last,
            level=level,
        )
        if text:
            material = htmlSafe(text, isHtml, math=showMath)
            cb = f&#39;&lt;span class=&#34;{textCls}&#34;&gt;&#39;
            ce = &#34;&lt;/span&gt;&#34;

            # a &lt;br&gt; in flex box has no effect
            # so we create a &#34;breaking&#34; span by setting the width to 100% and
            # the height to 0
            # See https://tobiasahlin.com/blog/flexbox-break-to-new-row/
            # We might have to dig one level of spans deeper if contribB is not empty
            if &#34;&lt;br&gt;&#34; in material:
                match = SPAN_RE.match(material)
                if match:
                    (start, content, end) = match.group(1, 2, 3)
                else:
                    (start, content, end) = (&#34;&#34;, material, &#34;&#34;)
                parts = content.split(&#34;&lt;br&gt;&#34;)
                joinerBase = &#39;&lt;span class=&#34;break&#34;&gt;&lt;br&gt;&lt;/span&gt;&#39;
                joiner = (
                    joinerBase
                    if contribB == &#34;&#34;
                    else f&#34;{contribE}{joinerBase}{contribB}&#34;
                )
                material = joiner.join(
                    f&#34;{cb}{start}{part}{end}{ce}&#34; for part in parts
                )
                contrib = material
            else:
                contrib = f&#34;{cb}{material}{ce}&#34;
    else:
        tplFilled = getText(
            False,
            n,
            nType,
            outer,
            first,
            last,
            level,
            passage if outer else &#34;&#34;,
            descend,
            options=options,
        )
        if tplFilled:
            contrib = f&#39;&lt;span class=&#34;{textCls} {ltr}&#34;&gt;{tplFilled}&lt;/span&gt;&#39;

    return contribB + contrib + graphics


# PRETTY LOW-LEVEL


def _prettyPre(tree, outer, label, featurePart, boundaryCls, html, graphicsFetched):
    isPretty = True
    (chunk, info, subTrees) = tree
    n = chunk[0]

    options = info.options
    showGraphics = options.showGraphics

    settings = info.settings
    getGraphics = settings.getGraphics
    ltr = settings.ltr

    props = info.props
    hasGraphics = props.hasGraphics
    nType = props.nType
    cls = props.cls
    isBaseNonSlot = props.isBaseNonSlot
    hlCls = props.hlCls[isPretty]
    hlStyle = props.hlStyle[isPretty]

    contCls = cls[&#34;container&#34;]
    label0 = label.get(&#34;&#34;, None)
    labelB = label.get(&#34;b&#34;, None)

    n = tree[0][0]

    containerB = f&#39;&lt;div class=&#34;{contCls} {{}} {ltr} {boundaryCls} {hlCls}&#34; {hlStyle}&gt;&#39;
    containerE = &#34;&lt;/div&gt;&#34;

    terminalCls = &#34;trm&#34;
    material = featurePart
    if labelB is not None:
        trm = terminalCls
        html.append(f&#34;{containerB.format(trm)}{labelB}{material}{containerE}&#34;)
    if label0 is not None:
        trm = terminalCls if isBaseNonSlot or not subTrees else &#34;&#34;
        html.append(f&#34;{containerB.format(trm)}{label0}{material}&#34;)

    if showGraphics and hasGraphics and n not in graphicsFetched:
        html.append(getGraphics(True, n, nType, outer))
        graphicsFetched.add(n)

    return (containerB, containerE)


def _prettyPost(label, featurePart, html, containerB, containerE):
    label0 = label.get(&#34;&#34;, None)
    labelE = label.get(&#34;e&#34;, None)

    if label0 is not None:
        html.append(containerE)
    if labelE is not None:
        html.append(f&#34;{containerB}{labelE} {featurePart}{containerE}&#34;)


def _prettyTree(tree, outer, first, last, level, nodePlain):
    isPretty = True
    (chunk, info, subTrees) = tree
    n = chunk[0]

    options = info.options

    settings = info.settings
    upMethod = settings.upMethod
    slotsMethod = settings.slotsMethod
    webLink = settings.webLink
    getText = settings.getText

    props = info.props
    nType = props.nType
    cls = props.cls
    hlCls = props.hlCls[isPretty]
    hlStyle = props.hlStyle[isPretty]
    descend = props.descend
    isBaseNonSlot = props.isBaseNonSlot
    isLexType = props.isLexType
    lexType = props.lexType
    textCls = props.textCls

    nodePart = _getNodePart(True, info, n, outer, False)
    labelHlCls = hlCls
    labelHlStyle = hlStyle

    if isBaseNonSlot:
        heading = nodePlain
    else:
        heading = getText(
            True, n, nType, outer, first, last, level, &#34;&#34;, descend, options=options
        )

    heading = f&#39;&lt;span class=&#34;{textCls}&#34;&gt;{heading}&lt;/span&gt;&#39; if heading else &#34;&#34;

    featurePart = _getFeatures(info, n, nType)

    if isLexType:
        slots = slotsMethod(n)
        extremeOccs = (slots[0],) if len(slots) == 1 else (slots[0], slots[-1])
        linkOccs = &#34; - &#34;.join(webLink(lo, _asString=True) for lo in extremeOccs)
        featurePart += f&#39;&lt;div class=&#34;occs&#34;&gt;{linkOccs}&lt;/div&gt;&#39;
    if lexType:
        lx = upMethod(n, otype=lexType)
        if lx:
            heading = webLink(lx[0], heading, _asString=True)

    label = {}
    for x in (&#34;&#34;, &#34;b&#34;, &#34;e&#34;):
        key = f&#34;label{x}&#34;
        if key in cls:
            val = cls[key]
            terminalCls = &#34;trm&#34; if x or isBaseNonSlot or not subTrees else &#34;&#34;
            sep = &#34; &#34; if nodePart and heading else &#34;&#34;
            material = f&#34;{nodePart}{sep}{heading}&#34; if nodePart or heading else &#34;&#34;
            label[x] = (
                f&#39;&lt;div class=&#34;{val} {terminalCls} {labelHlCls}&#34; {labelHlStyle}&gt;&#39;
                f&#34;{material}&lt;/div&gt;&#34;
                if material
                else &#34;&#34;
            )

    return (label, featurePart)


def _getPassage(isPretty, info, n):
    options = info.options
    withPassage = options.withPassage

    settings = info.settings
    webLink = settings.webLink

    if not withPassage:
        return &#34;&#34;

    ltr = settings.ltr

    passage = webLink(n, _asString=True)
    wrap = &#34;div&#34; if isPretty else &#34;span&#34;
    sep = &#34;&#34; if isPretty else NB * 2
    return (
        f&#34;&#34;&#34;&lt;{wrap} class=&#34;tfsechead {ltr}&#34;&gt;&#34;&#34;&#34;
        f&#34;&#34;&#34;&lt;span class=&#34;ltr&#34;&gt;{passage}&lt;/span&gt;&lt;/{wrap}&gt;{sep}&#34;&#34;&#34;
    )


def _getNodePart(isPretty, info, n, outer, switched):
    options = info.options
    withNodes = options.withNodes and not switched
    withTypes = options.withTypes and not switched
    prettyTypes = options.prettyTypes and not switched
    lineNumbers = options.lineNumbers and not switched

    settings = info.settings
    browsing = settings.browsing
    fLookupMethod = settings.fLookupMethod

    props = info.props
    nType = props.nType
    isSlot = props.isSlot
    hlCls = props.hlCls[isPretty]
    lineNumberFeature = props.lineNumberFeature

    allowInfo = isPretty or (outer and not switched) or hlCls != &#34;&#34;

    num = &#34;&#34;
    if withNodes and allowInfo:
        num = n

    ntp = &#34;&#34;
    if (withTypes or isPretty and prettyTypes) and not isSlot and allowInfo:
        ntp = nType

    line = &#34;&#34;
    if lineNumbers and allowInfo:
        if lineNumberFeature:
            line = fLookupMethod(lineNumberFeature).v(n)
        if line:
            line = f&#34;@{line}&#34; if line else &#34;&#34;

    elemb = &#39;a href=&#34;#&#34;&#39; if browsing else &#34;span&#34;
    eleme = &#34;a&#34; if browsing else &#34;span&#34;
    sep = &#34;:&#34; if ntp and num else &#34;&#34;

    return (
        f&#39;&lt;{elemb} class=&#34;nd&#34;&gt;{ntp}{sep}{num}{line} &lt;/{eleme}&gt;&#39;
        if ntp or num or line
        else &#34;&#34;
    )


TO_SYM_WRAPPED = f&#39;&lt;span class=&#34;etfx&#34;&gt;{TO_SYM}&lt;/span&gt;&#39;
FROM_SYM_WRAPPED = f&#39;&lt;span class=&#34;etfx&#34;&gt;{FROM_SYM}&lt;/span&gt;&#39;


def _getEdge(e, n, kv, withNodes, right, highlights):
    (m, val) = kv if type(kv) is tuple else (kv, None)
    pair = (n, m) if right else (m, n)

    (hlCls, hlStyle) = getEdgeHlAtt(e, pair, highlights)

    nodeRep = f&#39;&lt;span class=&#34;nde&#34;&gt;{m}&lt;/span&gt;&#39; if withNodes else &#34;&#34;
    valRep = &#34;&#34; if val is None else htmlEsc(val)
    plainValue = (
        f&#34;{valRep}{TO_SYM_WRAPPED}{nodeRep}&#34;
        if right
        else f&#34;{nodeRep}{FROM_SYM_WRAPPED}{valRep}&#34;
    )
    arrow = &#34;right&#34; if right else &#34;left&#34;
    sep = &#34; &#34; if hlCls else &#34;&#34;

    return dedent(
        f&#34;&#34;&#34;
        &lt;span
            ef=&#34;{e}&#34;
            nd=&#34;{n}&#34;
            md=&#34;{m}&#34;
            arrow=&#34;{arrow}&#34;
            class=&#34;etf{sep}{hlCls}&#34; {hlStyle}
        &gt;{plainValue}&lt;/span&gt;
        &#34;&#34;&#34;
    )


def _getFeatures(info, n, nType):
    &#34;&#34;&#34;Feature fetcher.

    Helper for `pretty` that wraps the requested features and their values for
    *node* in HTML for pretty display.
    &#34;&#34;&#34;

    options = info.options
    dFeatures = options.features
    dFeaturesIndirect = options.featuresIndirect
    edgeFeatures = options.edgeFeatures
    forceEdges = options.forceEdges
    multiFeatures = options.multiFeatures

    if multiFeatures:
        featuresAll = options.featuresAll

    # queryFeatures = options.queryFeatures
    tupleFeatures = options.tupleFeatures
    standardFeatures = options.standardFeatures
    suppress = options.suppress
    noneValues = options.noneValues
    showMath = options.showMath
    withNodes = options.withNodes
    edgeHighlights = options.edgeHighlights

    settings = info.settings
    upMethod = settings.upMethod
    fLookupMethod = settings.fLookupMethod
    eLookupMethod = settings.eLookupMethod
    allEFeats = settings.allEFeats

    props = info.props
    (features, indirect) = props.features
    (featuresBare, indirectBare) = props.featuresBare

    if forceEdges:
        newDFeatures = []
        seen = set()
        for f in dFeatures + list(allEFeats):
            if f in allEFeats:
                if f in edgeFeatures:
                    if f not in seen:
                        newDFeatures.append(f)
                        seen.add(f)
                else:
                    continue
            else:
                newDFeatures.append(f)
        dFeatures = newDFeatures

    # a feature can be nType:feature
    # do a upMethod(n, otype=nType)[0] and take the feature from there

    givenFeatureSet = set(features) | set(featuresBare)
    xFeatures = tuple(
        f for f in dFeatures if not standardFeatures or f not in givenFeatureSet
    )
    featureList = tuple(featuresBare + features) + xFeatures
    if multiFeatures:
        featureList += featuresAll
    bFeatures = len(featuresBare)
    nbFeatures = len(featuresBare) + len(features)

    featurePart = &#34;&#34;

    # if standardFeatures or queryFeatures or multiFeatures or forceEdges:
    if standardFeatures or tupleFeatures or multiFeatures or forceEdges:
        seen = set()

        for i, name in enumerate(featureList):
            if name not in suppress and name not in seen:
                seen.add(name)

                if (
                    name in dFeaturesIndirect
                    or name in indirectBare
                    or name in indirect
                ):
                    refType = (
                        dFeaturesIndirect[name]
                        if name in dFeaturesIndirect
                        else indirectBare[name]
                        if name in indirectBare
                        else indirect[name]
                    )
                    refNode = upMethod(n, otype=refType)
                    refNode = refNode[0] if refNode else None
                else:
                    refNode = n

                value = None

                if refNode is not None:
                    if name in allEFeats:
                        esObj = eLookupMethod(name, warn=False)
                        valueF = esObj.f(refNode)
                        valueT = esObj.t(refNode)
                        eHighlights = (
                            None
                            if edgeHighlights is None
                            else edgeHighlights.get(name, None)
                        )
                        if len(valueF):
                            valueF = &#34; &#34;.join(
                                _getEdge(
                                    name, refNode, it, withNodes, True, eHighlights
                                )
                                for it in valueF
                            )
                        if len(valueT):
                            valueT = &#34; &#34;.join(
                                _getEdge(
                                    name, refNode, it, withNodes, False, eHighlights
                                )
                                for it in valueT
                            )
                        value = (
                            None
                            if not len(valueF) and not len(valueT)
                            else (valueT or &#34;&#34;) + (valueF or &#34;&#34;)
                        )
                    else:
                        fsObj = fLookupMethod(name, warn=False)
                        value = fsObj.v(refNode)
                        if value in noneValues:
                            value = None
                        else:
                            value = htmlEsc(value, math=showMath)

                if value is not None:
                    if name not in allEFeats:
                        value = value.replace(&#34;\n&#34;, &#34;\\n&lt;br&gt;&#34;)
                        if value.endswith(&#34; &#34;):
                            value = value[0:-1] + NBSP
                    isBare = i &lt; bFeatures
                    isExtra = i &gt;= nbFeatures
                    if (
                        not multiFeatures
                        and not (isExtra and forceEdges and name in edgeFeatures)
                        and (
                            # (isExtra and not queryFeatures)
                            # isExtra
                            # or (
                            not isExtra
                            and (not standardFeatures and name not in dFeatures)
                            # )
                        )
                    ):
                        continue
                    nameRep = (
                        &#34;&#34;
                        if isBare
                        else (
                            (
                                f&#39;&lt;span class=&#34;e&#34; edge=&#34;{name}&#34; nd=&#34;{refNode}&#34;&gt;&#39;
                                f&#34;{name}â€¢&lt;/span&gt;&#34;
                            )
                            if name in allEFeats
                            else f&#39;&lt;span class=&#34;f&#34;&gt;{name}=&lt;/span&gt;&#39;
                        )
                    )
                    titleRep = f&#39;title=&#34;{name}&#34;&#39; if isBare else &#34;&#34;
                    xCls = &#34;xft&#34; if isExtra else &#34;&#34;
                    featurePart += (
                        f&#39;&lt;span class=&#34;{name.lower()} {xCls}&#34; {titleRep}&gt;&#39;
                        f&#34;{nameRep}{value}&lt;/span&gt;&#34;
                    )
    if not featurePart:
        return &#34;&#34;

    return f&#34;&#34;&#34;&lt;div class=&#34;features&#34;&gt;{featurePart}&lt;/div&gt;&#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.advanced.render.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>app, isPretty, n, _inTuple, _asString, explain, **options)</span>
</code></dt>
<dd>
<div class="desc"><p>Renders a node, in plain or pretty mode.</p>
<p>We take care that when a node has graphics, and the node is split into several
chunks / fragments, the graphics only occurs on the first fragment.</p></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#render">Render</a><ul>
<li><a href="#information-shielding">Information shielding</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.advanced" href="index.html">tf.advanced</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tf.advanced.render.render" href="#tf.advanced.render.render">render</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
