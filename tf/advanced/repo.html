<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.advanced.repo API documentation</title>
<meta name="description" content="Auto downloading from a backend repository â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.advanced.repo</code></h1>
</header>
<section id="section-intro">
<h1 id="auto-downloading-from-a-backend-repository">Auto downloading from a backend repository</h1>
<h2 id="description">Description</h2>
<p>Text-Fabric maintains local copies of subfolders of backend repositories,
where it stores the feature data of corpora that the user is working with.</p>
<p>Currently GitHub and GitLab are supported as backends.
In case of GitLab, not only <a href="https://gitlab.com">gitlab.com</a> is supported,
but also GitLab instances on other servers that support the GitLab API.</p>
<p>There is some bookkeeping to account for which release and commit the
feature files come from.</p>
<p>Users can request data from any repo according to any release and/or commit.</p>
<h2 id="rate-limiting">Rate limiting</h2>
<p>The <code>checkRepo()</code> function uses the GitHub and GitLab APIs.
GitHub has a rate limiting policy for its API.
See below to deal with this if it becomes a problem.</p>
<p>On GitLab we ignore the rate limiting.</p>
<h1 id="github">GitHub</h1>
<p>GitHub has a rate limiting policy for its API of max 60 calls per hour.
This can be too restrictive, and here are two ways to keep working nevertheless.</p>
<h2 id="increase-the-rate-limit">Increase the rate limit</h2>
<p>If you use this function in an application of yours that uses it very often,
you can increase the limit to 5000 calls per hour by making yourself known.</p>
<ul>
<li><a href="https://github.com/settings/tokens">create a personal access token</a></li>
<li>Copy your token and put it in an environment variable named <code>GHPERS</code>
on the system where your app runs.
See below how to do that.</li>
<li>If <code><a title="tf.advanced.repo.checkoutRepo" href="#tf.advanced.repo.checkoutRepo">checkoutRepo()</a></code> finds this variable, it will add the
token to every GitHub API call it makes, and that will
increase the rate.</li>
<li>Never pass your personal credentials on to others, let them obtain their own!</li>
</ul>
<p>You might want to read this:</p>
<ul>
<li><a href="https://docs.github.com/en/rest/overview/resources-in-the-rest-api#rate-limiting">Read more about rate limiting on GitHub</a></li>
</ul>
<h1 id="gitlab">GitLab</h1>
<p>In order to reach an on-premise GitLab and have access to the repository in
question, you may need to have a VPN connection with the GitLab backend.</p>
<p>Additionally, you may need to make your identity known.
If you have an account on the GitLab instance, go to your settings and request
a personal token with <em>api</em> privileges.</p>
<p>On your own system, make an environment variable named GL_<em>BACKEND</em><code>_PERS</code> whose
content is exactly the value of this token.</p>
<p>And <em>BACKEND</em> should be the uppercase variant of the name of the GitLab backend,
where every character that is not a letter or digit or <code>_</code> is replaced by a <code>_</code>.</p>
<p>For example, for <code>gitlab.huc.knaw.nl</code> use <code>GL_GITLAB_HUC_KNAW_NL_PERS</code>
and for <code>gitlab.com</code> use <code>GL_GITLAB_COM_PERS</code>.</p>
<p>See below how to put this in an environment variable.</p>
<h1 id="token-in-environment-variables">Token in environment variables</h1>
<p>How to put your personal access token into an environment variable?</p>
<div class="admonition note">
<p class="admonition-title">What is an environment variable?</p>
<p>It is a setting on your system that various programs/processes can read.
On Windows it is part of the <code>Registry</code>.</p>
<p>In this particular case, you put a personal token
that you obtain from GitHub/GitLab
in such an environment variable.
When Text-Fabric accesses the backend, it will look up this token
first, and pass it to the backend API. The backend then knows who you are and
will give you more privileges.</p>
</div>
<h3 id="on-mac-and-linux">On Mac and Linux</h3>
<p>Find the file that contains your terminal settings. In many cases that is
<code>.bash_profile</code> in your home directory.</p>
<p>Some people put commands like these in their <code>~/.bashrc</code> file, which is also fine.
If you do not see a <code>.bashrc</code> file, put it into your <code>.bash_profile</code> file.</p>
<p>A slightly more advanced shell than <code>bash</code> is <code>zsh</code> and it is the default on newer
Macs. If that is your case, look for a file <code>.zshrc</code> in your home directory or
create one.</p>
<p>Whatever is your case, pick the file indicated above and edit it.</p>
<div class="admonition hint">
<p class="admonition-title">How to edit a file in your terminal?</p>
<p>If you are already familiar with <code>vi</code>, <code>vim</code>, <code>emacs</code>, or <code>nano</code>
you already know how to do it.</p>
<p>If not, <code>nano</code> is simple editor that is useful for tasks like this.
Assuming that you want to edit the <code>.zshrc</code> in your home directory,
go to your terminal and say this:</p>
<pre><code>nano ~/.zshrc
</code></pre>
<p>Then you get a view on your file. Then</p>
<ul>
<li>press <code>Ctrl V</code> a number of times till you are at the end of the file,</li>
<li>type the two lines lines of text (specified in the next step), or
copy them from the clipboard</li>
<li>type <code>Ctrl X</code> to exit; nano will ask you to save changes, type <code>Y</code>,
it will then verify the file name, type <code>Enter</code> and you're done</li>
</ul>
</div>
<p><strong>GitHub</strong>
Put the following lines in this file:</p>
<pre><code class="language-sh">GHPERS=&quot;xxx&quot;
export GHPERS
</code></pre>
<p><strong>GitLab</strong>
Put the following lines in this file:</p>
<pre><code class="language-sh">GL_BACKEND_PERS=&quot;xxx&quot;
export GL_BACKEND_PERS
</code></pre>
<p>where</p>
<ul>
<li><code>xxx</code> is replaced by your actual token.</li>
<li>
<p><code>BACKEND</code> is replaced by the uppercase GitLab backend
e.g.</p>
<ul>
<li><code>gitlab.com</code> becomes <code>GL_GITLAB_COM_PERS</code></li>
<li><code>gitlab.huc.knaw.nl</code> becomes <code>GL_GITLAB_HUC_KNAW_NL_PERS</code></li>
</ul>
<p>In this way you can store tokens for multiple GitLab backends.</p>
</li>
</ul>
<p>Then restart your terminal or say in an existing terminal</p>
<pre><code class="language-sh">source ~/.zshrc
</code></pre>
<h3 id="on-windows">On Windows</h3>
<p>Click on the Start button and type in <code>environment variable</code> into the search box.</p>
<p>Click on <code>Edit the system environment variables</code>.</p>
<p>This will
open up the System Properties dialog to the Advanced tab.</p>
<p>Click on the <code>Environment Variables button</code> at the bottom.</p>
<p>Click on <code>New &hellip;</code> under <code>User environment variables</code>.</p>
<p><strong>GitHub</strong>: Then fill in <code>GHPERS</code> under <em>name</em> and the token string under <em>value</em>.</p>
<p><strong>GitLab</strong>: Then fill in <code>GL_BACKEND_PERS</code>
under <em>name</em> and the token string under <em>value</em>.</p>
<p>Then quit the command prompt and start a new one.</p>
<h3 id="result">Result</h3>
<p><strong>GitHub</strong></p>
<p>With this done, you will automatically get the good rate limit,
whenever you fire up Text-Fabric in the future.</p>
<p><strong>GitLab</strong></p>
<p>You are now known to the GitLab backend, and you have the same access to its
repository as when you log in via the web interface.</p>
<h2 id="minimize-accessing-github">Minimize accessing GitHub</h2>
<p>Another way te avoid being bitten by the rate limit is to reduce the number
of your access actions to GitHub.</p>
<p>There are two instances where Text-Fabric wants to access GitHub:</p>
<ol>
<li>when you start the Text-Fabric browser from the command line</li>
<li>when you give the <code>use()</code> command in your Python program (or in a Jupyter Notebook).</li>
</ol>
<h3 id="using-a-corpus-for-the-first-time-within-the-rate-limit">Using a corpus for the first time, within the rate limit</h3>
<p>If you are still within the rate limit, just give the usual commands, such as</p>
<pre><code class="language-sh">text-fabric org/repo
</code></pre>
<p>or</p>
<pre><code class="language-python">use('org/repo', hoist=globals())
</code></pre>
<p>where <code>corpus</code> should be replaced with the real name of your corpus.</p>
<p>The data will be downloaded to your computer and stored in your
<code>~/text-fabric-data</code> directory tree.</p>
<h3 id="using-a-corpus-for-the-first-time-after-hitting-the-rate-limit">Using a corpus for the first time, after hitting the rate limit</h3>
<p>If you want to load a new corpus after having passed the rate limit, and not
wanting to wait an hour, you could directly clone the repos from GitHub/GitLab:</p>
<p>Open your terminal, and go to (or create) directory <code>~/github</code> or <code>~/gitlab</code>
(in your home directory).</p>
<p>Inside that directory, go to or create directory <code>org</code>
Go to that directory.</p>
<p>Then do</p>
<pre><code class="language-sh">git clone https://github.com/org/repo
</code></pre>
<p>or</p>
<pre><code class="language-sh">git clone https://gitlab.com/org/repo
</code></pre>
<p>(replacing <code>org</code> and <code>repo</code> with the values that apply to your corpus).</p>
<p>This will fetch the Text-Fabric <em>data</em>, <em>app</em>, and <em>tutorials</em> for that corpus.</p>
<p>Now you have all data you need on your system.</p>
<p>If you want to see by example how to use this data, have a look at
<a href="https://nbviewer.jupyter.org/github/annotation/banks/blob/master/tutorial/repo.ipynb">repo</a>,
especially when it discusses <code>clone</code>.</p>
<p>In order to run Text-Fabric without further access to the backend, say</p>
<pre><code class="language-sh">text-fabric corpus:clone checkout=clone
</code></pre>
<p>or, in a program,</p>
<pre><code class="language-python">A = use('org/repo:clone', checkData='clone', hoist=globals())
</code></pre>
<p>This will instruct Text-Fabric to use the app and data from within your <code>~/github</code>
or <code>~/gitlab</code> directory tree.</p>
<h3 id="using-a-corpus-that-you-already-have">Using a corpus that you already have</h3>
<p>Depending on how you got the corpus, it is in your
<code>~/github</code>, <code>~/gitlab</code> or in your <code>~/text-fabric-data</code> directory tree:</p>
<ol>
<li>if you cloned it from GitHub, it is in your <code>~/github</code> tree;</li>
<li>if you cloned it from GitLab, it is in your <code>~/gitlab</code> tree;</li>
<li>if you cloned it from an other instance of GitLab, say hosted at
<code>gitlab.huc.knaw.nl</code>, it is in your <code>~/gitlab.huc.knaw.nl</code> tree;</li>
<li>if you used the autoload of Text-Fabric it is in your <code>~/text-fabric-data</code>.</li>
</ol>
<p>In the first case, do this:</p>
<pre><code class="language-sh">text-fabric corpus:clone checkout=clone
</code></pre>
<p>or, in a program,</p>
<pre><code class="language-python">A = use('org/repo:clone', checkData='clone', hoist=globals())
</code></pre>
<p>In the second case, do this:</p>
<pre><code class="language-sh">text-fabric corpus:clone checkout=clone --backend=gitlab
</code></pre>
<p>or, in a program,</p>
<pre><code class="language-python">A = use('org/repo:clone', checkData='clone', backend=&quot;gitlab&quot;, hoist=globals())
</code></pre>
<p>In the third case, do this:</p>
<pre><code class="language-sh">text-fabric corpus:clone checkout=clone --backend=gitlab.huc.knaw.nl
</code></pre>
<p>or, in a program,</p>
<pre><code class="language-python">A = use(
        'org/repo:clone',
        checkData='clone',
        backend=&quot;gitlab&quot;.huc.knaw.nl,
        hoist=globals(),
    )
</code></pre>
<p>In the fourth case, do just this:</p>
<pre><code class="language-sh">text-fabric corpus
</code></pre>
<p>or, in a program,</p>
<pre><code class="language-python">A = use('org/repo', hoist=globals())
</code></pre>
<p>See also <code><a title="tf.advanced.app.App" href="app.html#tf.advanced.app.App">App</a></code>.</p>
<h3 id="updating-a-corpus-that-you-already-have">Updating a corpus that you already have</h3>
<p>If you cloned it from GitHub/GitLab:</p>
<p>In your terminal:</p>
<pre><code class="language-sh">cd ~/github/organization/repo
</code></pre>
<p>or</p>
<pre><code class="language-sh">cd ~/gitlab/organization/repo
</code></pre>
<p>(replacing <code>organization</code> with the name of the organization where the corpus resides
and <code>corpus</code> with the name of your corpus).</p>
<p>And then:</p>
<p>git pull origin master</p>
<pre><code>
Now you have the newest corpus data on your system.
and you can use it as follows
(we show the example for `github`):

``` sh
text-fabric corpus:clone checkout=clone
</code></pre>
<p>or, in a program,</p>
<pre><code class="language-python">A = use('org/repo:clone', checkData='clone', hoist=globals())
</code></pre>
<p>If you have autoloaded it from the backend,
you have to add the <code>latest</code> or <code>hot</code> specifier:</p>
<pre><code class="language-sh">text-fabric corpus:latest checkout=latest
</code></pre>
<p>or, in a program,</p>
<pre><code class="language-python">A = use('org/repo:latest', checkData='latest', hoist=globals())
</code></pre>
<p>And after that, you can omit <code>latest</code> or <code>hot</code> again, until you need new data again.</p>
<div class="admonition hint">
<p class="admonition-title">App versus data</p>
<p>The checkout specifiers such as <code>latest</code>, <code>hot</code>, <code>clone</code> apply
to either the corpus data or the TF App.</p>
<p>If the specifier follows the app name, separated with a colon,
it directs how the app code is being obtained.</p>
<p>If it is the value of the <code>checkout</code> parameter, it directs how the corpus data
is being obtained.</p>
</div>
<p>See further under <code><a title="tf.advanced.repo.checkoutRepo" href="#tf.advanced.repo.checkoutRepo">checkoutRepo()</a></code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L1-L1800" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# Auto downloading from a backend repository

## Description

Text-Fabric maintains local copies of subfolders of backend repositories,
where it stores the feature data of corpora that the user is working with.

Currently GitHub and GitLab are supported as backends.
In case of GitLab, not only [gitlab.com](https://gitlab.com) is supported,
but also GitLab instances on other servers that support the GitLab API.

There is some bookkeeping to account for which release and commit the
feature files come from.

Users can request data from any repo according to any release and/or commit.

## Rate limiting

The `checkRepo()` function uses the GitHub and GitLab APIs.
GitHub has a rate limiting policy for its API.
See below to deal with this if it becomes a problem.

On GitLab we ignore the rate limiting.

# GitHub

GitHub has a rate limiting policy for its API of max 60 calls per hour.
This can be too restrictive, and here are two ways to keep working nevertheless.

## Increase the rate limit

If you use this function in an application of yours that uses it very often,
you can increase the limit to 5000 calls per hour by making yourself known.

* [create a personal access token](https://github.com/settings/tokens)
* Copy your token and put it in an environment variable named `GHPERS`
  on the system where your app runs.
  See below how to do that.
* If `checkoutRepo` finds this variable, it will add the
  token to every GitHub API call it makes, and that will
  increase the rate.
* Never pass your personal credentials on to others, let them obtain their own!

You might want to read this:

* [Read more about rate limiting on GitHub](https://docs.github.com/en/rest/overview/resources-in-the-rest-api#rate-limiting)

# GitLab

In order to reach an on-premise GitLab and have access to the repository in
question, you may need to have a VPN connection with the GitLab backend.

Additionally, you may need to make your identity known.
If you have an account on the GitLab instance, go to your settings and request
a personal token with *api* privileges.

On your own system, make an environment variable named GL_*BACKEND*`_PERS` whose
content is exactly the value of this token.

And *BACKEND* should be the uppercase variant of the name of the GitLab backend,
where every character that is not a letter or digit or `_` is replaced by a `_`.

For example, for `gitlab.huc.knaw.nl` use `GL_GITLAB_HUC_KNAW_NL_PERS`
and for `gitlab.com` use `GL_GITLAB_COM_PERS`.

See below how to put this in an environment variable.

# Token in environment variables

How to put your personal access token into an environment variable?

!!! note &#34;What is an environment variable?&#34;
    It is a setting on your system that various programs/processes can read.
    On Windows it is part of the `Registry`.

    In this particular case, you put a personal token
    that you obtain from GitHub/GitLab
    in such an environment variable.
    When Text-Fabric accesses the backend, it will look up this token
    first, and pass it to the backend API. The backend then knows who you are and
    will give you more privileges.

### On Mac and Linux

Find the file that contains your terminal settings. In many cases that is
`.bash_profile` in your home directory.

Some people put commands like these in their `~/.bashrc` file, which is also fine.
If you do not see a `.bashrc` file, put it into your `.bash_profile` file.

A slightly more advanced shell than `bash` is `zsh` and it is the default on newer
Macs. If that is your case, look for a file `.zshrc` in your home directory or
create one.

Whatever is your case, pick the file indicated above and edit it.

!!! hint &#34;How to edit a file in your terminal?&#34;
    If you are already familiar with `vi`, `vim`, `emacs`, or `nano`
    you already know how to do it.

    If not, `nano` is simple editor that is useful for tasks like this.
    Assuming that you want to edit the `.zshrc` in your home directory,
    go to your terminal and say this:

        nano ~/.zshrc

    Then you get a view on your file. Then

    *   press `Ctrl V` a number of times till you are at the end of the file,
    *   type the two lines lines of text (specified in the next step), or
        copy them from the clipboard
    *   type `Ctrl X` to exit; nano will ask you to save changes, type `Y`,
        it will then verify the file name, type `Enter` and you&#39;re done


**GitHub**
Put the following lines in this file:

``` sh
GHPERS=&#34;xxx&#34;
export GHPERS
```

**GitLab**
Put the following lines in this file:

``` sh
GL_BACKEND_PERS=&#34;xxx&#34;
export GL_BACKEND_PERS
```

where

*   `xxx` is replaced by your actual token.
*   `BACKEND` is replaced by the uppercase GitLab backend
    e.g.
    *   `gitlab.com` becomes `GL_GITLAB_COM_PERS`
    *   `gitlab.huc.knaw.nl` becomes `GL_GITLAB_HUC_KNAW_NL_PERS`

    In this way you can store tokens for multiple GitLab backends.

Then restart your terminal or say in an existing terminal

```  sh
source ~/.zshrc
```

### On Windows

Click on the Start button and type in `environment variable` into the search box.

Click on `Edit the system environment variables`.

This will  open up the System Properties dialog to the Advanced tab.

Click on the `Environment Variables button` at the bottom.

Click on `New ...` under `User environment variables`.

**GitHub**: Then fill in `GHPERS` under *name* and the token string under *value*.

**GitLab**: Then fill in `GL_BACKEND_PERS`
under *name* and the token string under *value*.

Then quit the command prompt and start a new one.

### Result

**GitHub**

With this done, you will automatically get the good rate limit,
whenever you fire up Text-Fabric in the future.

**GitLab**

You are now known to the GitLab backend, and you have the same access to its
repository as when you log in via the web interface.

## Minimize accessing GitHub

Another way te avoid being bitten by the rate limit is to reduce the number
of your access actions to GitHub.

There are two instances where Text-Fabric wants to access GitHub:

1. when you start the Text-Fabric browser from the command line
2. when you give the `use()` command in your Python program (or in a Jupyter Notebook).

### Using a corpus for the first time, within the rate limit

If you are still within the rate limit, just give the usual commands, such as

``` sh
text-fabric org/repo
```

or

``` python
use(&#39;org/repo&#39;, hoist=globals())
```

where `corpus` should be replaced with the real name of your corpus.

The data will be downloaded to your computer and stored in your
`~/text-fabric-data` directory tree.

### Using a corpus for the first time, after hitting the rate limit

If you want to load a new corpus after having passed the rate limit, and not
wanting to wait an hour, you could directly clone the repos from GitHub/GitLab:

Open your terminal, and go to (or create) directory `~/github` or `~/gitlab`
(in your home directory).

Inside that directory, go to or create directory `org`
Go to that directory.

Then do

``` sh
git clone https://github.com/org/repo
```

or

``` sh
git clone https://gitlab.com/org/repo
```

(replacing `org` and `repo` with the values that apply to your corpus).

This will fetch the Text-Fabric *data*, *app*, and *tutorials* for that corpus.

Now you have all data you need on your system.

If you want to see by example how to use this data, have a look at
[repo](https://nbviewer.jupyter.org/github/annotation/banks/blob/master/tutorial/repo.ipynb),
especially when it discusses `clone`.

In order to run Text-Fabric without further access to the backend, say

``` sh
text-fabric corpus:clone checkout=clone
```

or, in a program,

``` python
A = use(&#39;org/repo:clone&#39;, checkData=&#39;clone&#39;, hoist=globals())
```

This will instruct Text-Fabric to use the app and data from within your `~/github`
or `~/gitlab` directory tree.

### Using a corpus that you already have

Depending on how you got the corpus, it is in your
`~/github`, `~/gitlab` or in your `~/text-fabric-data` directory tree:

1.   if you cloned it from GitHub, it is in your `~/github` tree;
2.   if you cloned it from GitLab, it is in your `~/gitlab` tree;
3.   if you cloned it from an other instance of GitLab, say hosted at
    `gitlab.huc.knaw.nl`, it is in your `~/gitlab.huc.knaw.nl` tree;
4.   if you used the autoload of Text-Fabric it is in your `~/text-fabric-data`.

In the first case, do this:

``` sh
text-fabric corpus:clone checkout=clone
```

or, in a program,

``` python
A = use(&#39;org/repo:clone&#39;, checkData=&#39;clone&#39;, hoist=globals())
```

In the second case, do this:

``` sh
text-fabric corpus:clone checkout=clone --backend=gitlab
```

or, in a program,

``` python
A = use(&#39;org/repo:clone&#39;, checkData=&#39;clone&#39;, backend=&#34;gitlab&#34;, hoist=globals())
```

In the third case, do this:

``` sh
text-fabric corpus:clone checkout=clone --backend=gitlab.huc.knaw.nl
```

or, in a program,

``` python
A = use(
        &#39;org/repo:clone&#39;,
        checkData=&#39;clone&#39;,
        backend=&#34;gitlab&#34;.huc.knaw.nl,
        hoist=globals(),
    )
```

In the fourth case, do just this:

``` sh
text-fabric corpus
```

or, in a program,

``` python
A = use(&#39;org/repo&#39;, hoist=globals())
```

See also `tf.advanced.app.App`.

### Updating a corpus that you already have

If you cloned it from GitHub/GitLab:

In your terminal:

``` sh
cd ~/github/organization/repo
```

or

``` sh
cd ~/gitlab/organization/repo
```

(replacing `organization` with the name of the organization where the corpus resides
and `corpus` with the name of your corpus).

And then:

git pull origin master
```

Now you have the newest corpus data on your system.
and you can use it as follows
(we show the example for `github`):

``` sh
text-fabric corpus:clone checkout=clone
```

or, in a program,

``` python
A = use(&#39;org/repo:clone&#39;, checkData=&#39;clone&#39;, hoist=globals())
```

If you have autoloaded it from the backend,
you have to add the `latest` or `hot` specifier:

``` sh
text-fabric corpus:latest checkout=latest
```

or, in a program,

``` python
A = use(&#39;org/repo:latest&#39;, checkData=&#39;latest&#39;, hoist=globals())
```

And after that, you can omit `latest` or `hot` again, until you need new data again.

!!! hint &#34;App versus data&#34;
    The checkout specifiers such as `latest`, `hot`, `clone` apply
    to either the corpus data or the TF App.

    If the specifier follows the app name, separated with a colon,
    it directs how the app code is being obtained.

    If it is the value of the `checkout` parameter, it directs how the corpus data
    is being obtained.
See further under `checkoutRepo`.
&#34;&#34;&#34;

import os
import io
import re
from shutil import rmtree
import requests
import base64
from zipfile import ZipFile

from github import Github, GithubException, UnknownObjectException
from gitlab import Gitlab
from gitlab.exceptions import GitlabGetError

from ..parameters import (
    GH,
    URL_TFDOC,
    backendRep,
    EXPRESS_SYNC,
    EXPRESS_SYNC_LEGACY,
    DOWNLOADS,
)
from ..core.helpers import console, htmlEsc, expanduser, initTree
from .helpers import dh
from .zipdata import zipData


VERSION_DIGIT_RE = re.compile(r&#34;^([0-9]+).*&#34;)
SHELL_VAR_RE = re.compile(r&#34;[^A-Z0-9_]&#34;)


def GLPERS(backend):
    return f&#34;GL_{SHELL_VAR_RE.sub(&#39;_&#39;, backend.upper())}_PERS&#34;


class Repo:
    &#34;&#34;&#34;Auxiliary class for `releaseData`&#34;&#34;&#34;

    def __init__(
        self,
        backend,
        org,
        repo,
        folder,
        version,
        increase,
        source=backendRep(GH, &#34;clone&#34;),
        dest=DOWNLOADS,
    ):
        self.org = org
        self.repo = repo
        self.folder = folder
        self.version = version
        self.increase = increase
        self.source = expanduser(source)
        self.dest = expanduser(dest)

        self.repoOnline = None

        self.backend = backend
        onGithub = backend is None
        self.onGithub = onGithub

        self.conn = None

    def newRelease(self):
        if not self.makeZip():
            return False

        conn = self.connect()

        if not conn:
            return False

        if not self.fetchInfo():
            return False

        if not self.bumpRelease():
            return False

        if not self.makeRelease():
            return False

        if not self.uploadZip():
            return False

        return True

    def makeZip(self):
        source = self.source
        dest = self.dest
        backend = self.backend
        org = self.org
        repo = self.repo
        folder = self.folder
        version = self.version

        dataIn = f&#34;{source}/{org}/{repo}/{folder}/{version}&#34;

        if not os.path.exists(dataIn):
            console(f&#34;No data found in {dataIn}&#34;, error=True)
            return False

        zipData(
            backend,
            org,
            repo,
            version=version,
            relative=folder,
            source=source,
            dest=dest,
        )
        return True

    def connect(self):
        log = self.log
        warning = self.warning
        backend = self.backend
        conn = self.conn

        if not conn:
            ghPerson = os.environ.get(&#34;GHPERS&#34;, None)
            if ghPerson:
                conn = Github(ghPerson)
            else:
                ghClient = os.environ.get(&#34;GHCLIENT&#34;, None)
                ghSecret = os.environ.get(&#34;GHSECRET&#34;, None)
                if ghClient and ghSecret:
                    conn = Github(client_id=ghClient, client_secret=ghSecret)
                else:
                    conn = Github()
        try:
            rate = conn.get_rate_limit().core
            log(
                f&#34;rate limit is {rate.limit} requests per hour,&#34;
                f&#34; with {rate.remaining} left for this hour&#34;
            )
            if rate.limit &lt; 100:
                warning(
                    f&#34;To increase the rate,&#34;
                    f&#34;see {URL_TFDOC}/advanced/repo.html#github&#34;
                )

            log(
                f&#34;\tconnecting to online {backend} repo {self.org}/{self.repo} ... &#34;,
                newline=False,
            )
            self.repoOnline = conn.get_repo(f&#34;{self.org}/{self.repo}&#34;)
            log(&#34;connected&#34;)
        except GithubException as why:
            warning(&#34;failed&#34;)
            warning(f&#34;{backend} says: {why}&#34;)
        except IOError:
            warning(&#34;no internet&#34;)

        self.conn = conn
        return conn

    def fetchInfo(self):
        g = self.repoOnline
        if not g:
            return False
        self.commitOn = None
        self.releaseOn = None
        self.releaseCommitOn = None
        result = self.getRelease()
        if result:
            self.releaseOn = result
        result = self.getCommit()
        if result:
            self.commitOn = result
        return True

    def bumpRelease(self):
        increase = self.increase

        latestR = self.releaseOn
        if latestR:
            console(f&#34;Latest release = {latestR}&#34;)
        else:
            latestR = &#34;v0.0.0&#34;
            console(&#34;No releases yet&#34;)

        # bump the release version

        v = &#34;&#34;
        if latestR.startswith(&#34;v&#34;):
            v = &#34;v&#34;
            r = latestR[1:] if latestR.startswith(&#34;v&#34;) else latestR
        parts = [int(p) for p in r.split(&#34;.&#34;)]
        nParts = len(parts)
        if nParts &lt; increase:
            for i in range(nParts, increase):
                parts.append(0)
        parts[increase - 1] += 1
        parts[increase:] = []
        newTag = f&#34;{v}{&#39;.&#39;.join(str(p) for p in parts)}&#34;
        console(f&#34;New release = {newTag}&#34;)
        self.newTag = newTag
        return True

    def makeRelease(self):
        g = self.repoOnline
        if not g:
            return False

        error = self.error
        commit = self.commitOn
        newTag = self.newTag

        tag_message = &#34;data update&#34;
        release_name = &#34;data update&#34;
        release_message = &#34;data update&#34;

        try:
            newReleaseObj = g.create_git_tag_and_release(
                newTag,
                tag_message,
                release_name,
                release_message,
                commit,
                &#34;commit&#34;,
            )
        except Exception as e:
            error(&#34;\tcannot create release&#34;, newline=True)
            console(str(e), error=True)
            return False

        self.newReleaseObj = newReleaseObj
        return True

    def uploadZip(self):
        newTag = self.newTag
        newReleaseObj = self.newReleaseObj
        dest = self.dest
        org = self.org
        repo = self.repo
        folder = self.folder
        version = self.version
        dataFile = f&#34;{folder}-{version}.zip&#34;
        dataDir = f&#34;{dest}/{org}-release/{repo}&#34;
        dataPath = f&#34;{dataDir}/{dataFile}&#34;
        error = self.error

        if not os.path.exists(dataPath):
            console(f&#34;No release data found: {dataPath}&#34;, error=True)
            return False

        try:
            newReleaseObj.upload_asset(
                dataPath, label=&#34;&#34;, content_type=&#34;application/zip&#34;, name=dataFile
            )
            console(f&#34;{dataFile} attached to release {newTag}&#34;)
        except Exception as e:
            error(&#34;\tcannot attach zipfile to release&#34;, newline=True)
            console(str(e), error=True)
            return False

        return True

    def getRelease(self):
        r = self.getReleaseObj()
        if not r:
            return None
        return r.tag_name

    def getReleaseObj(self):
        g = self.repoOnline
        if not g:
            return None

        error = self.error
        r = None

        try:
            r = g.get_latest_release()
        except UnknownObjectException:
            error(&#34;\tno releases&#34;, newline=True)
        except Exception:
            error(&#34;\tcannot find releases&#34;, newline=True)
        return r

    def getCommit(self):
        c = self.getCommitObj()
        if not c:
            return None
        return c.sha

    def getCommitObj(self):
        error = self.error

        g = self.repoOnline
        if not g:
            return None

        c = None

        try:
            cs = g.get_commits()
            if cs.totalCount:
                c = cs[0]
            else:
                error(&#34;\tno commits&#34;)
        except Exception:
            error(&#34;\tcannot find commits&#34;)
        return c

    def log(self, msg, newline=True):
        console(msg, newline=newline)

    def warning(self, msg, newline=True):
        console(msg, newline=newline)

    def error(self, msg, newline=True):
        console(msg, error=True, newline=newline)


def releaseData(
    backend,
    org,
    repo,
    folder,
    version,
    increase,
    source=None,
    dest=DOWNLOADS,
):
    &#34;&#34;&#34;Makes a new data release for a repository.

    !!!caution &#34;GitHub only&#34;
        Only GitHub repositories are supported.
        GitLab support will be implemented if there is a need for it.

    Parameters
    ----------
    backend: string
        `github` or `gitlab` or a GitLab instance such as `gitlab.huc.knaw.nl`.
    org: string
        The organization name of the repo
    repo: string
        The name of the repo
    folder: string
        The subfolder in the repo that contains the text-fabric files.
        If the tf files are versioned, it is the directory that
        contains the version directories.
        In most cases it is `tf` or it ends in `/tf`.
    version: string
        The version of the data that should be attached as a zip file to the release
    increase:
        The way in which the release version should be increased:

            1 = bump major version;
            2 = bump intermediate version;
            3 = bump minor version

    source: string, optional `None`
        Path to where the local GitHub clones are stored
    dest: string, optional `DOWNLOADS`
        Path to where the zipped data should be stored
    &#34;&#34;&#34;
    if source is None or not source:
        source = (backendRep(GH, &#34;clone&#34;),)

    R = Repo(GH, org, repo, folder, version, increase, source=source, dest=dest)
    return R.newRelease()


class Checkout:
    &#34;&#34;&#34;Auxiliary class for `checkoutRepo`&#34;&#34;&#34;

    @staticmethod
    def fromString(string):
        commit = None
        release = None
        local = None
        if not string:
            commit = &#34;&#34;
            release = &#34;&#34;
        elif string == &#34;latest&#34;:
            commit = None
            release = &#34;&#34;
        elif string == &#34;hot&#34;:
            commit = &#34;&#34;
            release = None
        elif string in {&#34;local&#34;, &#34;clone&#34;}:
            commit = None
            release = None
            local = string
        elif &#34;.&#34; in string or len(string) &lt; 12:
            commit = None
            release = string
        else:
            commit = string
            release = None
        return (commit, release, local)

    @staticmethod
    def toString(commit, release, local, backend, source=None, dest=None):
        extra = &#34;&#34;
        if local:
            if source is None:
                source = backendRep(backend, &#34;clone&#34;)
            if dest is None:
                dest = backendRep(backend, &#34;cache&#34;)

            baseRep = source if local == &#34;clone&#34; else dest
            extra = f&#34; offline under {baseRep}&#34;
        if local == &#34;clone&#34;:
            result = &#34;repo clone&#34;
        elif commit and release:
            result = f&#34;r{release}=#{commit}&#34;
        elif commit:
            result = f&#34;#{commit}&#34;
        elif release:
            result = f&#34;r{release}&#34;
        elif commit is None and release is None:
            result = &#34;unknown release or commit&#34;
        elif commit is None:
            result = &#34;latest release&#34;
        elif release is None:
            result = &#34;latest commit&#34;
        else:
            result = &#34;latest release or commit&#34;
        return f&#34;{result}{extra}&#34;

    def isClone(self):
        return self.local == &#34;clone&#34;

    def isOffline(self):
        return self.local in {&#34;clone&#34;, &#34;local&#34;}

    def __init__(
        self,
        backend,
        org,
        repo,
        relative,
        checkout,
        source,
        dest,
        keep,
        withPaths,
        silent,
        _browse,
        version=None,
        label=&#34;data&#34;,
    ):
        self.backend = backend
        onGithub = backend == GH
        self.onGithub = onGithub

        self.conn = None

        self._browse = _browse
        self.label = label
        self.org = org
        self.repo = repo
        self.source = source
        self.dest = dest
        (self.commitChk, self.releaseChk, self.local) = self.fromString(checkout)
        clone = self.isClone()
        offline = self.isOffline()

        self.relative = relative
        self.version = version
        versionRep = f&#34;/{version}&#34; if version else &#34;&#34;
        self.versionRep = versionRep
        relativeRep = f&#34;/{relative}&#34; if relative else &#34;&#34;
        self.dataDir = f&#34;{relative}{versionRep}&#34;

        self.baseLocal = expanduser(self.dest)
        self.dataRelLocal = f&#34;{org}/{repo}{relativeRep}&#34;
        self.dirPathSaveLocal = f&#34;{self.baseLocal}/{org}/{repo}&#34;
        self.dirPathLocal = f&#34;{self.baseLocal}/{self.dataRelLocal}{versionRep}&#34;
        self.dataPathLocal = f&#34;{self.dataRelLocal}{versionRep}&#34;
        self.filePathLocal = f&#34;{self.dirPathLocal}/{EXPRESS_SYNC}&#34;

        self.baseClone = expanduser(self.source)
        self.dataRelClone = f&#34;{org}/{repo}{relativeRep}&#34;
        self.dirPathClone = f&#34;{self.baseClone}/{self.dataRelClone}{versionRep}&#34;
        self.dataPathClone = f&#34;{self.dataRelClone}{versionRep}&#34;

        self.dataPath = self.dataRelClone if clone else self.dataRelLocal

        self.keep = keep
        self.withPaths = withPaths

        self.commitOff = None
        self.releaseOff = None
        self.commitOn = None
        self.releaseOn = None
        self.releaseCommitOn = None

        self.silent = silent

        self.repoOnline = None
        self.localBase = False
        self.localDir = None

        if clone:
            self.commitOff = None
            self.releaseOff = None
        else:
            self.fixInfo()
            self.readInfo()

        if not offline:
            self.connect()
            self.fetchInfo()

    def login(self):
        onGithub = self.onGithub
        conn = self.conn
        backend = self.backend

        self.canDownloadSubfolders = False

        if onGithub:
            person = os.environ.get(&#34;GHPERS&#34;, None)
            if person:
                conn = Github(person)
            else:
                client = os.environ.get(&#34;GHCLIENT&#34;, None)
                secret = os.environ.get(&#34;GHSECRET&#34;, None)
                if client and secret:
                    conn = Github(client_id=client, client_secret=secret)
                else:
                    conn = Github()
        else:
            bUrl = backendRep(backend, &#34;url&#34;)
            bMachine = backendRep(backend, &#34;machine&#34;)

            person = os.environ.get(GLPERS(bMachine), None)
            if person:
                conn = Gitlab(bUrl, private_token=person)
            else:
                conn = Gitlab(bUrl)

            backendVersion = conn.version()
            if (
                not backendVersion
                or backendVersion[0] == &#34;unknown&#34;
                or backendVersion[-1] == &#34;unknown&#34;
            ):
                self.conn = None
                self.error(f&#34;Cannot connect to GitLab instance {backend}\n&#34;)
                return

            versionThreshold = (14, 4, 0)

            if backendVersion:
                backendVersion = [
                    int(VERSION_DIGIT_RE.sub(r&#34;\1&#34;, vc))
                    for vc in backendVersion[0].split(&#34;.&#34;)
                ]
                if len(backendVersion) &lt; 3:
                    backendVersion.extend([0] * (3 - len(backendVersion)))

                canDownloadSubfolders = True
                for (t, v) in zip(versionThreshold, backendVersion):
                    if t != v:
                        canDownloadSubfolders = t &lt; v
                        break

                self.canDownloadSubfolders = canDownloadSubfolders

        self.conn = conn
        return conn

    def connect(self):
        conn = self.conn
        onGithub = self.onGithub
        backend = self.backend
        log = self.log
        warning = self.warning
        org = self.org
        repo = self.repo

        bName = backendRep(backend, &#34;name&#34;)

        if not conn:
            conn = self.login()
            if not self.conn:
                return

        if onGithub:
            try:
                rate = conn.get_rate_limit().core
                log(
                    f&#34;rate limit is {rate.limit} requests per hour,&#34;
                    f&#34; with {rate.remaining} left for this hour&#34;
                )
                if rate.limit &lt; 100:
                    warning(
                        f&#34;To increase the rate,&#34;
                        f&#34;see {URL_TFDOC}/advanced/repo.html#github&#34;
                    )

            except GithubException as why:
                warning(&#34;Could not get rate limit details&#34;)
                warning(f&#34;{bName} says: {why}&#34;)

        log(
            f&#34;\tconnecting to online {bName} repo {org}/{repo} ... &#34;,
            newline=False,
        )
        repoOnline = None

        try:
            if onGithub:
                try:
                    repoOnline = conn.get_repo(f&#34;{org}/{repo}&#34;)
                    log(&#34;connected&#34;)
                except GithubException as why:
                    warning(&#34;failed&#34;)
                    warning(f&#34;{bName} says: {why}&#34;)
            else:
                try:
                    repoOnline = conn.projects.get(f&#34;{org}/{repo}&#34;)
                    log(&#34;connected&#34;)
                except GitlabGetError as why:
                    warning(&#34;failed&#34;)
                    warning(f&#34;{bName} says: {why}&#34;)
        except IOError as why:
            warning(&#34;no internet&#34;)
            warning(&#34;failed&#34;)
            warning(f&#34;{bName} says: {why}&#34;)

        self.repoOnline = repoOnline

    def log(self, msg, newline=True):
        silent = self.silent
        if not silent:
            console(msg, newline=newline)

    def warning(self, msg, newline=True):
        silent = self.silent
        if not silent == &#34;deep&#34;:
            console(msg, newline=newline)

    def error(self, msg, newline=True):
        console(msg, error=True, newline=newline)

    def possibleError(self, msg, showErrors, again=False, indent=&#34;\t&#34;, newline=False):
        error = self.error
        warning = self.warning

        if showErrors:
            error(msg, newline=newline)
        else:
            warning(msg, newline=newline)
            if again:
                warning(f&#34;{indent}Will try something else&#34;)

    def makeSureLocal(self, attempt=False):
        _browse = self._browse
        backend = self.backend
        label = self.label
        offline = self.isOffline()
        clone = self.isClone()

        error = self.error
        warning = self.warning
        log = self.log

        cOff = self.commitOff
        rOff = self.releaseOff
        cChk = self.commitChk
        rChk = self.releaseChk
        cOn = self.commitOn
        rOn = self.releaseOn
        rcOn = self.releaseCommitOn

        askExact = rChk or cChk
        askExactRelease = rChk
        askExactCommit = cChk
        askLatest = not askExact and (rChk == &#34;&#34; or cChk == &#34;&#34;)
        askLatestAny = rChk == &#34;&#34; and cChk == &#34;&#34;
        askLatestRelease = rChk == &#34;&#34; and cChk is None
        askLatestCommit = cChk == &#34;&#34; and rChk is None

        isExactReleaseOff = rChk and rChk == rOff
        isExactCommitOff = cChk and cChk == cOff
        isExactReleaseOn = rChk and rChk == rOn
        isExactCommitOn = cChk and cChk == cOn
        isLatestRelease = rOff and rOff == rOn or cOff and cOff == rcOn
        isLatestCommit = cOff and cOff == cOn

        isLocal = (
            askExactRelease
            and isExactReleaseOff
            or askExactCommit
            and isExactCommitOff
            or askLatestAny
            and (isLatestRelease or isLatestCommit)
            or askLatestRelease
            and isLatestRelease
            or askLatestCommit
            and isLatestCommit
        )
        mayLocal = (
            askLatestAny
            and (rOff or cOff)
            or askLatestRelease
            and rOff
            or askLatestCommit
            and cOff
        )
        canOnline = self.repoOnline
        isOnline = canOnline and (
            askExactRelease
            and isExactReleaseOn
            or askExactCommit
            and isExactCommitOn
            or askLatestAny
            or askLatestRelease
            or askLatestCommit
        )

        if offline:
            if clone:
                dirPath = self.dirPathClone
                self.localBase = self.baseClone if os.path.exists(dirPath) else False
            else:
                self.localBase = (
                    self.baseLocal
                    if (
                        cChk
                        and cChk == cOff
                        or cChk is None
                        and cOff
                        or rChk
                        and rChk == rOff
                        or rChk is None
                        and rOff
                    )
                    else False
                )
            if not self.localBase:
                method = warning if attempt else error
                method(f&#34;The requested {label} is not available offline&#34;)
                # base = self.baseClone if clone else self.baseLocal
                dirVersion = self.dirPathClone if clone else self.dirPathLocal
                # method(f&#34;\t{base}/{self.dataPath} not found&#34;)
                method(f&#34;\t{dirVersion} not found&#34;)
        else:
            if isLocal:
                self.localBase = self.baseLocal
            else:
                if not canOnline:
                    if askLatest:
                        if mayLocal:
                            warning(f&#34;The offline {label} may not be the latest&#34;)
                            self.localBase = self.baseLocal
                        else:
                            error(f&#34;The requested {label} is not available offline&#34;)
                    else:
                        warning(f&#34;The requested {label} is not available offline&#34;)
                        error(&#34;No online connection&#34;)
                elif not isOnline:
                    error(f&#34;The requested {label} is not available online&#34;)
                else:
                    self.localBase = self.baseLocal if self.download() else False

        if self.localBase:
            self.localDir = self.dataPath
            state = (
                &#34;requested&#34;
                if askExact
                else &#34;latest release&#34;
                if rChk == &#34;&#34; and canOnline and self.releaseOff
                else &#34;latest? release&#34;
                if rChk == &#34;&#34; and not canOnline and self.releaseOff
                else &#34;latest commit&#34;
                if cChk == &#34;&#34; and canOnline and self.commitOff
                else &#34;latest? commit&#34;
                if cChk == &#34;&#34; and not canOnline and self.commitOff
                else &#34;local release&#34;
                if self.local == &#34;local&#34; and self.releaseOff
                else &#34;local commit&#34;
                if self.local == &#34;local&#34; and self.commitOff
                else &#34;local github&#34;
                if self.local == &#34;clone&#34;
                else &#34;for whatever reason&#34;
            )
            offString = self.toString(
                self.commitOff,
                self.releaseOff,
                self.local,
                backend,
                dest=self.dest,
                source=self.source,
            )
            labelEsc = htmlEsc(label)
            stateEsc = htmlEsc(state)
            offEsc = htmlEsc(offString)
            locEsc = htmlEsc(f&#34;{self.localBase}/{self.localDir}{self.versionRep}&#34;)
            if _browse:
                log(
                    f&#34;Using {label} in {self.localBase}/{self.localDir}{self.versionRep}:&#34;
                )
                log(f&#34;\t{offString} ({state})&#34;)
            else:
                dh(
                    f&#39;&lt;b title=&#34;{stateEsc}&#34;&gt;{labelEsc}:&lt;/b&gt;&#39;
                    f&#39; &lt;span title=&#34;{offEsc}&#34;&gt;{locEsc}&lt;/span&gt;&#39;
                )

    def download(self):
        cChk = self.commitChk
        rChk = self.releaseChk

        fetched = False
        if rChk is not None:
            fetched = self.downloadRelease(rChk, showErrors=cChk is None)
        if not fetched and cChk is not None:
            fetched = self.downloadCommit(cChk, showErrors=True)

        if fetched:
            self.writeInfo()
        return fetched

    def downloadRelease(self, release, showErrors=True):
        cChk = self.commitChk

        r = self.getReleaseObj(release, showErrors=showErrors)
        if not r:
            return False

        onGithub = self.onGithub
        version = self.version
        g = self.repoOnline

        (commit, release) = self.getReleaseFromObj(r)

        fetched = False

        if onGithub:
            assets = None
            try:
                assets = r.get_assets()
            except Exception:
                pass
            assetUrl = None
            versionRep3 = f&#34;-{version}&#34; if version else &#34;&#34;
            relativeFlat = self.relative.replace(&#34;/&#34;, &#34;-&#34;)
            dataFile = f&#34;{relativeFlat}{versionRep3}.zip&#34;
            if assets and assets.totalCount &gt; 0:
                for asset in assets:
                    if asset.name == dataFile:
                        assetUrl = asset.browser_download_url
                        break
            if assetUrl:
                fetched = self.downloadZip(assetUrl, showErrors=False)
            if not fetched:
                thisShowErrors = not cChk == &#34;&#34;
                fetched = self.downloadCommit(commit, showErrors=thisShowErrors)
        else:
            fetched = self.downloadZip(g, shiftUp=True, commit=commit, showErrors=True)

        if fetched:
            self.commitOff = commit
            self.releaseOff = release
        return fetched

    def downloadCommit(self, commit, showErrors=True):
        c = self.getCommitObj(commit)
        if not c:
            return False

        commit = self.getCommitFromObj(c)

        fetched = self.downloadDir(commit, exclude=r&#34;\.tfx&#34;, showErrors=showErrors)
        if fetched:
            self.commitOff = commit
            self.releaseOff = None
        return fetched

    def downloadZip(self, where, shiftUp=False, commit=None, showErrors=True):
        # commit parameter only supported for GitLab
        conn = self.conn
        backend = self.backend
        log = self.log
        label = self.label
        repo = self.repo
        dataDir = self.dataDir
        canDownloadSubfolders = self.canDownloadSubfolders
        dirPathLocal = self.dirPathLocal
        withPaths = self.withPaths

        dataUrl = None
        g = None

        if type(where) is str:
            dataUrl = where
            notice = where
            again = True
        else:
            g = where
            notice = backendRep(backend, &#34;name&#34;)
            again = False

        log(f&#34;\tdownloading from {notice} ... &#34;)

        try:
            if dataUrl is not None:
                r = requests.get(dataUrl, allow_redirects=True)
                zf = r.content
            elif g is not None:
                if canDownloadSubfolders:
                    # zf = g.repository_archive(format=&#34;zip&#34;, sha=commit, path=dataDir)
                    response = conn.http_get(
                        f&#34;/projects/{g.id}/repository/archive.zip&#34;,
                        query_data=dict(sha=commit, path=dataDir),
                        raw=True,
                    )
                    zf = response.content
                    if len(zf) == 0:
                        self.possibleError(
                            f&#34;No directory {dataDir} in #{commit}&#34;,
                            showErrors,
                            again=False,
                        )
                        msg = &#34;\tFailed&#34;
                        self.possibleError(msg, showErrors=showErrors)
                        return False
                else:
                    zf = g.repository_archive(format=&#34;zip&#34;, sha=commit)
            zf = io.BytesIO(zf)
        except Exception as e:
            msg = f&#34;\t{str(e)}\n\tcould not download from {notice}&#34;
            self.possibleError(msg, showErrors, again=again)
            return False

        log(f&#34;\tsaving {label}&#34;)

        cwd = os.getcwd()
        destZip = (
            os.path.dirname(dirPathLocal) if shiftUp and withPaths else dirPathLocal
        )
        good = True

        if g:
            gitlabSlugRe = re.compile(f&#34;^{repo}(?:-master)?-[^/]*/&#34;)
        try:
            z = ZipFile(zf)
            initTree(destZip, fresh=not self.keep)
            os.chdir(destZip)

            if withPaths:
                if g:
                    nItems = 0
                    for zInfo in z.infolist():
                        zInfo.filename = gitlabSlugRe.sub(&#34;&#34;, zInfo.filename) or &#34;/&#34;
                        if zInfo.filename[-1] == &#34;/&#34;:
                            continue
                        if zInfo.filename.startswith(&#34;__MACOS&#34;):
                            continue
                        if not canDownloadSubfolders:
                            if not zInfo.filename.startswith(dataDir):
                                continue
                        z.extract(zInfo)
                        nItems += 1
                    if nItems == 0:
                        self.possibleError(
                            f&#34;No directory {dataDir} in #{commit}&#34;,
                            showErrors,
                            again=False,
                        )
                        good = False
                else:
                    z.extractall()
                    if os.path.exists(&#34;__MACOSX&#34;):
                        rmtree(&#34;__MACOSX&#34;)
            else:
                nItems = 0
                for zInfo in z.infolist():
                    if g:
                        zInfo.filename = gitlabSlugRe.sub(&#34;&#34;, zInfo.filename) or &#34;/&#34;
                    if zInfo.filename[-1] == &#34;/&#34;:
                        continue
                    if zInfo.filename.startswith(&#34;__MACOS&#34;):
                        continue
                    if (
                        g
                        and not canDownloadSubfolders
                        and not zInfo.filename.startswith(dataDir)
                    ):
                        continue
                    zInfo.filename = os.path.basename(zInfo.filename)
                    z.extract(zInfo)
                    nItems += 1
                if nItems == 0:
                    msg = f&#34;#{commit}&#34; if g else notice
                    self.possibleError(
                        f&#34;No directory {dataDir} in {msg}&#34;,
                        showErrors,
                        again=False,
                    )
                    msg = &#34;\tFailed&#34;
                    self.possibleError(msg, showErrors=showErrors)
                    good = False
        except Exception:
            msg = f&#34;\tcould not save {label} to {destZip}&#34;
            self.possibleError(msg, showErrors=showErrors, again=True)
            os.chdir(cwd)
            return False
        os.chdir(cwd)
        return good

    def downloadDir(self, commit, exclude=None, showErrors=False):
        g = self.repoOnline
        if not g:
            return None

        onGithub = self.onGithub
        backend = self.backend

        log = self.log

        destDir = f&#34;{self.dirPathLocal}&#34;
        destSave = f&#34;{self.dirPathSaveLocal}&#34;
        initTree(destDir, fresh=not self.keep)

        excludeRe = re.compile(exclude) if exclude else None

        good = True

        if onGithub:

            def _downloadDir(subPath, level=0):
                nonlocal good
                if not good:
                    return
                lead = &#34;\t&#34; * level
                try:
                    contents = g.get_contents(subPath, ref=commit)
                except UnknownObjectException:
                    msg = (
                        f&#34;{lead}No directory {subPath} in &#34;
                        f&#34;{self.toString(commit, None, False, backend)}&#34;
                    )
                    self.possibleError(msg, showErrors, again=True, indent=lead)
                    good = False
                    return
                for content in contents:
                    thisPath = content.path
                    log(f&#34;\t{lead}{thisPath}...&#34;, newline=False)
                    if exclude and excludeRe.search(thisPath):
                        log(&#34;excluded&#34;)
                        continue
                    if content.type == &#34;dir&#34;:
                        log(&#34;directory&#34;)
                        os.makedirs(f&#34;{destSave}/{thisPath}&#34;, exist_ok=True)
                        _downloadDir(thisPath, level + 1)
                    else:
                        try:
                            fileContent = g.get_git_blob(content.sha)
                            fileData = base64.b64decode(fileContent.content)
                            fileDest = f&#34;{destSave}/{thisPath}&#34;
                            with open(fileDest, &#34;wb&#34;) as fd:
                                fd.write(fileData)
                            log(&#34;downloaded&#34;)
                        except (GithubException, IOError):
                            msg = &#34;error&#34;
                            self.possibleError(msg, showErrors, again=True, indent=lead)
                            good = False

            _downloadDir(self.dataDir, 0)

        else:
            good = self.downloadZip(g, shiftUp=True, commit=commit, showErrors=True)

        if good:
            log(&#34;\tOK&#34;)
        else:
            if onGithub:
                msg = &#34;\tFailed&#34;
                self.possibleError(msg, showErrors=showErrors if onGithub else True)

        return good

    def getRelease(self, release, showErrors=True):
        r = self.getReleaseObj(release, showErrors=showErrors)
        if not r:
            return None
        return self.getReleaseFromObj(r)

    def getCommit(self, commit):
        c = self.getCommitObj(commit)
        if not c:
            return None
        return self.getCommitFromObj(c)

    def getReleaseObj(self, release, showErrors=True):
        g = self.repoOnline
        if not g:
            return None

        onGithub = self.onGithub

        r = None
        msg = f&#39; tagged &#34;{release}&#34;&#39; if release else &#34;s&#34;

        if onGithub:
            try:
                r = g.get_release(release) if release else g.get_latest_release()
            except UnknownObjectException:
                self.possibleError(
                    f&#34;\tcannot find release{msg}&#34;, showErrors, newline=True
                )
            except Exception:
                self.possibleError(
                    f&#34;\tcannot find release{msg}&#34;,
                    showErrors,
                    newline=True,
                )
        else:
            try:
                if release:
                    r = g.releases.get(release)
                else:
                    releases = g.releases.list(all=True)
                    r = (
                        sorted(releases, key=lambda r: r.released_at)[-1]
                        if releases
                        else None
                    )
            except Exception:
                r = None
            if r is None:
                self.possibleError(
                    f&#34;\tcannot find release{msg}&#34;, showErrors, newline=True
                )
        return r

    def getCommitObj(self, commit):
        g = self.repoOnline
        if not g:
            return None

        error = self.error
        onGithub = self.onGithub

        c = None
        msg = f&#39; with hash &#34;{commit}&#34;&#39; if commit else &#34;s&#34;

        if onGithub:
            try:
                cs = g.get_commits(sha=commit) if commit else g.get_commits()
                if cs.totalCount:
                    c = cs[0]
                else:
                    error(f&#34;\tcannot find commit{msg}&#34;)
            except Exception:
                error(f&#34;\tcannot find commit{msg}&#34;)
        else:
            try:
                cs = g.commits.list(all=True)
                if not len(cs):
                    error(f&#34;\tno commit{msg}&#34;)
                else:
                    cs = sorted(cs, key=lambda x: x.created_at)
                    if commit:
                        for com in cs:
                            if com.id == commit:
                                c = com
                                break
                    else:
                        if len(cs):
                            c = cs[-1]
                    if c is None:
                        error(f&#34;\tcannot find commit{msg}&#34;)
            except Exception:
                error(f&#34;\tcannot find commit{msg}&#34;)
        return c

    def getReleaseFromObj(self, r):
        g = self.repoOnline
        if not g:
            return None

        onGithub = self.onGithub

        release = r.tag_name

        if onGithub:
            ref = g.get_git_ref(f&#34;tags/{release}&#34;)
            commit = ref.object.sha
        else:
            commit = r.commit[&#34;id&#34;]
        return (commit, release)

    def getCommitFromObj(self, c):
        g = self.repoOnline
        if not g:
            return None

        onGithub = self.onGithub

        return c.sha if onGithub else c.id

    def fetchInfo(self):
        g = self.repoOnline
        if not g:
            return

        self.commitOn = None
        self.releaseOn = None
        self.releaseCommitOn = None
        if self.releaseChk is not None:
            result = self.getRelease(self.releaseChk, showErrors=self.commitChk is None)
            if result:
                (self.releaseCommitOn, self.releaseOn) = result
        if self.commitChk is not None:
            result = self.getCommit(self.commitChk)
            if result:
                self.commitOn = result

    def fixInfo(self):
        sDir = self.dirPathLocal
        if not os.path.exists(sDir):
            return
        for sFile in EXPRESS_SYNC_LEGACY:
            sPath = f&#34;{sDir}/{sFile}&#34;
            if os.path.exists(sPath):
                goodPath = f&#34;{sDir}/{EXPRESS_SYNC}&#34;
                if os.path.exists(goodPath):
                    os.remove(sPath)
                else:
                    os.rename(sPath, goodPath)

    def readInfo(self):
        if os.path.exists(self.filePathLocal):
            with open(self.filePathLocal, encoding=&#34;utf8&#34;) as f:
                for line in f:
                    string = line.strip()
                    (commit, release, local) = self.fromString(string)
                    if commit:
                        self.commitOff = commit
                    if release:
                        self.releaseOff = release

    def writeInfo(self):
        if not os.path.exists(self.dirPathLocal):
            os.makedirs(self.dirPathLocal, exist_ok=True)
        with open(self.filePathLocal, &#34;w&#34;, encoding=&#34;utf8&#34;) as f:
            if self.releaseOff:
                f.write(f&#34;{self.releaseOff}\n&#34;)
            if self.commitOff:
                f.write(f&#34;{self.commitOff}\n&#34;)


def checkoutRepo(
    backend,
    _browse=False,
    org=&#34;annotation&#34;,
    repo=&#34;banks&#34;,
    folder=&#34;tf&#34;,
    version=&#34;&#34;,
    checkout=&#34;&#34;,
    source=None,
    dest=None,
    withPaths=True,
    keep=True,
    silent=False,
    label=&#34;data&#34;,
):
    &#34;&#34;&#34;Checks out text-fabric data from an (online) repository.

    The copy may be taken from any point in the commit history of the online repo.

    If you call this function, it will check whether the requested data is already
    on your computer in the expected location.
    If not, it may check whether the data is online and if so, download it to the
    expected location.

    Parameters
    ----------
    backend: string
        `github` or `gitlab` or a GitLab instance such as `gitlab.huc.knaw.nl`.

    org: string, optional &#34;annotation&#34;
        The *org* on GitHub or the group on GitLab

    repo: string, optional &#34;banks&#34;
        The *repo* on GitHub or the project on GitLab

    folder: string, optional `tf`
        The subfolder in the repo that contains the text-fabric files.
        If the tf files are versioned, it is the directory that
        contains the version directories.
        In most cases it is `tf` or it ends in `/tf`.

    version: string, optional, the empty string
        The version of the tf feature data

    checkout: string, optional the mepty string
        From which version/release/local copy we should extract the data.

        *   `&#34;&#34;`: whatever you have locally in `~/text-fabric-data`.
            If there is no data there, data will be downloaded.
        *   `local`: whatever you have locally in `~/text-fabric-data`.
            If there is no data there, you get an error message.
        *   `clone`: whatever you have locally as a GitHub/GitLab clone
            If there is no data there, you get an error message.
        *   `latest`: make sure the latest release has been fetched from online
        *   `hot`: make sure the latest commit has been fetched from online
        *   `vx.y.z`: make sure this specific release has been fetched from online
        *   `1234567890abcdef`: make sure this specific commit
            has been fetched from online

        See the
        [repo](https://nbviewer.jupyter.org/github/annotation/banks/blob/master/tutorial/repo.ipynb)
        notebook for an exhaustive demo of all the checkout options.

    source: string, optional empty string
        The base of your local repository clones.
        If given, it overrides the semi-baked in `~/github` value.

    dest: string, optional empty string
        The base of your local cache of downloaded tf feature files.
        If given, it overrides the semi-baked in `~/text-fabric-data` value.

    withPaths: boolean, optional `True`
        The data will be saved without the directory structure
        of files that are being downloaded.

    keep: boolean, optional `True`
        If False, the destination directory will be cleared
        before a download takes place.

    silent: boolean, optional True`
        Will suppress non-error messages.

    label: string, optional `data`
        If passed, it will will change the word &#34;data&#34; in log messages
        to what you choose.
        We use `label=&#39;TF-app&#39;` when we use this function to checkout the code
        of a TF-app.

    Returns
    -------
        (commitOffline, releaseOffline, kindLocal, localBase, localDir)

    *   *commitOffline* is the commit hash of the data you have offline afterwards
    *   *releaseOffline* is the release tag of the data you have offline afterwards
    *   *kindLocal* indicates whether an online check has been performed:
        it is `None` if there has been an online check. Otherwise it is
        `clone` if the data is in your `~/github` directory else it is `local`.
    *   *localBase* where the data is under: `~/github` or `~/text-fabric-data`,
        or whatever you have passed as *source* and *dest*.
    *   *localDir* releative path from *localBase* to your data.
        If your data has versions, *localDir* points to directory that has the versions,
        not to a specific version.

    Your local copy can be found:

    *   in the cache under your `~/text-fabric-data`, and from
        there under *backend*/*org/repo* where *backend* is github or gitlab or
        the server name of a gitlab instance.

    or

    *   in the place where you store your clones from GitHub/GitLab:
        `~/github` or `~/gitlab` or `~/`*backend*
        (whatever the value of the *backend* parameter is.
        From there it is under *org/repo*.

    The actual feature files are in *folder/version* if there is a *version*,
    else *folder*.

    &#34;&#34;&#34;

    if source is None:
        source = backendRep(backend, &#34;clone&#34;)

    if dest is None:
        dest = backendRep(backend, &#34;cache&#34;)

    def resolve(chkout, attempt=False):
        rData = Checkout(
            backend,
            org,
            repo,
            folder,
            chkout,
            source,
            dest,
            keep,
            withPaths,
            silent,
            _browse,
            version=version,
            label=label,
        )
        rData.makeSureLocal(attempt=attempt)
        return (
            (
                rData.commitOff,
                rData.releaseOff,
                rData.local,
                rData.localBase,
                rData.localDir,
            )
            if rData.localBase
            else (None, None, False, False, None)
        )

    if checkout == &#34;&#34;:
        rData = resolve(&#34;local&#34;, attempt=True)
        if rData[3]:
            return rData

    return resolve(checkout)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.advanced.repo.GLPERS"><code class="name flex">
<span>def <span class="ident">GLPERS</span></span>(<span>backend)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L417-L418" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def GLPERS(backend):
    return f&#34;GL_{SHELL_VAR_RE.sub(&#39;_&#39;, backend.upper())}_PERS&#34;</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.checkoutRepo"><code class="name flex">
<span>def <span class="ident">checkoutRepo</span></span>(<span>backend, org='annotation', repo='banks', folder='tf', version='', checkout='', source=None, dest=None, withPaths=True, keep=True, silent=False, label='data')</span>
</code></dt>
<dd>
<div class="desc"><p>Checks out text-fabric data from an (online) repository.</p>
<p>The copy may be taken from any point in the commit history of the online repo.</p>
<p>If you call this function, it will check whether the requested data is already
on your computer in the expected location.
If not, it may check whether the data is online and if so, download it to the
expected location.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>backend</code></strong> :&ensp;<code>string</code></dt>
<dd><code>github</code> or <code>gitlab</code> or a GitLab instance such as <code>gitlab.huc.knaw.nl</code>.</dd>
<dt><strong><code>org</code></strong> :&ensp;<code>string</code>, optional <code>"annotation"</code></dt>
<dd>The <em>org</em> on GitHub or the group on GitLab</dd>
<dt><strong><code>repo</code></strong> :&ensp;<code>string</code>, optional <code>"banks"</code></dt>
<dd>The <em>repo</em> on GitHub or the project on GitLab</dd>
<dt><strong><code>folder</code></strong> :&ensp;<code>string</code>, optional <code><a title="tf" href="../index.html">tf</a></code></dt>
<dd>The subfolder in the repo that contains the text-fabric files.
If the tf files are versioned, it is the directory that
contains the version directories.
In most cases it is <code><a title="tf" href="../index.html">tf</a></code> or it ends in <code>/tf</code>.</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>string</code>, optional<code>, the empty string</code></dt>
<dd>The version of the tf feature data</dd>
<dt><strong><code>checkout</code></strong> :&ensp;<code>string</code>, optional <code>the mepty string</code></dt>
<dd>
<p>From which version/release/local copy we should extract the data.</p>
<ul>
<li><code>""</code>: whatever you have locally in <code>~/text-fabric-data</code>.
If there is no data there, data will be downloaded.</li>
<li><code>local</code>: whatever you have locally in <code>~/text-fabric-data</code>.
If there is no data there, you get an error message.</li>
<li><code>clone</code>: whatever you have locally as a GitHub/GitLab clone
If there is no data there, you get an error message.</li>
<li><code>latest</code>: make sure the latest release has been fetched from online</li>
<li><code>hot</code>: make sure the latest commit has been fetched from online</li>
<li><code>vx.y.z</code>: make sure this specific release has been fetched from online</li>
<li><code>1234567890abcdef</code>: make sure this specific commit
has been fetched from online</li>
</ul>
<p>See the
<a href="https://nbviewer.jupyter.org/github/annotation/banks/blob/master/tutorial/repo.ipynb">repo</a>
notebook for an exhaustive demo of all the checkout options.</p>
</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>string</code>, optional <code>empty string</code></dt>
<dd>The base of your local repository clones.
If given, it overrides the semi-baked in <code>~/github</code> value.</dd>
<dt><strong><code>dest</code></strong> :&ensp;<code>string</code>, optional <code>empty string</code></dt>
<dd>The base of your local cache of downloaded tf feature files.
If given, it overrides the semi-baked in <code>~/text-fabric-data</code> value.</dd>
<dt><strong><code>withPaths</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>The data will be saved without the directory structure
of files that are being downloaded.</dd>
<dt><strong><code>keep</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>If False, the destination directory will be cleared
before a download takes place.</dd>
<dt><strong><code>silent</code></strong> :&ensp;<code>boolean</code>, optional `True``</dt>
<dd>Will suppress non-error messages.</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>string</code>, optional <code>data</code></dt>
<dd>If passed, it will will change the word "data" in log messages
to what you choose.
We use <code>label='TF-app'</code> when we use this function to checkout the code
of a TF-app.</dd>
</dl>
<h2 id="returns">Returns</h2>
<pre><code>(commitOffline, releaseOffline, kindLocal, localBase, localDir)
</code></pre>
<ul>
<li><em>commitOffline</em> is the commit hash of the data you have offline afterwards</li>
<li><em>releaseOffline</em> is the release tag of the data you have offline afterwards</li>
<li><em>kindLocal</em> indicates whether an online check has been performed:
it is <code>None</code> if there has been an online check. Otherwise it is
<code>clone</code> if the data is in your <code>~/github</code> directory else it is <code>local</code>.</li>
<li><em>localBase</em> where the data is under: <code>~/github</code> or <code>~/text-fabric-data</code>,
or whatever you have passed as <em>source</em> and <em>dest</em>.</li>
<li><em>localDir</em> releative path from <em>localBase</em> to your data.
If your data has versions, <em>localDir</em> points to directory that has the versions,
not to a specific version.</li>
</ul>
<dl>
<dt><code>Your local copy can be found:</code></dt>
<dd>&nbsp;</dd>
</dl>
<ul>
<li>in the cache under your <code>~/text-fabric-data</code>, and from
there under <em>backend</em>/<em>org/repo</em> where <em>backend</em> is github or gitlab or
the server name of a gitlab instance.</li>
</ul>
<dl>
<dt><code>or</code></dt>
<dd>&nbsp;</dd>
</dl>
<ul>
<li>in the place where you store your clones from GitHub/GitLab:
<code>~/github</code> or <code>~/gitlab</code> or <code>~/</code><em>backend</em>
(whatever the value of the <em>backend</em> parameter is.
From there it is under <em>org/repo</em>.</li>
</ul>
<p>The actual feature files are in <em>folder/version</em> if there is a <em>version</em>,
else <em>folder</em>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L1639-L1800" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def checkoutRepo(
    backend,
    _browse=False,
    org=&#34;annotation&#34;,
    repo=&#34;banks&#34;,
    folder=&#34;tf&#34;,
    version=&#34;&#34;,
    checkout=&#34;&#34;,
    source=None,
    dest=None,
    withPaths=True,
    keep=True,
    silent=False,
    label=&#34;data&#34;,
):
    &#34;&#34;&#34;Checks out text-fabric data from an (online) repository.

    The copy may be taken from any point in the commit history of the online repo.

    If you call this function, it will check whether the requested data is already
    on your computer in the expected location.
    If not, it may check whether the data is online and if so, download it to the
    expected location.

    Parameters
    ----------
    backend: string
        `github` or `gitlab` or a GitLab instance such as `gitlab.huc.knaw.nl`.

    org: string, optional &#34;annotation&#34;
        The *org* on GitHub or the group on GitLab

    repo: string, optional &#34;banks&#34;
        The *repo* on GitHub or the project on GitLab

    folder: string, optional `tf`
        The subfolder in the repo that contains the text-fabric files.
        If the tf files are versioned, it is the directory that
        contains the version directories.
        In most cases it is `tf` or it ends in `/tf`.

    version: string, optional, the empty string
        The version of the tf feature data

    checkout: string, optional the mepty string
        From which version/release/local copy we should extract the data.

        *   `&#34;&#34;`: whatever you have locally in `~/text-fabric-data`.
            If there is no data there, data will be downloaded.
        *   `local`: whatever you have locally in `~/text-fabric-data`.
            If there is no data there, you get an error message.
        *   `clone`: whatever you have locally as a GitHub/GitLab clone
            If there is no data there, you get an error message.
        *   `latest`: make sure the latest release has been fetched from online
        *   `hot`: make sure the latest commit has been fetched from online
        *   `vx.y.z`: make sure this specific release has been fetched from online
        *   `1234567890abcdef`: make sure this specific commit
            has been fetched from online

        See the
        [repo](https://nbviewer.jupyter.org/github/annotation/banks/blob/master/tutorial/repo.ipynb)
        notebook for an exhaustive demo of all the checkout options.

    source: string, optional empty string
        The base of your local repository clones.
        If given, it overrides the semi-baked in `~/github` value.

    dest: string, optional empty string
        The base of your local cache of downloaded tf feature files.
        If given, it overrides the semi-baked in `~/text-fabric-data` value.

    withPaths: boolean, optional `True`
        The data will be saved without the directory structure
        of files that are being downloaded.

    keep: boolean, optional `True`
        If False, the destination directory will be cleared
        before a download takes place.

    silent: boolean, optional True`
        Will suppress non-error messages.

    label: string, optional `data`
        If passed, it will will change the word &#34;data&#34; in log messages
        to what you choose.
        We use `label=&#39;TF-app&#39;` when we use this function to checkout the code
        of a TF-app.

    Returns
    -------
        (commitOffline, releaseOffline, kindLocal, localBase, localDir)

    *   *commitOffline* is the commit hash of the data you have offline afterwards
    *   *releaseOffline* is the release tag of the data you have offline afterwards
    *   *kindLocal* indicates whether an online check has been performed:
        it is `None` if there has been an online check. Otherwise it is
        `clone` if the data is in your `~/github` directory else it is `local`.
    *   *localBase* where the data is under: `~/github` or `~/text-fabric-data`,
        or whatever you have passed as *source* and *dest*.
    *   *localDir* releative path from *localBase* to your data.
        If your data has versions, *localDir* points to directory that has the versions,
        not to a specific version.

    Your local copy can be found:

    *   in the cache under your `~/text-fabric-data`, and from
        there under *backend*/*org/repo* where *backend* is github or gitlab or
        the server name of a gitlab instance.

    or

    *   in the place where you store your clones from GitHub/GitLab:
        `~/github` or `~/gitlab` or `~/`*backend*
        (whatever the value of the *backend* parameter is.
        From there it is under *org/repo*.

    The actual feature files are in *folder/version* if there is a *version*,
    else *folder*.

    &#34;&#34;&#34;

    if source is None:
        source = backendRep(backend, &#34;clone&#34;)

    if dest is None:
        dest = backendRep(backend, &#34;cache&#34;)

    def resolve(chkout, attempt=False):
        rData = Checkout(
            backend,
            org,
            repo,
            folder,
            chkout,
            source,
            dest,
            keep,
            withPaths,
            silent,
            _browse,
            version=version,
            label=label,
        )
        rData.makeSureLocal(attempt=attempt)
        return (
            (
                rData.commitOff,
                rData.releaseOff,
                rData.local,
                rData.localBase,
                rData.localDir,
            )
            if rData.localBase
            else (None, None, False, False, None)
        )

    if checkout == &#34;&#34;:
        rData = resolve(&#34;local&#34;, attempt=True)
        if rData[3]:
            return rData

    return resolve(checkout)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.releaseData"><code class="name flex">
<span>def <span class="ident">releaseData</span></span>(<span>backend, org, repo, folder, version, increase, source=None, dest='/Users/me/Downloads')</span>
</code></dt>
<dd>
<div class="desc"><p>Makes a new data release for a repository.</p>
<div class="admonition caution">
<p class="admonition-title">GitHub only</p>
<p>Only GitHub repositories are supported.
GitLab support will be implemented if there is a need for it.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>backend</code></strong> :&ensp;<code>string</code></dt>
<dd><code>github</code> or <code>gitlab</code> or a GitLab instance such as <code>gitlab.huc.knaw.nl</code>.</dd>
<dt><strong><code>org</code></strong> :&ensp;<code>string</code></dt>
<dd>The organization name of the repo</dd>
<dt><strong><code>repo</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the repo</dd>
<dt><strong><code>folder</code></strong> :&ensp;<code>string</code></dt>
<dd>The subfolder in the repo that contains the text-fabric files.
If the tf files are versioned, it is the directory that
contains the version directories.
In most cases it is <code><a title="tf" href="../index.html">tf</a></code> or it ends in <code>/tf</code>.</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>string</code></dt>
<dd>The version of the data that should be attached as a zip file to the release</dd>
</dl>
<p>increase:
The way in which the release version should be increased:</p>
<pre><code>    1 = bump major version;
    2 = bump intermediate version;
    3 = bump minor version
</code></pre>
<dl>
<dt><strong><code>source</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>Path to where the local GitHub clones are stored</dd>
<dt><strong><code>dest</code></strong> :&ensp;<code>string</code>, optional <code>DOWNLOADS</code></dt>
<dd>Path to where the zipped data should be stored</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L703-L750" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def releaseData(
    backend,
    org,
    repo,
    folder,
    version,
    increase,
    source=None,
    dest=DOWNLOADS,
):
    &#34;&#34;&#34;Makes a new data release for a repository.

    !!!caution &#34;GitHub only&#34;
        Only GitHub repositories are supported.
        GitLab support will be implemented if there is a need for it.

    Parameters
    ----------
    backend: string
        `github` or `gitlab` or a GitLab instance such as `gitlab.huc.knaw.nl`.
    org: string
        The organization name of the repo
    repo: string
        The name of the repo
    folder: string
        The subfolder in the repo that contains the text-fabric files.
        If the tf files are versioned, it is the directory that
        contains the version directories.
        In most cases it is `tf` or it ends in `/tf`.
    version: string
        The version of the data that should be attached as a zip file to the release
    increase:
        The way in which the release version should be increased:

            1 = bump major version;
            2 = bump intermediate version;
            3 = bump minor version

    source: string, optional `None`
        Path to where the local GitHub clones are stored
    dest: string, optional `DOWNLOADS`
        Path to where the zipped data should be stored
    &#34;&#34;&#34;
    if source is None or not source:
        source = (backendRep(GH, &#34;clone&#34;),)

    R = Repo(GH, org, repo, folder, version, increase, source=source, dest=dest)
    return R.newRelease()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.advanced.repo.Checkout"><code class="flex name class">
<span>class <span class="ident">Checkout</span></span>
<span>(</span><span>backend, org, repo, relative, checkout, source, dest, keep, withPaths, silent, _browse, version=None, label='data')</span>
</code></dt>
<dd>
<div class="desc"><p>Auxiliary class for <code><a title="tf.advanced.repo.checkoutRepo" href="#tf.advanced.repo.checkoutRepo">checkoutRepo()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L753-L1636" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Checkout:
    &#34;&#34;&#34;Auxiliary class for `checkoutRepo`&#34;&#34;&#34;

    @staticmethod
    def fromString(string):
        commit = None
        release = None
        local = None
        if not string:
            commit = &#34;&#34;
            release = &#34;&#34;
        elif string == &#34;latest&#34;:
            commit = None
            release = &#34;&#34;
        elif string == &#34;hot&#34;:
            commit = &#34;&#34;
            release = None
        elif string in {&#34;local&#34;, &#34;clone&#34;}:
            commit = None
            release = None
            local = string
        elif &#34;.&#34; in string or len(string) &lt; 12:
            commit = None
            release = string
        else:
            commit = string
            release = None
        return (commit, release, local)

    @staticmethod
    def toString(commit, release, local, backend, source=None, dest=None):
        extra = &#34;&#34;
        if local:
            if source is None:
                source = backendRep(backend, &#34;clone&#34;)
            if dest is None:
                dest = backendRep(backend, &#34;cache&#34;)

            baseRep = source if local == &#34;clone&#34; else dest
            extra = f&#34; offline under {baseRep}&#34;
        if local == &#34;clone&#34;:
            result = &#34;repo clone&#34;
        elif commit and release:
            result = f&#34;r{release}=#{commit}&#34;
        elif commit:
            result = f&#34;#{commit}&#34;
        elif release:
            result = f&#34;r{release}&#34;
        elif commit is None and release is None:
            result = &#34;unknown release or commit&#34;
        elif commit is None:
            result = &#34;latest release&#34;
        elif release is None:
            result = &#34;latest commit&#34;
        else:
            result = &#34;latest release or commit&#34;
        return f&#34;{result}{extra}&#34;

    def isClone(self):
        return self.local == &#34;clone&#34;

    def isOffline(self):
        return self.local in {&#34;clone&#34;, &#34;local&#34;}

    def __init__(
        self,
        backend,
        org,
        repo,
        relative,
        checkout,
        source,
        dest,
        keep,
        withPaths,
        silent,
        _browse,
        version=None,
        label=&#34;data&#34;,
    ):
        self.backend = backend
        onGithub = backend == GH
        self.onGithub = onGithub

        self.conn = None

        self._browse = _browse
        self.label = label
        self.org = org
        self.repo = repo
        self.source = source
        self.dest = dest
        (self.commitChk, self.releaseChk, self.local) = self.fromString(checkout)
        clone = self.isClone()
        offline = self.isOffline()

        self.relative = relative
        self.version = version
        versionRep = f&#34;/{version}&#34; if version else &#34;&#34;
        self.versionRep = versionRep
        relativeRep = f&#34;/{relative}&#34; if relative else &#34;&#34;
        self.dataDir = f&#34;{relative}{versionRep}&#34;

        self.baseLocal = expanduser(self.dest)
        self.dataRelLocal = f&#34;{org}/{repo}{relativeRep}&#34;
        self.dirPathSaveLocal = f&#34;{self.baseLocal}/{org}/{repo}&#34;
        self.dirPathLocal = f&#34;{self.baseLocal}/{self.dataRelLocal}{versionRep}&#34;
        self.dataPathLocal = f&#34;{self.dataRelLocal}{versionRep}&#34;
        self.filePathLocal = f&#34;{self.dirPathLocal}/{EXPRESS_SYNC}&#34;

        self.baseClone = expanduser(self.source)
        self.dataRelClone = f&#34;{org}/{repo}{relativeRep}&#34;
        self.dirPathClone = f&#34;{self.baseClone}/{self.dataRelClone}{versionRep}&#34;
        self.dataPathClone = f&#34;{self.dataRelClone}{versionRep}&#34;

        self.dataPath = self.dataRelClone if clone else self.dataRelLocal

        self.keep = keep
        self.withPaths = withPaths

        self.commitOff = None
        self.releaseOff = None
        self.commitOn = None
        self.releaseOn = None
        self.releaseCommitOn = None

        self.silent = silent

        self.repoOnline = None
        self.localBase = False
        self.localDir = None

        if clone:
            self.commitOff = None
            self.releaseOff = None
        else:
            self.fixInfo()
            self.readInfo()

        if not offline:
            self.connect()
            self.fetchInfo()

    def login(self):
        onGithub = self.onGithub
        conn = self.conn
        backend = self.backend

        self.canDownloadSubfolders = False

        if onGithub:
            person = os.environ.get(&#34;GHPERS&#34;, None)
            if person:
                conn = Github(person)
            else:
                client = os.environ.get(&#34;GHCLIENT&#34;, None)
                secret = os.environ.get(&#34;GHSECRET&#34;, None)
                if client and secret:
                    conn = Github(client_id=client, client_secret=secret)
                else:
                    conn = Github()
        else:
            bUrl = backendRep(backend, &#34;url&#34;)
            bMachine = backendRep(backend, &#34;machine&#34;)

            person = os.environ.get(GLPERS(bMachine), None)
            if person:
                conn = Gitlab(bUrl, private_token=person)
            else:
                conn = Gitlab(bUrl)

            backendVersion = conn.version()
            if (
                not backendVersion
                or backendVersion[0] == &#34;unknown&#34;
                or backendVersion[-1] == &#34;unknown&#34;
            ):
                self.conn = None
                self.error(f&#34;Cannot connect to GitLab instance {backend}\n&#34;)
                return

            versionThreshold = (14, 4, 0)

            if backendVersion:
                backendVersion = [
                    int(VERSION_DIGIT_RE.sub(r&#34;\1&#34;, vc))
                    for vc in backendVersion[0].split(&#34;.&#34;)
                ]
                if len(backendVersion) &lt; 3:
                    backendVersion.extend([0] * (3 - len(backendVersion)))

                canDownloadSubfolders = True
                for (t, v) in zip(versionThreshold, backendVersion):
                    if t != v:
                        canDownloadSubfolders = t &lt; v
                        break

                self.canDownloadSubfolders = canDownloadSubfolders

        self.conn = conn
        return conn

    def connect(self):
        conn = self.conn
        onGithub = self.onGithub
        backend = self.backend
        log = self.log
        warning = self.warning
        org = self.org
        repo = self.repo

        bName = backendRep(backend, &#34;name&#34;)

        if not conn:
            conn = self.login()
            if not self.conn:
                return

        if onGithub:
            try:
                rate = conn.get_rate_limit().core
                log(
                    f&#34;rate limit is {rate.limit} requests per hour,&#34;
                    f&#34; with {rate.remaining} left for this hour&#34;
                )
                if rate.limit &lt; 100:
                    warning(
                        f&#34;To increase the rate,&#34;
                        f&#34;see {URL_TFDOC}/advanced/repo.html#github&#34;
                    )

            except GithubException as why:
                warning(&#34;Could not get rate limit details&#34;)
                warning(f&#34;{bName} says: {why}&#34;)

        log(
            f&#34;\tconnecting to online {bName} repo {org}/{repo} ... &#34;,
            newline=False,
        )
        repoOnline = None

        try:
            if onGithub:
                try:
                    repoOnline = conn.get_repo(f&#34;{org}/{repo}&#34;)
                    log(&#34;connected&#34;)
                except GithubException as why:
                    warning(&#34;failed&#34;)
                    warning(f&#34;{bName} says: {why}&#34;)
            else:
                try:
                    repoOnline = conn.projects.get(f&#34;{org}/{repo}&#34;)
                    log(&#34;connected&#34;)
                except GitlabGetError as why:
                    warning(&#34;failed&#34;)
                    warning(f&#34;{bName} says: {why}&#34;)
        except IOError as why:
            warning(&#34;no internet&#34;)
            warning(&#34;failed&#34;)
            warning(f&#34;{bName} says: {why}&#34;)

        self.repoOnline = repoOnline

    def log(self, msg, newline=True):
        silent = self.silent
        if not silent:
            console(msg, newline=newline)

    def warning(self, msg, newline=True):
        silent = self.silent
        if not silent == &#34;deep&#34;:
            console(msg, newline=newline)

    def error(self, msg, newline=True):
        console(msg, error=True, newline=newline)

    def possibleError(self, msg, showErrors, again=False, indent=&#34;\t&#34;, newline=False):
        error = self.error
        warning = self.warning

        if showErrors:
            error(msg, newline=newline)
        else:
            warning(msg, newline=newline)
            if again:
                warning(f&#34;{indent}Will try something else&#34;)

    def makeSureLocal(self, attempt=False):
        _browse = self._browse
        backend = self.backend
        label = self.label
        offline = self.isOffline()
        clone = self.isClone()

        error = self.error
        warning = self.warning
        log = self.log

        cOff = self.commitOff
        rOff = self.releaseOff
        cChk = self.commitChk
        rChk = self.releaseChk
        cOn = self.commitOn
        rOn = self.releaseOn
        rcOn = self.releaseCommitOn

        askExact = rChk or cChk
        askExactRelease = rChk
        askExactCommit = cChk
        askLatest = not askExact and (rChk == &#34;&#34; or cChk == &#34;&#34;)
        askLatestAny = rChk == &#34;&#34; and cChk == &#34;&#34;
        askLatestRelease = rChk == &#34;&#34; and cChk is None
        askLatestCommit = cChk == &#34;&#34; and rChk is None

        isExactReleaseOff = rChk and rChk == rOff
        isExactCommitOff = cChk and cChk == cOff
        isExactReleaseOn = rChk and rChk == rOn
        isExactCommitOn = cChk and cChk == cOn
        isLatestRelease = rOff and rOff == rOn or cOff and cOff == rcOn
        isLatestCommit = cOff and cOff == cOn

        isLocal = (
            askExactRelease
            and isExactReleaseOff
            or askExactCommit
            and isExactCommitOff
            or askLatestAny
            and (isLatestRelease or isLatestCommit)
            or askLatestRelease
            and isLatestRelease
            or askLatestCommit
            and isLatestCommit
        )
        mayLocal = (
            askLatestAny
            and (rOff or cOff)
            or askLatestRelease
            and rOff
            or askLatestCommit
            and cOff
        )
        canOnline = self.repoOnline
        isOnline = canOnline and (
            askExactRelease
            and isExactReleaseOn
            or askExactCommit
            and isExactCommitOn
            or askLatestAny
            or askLatestRelease
            or askLatestCommit
        )

        if offline:
            if clone:
                dirPath = self.dirPathClone
                self.localBase = self.baseClone if os.path.exists(dirPath) else False
            else:
                self.localBase = (
                    self.baseLocal
                    if (
                        cChk
                        and cChk == cOff
                        or cChk is None
                        and cOff
                        or rChk
                        and rChk == rOff
                        or rChk is None
                        and rOff
                    )
                    else False
                )
            if not self.localBase:
                method = warning if attempt else error
                method(f&#34;The requested {label} is not available offline&#34;)
                # base = self.baseClone if clone else self.baseLocal
                dirVersion = self.dirPathClone if clone else self.dirPathLocal
                # method(f&#34;\t{base}/{self.dataPath} not found&#34;)
                method(f&#34;\t{dirVersion} not found&#34;)
        else:
            if isLocal:
                self.localBase = self.baseLocal
            else:
                if not canOnline:
                    if askLatest:
                        if mayLocal:
                            warning(f&#34;The offline {label} may not be the latest&#34;)
                            self.localBase = self.baseLocal
                        else:
                            error(f&#34;The requested {label} is not available offline&#34;)
                    else:
                        warning(f&#34;The requested {label} is not available offline&#34;)
                        error(&#34;No online connection&#34;)
                elif not isOnline:
                    error(f&#34;The requested {label} is not available online&#34;)
                else:
                    self.localBase = self.baseLocal if self.download() else False

        if self.localBase:
            self.localDir = self.dataPath
            state = (
                &#34;requested&#34;
                if askExact
                else &#34;latest release&#34;
                if rChk == &#34;&#34; and canOnline and self.releaseOff
                else &#34;latest? release&#34;
                if rChk == &#34;&#34; and not canOnline and self.releaseOff
                else &#34;latest commit&#34;
                if cChk == &#34;&#34; and canOnline and self.commitOff
                else &#34;latest? commit&#34;
                if cChk == &#34;&#34; and not canOnline and self.commitOff
                else &#34;local release&#34;
                if self.local == &#34;local&#34; and self.releaseOff
                else &#34;local commit&#34;
                if self.local == &#34;local&#34; and self.commitOff
                else &#34;local github&#34;
                if self.local == &#34;clone&#34;
                else &#34;for whatever reason&#34;
            )
            offString = self.toString(
                self.commitOff,
                self.releaseOff,
                self.local,
                backend,
                dest=self.dest,
                source=self.source,
            )
            labelEsc = htmlEsc(label)
            stateEsc = htmlEsc(state)
            offEsc = htmlEsc(offString)
            locEsc = htmlEsc(f&#34;{self.localBase}/{self.localDir}{self.versionRep}&#34;)
            if _browse:
                log(
                    f&#34;Using {label} in {self.localBase}/{self.localDir}{self.versionRep}:&#34;
                )
                log(f&#34;\t{offString} ({state})&#34;)
            else:
                dh(
                    f&#39;&lt;b title=&#34;{stateEsc}&#34;&gt;{labelEsc}:&lt;/b&gt;&#39;
                    f&#39; &lt;span title=&#34;{offEsc}&#34;&gt;{locEsc}&lt;/span&gt;&#39;
                )

    def download(self):
        cChk = self.commitChk
        rChk = self.releaseChk

        fetched = False
        if rChk is not None:
            fetched = self.downloadRelease(rChk, showErrors=cChk is None)
        if not fetched and cChk is not None:
            fetched = self.downloadCommit(cChk, showErrors=True)

        if fetched:
            self.writeInfo()
        return fetched

    def downloadRelease(self, release, showErrors=True):
        cChk = self.commitChk

        r = self.getReleaseObj(release, showErrors=showErrors)
        if not r:
            return False

        onGithub = self.onGithub
        version = self.version
        g = self.repoOnline

        (commit, release) = self.getReleaseFromObj(r)

        fetched = False

        if onGithub:
            assets = None
            try:
                assets = r.get_assets()
            except Exception:
                pass
            assetUrl = None
            versionRep3 = f&#34;-{version}&#34; if version else &#34;&#34;
            relativeFlat = self.relative.replace(&#34;/&#34;, &#34;-&#34;)
            dataFile = f&#34;{relativeFlat}{versionRep3}.zip&#34;
            if assets and assets.totalCount &gt; 0:
                for asset in assets:
                    if asset.name == dataFile:
                        assetUrl = asset.browser_download_url
                        break
            if assetUrl:
                fetched = self.downloadZip(assetUrl, showErrors=False)
            if not fetched:
                thisShowErrors = not cChk == &#34;&#34;
                fetched = self.downloadCommit(commit, showErrors=thisShowErrors)
        else:
            fetched = self.downloadZip(g, shiftUp=True, commit=commit, showErrors=True)

        if fetched:
            self.commitOff = commit
            self.releaseOff = release
        return fetched

    def downloadCommit(self, commit, showErrors=True):
        c = self.getCommitObj(commit)
        if not c:
            return False

        commit = self.getCommitFromObj(c)

        fetched = self.downloadDir(commit, exclude=r&#34;\.tfx&#34;, showErrors=showErrors)
        if fetched:
            self.commitOff = commit
            self.releaseOff = None
        return fetched

    def downloadZip(self, where, shiftUp=False, commit=None, showErrors=True):
        # commit parameter only supported for GitLab
        conn = self.conn
        backend = self.backend
        log = self.log
        label = self.label
        repo = self.repo
        dataDir = self.dataDir
        canDownloadSubfolders = self.canDownloadSubfolders
        dirPathLocal = self.dirPathLocal
        withPaths = self.withPaths

        dataUrl = None
        g = None

        if type(where) is str:
            dataUrl = where
            notice = where
            again = True
        else:
            g = where
            notice = backendRep(backend, &#34;name&#34;)
            again = False

        log(f&#34;\tdownloading from {notice} ... &#34;)

        try:
            if dataUrl is not None:
                r = requests.get(dataUrl, allow_redirects=True)
                zf = r.content
            elif g is not None:
                if canDownloadSubfolders:
                    # zf = g.repository_archive(format=&#34;zip&#34;, sha=commit, path=dataDir)
                    response = conn.http_get(
                        f&#34;/projects/{g.id}/repository/archive.zip&#34;,
                        query_data=dict(sha=commit, path=dataDir),
                        raw=True,
                    )
                    zf = response.content
                    if len(zf) == 0:
                        self.possibleError(
                            f&#34;No directory {dataDir} in #{commit}&#34;,
                            showErrors,
                            again=False,
                        )
                        msg = &#34;\tFailed&#34;
                        self.possibleError(msg, showErrors=showErrors)
                        return False
                else:
                    zf = g.repository_archive(format=&#34;zip&#34;, sha=commit)
            zf = io.BytesIO(zf)
        except Exception as e:
            msg = f&#34;\t{str(e)}\n\tcould not download from {notice}&#34;
            self.possibleError(msg, showErrors, again=again)
            return False

        log(f&#34;\tsaving {label}&#34;)

        cwd = os.getcwd()
        destZip = (
            os.path.dirname(dirPathLocal) if shiftUp and withPaths else dirPathLocal
        )
        good = True

        if g:
            gitlabSlugRe = re.compile(f&#34;^{repo}(?:-master)?-[^/]*/&#34;)
        try:
            z = ZipFile(zf)
            initTree(destZip, fresh=not self.keep)
            os.chdir(destZip)

            if withPaths:
                if g:
                    nItems = 0
                    for zInfo in z.infolist():
                        zInfo.filename = gitlabSlugRe.sub(&#34;&#34;, zInfo.filename) or &#34;/&#34;
                        if zInfo.filename[-1] == &#34;/&#34;:
                            continue
                        if zInfo.filename.startswith(&#34;__MACOS&#34;):
                            continue
                        if not canDownloadSubfolders:
                            if not zInfo.filename.startswith(dataDir):
                                continue
                        z.extract(zInfo)
                        nItems += 1
                    if nItems == 0:
                        self.possibleError(
                            f&#34;No directory {dataDir} in #{commit}&#34;,
                            showErrors,
                            again=False,
                        )
                        good = False
                else:
                    z.extractall()
                    if os.path.exists(&#34;__MACOSX&#34;):
                        rmtree(&#34;__MACOSX&#34;)
            else:
                nItems = 0
                for zInfo in z.infolist():
                    if g:
                        zInfo.filename = gitlabSlugRe.sub(&#34;&#34;, zInfo.filename) or &#34;/&#34;
                    if zInfo.filename[-1] == &#34;/&#34;:
                        continue
                    if zInfo.filename.startswith(&#34;__MACOS&#34;):
                        continue
                    if (
                        g
                        and not canDownloadSubfolders
                        and not zInfo.filename.startswith(dataDir)
                    ):
                        continue
                    zInfo.filename = os.path.basename(zInfo.filename)
                    z.extract(zInfo)
                    nItems += 1
                if nItems == 0:
                    msg = f&#34;#{commit}&#34; if g else notice
                    self.possibleError(
                        f&#34;No directory {dataDir} in {msg}&#34;,
                        showErrors,
                        again=False,
                    )
                    msg = &#34;\tFailed&#34;
                    self.possibleError(msg, showErrors=showErrors)
                    good = False
        except Exception:
            msg = f&#34;\tcould not save {label} to {destZip}&#34;
            self.possibleError(msg, showErrors=showErrors, again=True)
            os.chdir(cwd)
            return False
        os.chdir(cwd)
        return good

    def downloadDir(self, commit, exclude=None, showErrors=False):
        g = self.repoOnline
        if not g:
            return None

        onGithub = self.onGithub
        backend = self.backend

        log = self.log

        destDir = f&#34;{self.dirPathLocal}&#34;
        destSave = f&#34;{self.dirPathSaveLocal}&#34;
        initTree(destDir, fresh=not self.keep)

        excludeRe = re.compile(exclude) if exclude else None

        good = True

        if onGithub:

            def _downloadDir(subPath, level=0):
                nonlocal good
                if not good:
                    return
                lead = &#34;\t&#34; * level
                try:
                    contents = g.get_contents(subPath, ref=commit)
                except UnknownObjectException:
                    msg = (
                        f&#34;{lead}No directory {subPath} in &#34;
                        f&#34;{self.toString(commit, None, False, backend)}&#34;
                    )
                    self.possibleError(msg, showErrors, again=True, indent=lead)
                    good = False
                    return
                for content in contents:
                    thisPath = content.path
                    log(f&#34;\t{lead}{thisPath}...&#34;, newline=False)
                    if exclude and excludeRe.search(thisPath):
                        log(&#34;excluded&#34;)
                        continue
                    if content.type == &#34;dir&#34;:
                        log(&#34;directory&#34;)
                        os.makedirs(f&#34;{destSave}/{thisPath}&#34;, exist_ok=True)
                        _downloadDir(thisPath, level + 1)
                    else:
                        try:
                            fileContent = g.get_git_blob(content.sha)
                            fileData = base64.b64decode(fileContent.content)
                            fileDest = f&#34;{destSave}/{thisPath}&#34;
                            with open(fileDest, &#34;wb&#34;) as fd:
                                fd.write(fileData)
                            log(&#34;downloaded&#34;)
                        except (GithubException, IOError):
                            msg = &#34;error&#34;
                            self.possibleError(msg, showErrors, again=True, indent=lead)
                            good = False

            _downloadDir(self.dataDir, 0)

        else:
            good = self.downloadZip(g, shiftUp=True, commit=commit, showErrors=True)

        if good:
            log(&#34;\tOK&#34;)
        else:
            if onGithub:
                msg = &#34;\tFailed&#34;
                self.possibleError(msg, showErrors=showErrors if onGithub else True)

        return good

    def getRelease(self, release, showErrors=True):
        r = self.getReleaseObj(release, showErrors=showErrors)
        if not r:
            return None
        return self.getReleaseFromObj(r)

    def getCommit(self, commit):
        c = self.getCommitObj(commit)
        if not c:
            return None
        return self.getCommitFromObj(c)

    def getReleaseObj(self, release, showErrors=True):
        g = self.repoOnline
        if not g:
            return None

        onGithub = self.onGithub

        r = None
        msg = f&#39; tagged &#34;{release}&#34;&#39; if release else &#34;s&#34;

        if onGithub:
            try:
                r = g.get_release(release) if release else g.get_latest_release()
            except UnknownObjectException:
                self.possibleError(
                    f&#34;\tcannot find release{msg}&#34;, showErrors, newline=True
                )
            except Exception:
                self.possibleError(
                    f&#34;\tcannot find release{msg}&#34;,
                    showErrors,
                    newline=True,
                )
        else:
            try:
                if release:
                    r = g.releases.get(release)
                else:
                    releases = g.releases.list(all=True)
                    r = (
                        sorted(releases, key=lambda r: r.released_at)[-1]
                        if releases
                        else None
                    )
            except Exception:
                r = None
            if r is None:
                self.possibleError(
                    f&#34;\tcannot find release{msg}&#34;, showErrors, newline=True
                )
        return r

    def getCommitObj(self, commit):
        g = self.repoOnline
        if not g:
            return None

        error = self.error
        onGithub = self.onGithub

        c = None
        msg = f&#39; with hash &#34;{commit}&#34;&#39; if commit else &#34;s&#34;

        if onGithub:
            try:
                cs = g.get_commits(sha=commit) if commit else g.get_commits()
                if cs.totalCount:
                    c = cs[0]
                else:
                    error(f&#34;\tcannot find commit{msg}&#34;)
            except Exception:
                error(f&#34;\tcannot find commit{msg}&#34;)
        else:
            try:
                cs = g.commits.list(all=True)
                if not len(cs):
                    error(f&#34;\tno commit{msg}&#34;)
                else:
                    cs = sorted(cs, key=lambda x: x.created_at)
                    if commit:
                        for com in cs:
                            if com.id == commit:
                                c = com
                                break
                    else:
                        if len(cs):
                            c = cs[-1]
                    if c is None:
                        error(f&#34;\tcannot find commit{msg}&#34;)
            except Exception:
                error(f&#34;\tcannot find commit{msg}&#34;)
        return c

    def getReleaseFromObj(self, r):
        g = self.repoOnline
        if not g:
            return None

        onGithub = self.onGithub

        release = r.tag_name

        if onGithub:
            ref = g.get_git_ref(f&#34;tags/{release}&#34;)
            commit = ref.object.sha
        else:
            commit = r.commit[&#34;id&#34;]
        return (commit, release)

    def getCommitFromObj(self, c):
        g = self.repoOnline
        if not g:
            return None

        onGithub = self.onGithub

        return c.sha if onGithub else c.id

    def fetchInfo(self):
        g = self.repoOnline
        if not g:
            return

        self.commitOn = None
        self.releaseOn = None
        self.releaseCommitOn = None
        if self.releaseChk is not None:
            result = self.getRelease(self.releaseChk, showErrors=self.commitChk is None)
            if result:
                (self.releaseCommitOn, self.releaseOn) = result
        if self.commitChk is not None:
            result = self.getCommit(self.commitChk)
            if result:
                self.commitOn = result

    def fixInfo(self):
        sDir = self.dirPathLocal
        if not os.path.exists(sDir):
            return
        for sFile in EXPRESS_SYNC_LEGACY:
            sPath = f&#34;{sDir}/{sFile}&#34;
            if os.path.exists(sPath):
                goodPath = f&#34;{sDir}/{EXPRESS_SYNC}&#34;
                if os.path.exists(goodPath):
                    os.remove(sPath)
                else:
                    os.rename(sPath, goodPath)

    def readInfo(self):
        if os.path.exists(self.filePathLocal):
            with open(self.filePathLocal, encoding=&#34;utf8&#34;) as f:
                for line in f:
                    string = line.strip()
                    (commit, release, local) = self.fromString(string)
                    if commit:
                        self.commitOff = commit
                    if release:
                        self.releaseOff = release

    def writeInfo(self):
        if not os.path.exists(self.dirPathLocal):
            os.makedirs(self.dirPathLocal, exist_ok=True)
        with open(self.filePathLocal, &#34;w&#34;, encoding=&#34;utf8&#34;) as f:
            if self.releaseOff:
                f.write(f&#34;{self.releaseOff}\n&#34;)
            if self.commitOff:
                f.write(f&#34;{self.commitOff}\n&#34;)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="tf.advanced.repo.Checkout.fromString"><code class="name flex">
<span>def <span class="ident">fromString</span></span>(<span>string)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L756-L780" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def fromString(string):
    commit = None
    release = None
    local = None
    if not string:
        commit = &#34;&#34;
        release = &#34;&#34;
    elif string == &#34;latest&#34;:
        commit = None
        release = &#34;&#34;
    elif string == &#34;hot&#34;:
        commit = &#34;&#34;
        release = None
    elif string in {&#34;local&#34;, &#34;clone&#34;}:
        commit = None
        release = None
        local = string
    elif &#34;.&#34; in string or len(string) &lt; 12:
        commit = None
        release = string
    else:
        commit = string
        release = None
    return (commit, release, local)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.toString"><code class="name flex">
<span>def <span class="ident">toString</span></span>(<span>commit, release, local, backend, source=None, dest=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L782-L809" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def toString(commit, release, local, backend, source=None, dest=None):
    extra = &#34;&#34;
    if local:
        if source is None:
            source = backendRep(backend, &#34;clone&#34;)
        if dest is None:
            dest = backendRep(backend, &#34;cache&#34;)

        baseRep = source if local == &#34;clone&#34; else dest
        extra = f&#34; offline under {baseRep}&#34;
    if local == &#34;clone&#34;:
        result = &#34;repo clone&#34;
    elif commit and release:
        result = f&#34;r{release}=#{commit}&#34;
    elif commit:
        result = f&#34;#{commit}&#34;
    elif release:
        result = f&#34;r{release}&#34;
    elif commit is None and release is None:
        result = &#34;unknown release or commit&#34;
    elif commit is None:
        result = &#34;latest release&#34;
    elif release is None:
        result = &#34;latest commit&#34;
    else:
        result = &#34;latest release or commit&#34;
    return f&#34;{result}{extra}&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tf.advanced.repo.Checkout.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L955-L1014" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def connect(self):
    conn = self.conn
    onGithub = self.onGithub
    backend = self.backend
    log = self.log
    warning = self.warning
    org = self.org
    repo = self.repo

    bName = backendRep(backend, &#34;name&#34;)

    if not conn:
        conn = self.login()
        if not self.conn:
            return

    if onGithub:
        try:
            rate = conn.get_rate_limit().core
            log(
                f&#34;rate limit is {rate.limit} requests per hour,&#34;
                f&#34; with {rate.remaining} left for this hour&#34;
            )
            if rate.limit &lt; 100:
                warning(
                    f&#34;To increase the rate,&#34;
                    f&#34;see {URL_TFDOC}/advanced/repo.html#github&#34;
                )

        except GithubException as why:
            warning(&#34;Could not get rate limit details&#34;)
            warning(f&#34;{bName} says: {why}&#34;)

    log(
        f&#34;\tconnecting to online {bName} repo {org}/{repo} ... &#34;,
        newline=False,
    )
    repoOnline = None

    try:
        if onGithub:
            try:
                repoOnline = conn.get_repo(f&#34;{org}/{repo}&#34;)
                log(&#34;connected&#34;)
            except GithubException as why:
                warning(&#34;failed&#34;)
                warning(f&#34;{bName} says: {why}&#34;)
        else:
            try:
                repoOnline = conn.projects.get(f&#34;{org}/{repo}&#34;)
                log(&#34;connected&#34;)
            except GitlabGetError as why:
                warning(&#34;failed&#34;)
                warning(f&#34;{bName} says: {why}&#34;)
    except IOError as why:
        warning(&#34;no internet&#34;)
        warning(&#34;failed&#34;)
        warning(f&#34;{bName} says: {why}&#34;)

    self.repoOnline = repoOnline</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L1194-L1206" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def download(self):
    cChk = self.commitChk
    rChk = self.releaseChk

    fetched = False
    if rChk is not None:
        fetched = self.downloadRelease(rChk, showErrors=cChk is None)
    if not fetched and cChk is not None:
        fetched = self.downloadCommit(cChk, showErrors=True)

    if fetched:
        self.writeInfo()
    return fetched</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.downloadCommit"><code class="name flex">
<span>def <span class="ident">downloadCommit</span></span>(<span>self, commit, showErrors=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L1251-L1262" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def downloadCommit(self, commit, showErrors=True):
    c = self.getCommitObj(commit)
    if not c:
        return False

    commit = self.getCommitFromObj(c)

    fetched = self.downloadDir(commit, exclude=r&#34;\.tfx&#34;, showErrors=showErrors)
    if fetched:
        self.commitOff = commit
        self.releaseOff = None
    return fetched</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.downloadDir"><code class="name flex">
<span>def <span class="ident">downloadDir</span></span>(<span>self, commit, exclude=None, showErrors=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L1396-L1466" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def downloadDir(self, commit, exclude=None, showErrors=False):
    g = self.repoOnline
    if not g:
        return None

    onGithub = self.onGithub
    backend = self.backend

    log = self.log

    destDir = f&#34;{self.dirPathLocal}&#34;
    destSave = f&#34;{self.dirPathSaveLocal}&#34;
    initTree(destDir, fresh=not self.keep)

    excludeRe = re.compile(exclude) if exclude else None

    good = True

    if onGithub:

        def _downloadDir(subPath, level=0):
            nonlocal good
            if not good:
                return
            lead = &#34;\t&#34; * level
            try:
                contents = g.get_contents(subPath, ref=commit)
            except UnknownObjectException:
                msg = (
                    f&#34;{lead}No directory {subPath} in &#34;
                    f&#34;{self.toString(commit, None, False, backend)}&#34;
                )
                self.possibleError(msg, showErrors, again=True, indent=lead)
                good = False
                return
            for content in contents:
                thisPath = content.path
                log(f&#34;\t{lead}{thisPath}...&#34;, newline=False)
                if exclude and excludeRe.search(thisPath):
                    log(&#34;excluded&#34;)
                    continue
                if content.type == &#34;dir&#34;:
                    log(&#34;directory&#34;)
                    os.makedirs(f&#34;{destSave}/{thisPath}&#34;, exist_ok=True)
                    _downloadDir(thisPath, level + 1)
                else:
                    try:
                        fileContent = g.get_git_blob(content.sha)
                        fileData = base64.b64decode(fileContent.content)
                        fileDest = f&#34;{destSave}/{thisPath}&#34;
                        with open(fileDest, &#34;wb&#34;) as fd:
                            fd.write(fileData)
                        log(&#34;downloaded&#34;)
                    except (GithubException, IOError):
                        msg = &#34;error&#34;
                        self.possibleError(msg, showErrors, again=True, indent=lead)
                        good = False

        _downloadDir(self.dataDir, 0)

    else:
        good = self.downloadZip(g, shiftUp=True, commit=commit, showErrors=True)

    if good:
        log(&#34;\tOK&#34;)
    else:
        if onGithub:
            msg = &#34;\tFailed&#34;
            self.possibleError(msg, showErrors=showErrors if onGithub else True)

    return good</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.downloadRelease"><code class="name flex">
<span>def <span class="ident">downloadRelease</span></span>(<span>self, release, showErrors=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L1208-L1249" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def downloadRelease(self, release, showErrors=True):
    cChk = self.commitChk

    r = self.getReleaseObj(release, showErrors=showErrors)
    if not r:
        return False

    onGithub = self.onGithub
    version = self.version
    g = self.repoOnline

    (commit, release) = self.getReleaseFromObj(r)

    fetched = False

    if onGithub:
        assets = None
        try:
            assets = r.get_assets()
        except Exception:
            pass
        assetUrl = None
        versionRep3 = f&#34;-{version}&#34; if version else &#34;&#34;
        relativeFlat = self.relative.replace(&#34;/&#34;, &#34;-&#34;)
        dataFile = f&#34;{relativeFlat}{versionRep3}.zip&#34;
        if assets and assets.totalCount &gt; 0:
            for asset in assets:
                if asset.name == dataFile:
                    assetUrl = asset.browser_download_url
                    break
        if assetUrl:
            fetched = self.downloadZip(assetUrl, showErrors=False)
        if not fetched:
            thisShowErrors = not cChk == &#34;&#34;
            fetched = self.downloadCommit(commit, showErrors=thisShowErrors)
    else:
        fetched = self.downloadZip(g, shiftUp=True, commit=commit, showErrors=True)

    if fetched:
        self.commitOff = commit
        self.releaseOff = release
    return fetched</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.downloadZip"><code class="name flex">
<span>def <span class="ident">downloadZip</span></span>(<span>self, where, shiftUp=False, commit=None, showErrors=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L1264-L1394" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def downloadZip(self, where, shiftUp=False, commit=None, showErrors=True):
    # commit parameter only supported for GitLab
    conn = self.conn
    backend = self.backend
    log = self.log
    label = self.label
    repo = self.repo
    dataDir = self.dataDir
    canDownloadSubfolders = self.canDownloadSubfolders
    dirPathLocal = self.dirPathLocal
    withPaths = self.withPaths

    dataUrl = None
    g = None

    if type(where) is str:
        dataUrl = where
        notice = where
        again = True
    else:
        g = where
        notice = backendRep(backend, &#34;name&#34;)
        again = False

    log(f&#34;\tdownloading from {notice} ... &#34;)

    try:
        if dataUrl is not None:
            r = requests.get(dataUrl, allow_redirects=True)
            zf = r.content
        elif g is not None:
            if canDownloadSubfolders:
                # zf = g.repository_archive(format=&#34;zip&#34;, sha=commit, path=dataDir)
                response = conn.http_get(
                    f&#34;/projects/{g.id}/repository/archive.zip&#34;,
                    query_data=dict(sha=commit, path=dataDir),
                    raw=True,
                )
                zf = response.content
                if len(zf) == 0:
                    self.possibleError(
                        f&#34;No directory {dataDir} in #{commit}&#34;,
                        showErrors,
                        again=False,
                    )
                    msg = &#34;\tFailed&#34;
                    self.possibleError(msg, showErrors=showErrors)
                    return False
            else:
                zf = g.repository_archive(format=&#34;zip&#34;, sha=commit)
        zf = io.BytesIO(zf)
    except Exception as e:
        msg = f&#34;\t{str(e)}\n\tcould not download from {notice}&#34;
        self.possibleError(msg, showErrors, again=again)
        return False

    log(f&#34;\tsaving {label}&#34;)

    cwd = os.getcwd()
    destZip = (
        os.path.dirname(dirPathLocal) if shiftUp and withPaths else dirPathLocal
    )
    good = True

    if g:
        gitlabSlugRe = re.compile(f&#34;^{repo}(?:-master)?-[^/]*/&#34;)
    try:
        z = ZipFile(zf)
        initTree(destZip, fresh=not self.keep)
        os.chdir(destZip)

        if withPaths:
            if g:
                nItems = 0
                for zInfo in z.infolist():
                    zInfo.filename = gitlabSlugRe.sub(&#34;&#34;, zInfo.filename) or &#34;/&#34;
                    if zInfo.filename[-1] == &#34;/&#34;:
                        continue
                    if zInfo.filename.startswith(&#34;__MACOS&#34;):
                        continue
                    if not canDownloadSubfolders:
                        if not zInfo.filename.startswith(dataDir):
                            continue
                    z.extract(zInfo)
                    nItems += 1
                if nItems == 0:
                    self.possibleError(
                        f&#34;No directory {dataDir} in #{commit}&#34;,
                        showErrors,
                        again=False,
                    )
                    good = False
            else:
                z.extractall()
                if os.path.exists(&#34;__MACOSX&#34;):
                    rmtree(&#34;__MACOSX&#34;)
        else:
            nItems = 0
            for zInfo in z.infolist():
                if g:
                    zInfo.filename = gitlabSlugRe.sub(&#34;&#34;, zInfo.filename) or &#34;/&#34;
                if zInfo.filename[-1] == &#34;/&#34;:
                    continue
                if zInfo.filename.startswith(&#34;__MACOS&#34;):
                    continue
                if (
                    g
                    and not canDownloadSubfolders
                    and not zInfo.filename.startswith(dataDir)
                ):
                    continue
                zInfo.filename = os.path.basename(zInfo.filename)
                z.extract(zInfo)
                nItems += 1
            if nItems == 0:
                msg = f&#34;#{commit}&#34; if g else notice
                self.possibleError(
                    f&#34;No directory {dataDir} in {msg}&#34;,
                    showErrors,
                    again=False,
                )
                msg = &#34;\tFailed&#34;
                self.possibleError(msg, showErrors=showErrors)
                good = False
    except Exception:
        msg = f&#34;\tcould not save {label} to {destZip}&#34;
        self.possibleError(msg, showErrors=showErrors, again=True)
        os.chdir(cwd)
        return False
    os.chdir(cwd)
    return good</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.error"><code class="name flex">
<span>def <span class="ident">error</span></span>(<span>self, msg, newline=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L1026-L1027" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def error(self, msg, newline=True):
    console(msg, error=True, newline=newline)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.fetchInfo"><code class="name flex">
<span>def <span class="ident">fetchInfo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L1588-L1603" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fetchInfo(self):
    g = self.repoOnline
    if not g:
        return

    self.commitOn = None
    self.releaseOn = None
    self.releaseCommitOn = None
    if self.releaseChk is not None:
        result = self.getRelease(self.releaseChk, showErrors=self.commitChk is None)
        if result:
            (self.releaseCommitOn, self.releaseOn) = result
    if self.commitChk is not None:
        result = self.getCommit(self.commitChk)
        if result:
            self.commitOn = result</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.fixInfo"><code class="name flex">
<span>def <span class="ident">fixInfo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L1605-L1616" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fixInfo(self):
    sDir = self.dirPathLocal
    if not os.path.exists(sDir):
        return
    for sFile in EXPRESS_SYNC_LEGACY:
        sPath = f&#34;{sDir}/{sFile}&#34;
        if os.path.exists(sPath):
            goodPath = f&#34;{sDir}/{EXPRESS_SYNC}&#34;
            if os.path.exists(goodPath):
                os.remove(sPath)
            else:
                os.rename(sPath, goodPath)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.getCommit"><code class="name flex">
<span>def <span class="ident">getCommit</span></span>(<span>self, commit)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L1474-L1478" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getCommit(self, commit):
    c = self.getCommitObj(commit)
    if not c:
        return None
    return self.getCommitFromObj(c)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.getCommitFromObj"><code class="name flex">
<span>def <span class="ident">getCommitFromObj</span></span>(<span>self, c)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L1579-L1586" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getCommitFromObj(self, c):
    g = self.repoOnline
    if not g:
        return None

    onGithub = self.onGithub

    return c.sha if onGithub else c.id</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.getCommitObj"><code class="name flex">
<span>def <span class="ident">getCommitObj</span></span>(<span>self, commit)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L1522-L1561" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getCommitObj(self, commit):
    g = self.repoOnline
    if not g:
        return None

    error = self.error
    onGithub = self.onGithub

    c = None
    msg = f&#39; with hash &#34;{commit}&#34;&#39; if commit else &#34;s&#34;

    if onGithub:
        try:
            cs = g.get_commits(sha=commit) if commit else g.get_commits()
            if cs.totalCount:
                c = cs[0]
            else:
                error(f&#34;\tcannot find commit{msg}&#34;)
        except Exception:
            error(f&#34;\tcannot find commit{msg}&#34;)
    else:
        try:
            cs = g.commits.list(all=True)
            if not len(cs):
                error(f&#34;\tno commit{msg}&#34;)
            else:
                cs = sorted(cs, key=lambda x: x.created_at)
                if commit:
                    for com in cs:
                        if com.id == commit:
                            c = com
                            break
                else:
                    if len(cs):
                        c = cs[-1]
                if c is None:
                    error(f&#34;\tcannot find commit{msg}&#34;)
        except Exception:
            error(f&#34;\tcannot find commit{msg}&#34;)
    return c</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.getRelease"><code class="name flex">
<span>def <span class="ident">getRelease</span></span>(<span>self, release, showErrors=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L1468-L1472" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getRelease(self, release, showErrors=True):
    r = self.getReleaseObj(release, showErrors=showErrors)
    if not r:
        return None
    return self.getReleaseFromObj(r)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.getReleaseFromObj"><code class="name flex">
<span>def <span class="ident">getReleaseFromObj</span></span>(<span>self, r)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L1563-L1577" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getReleaseFromObj(self, r):
    g = self.repoOnline
    if not g:
        return None

    onGithub = self.onGithub

    release = r.tag_name

    if onGithub:
        ref = g.get_git_ref(f&#34;tags/{release}&#34;)
        commit = ref.object.sha
    else:
        commit = r.commit[&#34;id&#34;]
    return (commit, release)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.getReleaseObj"><code class="name flex">
<span>def <span class="ident">getReleaseObj</span></span>(<span>self, release, showErrors=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L1480-L1520" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getReleaseObj(self, release, showErrors=True):
    g = self.repoOnline
    if not g:
        return None

    onGithub = self.onGithub

    r = None
    msg = f&#39; tagged &#34;{release}&#34;&#39; if release else &#34;s&#34;

    if onGithub:
        try:
            r = g.get_release(release) if release else g.get_latest_release()
        except UnknownObjectException:
            self.possibleError(
                f&#34;\tcannot find release{msg}&#34;, showErrors, newline=True
            )
        except Exception:
            self.possibleError(
                f&#34;\tcannot find release{msg}&#34;,
                showErrors,
                newline=True,
            )
    else:
        try:
            if release:
                r = g.releases.get(release)
            else:
                releases = g.releases.list(all=True)
                r = (
                    sorted(releases, key=lambda r: r.released_at)[-1]
                    if releases
                    else None
                )
        except Exception:
            r = None
        if r is None:
            self.possibleError(
                f&#34;\tcannot find release{msg}&#34;, showErrors, newline=True
            )
    return r</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.isClone"><code class="name flex">
<span>def <span class="ident">isClone</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L811-L812" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isClone(self):
    return self.local == &#34;clone&#34;</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.isOffline"><code class="name flex">
<span>def <span class="ident">isOffline</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L814-L815" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isOffline(self):
    return self.local in {&#34;clone&#34;, &#34;local&#34;}</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.log"><code class="name flex">
<span>def <span class="ident">log</span></span>(<span>self, msg, newline=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L1016-L1019" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def log(self, msg, newline=True):
    silent = self.silent
    if not silent:
        console(msg, newline=newline)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.login"><code class="name flex">
<span>def <span class="ident">login</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L896-L953" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def login(self):
    onGithub = self.onGithub
    conn = self.conn
    backend = self.backend

    self.canDownloadSubfolders = False

    if onGithub:
        person = os.environ.get(&#34;GHPERS&#34;, None)
        if person:
            conn = Github(person)
        else:
            client = os.environ.get(&#34;GHCLIENT&#34;, None)
            secret = os.environ.get(&#34;GHSECRET&#34;, None)
            if client and secret:
                conn = Github(client_id=client, client_secret=secret)
            else:
                conn = Github()
    else:
        bUrl = backendRep(backend, &#34;url&#34;)
        bMachine = backendRep(backend, &#34;machine&#34;)

        person = os.environ.get(GLPERS(bMachine), None)
        if person:
            conn = Gitlab(bUrl, private_token=person)
        else:
            conn = Gitlab(bUrl)

        backendVersion = conn.version()
        if (
            not backendVersion
            or backendVersion[0] == &#34;unknown&#34;
            or backendVersion[-1] == &#34;unknown&#34;
        ):
            self.conn = None
            self.error(f&#34;Cannot connect to GitLab instance {backend}\n&#34;)
            return

        versionThreshold = (14, 4, 0)

        if backendVersion:
            backendVersion = [
                int(VERSION_DIGIT_RE.sub(r&#34;\1&#34;, vc))
                for vc in backendVersion[0].split(&#34;.&#34;)
            ]
            if len(backendVersion) &lt; 3:
                backendVersion.extend([0] * (3 - len(backendVersion)))

            canDownloadSubfolders = True
            for (t, v) in zip(versionThreshold, backendVersion):
                if t != v:
                    canDownloadSubfolders = t &lt; v
                    break

            self.canDownloadSubfolders = canDownloadSubfolders

    self.conn = conn
    return conn</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.makeSureLocal"><code class="name flex">
<span>def <span class="ident">makeSureLocal</span></span>(<span>self, attempt=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L1040-L1192" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeSureLocal(self, attempt=False):
    _browse = self._browse
    backend = self.backend
    label = self.label
    offline = self.isOffline()
    clone = self.isClone()

    error = self.error
    warning = self.warning
    log = self.log

    cOff = self.commitOff
    rOff = self.releaseOff
    cChk = self.commitChk
    rChk = self.releaseChk
    cOn = self.commitOn
    rOn = self.releaseOn
    rcOn = self.releaseCommitOn

    askExact = rChk or cChk
    askExactRelease = rChk
    askExactCommit = cChk
    askLatest = not askExact and (rChk == &#34;&#34; or cChk == &#34;&#34;)
    askLatestAny = rChk == &#34;&#34; and cChk == &#34;&#34;
    askLatestRelease = rChk == &#34;&#34; and cChk is None
    askLatestCommit = cChk == &#34;&#34; and rChk is None

    isExactReleaseOff = rChk and rChk == rOff
    isExactCommitOff = cChk and cChk == cOff
    isExactReleaseOn = rChk and rChk == rOn
    isExactCommitOn = cChk and cChk == cOn
    isLatestRelease = rOff and rOff == rOn or cOff and cOff == rcOn
    isLatestCommit = cOff and cOff == cOn

    isLocal = (
        askExactRelease
        and isExactReleaseOff
        or askExactCommit
        and isExactCommitOff
        or askLatestAny
        and (isLatestRelease or isLatestCommit)
        or askLatestRelease
        and isLatestRelease
        or askLatestCommit
        and isLatestCommit
    )
    mayLocal = (
        askLatestAny
        and (rOff or cOff)
        or askLatestRelease
        and rOff
        or askLatestCommit
        and cOff
    )
    canOnline = self.repoOnline
    isOnline = canOnline and (
        askExactRelease
        and isExactReleaseOn
        or askExactCommit
        and isExactCommitOn
        or askLatestAny
        or askLatestRelease
        or askLatestCommit
    )

    if offline:
        if clone:
            dirPath = self.dirPathClone
            self.localBase = self.baseClone if os.path.exists(dirPath) else False
        else:
            self.localBase = (
                self.baseLocal
                if (
                    cChk
                    and cChk == cOff
                    or cChk is None
                    and cOff
                    or rChk
                    and rChk == rOff
                    or rChk is None
                    and rOff
                )
                else False
            )
        if not self.localBase:
            method = warning if attempt else error
            method(f&#34;The requested {label} is not available offline&#34;)
            # base = self.baseClone if clone else self.baseLocal
            dirVersion = self.dirPathClone if clone else self.dirPathLocal
            # method(f&#34;\t{base}/{self.dataPath} not found&#34;)
            method(f&#34;\t{dirVersion} not found&#34;)
    else:
        if isLocal:
            self.localBase = self.baseLocal
        else:
            if not canOnline:
                if askLatest:
                    if mayLocal:
                        warning(f&#34;The offline {label} may not be the latest&#34;)
                        self.localBase = self.baseLocal
                    else:
                        error(f&#34;The requested {label} is not available offline&#34;)
                else:
                    warning(f&#34;The requested {label} is not available offline&#34;)
                    error(&#34;No online connection&#34;)
            elif not isOnline:
                error(f&#34;The requested {label} is not available online&#34;)
            else:
                self.localBase = self.baseLocal if self.download() else False

    if self.localBase:
        self.localDir = self.dataPath
        state = (
            &#34;requested&#34;
            if askExact
            else &#34;latest release&#34;
            if rChk == &#34;&#34; and canOnline and self.releaseOff
            else &#34;latest? release&#34;
            if rChk == &#34;&#34; and not canOnline and self.releaseOff
            else &#34;latest commit&#34;
            if cChk == &#34;&#34; and canOnline and self.commitOff
            else &#34;latest? commit&#34;
            if cChk == &#34;&#34; and not canOnline and self.commitOff
            else &#34;local release&#34;
            if self.local == &#34;local&#34; and self.releaseOff
            else &#34;local commit&#34;
            if self.local == &#34;local&#34; and self.commitOff
            else &#34;local github&#34;
            if self.local == &#34;clone&#34;
            else &#34;for whatever reason&#34;
        )
        offString = self.toString(
            self.commitOff,
            self.releaseOff,
            self.local,
            backend,
            dest=self.dest,
            source=self.source,
        )
        labelEsc = htmlEsc(label)
        stateEsc = htmlEsc(state)
        offEsc = htmlEsc(offString)
        locEsc = htmlEsc(f&#34;{self.localBase}/{self.localDir}{self.versionRep}&#34;)
        if _browse:
            log(
                f&#34;Using {label} in {self.localBase}/{self.localDir}{self.versionRep}:&#34;
            )
            log(f&#34;\t{offString} ({state})&#34;)
        else:
            dh(
                f&#39;&lt;b title=&#34;{stateEsc}&#34;&gt;{labelEsc}:&lt;/b&gt;&#39;
                f&#39; &lt;span title=&#34;{offEsc}&#34;&gt;{locEsc}&lt;/span&gt;&#39;
            )</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.possibleError"><code class="name flex">
<span>def <span class="ident">possibleError</span></span>(<span>self, msg, showErrors, again=False, indent='\t', newline=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L1029-L1038" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def possibleError(self, msg, showErrors, again=False, indent=&#34;\t&#34;, newline=False):
    error = self.error
    warning = self.warning

    if showErrors:
        error(msg, newline=newline)
    else:
        warning(msg, newline=newline)
        if again:
            warning(f&#34;{indent}Will try something else&#34;)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.readInfo"><code class="name flex">
<span>def <span class="ident">readInfo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L1618-L1627" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readInfo(self):
    if os.path.exists(self.filePathLocal):
        with open(self.filePathLocal, encoding=&#34;utf8&#34;) as f:
            for line in f:
                string = line.strip()
                (commit, release, local) = self.fromString(string)
                if commit:
                    self.commitOff = commit
                if release:
                    self.releaseOff = release</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.warning"><code class="name flex">
<span>def <span class="ident">warning</span></span>(<span>self, msg, newline=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L1021-L1024" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def warning(self, msg, newline=True):
    silent = self.silent
    if not silent == &#34;deep&#34;:
        console(msg, newline=newline)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Checkout.writeInfo"><code class="name flex">
<span>def <span class="ident">writeInfo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L1629-L1636" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def writeInfo(self):
    if not os.path.exists(self.dirPathLocal):
        os.makedirs(self.dirPathLocal, exist_ok=True)
    with open(self.filePathLocal, &#34;w&#34;, encoding=&#34;utf8&#34;) as f:
        if self.releaseOff:
            f.write(f&#34;{self.releaseOff}\n&#34;)
        if self.commitOff:
            f.write(f&#34;{self.commitOff}\n&#34;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tf.advanced.repo.Repo"><code class="flex name class">
<span>class <span class="ident">Repo</span></span>
<span>(</span><span>backend, org, repo, folder, version, increase, source='/Users/me/github', dest='/Users/me/Downloads')</span>
</code></dt>
<dd>
<div class="desc"><p>Auxiliary class for <code><a title="tf.advanced.repo.releaseData" href="#tf.advanced.repo.releaseData">releaseData()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L421-L700" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Repo:
    &#34;&#34;&#34;Auxiliary class for `releaseData`&#34;&#34;&#34;

    def __init__(
        self,
        backend,
        org,
        repo,
        folder,
        version,
        increase,
        source=backendRep(GH, &#34;clone&#34;),
        dest=DOWNLOADS,
    ):
        self.org = org
        self.repo = repo
        self.folder = folder
        self.version = version
        self.increase = increase
        self.source = expanduser(source)
        self.dest = expanduser(dest)

        self.repoOnline = None

        self.backend = backend
        onGithub = backend is None
        self.onGithub = onGithub

        self.conn = None

    def newRelease(self):
        if not self.makeZip():
            return False

        conn = self.connect()

        if not conn:
            return False

        if not self.fetchInfo():
            return False

        if not self.bumpRelease():
            return False

        if not self.makeRelease():
            return False

        if not self.uploadZip():
            return False

        return True

    def makeZip(self):
        source = self.source
        dest = self.dest
        backend = self.backend
        org = self.org
        repo = self.repo
        folder = self.folder
        version = self.version

        dataIn = f&#34;{source}/{org}/{repo}/{folder}/{version}&#34;

        if not os.path.exists(dataIn):
            console(f&#34;No data found in {dataIn}&#34;, error=True)
            return False

        zipData(
            backend,
            org,
            repo,
            version=version,
            relative=folder,
            source=source,
            dest=dest,
        )
        return True

    def connect(self):
        log = self.log
        warning = self.warning
        backend = self.backend
        conn = self.conn

        if not conn:
            ghPerson = os.environ.get(&#34;GHPERS&#34;, None)
            if ghPerson:
                conn = Github(ghPerson)
            else:
                ghClient = os.environ.get(&#34;GHCLIENT&#34;, None)
                ghSecret = os.environ.get(&#34;GHSECRET&#34;, None)
                if ghClient and ghSecret:
                    conn = Github(client_id=ghClient, client_secret=ghSecret)
                else:
                    conn = Github()
        try:
            rate = conn.get_rate_limit().core
            log(
                f&#34;rate limit is {rate.limit} requests per hour,&#34;
                f&#34; with {rate.remaining} left for this hour&#34;
            )
            if rate.limit &lt; 100:
                warning(
                    f&#34;To increase the rate,&#34;
                    f&#34;see {URL_TFDOC}/advanced/repo.html#github&#34;
                )

            log(
                f&#34;\tconnecting to online {backend} repo {self.org}/{self.repo} ... &#34;,
                newline=False,
            )
            self.repoOnline = conn.get_repo(f&#34;{self.org}/{self.repo}&#34;)
            log(&#34;connected&#34;)
        except GithubException as why:
            warning(&#34;failed&#34;)
            warning(f&#34;{backend} says: {why}&#34;)
        except IOError:
            warning(&#34;no internet&#34;)

        self.conn = conn
        return conn

    def fetchInfo(self):
        g = self.repoOnline
        if not g:
            return False
        self.commitOn = None
        self.releaseOn = None
        self.releaseCommitOn = None
        result = self.getRelease()
        if result:
            self.releaseOn = result
        result = self.getCommit()
        if result:
            self.commitOn = result
        return True

    def bumpRelease(self):
        increase = self.increase

        latestR = self.releaseOn
        if latestR:
            console(f&#34;Latest release = {latestR}&#34;)
        else:
            latestR = &#34;v0.0.0&#34;
            console(&#34;No releases yet&#34;)

        # bump the release version

        v = &#34;&#34;
        if latestR.startswith(&#34;v&#34;):
            v = &#34;v&#34;
            r = latestR[1:] if latestR.startswith(&#34;v&#34;) else latestR
        parts = [int(p) for p in r.split(&#34;.&#34;)]
        nParts = len(parts)
        if nParts &lt; increase:
            for i in range(nParts, increase):
                parts.append(0)
        parts[increase - 1] += 1
        parts[increase:] = []
        newTag = f&#34;{v}{&#39;.&#39;.join(str(p) for p in parts)}&#34;
        console(f&#34;New release = {newTag}&#34;)
        self.newTag = newTag
        return True

    def makeRelease(self):
        g = self.repoOnline
        if not g:
            return False

        error = self.error
        commit = self.commitOn
        newTag = self.newTag

        tag_message = &#34;data update&#34;
        release_name = &#34;data update&#34;
        release_message = &#34;data update&#34;

        try:
            newReleaseObj = g.create_git_tag_and_release(
                newTag,
                tag_message,
                release_name,
                release_message,
                commit,
                &#34;commit&#34;,
            )
        except Exception as e:
            error(&#34;\tcannot create release&#34;, newline=True)
            console(str(e), error=True)
            return False

        self.newReleaseObj = newReleaseObj
        return True

    def uploadZip(self):
        newTag = self.newTag
        newReleaseObj = self.newReleaseObj
        dest = self.dest
        org = self.org
        repo = self.repo
        folder = self.folder
        version = self.version
        dataFile = f&#34;{folder}-{version}.zip&#34;
        dataDir = f&#34;{dest}/{org}-release/{repo}&#34;
        dataPath = f&#34;{dataDir}/{dataFile}&#34;
        error = self.error

        if not os.path.exists(dataPath):
            console(f&#34;No release data found: {dataPath}&#34;, error=True)
            return False

        try:
            newReleaseObj.upload_asset(
                dataPath, label=&#34;&#34;, content_type=&#34;application/zip&#34;, name=dataFile
            )
            console(f&#34;{dataFile} attached to release {newTag}&#34;)
        except Exception as e:
            error(&#34;\tcannot attach zipfile to release&#34;, newline=True)
            console(str(e), error=True)
            return False

        return True

    def getRelease(self):
        r = self.getReleaseObj()
        if not r:
            return None
        return r.tag_name

    def getReleaseObj(self):
        g = self.repoOnline
        if not g:
            return None

        error = self.error
        r = None

        try:
            r = g.get_latest_release()
        except UnknownObjectException:
            error(&#34;\tno releases&#34;, newline=True)
        except Exception:
            error(&#34;\tcannot find releases&#34;, newline=True)
        return r

    def getCommit(self):
        c = self.getCommitObj()
        if not c:
            return None
        return c.sha

    def getCommitObj(self):
        error = self.error

        g = self.repoOnline
        if not g:
            return None

        c = None

        try:
            cs = g.get_commits()
            if cs.totalCount:
                c = cs[0]
            else:
                error(&#34;\tno commits&#34;)
        except Exception:
            error(&#34;\tcannot find commits&#34;)
        return c

    def log(self, msg, newline=True):
        console(msg, newline=newline)

    def warning(self, msg, newline=True):
        console(msg, newline=newline)

    def error(self, msg, newline=True):
        console(msg, error=True, newline=newline)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tf.advanced.repo.Repo.bumpRelease"><code class="name flex">
<span>def <span class="ident">bumpRelease</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L559-L585" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bumpRelease(self):
    increase = self.increase

    latestR = self.releaseOn
    if latestR:
        console(f&#34;Latest release = {latestR}&#34;)
    else:
        latestR = &#34;v0.0.0&#34;
        console(&#34;No releases yet&#34;)

    # bump the release version

    v = &#34;&#34;
    if latestR.startswith(&#34;v&#34;):
        v = &#34;v&#34;
        r = latestR[1:] if latestR.startswith(&#34;v&#34;) else latestR
    parts = [int(p) for p in r.split(&#34;.&#34;)]
    nParts = len(parts)
    if nParts &lt; increase:
        for i in range(nParts, increase):
            parts.append(0)
    parts[increase - 1] += 1
    parts[increase:] = []
    newTag = f&#34;{v}{&#39;.&#39;.join(str(p) for p in parts)}&#34;
    console(f&#34;New release = {newTag}&#34;)
    self.newTag = newTag
    return True</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.connect"><code class="name flex">
<span>def <span class="ident">connect</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L500-L542" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def connect(self):
    log = self.log
    warning = self.warning
    backend = self.backend
    conn = self.conn

    if not conn:
        ghPerson = os.environ.get(&#34;GHPERS&#34;, None)
        if ghPerson:
            conn = Github(ghPerson)
        else:
            ghClient = os.environ.get(&#34;GHCLIENT&#34;, None)
            ghSecret = os.environ.get(&#34;GHSECRET&#34;, None)
            if ghClient and ghSecret:
                conn = Github(client_id=ghClient, client_secret=ghSecret)
            else:
                conn = Github()
    try:
        rate = conn.get_rate_limit().core
        log(
            f&#34;rate limit is {rate.limit} requests per hour,&#34;
            f&#34; with {rate.remaining} left for this hour&#34;
        )
        if rate.limit &lt; 100:
            warning(
                f&#34;To increase the rate,&#34;
                f&#34;see {URL_TFDOC}/advanced/repo.html#github&#34;
            )

        log(
            f&#34;\tconnecting to online {backend} repo {self.org}/{self.repo} ... &#34;,
            newline=False,
        )
        self.repoOnline = conn.get_repo(f&#34;{self.org}/{self.repo}&#34;)
        log(&#34;connected&#34;)
    except GithubException as why:
        warning(&#34;failed&#34;)
        warning(f&#34;{backend} says: {why}&#34;)
    except IOError:
        warning(&#34;no internet&#34;)

    self.conn = conn
    return conn</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.error"><code class="name flex">
<span>def <span class="ident">error</span></span>(<span>self, msg, newline=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L699-L700" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def error(self, msg, newline=True):
    console(msg, error=True, newline=newline)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.fetchInfo"><code class="name flex">
<span>def <span class="ident">fetchInfo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L544-L557" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fetchInfo(self):
    g = self.repoOnline
    if not g:
        return False
    self.commitOn = None
    self.releaseOn = None
    self.releaseCommitOn = None
    result = self.getRelease()
    if result:
        self.releaseOn = result
    result = self.getCommit()
    if result:
        self.commitOn = result
    return True</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.getCommit"><code class="name flex">
<span>def <span class="ident">getCommit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L668-L672" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getCommit(self):
    c = self.getCommitObj()
    if not c:
        return None
    return c.sha</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.getCommitObj"><code class="name flex">
<span>def <span class="ident">getCommitObj</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L674-L691" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getCommitObj(self):
    error = self.error

    g = self.repoOnline
    if not g:
        return None

    c = None

    try:
        cs = g.get_commits()
        if cs.totalCount:
            c = cs[0]
        else:
            error(&#34;\tno commits&#34;)
    except Exception:
        error(&#34;\tcannot find commits&#34;)
    return c</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.getRelease"><code class="name flex">
<span>def <span class="ident">getRelease</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L646-L650" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getRelease(self):
    r = self.getReleaseObj()
    if not r:
        return None
    return r.tag_name</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.getReleaseObj"><code class="name flex">
<span>def <span class="ident">getReleaseObj</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L652-L666" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getReleaseObj(self):
    g = self.repoOnline
    if not g:
        return None

    error = self.error
    r = None

    try:
        r = g.get_latest_release()
    except UnknownObjectException:
        error(&#34;\tno releases&#34;, newline=True)
    except Exception:
        error(&#34;\tcannot find releases&#34;, newline=True)
    return r</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.log"><code class="name flex">
<span>def <span class="ident">log</span></span>(<span>self, msg, newline=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L693-L694" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def log(self, msg, newline=True):
    console(msg, newline=newline)</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.makeRelease"><code class="name flex">
<span>def <span class="ident">makeRelease</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L587-L615" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeRelease(self):
    g = self.repoOnline
    if not g:
        return False

    error = self.error
    commit = self.commitOn
    newTag = self.newTag

    tag_message = &#34;data update&#34;
    release_name = &#34;data update&#34;
    release_message = &#34;data update&#34;

    try:
        newReleaseObj = g.create_git_tag_and_release(
            newTag,
            tag_message,
            release_name,
            release_message,
            commit,
            &#34;commit&#34;,
        )
    except Exception as e:
        error(&#34;\tcannot create release&#34;, newline=True)
        console(str(e), error=True)
        return False

    self.newReleaseObj = newReleaseObj
    return True</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.makeZip"><code class="name flex">
<span>def <span class="ident">makeZip</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L474-L498" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeZip(self):
    source = self.source
    dest = self.dest
    backend = self.backend
    org = self.org
    repo = self.repo
    folder = self.folder
    version = self.version

    dataIn = f&#34;{source}/{org}/{repo}/{folder}/{version}&#34;

    if not os.path.exists(dataIn):
        console(f&#34;No data found in {dataIn}&#34;, error=True)
        return False

    zipData(
        backend,
        org,
        repo,
        version=version,
        relative=folder,
        source=source,
        dest=dest,
    )
    return True</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.newRelease"><code class="name flex">
<span>def <span class="ident">newRelease</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L451-L472" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def newRelease(self):
    if not self.makeZip():
        return False

    conn = self.connect()

    if not conn:
        return False

    if not self.fetchInfo():
        return False

    if not self.bumpRelease():
        return False

    if not self.makeRelease():
        return False

    if not self.uploadZip():
        return False

    return True</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.uploadZip"><code class="name flex">
<span>def <span class="ident">uploadZip</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L617-L644" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def uploadZip(self):
    newTag = self.newTag
    newReleaseObj = self.newReleaseObj
    dest = self.dest
    org = self.org
    repo = self.repo
    folder = self.folder
    version = self.version
    dataFile = f&#34;{folder}-{version}.zip&#34;
    dataDir = f&#34;{dest}/{org}-release/{repo}&#34;
    dataPath = f&#34;{dataDir}/{dataFile}&#34;
    error = self.error

    if not os.path.exists(dataPath):
        console(f&#34;No release data found: {dataPath}&#34;, error=True)
        return False

    try:
        newReleaseObj.upload_asset(
            dataPath, label=&#34;&#34;, content_type=&#34;application/zip&#34;, name=dataFile
        )
        console(f&#34;{dataFile} attached to release {newTag}&#34;)
    except Exception as e:
        error(&#34;\tcannot attach zipfile to release&#34;, newline=True)
        console(str(e), error=True)
        return False

    return True</code></pre>
</details>
</dd>
<dt id="tf.advanced.repo.Repo.warning"><code class="name flex">
<span>def <span class="ident">warning</span></span>(<span>self, msg, newline=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/8392aa1c5e94bea9b52834a84834f477899e54c0/tf/advanced/repo.py#L696-L697" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def warning(self, msg, newline=True):
    console(msg, newline=newline)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#auto-downloading-from-a-backend-repository">Auto downloading from a backend repository</a><ul>
<li><a href="#description">Description</a></li>
<li><a href="#rate-limiting">Rate limiting</a></li>
</ul>
</li>
<li><a href="#github">GitHub</a><ul>
<li><a href="#increase-the-rate-limit">Increase the rate limit</a></li>
</ul>
</li>
<li><a href="#gitlab">GitLab</a></li>
<li><a href="#token-in-environment-variables">Token in environment variables</a><ul>
<li><a href="#on-mac-and-linux">On Mac and Linux</a></li>
<li><a href="#on-windows">On Windows</a></li>
<li><a href="#result">Result</a></li>
<li><a href="#minimize-accessing-github">Minimize accessing GitHub</a><ul>
<li><a href="#using-a-corpus-for-the-first-time-within-the-rate-limit">Using a corpus for the first time, within the rate limit</a></li>
<li><a href="#using-a-corpus-for-the-first-time-after-hitting-the-rate-limit">Using a corpus for the first time, after hitting the rate limit</a></li>
<li><a href="#using-a-corpus-that-you-already-have">Using a corpus that you already have</a></li>
<li><a href="#updating-a-corpus-that-you-already-have">Updating a corpus that you already have</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.advanced" href="index.html">tf.advanced</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tf.advanced.repo.GLPERS" href="#tf.advanced.repo.GLPERS">GLPERS</a></code></li>
<li><code><a title="tf.advanced.repo.checkoutRepo" href="#tf.advanced.repo.checkoutRepo">checkoutRepo</a></code></li>
<li><code><a title="tf.advanced.repo.releaseData" href="#tf.advanced.repo.releaseData">releaseData</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.advanced.repo.Checkout" href="#tf.advanced.repo.Checkout">Checkout</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.advanced.repo.Checkout.connect" href="#tf.advanced.repo.Checkout.connect">connect</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.download" href="#tf.advanced.repo.Checkout.download">download</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.downloadCommit" href="#tf.advanced.repo.Checkout.downloadCommit">downloadCommit</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.downloadDir" href="#tf.advanced.repo.Checkout.downloadDir">downloadDir</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.downloadRelease" href="#tf.advanced.repo.Checkout.downloadRelease">downloadRelease</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.downloadZip" href="#tf.advanced.repo.Checkout.downloadZip">downloadZip</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.error" href="#tf.advanced.repo.Checkout.error">error</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.fetchInfo" href="#tf.advanced.repo.Checkout.fetchInfo">fetchInfo</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.fixInfo" href="#tf.advanced.repo.Checkout.fixInfo">fixInfo</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.fromString" href="#tf.advanced.repo.Checkout.fromString">fromString</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.getCommit" href="#tf.advanced.repo.Checkout.getCommit">getCommit</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.getCommitFromObj" href="#tf.advanced.repo.Checkout.getCommitFromObj">getCommitFromObj</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.getCommitObj" href="#tf.advanced.repo.Checkout.getCommitObj">getCommitObj</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.getRelease" href="#tf.advanced.repo.Checkout.getRelease">getRelease</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.getReleaseFromObj" href="#tf.advanced.repo.Checkout.getReleaseFromObj">getReleaseFromObj</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.getReleaseObj" href="#tf.advanced.repo.Checkout.getReleaseObj">getReleaseObj</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.isClone" href="#tf.advanced.repo.Checkout.isClone">isClone</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.isOffline" href="#tf.advanced.repo.Checkout.isOffline">isOffline</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.log" href="#tf.advanced.repo.Checkout.log">log</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.login" href="#tf.advanced.repo.Checkout.login">login</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.makeSureLocal" href="#tf.advanced.repo.Checkout.makeSureLocal">makeSureLocal</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.possibleError" href="#tf.advanced.repo.Checkout.possibleError">possibleError</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.readInfo" href="#tf.advanced.repo.Checkout.readInfo">readInfo</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.toString" href="#tf.advanced.repo.Checkout.toString">toString</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.warning" href="#tf.advanced.repo.Checkout.warning">warning</a></code></li>
<li><code><a title="tf.advanced.repo.Checkout.writeInfo" href="#tf.advanced.repo.Checkout.writeInfo">writeInfo</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tf.advanced.repo.Repo" href="#tf.advanced.repo.Repo">Repo</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.advanced.repo.Repo.bumpRelease" href="#tf.advanced.repo.Repo.bumpRelease">bumpRelease</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.connect" href="#tf.advanced.repo.Repo.connect">connect</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.error" href="#tf.advanced.repo.Repo.error">error</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.fetchInfo" href="#tf.advanced.repo.Repo.fetchInfo">fetchInfo</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.getCommit" href="#tf.advanced.repo.Repo.getCommit">getCommit</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.getCommitObj" href="#tf.advanced.repo.Repo.getCommitObj">getCommitObj</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.getRelease" href="#tf.advanced.repo.Repo.getRelease">getRelease</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.getReleaseObj" href="#tf.advanced.repo.Repo.getReleaseObj">getReleaseObj</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.log" href="#tf.advanced.repo.Repo.log">log</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.makeRelease" href="#tf.advanced.repo.Repo.makeRelease">makeRelease</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.makeZip" href="#tf.advanced.repo.Repo.makeZip">makeZip</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.newRelease" href="#tf.advanced.repo.Repo.newRelease">newRelease</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.uploadZip" href="#tf.advanced.repo.Repo.uploadZip">uploadZip</a></code></li>
<li><code><a title="tf.advanced.repo.Repo.warning" href="#tf.advanced.repo.Repo.warning">warning</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://www.dans.knaw.nl"><img alt="DANS" src="../../tf/images/DANS-logo.png" width="200" alt="DANS"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>