<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.advanced.helpers API documentation</title>
<meta name="description" content="" />
<!-- integrity SRI from https://cdnjs.com/libraries/10up-sanitize.css/11.0.1 -->
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css"
integrity="sha512-kcbluZFacWN57NgWZ4aH6eUMBEaTyErFhIFD3y5qYZbKuuyImH0K/AKsBbfXlivh2z5C+3IDTIhI11YmKomzmA=="
crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css"
integrity="sha512-uVeAgzAmieLUTGba0qr9vXQgVD7fko2kcbYIKIraXUIDg9iJLxveTFUrg3DJhqn3cAf3HFDbgmhq0eGko5wEAA=="
crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.advanced.helpers</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L1-L795" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import collections
from textwrap import dedent

import re
from IPython.display import display, Markdown, HTML

from ..core.helpers import htmlEsc, console
from ..core.files import (
    expanduser as ex,
    unexpanduser as ux,
    backendRep,
    TEMP_DIR,
    prefixSlash,
    dirExists,
)
from ..core.text import DEFAULT_FORMAT


NORMAL = &#34;normal&#34;
ORIG = &#34;orig&#34;

RESULT = &#34;result&#34;
NB = &#34;\u00a0&#34;
EM = &#34;*empty*&#34;

SEQ_TYPES1 = {tuple, list}
SEQ_TYPES2 = {tuple, list, set, frozenset}


def runsInNotebook():
    &#34;&#34;&#34;Determines whether the program runs in an interactive shell.

    From
    [stackoverflow](https://stackoverflow.com/questions/15411967/how-can-i-check-if-code-is-executed-in-the-ipython-notebook/24937408)
    &#34;&#34;&#34;
    try:
        runcontext = get_ipython()
        shell = runcontext.__class__.__name__
        if shell == &#34;ZMQInteractiveShell&#34;:
            return True  # Jupyter notebook or qtconsole
        elif shell == &#34;TerminalInteractiveShell&#34;:
            return False  # Terminal running IPython
        else:
            return False  # Other type (?)
    except NameError:
        return False  # Probably standard Python interpreter


def _getLtr(app, options):
    aContext = app.context
    direction = aContext.direction

    fmt = options.fmt or DEFAULT_FORMAT

    return (
        &#34;rtl&#34;
        if direction == &#34;rtl&#34; and (f&#34;{ORIG}-&#34; in fmt or f&#34;-{ORIG}&#34; in fmt)
        else (&#34;&#34; if direction == &#34;ltr&#34; else &#34;ltr&#34;)
    )


def dm(md, inNb=True, unexpand=False):
    &#34;&#34;&#34;Display markdown.

    Parameters
    ----------
    md: string
        Raw markdown string.
    inNb: boolean, optional True
        Whether the program runs in a notebook
    unexpand: boolean
        Whether to strip a potential user path from the value first

    Returns
    -------
    None
        The formatted markdown is rendered in the output cell if `inNb`
        else the raw markdown is printed to the output.
    &#34;&#34;&#34;

    if unexpand:
        md = ux(md)

    if inNb:
        display(Markdown(md))
    else:
        console(md)


def dh(html, inNb=True, unexpand=False):
    &#34;&#34;&#34;Display HTML.

    Parameters
    ----------
    html: string
        Raw HTML string.
    inNb: boolean, optional True
        Whether the program runs in a notebook
    unexpand: boolean
        Whether to strip a potential user path from the value first

    Returns
    -------
    None
        The formatted HTML is rendered in the output cell if `inNb`
        else the raw HTML is printed to the output.
    &#34;&#34;&#34;

    if unexpand:
        html = ux(html)

    if inNb:
        display(HTML(html))
    else:
        console(html)


# MODULE REFERENCES

BACKEND_RE = re.compile(r&#34;&lt;([^/&gt;]*)&gt;&#34;)


thisBackend = []


def backendRepl(match):
    thisBackend.append(match.group(1))
    return &#34;&#34;


def splitModRef(moduleRef):
    thisBackend.clear()
    theBackend = None
    bareModuleRef = BACKEND_RE.sub(backendRepl, moduleRef)
    if len(thisBackend):
        theBackend = thisBackend[0]
        if len(thisBackend) &gt; 1:
            console(
                f&#34;Multiple &lt;backend&gt; in {moduleRef}: &#34;
                f&#34;{&#39;, &#39;.join(thisBackend)}; using &lt;{theBackend}&gt; only &#34;,
                error=True,
            )

    bRep = f&#34;&lt;{theBackend}&gt;&#34; if theBackend else &#34;&#34;

    parts = bareModuleRef.split(&#34;:&#34;, 1)
    if len(parts) == 1:
        parts.append(&#34;&#34;)
    (ref, specifier) = parts
    parts = ref.split(&#34;/&#34;, 2)

    if len(parts) &lt; 2:
        console(
            f&#34;&#34;&#34;
Module ref &#34;{bRep}{bareModuleRef}&#34; is not &#34;{{org}}/{{repo}}/{{path}}&#34;
&#34;&#34;&#34;,
            error=True,
        )
        return None

    if len(parts) == 2:
        parts.append(&#34;&#34;)

    return [*parts, specifier, theBackend]


# COLLECT CONFIG SETTINGS IN A DICT


def getLocalDir(backend, cfg, local, version):
    provenanceSpec = cfg.get(&#34;provenanceSpec&#34;, {})
    org = provenanceSpec.get(&#34;org&#34;, None)
    repo = provenanceSpec.get(&#34;repo&#34;, None)
    relative = prefixSlash(provenanceSpec.get(&#34;relative&#34;, &#34;tf&#34;))
    version = provenanceSpec.get(&#34;version&#34;, None) if version is None else version
    base = hasData(backend, local, org, repo, version, relative)

    if not base:
        base = backendRep(backend, &#34;cache&#34;)

    return ex(f&#34;{base}/{org}/{repo}/{TEMP_DIR}&#34;)


def hasData(backend, local, org, repo, version, relative):
    versionRep = f&#34;/{version}&#34; if version else &#34;&#34;
    if local == &#34;clone&#34;:
        cloneBase = backendRep(backend, &#34;clone&#34;)
        ghTarget = f&#34;{cloneBase}/{org}/{repo}{relative}{versionRep}&#34;
        if dirExists(ghTarget):
            return cloneBase

    cacheBase = backendRep(backend, &#34;cache&#34;)
    cacheTarget = f&#34;{cacheBase}/{org}/{repo}{relative}{versionRep}&#34;
    if dirExists(cacheTarget):
        return cacheBase
    return False


def tupleEnum(tuples, start, end, limit, item, inNb):
    if start is None:
        start = 1
    i = -1
    if not hasattr(tuples, &#34;__len__&#34;):
        if end is None or end - start + 1 &gt; limit:
            end = start - 1 + limit
        for tup in tuples:
            i += 1
            if i &lt; start - 1:
                continue
            if i &gt;= end:
                break
            yield (i + 1, tup)
    else:
        if end is None or end &gt; len(tuples):
            end = len(tuples)
        rest = 0
        if end - (start - 1) &gt; limit:
            rest = end - (start - 1) - limit
            end = start - 1 + limit
        for i in range(start - 1, end):
            yield (i + 1, tuples[i])
        if rest:
            dh(
                f&#34;&lt;b&gt;{rest} more {item}s skipped&lt;/b&gt; because we show a maximum of&#34;
                f&#34; {limit} {item}s at a time&#34;,
                inNb=inNb,
            )


def parseFeatures(features):
    if (
        type(features) in SEQ_TYPES1
        and len(features) == 2
        and type(features[0]) in SEQ_TYPES2
        and type(features[1]) is dict
    ):
        return features

    feats = (
        ()
        if not features
        else features.split()
        if type(features) is str
        else tuple(features)
    )
    return parseFeaturesLogical(feats)


def parseFeaturesLogical(feats):
    bare = []
    indirect = {}

    for feat in feats:
        if not feat:
            continue
        parts = feat.split(&#34;:&#34;, 1)
        feat = parts[-1]
        bare.append(feat)
        if len(parts) &gt; 1:
            indirect[feat] = parts[0]
    return (bare, indirect)


def transitiveClosure(relation, reflexiveExceptions):
    &#34;&#34;&#34;Produce the reflexive transitive closure of a relation.

    The transitive closure of a relation `R` is the relation `TR`
    such that `a TR b` if and only if there is a chain of `c1`, `c2`, ..., `cn`
    such that `a Rc1`, `c1 R c2`, ..., `cn R b`.

    If we allow the chain to have length zero, we effectively have that
    `a TR a` for all elements. That is the reflexive, transitive closure.

    This function builds the latter, but we allow for exceptions to the
    reflexivity.

    Parameters
    ----------
    relation: dict
        The input relation, keyed by elements, valued by the set of
        elements that stand in relation to the key.
    reflexiveExceptions: set
        The set of elements that will not be reflexively closed.

    Returns
    -------
    dict
        The transitive reflexive closure (with possible exceptions to
        the reflexivity) of the given relation.

    Notes
    -----
    We use this function to build the closure of the `childType` relation
    between node types. We want to exclude the slot type from the
    reflexivity. The closure of the `childType` relation is the descendant type
    relation.
    The display algorithm uses this to unravel nodes.

    See also
    --------
    tf.advanced.display: Display algorithm
    &#34;&#34;&#34;

    descendants = {parent: set(children) for (parent, children) in relation.items()}

    changed = True
    while changed:
        changed = False
        for (parent, children) in relation.items():
            for child in children:
                if child in descendants:
                    for grandChild in descendants[child]:
                        if grandChild not in descendants[parent]:
                            descendants[parent].add(grandChild)
                            changed = True
    for parent in relation:
        if parent not in reflexiveExceptions:
            descendants[parent].add(parent)
    return descendants


def htmlSafe(text, isHtml, math=False):
    return text.replace(&#34;\n&#34;, &#34;&lt;br&gt;&#34;) if isHtml else htmlEsc(text, math=math)


def getText(
    app, isPretty, n, nType, outer, first, last, level, passage, descend, options=None
):
    display = app.display
    dContext = display.distill(options or {})
    ltr = _getLtr(app, dContext) or &#34;ltr&#34;
    showMath = dContext.showMath
    T = app.api.T
    sectionTypeSet = T.sectionTypeSet
    structureTypeSet = T.structureTypeSet

    aContext = app.context
    templates = aContext.labels if isPretty else aContext.templates

    fmt = None if options is None else options.fmt
    withLabels = True if options is None else options.withLabels
    isHtml = False if options is None else options.isHtml
    suppress = set() if options is None else options.suppress

    (tpl, feats) = templates[nType]

    if not (tpl is True or withLabels):
        return &#34;&#34;

    # now there is a coarse fix for something in the Hermans corpus:
    # in plain display we add a space when we fill in a template.
    # But that leads to unwanted results.
    # The problem in the Hermans corpus can be solved in other ways.
    # We remove the fix again.

    # x = &#34;&#34; if isPretty else &#34; &#34;

    tplFilled = (
        (
            (
                f&#34;&#34;&#34;&lt;span class=&#34;tfsechead {ltr}&#34;&gt;&lt;span class=&#34;ltr&#34;&gt;&#34;&#34;&#34;
                + (NB if passage else app.sectionStrFromNode(n))
                + &#34;&lt;/span&gt;&lt;/span&gt;&#34;
            )
            if nType in sectionTypeSet
            else f&#39;&lt;span class=&#34;structure&#34;&gt;{app.structureStrFromNode(n)}&lt;/span&gt;&#39;
            if nType in structureTypeSet
            else htmlSafe(
                T.text(
                    n,
                    fmt=fmt,
                    descend=descend,
                    outer=outer,
                    first=first,
                    last=last,
                    level=level,
                ),
                isHtml,
                math=showMath,
            )
        )
        if tpl is True
        else (
            (
                tpl.format(
                    **{
                        feat: getValue(app, n, nType, feat, suppress, math=showMath)
                        for feat in feats
                    }
                )
                #  + x
            )
        )
    )
    return tplFilled


def getValue(app, n, nType, feat, suppress, math=False):
    F = app.api.F
    Fs = app.api.Fs

    customMethods = app.customMethods
    transform = customMethods.transform

    if feat in suppress:
        val = &#34;&#34;
    else:
        featObj = Fs(feat) if hasattr(F, feat) else None
        val = htmlEsc(featObj.v(n), math=math) if featObj else None
        modifier = transform.get(nType, {}).get(feat, None)
        if modifier:
            val = modifier(n, val)
        val = val.replace(&#34;\n&#34;, &#34;\\n&#34;)
    return f&#39;&lt;span title=&#34;{feat}&#34;&gt;{val}&lt;/span&gt;&#39;


def getHeaderTypes(app, tuples):
    api = app.api
    F = api.F
    fOtype = F.otype.v

    iTypes = collections.defaultdict(collections.Counter)

    for (t, tup) in tuples:
        if t is None:
            continue
        for (i, n) in enumerate(tup):
            iTypes[i][fOtype(n)] += 1

    headerTypes = {}

    for (i, tpInfo) in iTypes.items():
        nodeTypes = [
            ti[0] for ti in sorted(tpInfo.items(), key=lambda x: (-x[1], x[0]))
        ]
        nTypes = len(nodeTypes)
        head = nodeTypes[0]
        if nTypes &gt; 1:
            remaining = &#34;, &#34;.join(nodeTypes[1:])
            head += f&#39; &lt;span title=&#34;{remaining}&#34;&gt;(+{nTypes - 1})&lt;/span&gt;&#39;
        headerTypes[i] = head

    return headerTypes


def getHeaders(app, tuples):
    headerTypes = getHeaderTypes(app, tuples)
    headerMaterial = &#34;&lt;/span&gt;&lt;span&gt;&#34;.join(
        headerTypes.get(i, f&#34;column {i}&#34;) for i in range(len(headerTypes))
    )
    return dedent(
        f&#34;&#34;&#34;
        &lt;div class=&#34;dtheadrow&#34;&gt;
          &lt;span&gt;n&lt;/span&gt;&lt;span&gt;{headerMaterial}&lt;/span&gt;
        &lt;/div&gt;
        &#34;&#34;&#34;
    )


# COMPOSE TABLES FOR CSV EXPORT


def isUniform(app, tuples):
    &#34;&#34;&#34;Whether the members of tuples are uniform.

    An iterable of tuples of nodes is uniform, if each
    tuple has the same number of nodes,
    and if the type of a node at position `i` in the tuple
    is the same for all tuples.
    &#34;&#34;&#34;
    api = app.api
    F = api.F
    fOtype = F.otype.v

    uniform = True
    fixedLength = None
    fixedTypes = None

    for tup in tuples:
        thisLength = len(tup)
        theseTypes = tuple(fOtype(n) for n in tup)

        if fixedLength is None:
            fixedLength = thisLength
        if fixedTypes is None:
            fixedTypes = theseTypes

        if thisLength != fixedLength or theseTypes != fixedTypes:
            uniform = False
            break

    return uniform


def getRowsX(app, tuples, features, condenseType, fmt=None):
    &#34;&#34;&#34;Transform an iterable of nodes into a table with extra information.

    If the tuples are uniform (`isUniform`), the formatting will
    be richer then when the tuples are not uniform.
    &#34;&#34;&#34;

    return (
        getResultsX(app, tuples, features, condenseType, fmt=fmt)
        if isUniform(app, tuples)
        else getTuplesX(app, tuples, condenseType, fmt=fmt)
    )


def getResultsX(app, results, features, condenseType, fmt=None):
    &#34;&#34;&#34;Transform a uniform iterable of nodes into a table with extra information.

    Parameters
    ----------
    results: iterable of tuple of int
        A uniform `isUniform` sequence of tuples of nodes
    features: key value pairs
        features per index position of the tuples.
        It specifies for some positions `i` which features for the nodes at that
        position should be looked up. For each `i` it should be an iterable
        or comma-separated list of feature names.
    condenseType: string
        A node type. Types smaller or equal than this type will have their text
        displayed in the result.
    fmt: string, optional None
        A text format. If text has to be displayed, this format is used.
        If not passed, a default is used.
    &#34;&#34;&#34;

    api = app.api
    F = api.F
    Fs = api.Fs
    T = api.T
    N = api.N
    fOtype = F.otype.v
    otypeRank = N.otypeRank
    sectionTypeSet = T.sectionTypeSet

    aContext = app.context
    noDescendTypes = aContext.noDescendTypes

    sectionDepth = len(sectionTypeSet)
    if len(results) == 0:
        return ()
    firstResult = results[0]
    nTuple = len(firstResult)
    refColumns = [
        i for (i, n) in enumerate(firstResult) if fOtype(n) not in sectionTypeSet
    ]
    refColumn = refColumns[0] if refColumns else nTuple - 1
    header = [&#34;R&#34;] + [f&#34;S{i}&#34; for i in range(1, sectionDepth + 1)]
    emptyA = []

    featureDict = {i: tuple(f.split()) if type(f) is str else f for (i, f) in features}

    def withText(nodeType):
        return (
            condenseType is None
            and nodeType not in sectionTypeSet
            or otypeRank[nodeType] &lt;= otypeRank[condenseType]
        )

    noDescendTypes = noDescendTypes

    for j in range(nTuple):
        i = j + 1
        n = firstResult[j]
        nType = fOtype(n)
        header.extend([f&#34;NODE{i}&#34;, f&#34;TYPE{i}&#34;])
        if withText(nType):
            header.append(f&#34;TEXT{i}&#34;)
        header.extend(f&#34;{feature}{i}&#34; for feature in featureDict.get(j, emptyA))
    rows = [tuple(header)]
    for (rm, r) in enumerate(results):
        rn = rm + 1
        row = [rn]
        refN = r[refColumn]
        sparts = T.sectionFromNode(refN)
        nParts = len(sparts)
        section = sparts + ((None,) * (sectionDepth - nParts))
        row.extend(section)
        for j in range(nTuple):
            n = r[j]
            nType = fOtype(n)
            row.extend((n, nType))
            if withText(nType):
                text = T.text(n, fmt=fmt, descend=nType not in noDescendTypes)
                row.append(text)
            row.extend(Fs(feature).v(n) for feature in featureDict.get(j, emptyA))
        rows.append(tuple(row))
    return tuple(rows)


def getTuplesX(app, results, condenseType, fmt=None):
    &#34;&#34;&#34;Transform a non-uniform iterable of nodes into a table with extra information.

    Parameters
    ----------
    results: iterable of tuple of int
        A uniform `isUniform` sequence of tuples of nodes
    condenseType: string
        A node type. Types smaller or equal than this type will have their text
        displayed in the result.
    fmt: string, optional None
        A text format. If text has to be displayed, this format is used.
        If not passed, a default is used.
    &#34;&#34;&#34;

    api = app.api
    F = api.F
    T = api.T
    N = api.N
    fOtype = F.otype.v
    otypeRank = N.otypeRank
    sectionTypeSet = T.sectionTypeSet

    aContext = app.context
    noDescendTypes = aContext.noDescendTypes

    sectionDepth = len(sectionTypeSet)
    if len(results) == 0:
        return ()

    def withText(nodeType):
        return (
            condenseType is None
            and nodeType not in sectionTypeSet
            or otypeRank[nodeType] &lt;= otypeRank[condenseType]
        )

    noDescendTypes = noDescendTypes

    rows = []

    for (tm, tup) in enumerate(results):
        tn = tm + 1
        row = [tn]
        for n in tup:
            sparts = T.sectionFromNode(n)
            nParts = len(sparts)
            section = sparts + ((None,) * (sectionDepth - nParts))
            row.extend(section)
            nType = fOtype(n)
            row.extend((n, nType))
            if withText(nType):
                text = T.text(n, fmt=fmt, descend=nType not in noDescendTypes)
                row.append(text)
        rows.append(tuple(row))
    return tuple(rows)


def hEmpty(x):
    return (
        &#34;&lt;i&gt;no value&lt;/i&gt;&#34;
        if x is None
        else &#34;&#34;&#34;&lt;code&gt;0&lt;/code&gt;&#34;&#34;&#34;
        if x == 0
        else &#34;&#34;&#34;&lt;code&gt;&#39;&#39;&lt;/code&gt;&#34;&#34;&#34;
        if x == &#34;&#34;
        else f&#34;&#34;&#34;&lt;code&gt;{str(x)}&lt;/code&gt;&#34;&#34;&#34;
    )


def hScalar(x):
    if type(x) is str:
        x = htmlEsc(x)
        if &#34;\n&#34; in x:
            x = x.replace(&#34;\n&#34;, &#34;&lt;br&gt;&#34;)

    xRep = f&#34;&lt;code&gt;{x}&lt;/code&gt;&#34;
    return (len(x) &lt; 60 if type(x) is str else True, xRep)


def hScalar0(x):
    tpv = type(x)
    if tpv is dict:
        (k, v) = list(x.items())[0]
    else:
        v = list(x)[0]

    (simple, vRep) = hData(v)

    html = (
        (
            f&#34;{{&lt;b&gt;{k}&lt;/b&gt;: {vRep}}}&#34;
            if tpv is dict
            else f&#34;[{vRep}]&#34;
            if tpv is list
            else f&#34;({vRep})&#34;
            if tpv is tuple
            else f&#34;{{{vRep}}}&#34;
        )
        if simple
        else (
            f&#34;&#34;&#34;&lt;li&gt;&lt;details open&gt;
                &lt;summary&gt;&lt;b&gt;{k}&lt;/b&gt;:&lt;/summary&gt;
                {vRep}
                &lt;/details&gt;&lt;/li&gt;&#34;&#34;&#34;
            if tpv is dict
            else f&#34;&#34;&#34;&lt;li&gt;&lt;details open&gt;
                &lt;summary&gt;:&lt;/summary&gt;
                {vRep}
                &lt;/details&gt;&lt;/li&gt;&#34;&#34;&#34;
        )
    )
    return (simple, html)


def hList(x, outer=False):
    elem = f&#34;{&#39;o&#39; if outer else &#39;u&#39;}l&#34;
    html = []
    html.append(f&#34;&lt;{elem}&gt;&#34;)

    for v in x:
        (simple, vRep) = hData(v)

        if simple:
            html.append(f&#34;&#34;&#34;&lt;li&gt;{vRep}&lt;/li&gt;&#34;&#34;&#34;)
        else:
            html.append(f&#34;&#34;&#34;&lt;li&gt;&lt;details&gt;&lt;summary&gt;:&lt;/summary&gt;{vRep}&lt;/details&gt;&lt;/li&gt;&#34;&#34;&#34;)

    html.append(f&#34;&lt;/{elem}&gt;&#34;)

    return &#34;&#34;.join(html)


def hDict(x, outer=False):
    elem = f&#34;{&#39;o&#39; if outer else &#39;u&#39;}l&#34;
    html = []
    html.append(f&#34;&lt;{elem}&gt;&#34;)

    for (k, v) in sorted(x.items(), key=lambda y: str(y)):
        (simple, vRep) = hData(v)

        if simple:
            html.append(f&#34;&#34;&#34;&lt;li&gt;&lt;b&gt;{k}&lt;/b&gt;: {vRep}&lt;/li&gt;&#34;&#34;&#34;)
        else:
            html.append(
                f&#34;&#34;&#34;&lt;li&gt;&lt;details&gt;&lt;summary&gt;&lt;b&gt;{k}&lt;/b&gt;:&lt;/summary&gt;{vRep}&lt;/details&gt;&lt;/li&gt;&#34;&#34;&#34;
            )

    html.append(f&#34;&lt;/{elem}&gt;&#34;)

    return &#34;&#34;.join(html)


def hData(x):
    if not x:
        return (True, hEmpty(x))
    tpv = type(x)
    if tpv is str or tpv is float or tpv is int or tpv is bool:
        return hScalar(x)
    if tpv is list or tpv is tuple or tpv is set or tpv is dict:
        return (
            (True, hEmpty(x))
            if len(x) == 0
            else hScalar0(x)
            if len(x) == 1
            else (False, hDict(x))
            if tpv is dict
            else (False, hList(x))
        )
    if tpv is dict:
        return (False, hDict(x))
    return hScalar(x)


def showDict(title, data, _browse, inNb, *keys):
    &#34;&#34;&#34;Shows selected keys of a dictionary in a pretty way.

    Parameters
    ----------
    _browse: boolean
        Whether we are in the TF browser.
    inNb: boolean
        Whether we run in a notebook.
    keys: iterable of string
        For each key passed to this function, the information for that key
        will be displayed. If no keys are passed, all keys will be displayed.

    Returns
    -------
    displayed HTML
        An expandable list of the key-value pair for the requested keys.
    &#34;&#34;&#34;

    keys = set(keys)

    html = hDict({k: v for (k, v) in data.items() if not keys or k in keys}, outer=True)
    openRep = &#34;open&#34; if keys else &#34;&#34;
    html = f&#34;&lt;details {openRep}&gt;&lt;summary&gt;{title}&lt;/summary&gt;{html}&lt;/details&gt;&#34;

    if _browse:
        return html
    else:
        dh(html, inNb=inNb)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.advanced.helpers.backendRepl"><code class="name flex">
<span>def <span class="ident">backendRepl</span></span>(<span>match)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L126-L128" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def backendRepl(match):
    thisBackend.append(match.group(1))
    return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.dh"><code class="name flex">
<span>def <span class="ident">dh</span></span>(<span>html, inNb=True, unexpand=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Display HTML.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>html</code></strong> :&ensp;<code>string</code></dt>
<dd>Raw HTML string.</dd>
<dt><strong><code>inNb</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>Whether the program runs in a notebook</dd>
<dt><strong><code>unexpand</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether to strip a potential user path from the value first</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>The formatted HTML is rendered in the output cell if <code>inNb</code>
else the raw HTML is printed to the output.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L90-L115" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dh(html, inNb=True, unexpand=False):
    &#34;&#34;&#34;Display HTML.

    Parameters
    ----------
    html: string
        Raw HTML string.
    inNb: boolean, optional True
        Whether the program runs in a notebook
    unexpand: boolean
        Whether to strip a potential user path from the value first

    Returns
    -------
    None
        The formatted HTML is rendered in the output cell if `inNb`
        else the raw HTML is printed to the output.
    &#34;&#34;&#34;

    if unexpand:
        html = ux(html)

    if inNb:
        display(HTML(html))
    else:
        console(html)</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.dm"><code class="name flex">
<span>def <span class="ident">dm</span></span>(<span>md, inNb=True, unexpand=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Display markdown.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>md</code></strong> :&ensp;<code>string</code></dt>
<dd>Raw markdown string.</dd>
<dt><strong><code>inNb</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>Whether the program runs in a notebook</dd>
<dt><strong><code>unexpand</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether to strip a potential user path from the value first</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>The formatted markdown is rendered in the output cell if <code>inNb</code>
else the raw markdown is printed to the output.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L62-L87" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dm(md, inNb=True, unexpand=False):
    &#34;&#34;&#34;Display markdown.

    Parameters
    ----------
    md: string
        Raw markdown string.
    inNb: boolean, optional True
        Whether the program runs in a notebook
    unexpand: boolean
        Whether to strip a potential user path from the value first

    Returns
    -------
    None
        The formatted markdown is rendered in the output cell if `inNb`
        else the raw markdown is printed to the output.
    &#34;&#34;&#34;

    if unexpand:
        md = ux(md)

    if inNb:
        display(Markdown(md))
    else:
        console(md)</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.getHeaderTypes"><code class="name flex">
<span>def <span class="ident">getHeaderTypes</span></span>(<span>app, tuples)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L417-L443" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getHeaderTypes(app, tuples):
    api = app.api
    F = api.F
    fOtype = F.otype.v

    iTypes = collections.defaultdict(collections.Counter)

    for (t, tup) in tuples:
        if t is None:
            continue
        for (i, n) in enumerate(tup):
            iTypes[i][fOtype(n)] += 1

    headerTypes = {}

    for (i, tpInfo) in iTypes.items():
        nodeTypes = [
            ti[0] for ti in sorted(tpInfo.items(), key=lambda x: (-x[1], x[0]))
        ]
        nTypes = len(nodeTypes)
        head = nodeTypes[0]
        if nTypes &gt; 1:
            remaining = &#34;, &#34;.join(nodeTypes[1:])
            head += f&#39; &lt;span title=&#34;{remaining}&#34;&gt;(+{nTypes - 1})&lt;/span&gt;&#39;
        headerTypes[i] = head

    return headerTypes</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.getHeaders"><code class="name flex">
<span>def <span class="ident">getHeaders</span></span>(<span>app, tuples)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L446-L457" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getHeaders(app, tuples):
    headerTypes = getHeaderTypes(app, tuples)
    headerMaterial = &#34;&lt;/span&gt;&lt;span&gt;&#34;.join(
        headerTypes.get(i, f&#34;column {i}&#34;) for i in range(len(headerTypes))
    )
    return dedent(
        f&#34;&#34;&#34;
        &lt;div class=&#34;dtheadrow&#34;&gt;
          &lt;span&gt;n&lt;/span&gt;&lt;span&gt;{headerMaterial}&lt;/span&gt;
        &lt;/div&gt;
        &#34;&#34;&#34;
    )</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.getLocalDir"><code class="name flex">
<span>def <span class="ident">getLocalDir</span></span>(<span>backend, cfg, local, version)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L170-L181" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getLocalDir(backend, cfg, local, version):
    provenanceSpec = cfg.get(&#34;provenanceSpec&#34;, {})
    org = provenanceSpec.get(&#34;org&#34;, None)
    repo = provenanceSpec.get(&#34;repo&#34;, None)
    relative = prefixSlash(provenanceSpec.get(&#34;relative&#34;, &#34;tf&#34;))
    version = provenanceSpec.get(&#34;version&#34;, None) if version is None else version
    base = hasData(backend, local, org, repo, version, relative)

    if not base:
        base = backendRep(backend, &#34;cache&#34;)

    return ex(f&#34;{base}/{org}/{repo}/{TEMP_DIR}&#34;)</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.getResultsX"><code class="name flex">
<span>def <span class="ident">getResultsX</span></span>(<span>app, results, features, condenseType, fmt=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Transform a uniform iterable of nodes into a table with extra information.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>results</code></strong> :&ensp;<code>iterable</code> of <code>tuple</code> of <code>int</code></dt>
<dd>A uniform <code><a title="tf.advanced.helpers.isUniform" href="#tf.advanced.helpers.isUniform">isUniform()</a></code> sequence of tuples of nodes</dd>
<dt><strong><code>features</code></strong> :&ensp;<code>key value pairs</code></dt>
<dd>features per index position of the tuples.
It specifies for some positions <code>i</code> which features for the nodes at that
position should be looked up. For each <code>i</code> it should be an iterable
or comma-separated list of feature names.</dd>
<dt><strong><code>condenseType</code></strong> :&ensp;<code>string</code></dt>
<dd>A node type. Types smaller or equal than this type will have their text
displayed in the result.</dd>
<dt><strong><code>fmt</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>A text format. If text has to be displayed, this format is used.
If not passed, a default is used.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L509-L590" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getResultsX(app, results, features, condenseType, fmt=None):
    &#34;&#34;&#34;Transform a uniform iterable of nodes into a table with extra information.

    Parameters
    ----------
    results: iterable of tuple of int
        A uniform `isUniform` sequence of tuples of nodes
    features: key value pairs
        features per index position of the tuples.
        It specifies for some positions `i` which features for the nodes at that
        position should be looked up. For each `i` it should be an iterable
        or comma-separated list of feature names.
    condenseType: string
        A node type. Types smaller or equal than this type will have their text
        displayed in the result.
    fmt: string, optional None
        A text format. If text has to be displayed, this format is used.
        If not passed, a default is used.
    &#34;&#34;&#34;

    api = app.api
    F = api.F
    Fs = api.Fs
    T = api.T
    N = api.N
    fOtype = F.otype.v
    otypeRank = N.otypeRank
    sectionTypeSet = T.sectionTypeSet

    aContext = app.context
    noDescendTypes = aContext.noDescendTypes

    sectionDepth = len(sectionTypeSet)
    if len(results) == 0:
        return ()
    firstResult = results[0]
    nTuple = len(firstResult)
    refColumns = [
        i for (i, n) in enumerate(firstResult) if fOtype(n) not in sectionTypeSet
    ]
    refColumn = refColumns[0] if refColumns else nTuple - 1
    header = [&#34;R&#34;] + [f&#34;S{i}&#34; for i in range(1, sectionDepth + 1)]
    emptyA = []

    featureDict = {i: tuple(f.split()) if type(f) is str else f for (i, f) in features}

    def withText(nodeType):
        return (
            condenseType is None
            and nodeType not in sectionTypeSet
            or otypeRank[nodeType] &lt;= otypeRank[condenseType]
        )

    noDescendTypes = noDescendTypes

    for j in range(nTuple):
        i = j + 1
        n = firstResult[j]
        nType = fOtype(n)
        header.extend([f&#34;NODE{i}&#34;, f&#34;TYPE{i}&#34;])
        if withText(nType):
            header.append(f&#34;TEXT{i}&#34;)
        header.extend(f&#34;{feature}{i}&#34; for feature in featureDict.get(j, emptyA))
    rows = [tuple(header)]
    for (rm, r) in enumerate(results):
        rn = rm + 1
        row = [rn]
        refN = r[refColumn]
        sparts = T.sectionFromNode(refN)
        nParts = len(sparts)
        section = sparts + ((None,) * (sectionDepth - nParts))
        row.extend(section)
        for j in range(nTuple):
            n = r[j]
            nType = fOtype(n)
            row.extend((n, nType))
            if withText(nType):
                text = T.text(n, fmt=fmt, descend=nType not in noDescendTypes)
                row.append(text)
            row.extend(Fs(feature).v(n) for feature in featureDict.get(j, emptyA))
        rows.append(tuple(row))
    return tuple(rows)</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.getRowsX"><code class="name flex">
<span>def <span class="ident">getRowsX</span></span>(<span>app, tuples, features, condenseType, fmt=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Transform an iterable of nodes into a table with extra information.</p>
<p>If the tuples are uniform (<code><a title="tf.advanced.helpers.isUniform" href="#tf.advanced.helpers.isUniform">isUniform()</a></code>), the formatting will
be richer then when the tuples are not uniform.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L495-L506" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getRowsX(app, tuples, features, condenseType, fmt=None):
    &#34;&#34;&#34;Transform an iterable of nodes into a table with extra information.

    If the tuples are uniform (`isUniform`), the formatting will
    be richer then when the tuples are not uniform.
    &#34;&#34;&#34;

    return (
        getResultsX(app, tuples, features, condenseType, fmt=fmt)
        if isUniform(app, tuples)
        else getTuplesX(app, tuples, condenseType, fmt=fmt)
    )</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.getText"><code class="name flex">
<span>def <span class="ident">getText</span></span>(<span>app, isPretty, n, nType, outer, first, last, level, passage, descend, options=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L326-L395" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getText(
    app, isPretty, n, nType, outer, first, last, level, passage, descend, options=None
):
    display = app.display
    dContext = display.distill(options or {})
    ltr = _getLtr(app, dContext) or &#34;ltr&#34;
    showMath = dContext.showMath
    T = app.api.T
    sectionTypeSet = T.sectionTypeSet
    structureTypeSet = T.structureTypeSet

    aContext = app.context
    templates = aContext.labels if isPretty else aContext.templates

    fmt = None if options is None else options.fmt
    withLabels = True if options is None else options.withLabels
    isHtml = False if options is None else options.isHtml
    suppress = set() if options is None else options.suppress

    (tpl, feats) = templates[nType]

    if not (tpl is True or withLabels):
        return &#34;&#34;

    # now there is a coarse fix for something in the Hermans corpus:
    # in plain display we add a space when we fill in a template.
    # But that leads to unwanted results.
    # The problem in the Hermans corpus can be solved in other ways.
    # We remove the fix again.

    # x = &#34;&#34; if isPretty else &#34; &#34;

    tplFilled = (
        (
            (
                f&#34;&#34;&#34;&lt;span class=&#34;tfsechead {ltr}&#34;&gt;&lt;span class=&#34;ltr&#34;&gt;&#34;&#34;&#34;
                + (NB if passage else app.sectionStrFromNode(n))
                + &#34;&lt;/span&gt;&lt;/span&gt;&#34;
            )
            if nType in sectionTypeSet
            else f&#39;&lt;span class=&#34;structure&#34;&gt;{app.structureStrFromNode(n)}&lt;/span&gt;&#39;
            if nType in structureTypeSet
            else htmlSafe(
                T.text(
                    n,
                    fmt=fmt,
                    descend=descend,
                    outer=outer,
                    first=first,
                    last=last,
                    level=level,
                ),
                isHtml,
                math=showMath,
            )
        )
        if tpl is True
        else (
            (
                tpl.format(
                    **{
                        feat: getValue(app, n, nType, feat, suppress, math=showMath)
                        for feat in feats
                    }
                )
                #  + x
            )
        )
    )
    return tplFilled</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.getTuplesX"><code class="name flex">
<span>def <span class="ident">getTuplesX</span></span>(<span>app, results, condenseType, fmt=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Transform a non-uniform iterable of nodes into a table with extra information.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>results</code></strong> :&ensp;<code>iterable</code> of <code>tuple</code> of <code>int</code></dt>
<dd>A uniform <code><a title="tf.advanced.helpers.isUniform" href="#tf.advanced.helpers.isUniform">isUniform()</a></code> sequence of tuples of nodes</dd>
<dt><strong><code>condenseType</code></strong> :&ensp;<code>string</code></dt>
<dd>A node type. Types smaller or equal than this type will have their text
displayed in the result.</dd>
<dt><strong><code>fmt</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>A text format. If text has to be displayed, this format is used.
If not passed, a default is used.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L593-L648" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getTuplesX(app, results, condenseType, fmt=None):
    &#34;&#34;&#34;Transform a non-uniform iterable of nodes into a table with extra information.

    Parameters
    ----------
    results: iterable of tuple of int
        A uniform `isUniform` sequence of tuples of nodes
    condenseType: string
        A node type. Types smaller or equal than this type will have their text
        displayed in the result.
    fmt: string, optional None
        A text format. If text has to be displayed, this format is used.
        If not passed, a default is used.
    &#34;&#34;&#34;

    api = app.api
    F = api.F
    T = api.T
    N = api.N
    fOtype = F.otype.v
    otypeRank = N.otypeRank
    sectionTypeSet = T.sectionTypeSet

    aContext = app.context
    noDescendTypes = aContext.noDescendTypes

    sectionDepth = len(sectionTypeSet)
    if len(results) == 0:
        return ()

    def withText(nodeType):
        return (
            condenseType is None
            and nodeType not in sectionTypeSet
            or otypeRank[nodeType] &lt;= otypeRank[condenseType]
        )

    noDescendTypes = noDescendTypes

    rows = []

    for (tm, tup) in enumerate(results):
        tn = tm + 1
        row = [tn]
        for n in tup:
            sparts = T.sectionFromNode(n)
            nParts = len(sparts)
            section = sparts + ((None,) * (sectionDepth - nParts))
            row.extend(section)
            nType = fOtype(n)
            row.extend((n, nType))
            if withText(nType):
                text = T.text(n, fmt=fmt, descend=nType not in noDescendTypes)
                row.append(text)
        rows.append(tuple(row))
    return tuple(rows)</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.getValue"><code class="name flex">
<span>def <span class="ident">getValue</span></span>(<span>app, n, nType, feat, suppress, math=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L398-L414" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def getValue(app, n, nType, feat, suppress, math=False):
    F = app.api.F
    Fs = app.api.Fs

    customMethods = app.customMethods
    transform = customMethods.transform

    if feat in suppress:
        val = &#34;&#34;
    else:
        featObj = Fs(feat) if hasattr(F, feat) else None
        val = htmlEsc(featObj.v(n), math=math) if featObj else None
        modifier = transform.get(nType, {}).get(feat, None)
        if modifier:
            val = modifier(n, val)
        val = val.replace(&#34;\n&#34;, &#34;\\n&#34;)
    return f&#39;&lt;span title=&#34;{feat}&#34;&gt;{val}&lt;/span&gt;&#39;</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.hData"><code class="name flex">
<span>def <span class="ident">hData</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L746-L764" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hData(x):
    if not x:
        return (True, hEmpty(x))
    tpv = type(x)
    if tpv is str or tpv is float or tpv is int or tpv is bool:
        return hScalar(x)
    if tpv is list or tpv is tuple or tpv is set or tpv is dict:
        return (
            (True, hEmpty(x))
            if len(x) == 0
            else hScalar0(x)
            if len(x) == 1
            else (False, hDict(x))
            if tpv is dict
            else (False, hList(x))
        )
    if tpv is dict:
        return (False, hDict(x))
    return hScalar(x)</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.hDict"><code class="name flex">
<span>def <span class="ident">hDict</span></span>(<span>x, outer=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L726-L743" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hDict(x, outer=False):
    elem = f&#34;{&#39;o&#39; if outer else &#39;u&#39;}l&#34;
    html = []
    html.append(f&#34;&lt;{elem}&gt;&#34;)

    for (k, v) in sorted(x.items(), key=lambda y: str(y)):
        (simple, vRep) = hData(v)

        if simple:
            html.append(f&#34;&#34;&#34;&lt;li&gt;&lt;b&gt;{k}&lt;/b&gt;: {vRep}&lt;/li&gt;&#34;&#34;&#34;)
        else:
            html.append(
                f&#34;&#34;&#34;&lt;li&gt;&lt;details&gt;&lt;summary&gt;&lt;b&gt;{k}&lt;/b&gt;:&lt;/summary&gt;{vRep}&lt;/details&gt;&lt;/li&gt;&#34;&#34;&#34;
            )

    html.append(f&#34;&lt;/{elem}&gt;&#34;)

    return &#34;&#34;.join(html)</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.hEmpty"><code class="name flex">
<span>def <span class="ident">hEmpty</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L651-L660" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hEmpty(x):
    return (
        &#34;&lt;i&gt;no value&lt;/i&gt;&#34;
        if x is None
        else &#34;&#34;&#34;&lt;code&gt;0&lt;/code&gt;&#34;&#34;&#34;
        if x == 0
        else &#34;&#34;&#34;&lt;code&gt;&#39;&#39;&lt;/code&gt;&#34;&#34;&#34;
        if x == &#34;&#34;
        else f&#34;&#34;&#34;&lt;code&gt;{str(x)}&lt;/code&gt;&#34;&#34;&#34;
    )</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.hList"><code class="name flex">
<span>def <span class="ident">hList</span></span>(<span>x, outer=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L708-L723" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hList(x, outer=False):
    elem = f&#34;{&#39;o&#39; if outer else &#39;u&#39;}l&#34;
    html = []
    html.append(f&#34;&lt;{elem}&gt;&#34;)

    for v in x:
        (simple, vRep) = hData(v)

        if simple:
            html.append(f&#34;&#34;&#34;&lt;li&gt;{vRep}&lt;/li&gt;&#34;&#34;&#34;)
        else:
            html.append(f&#34;&#34;&#34;&lt;li&gt;&lt;details&gt;&lt;summary&gt;:&lt;/summary&gt;{vRep}&lt;/details&gt;&lt;/li&gt;&#34;&#34;&#34;)

    html.append(f&#34;&lt;/{elem}&gt;&#34;)

    return &#34;&#34;.join(html)</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.hScalar"><code class="name flex">
<span>def <span class="ident">hScalar</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L663-L670" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hScalar(x):
    if type(x) is str:
        x = htmlEsc(x)
        if &#34;\n&#34; in x:
            x = x.replace(&#34;\n&#34;, &#34;&lt;br&gt;&#34;)

    xRep = f&#34;&lt;code&gt;{x}&lt;/code&gt;&#34;
    return (len(x) &lt; 60 if type(x) is str else True, xRep)</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.hScalar0"><code class="name flex">
<span>def <span class="ident">hScalar0</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L673-L705" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hScalar0(x):
    tpv = type(x)
    if tpv is dict:
        (k, v) = list(x.items())[0]
    else:
        v = list(x)[0]

    (simple, vRep) = hData(v)

    html = (
        (
            f&#34;{{&lt;b&gt;{k}&lt;/b&gt;: {vRep}}}&#34;
            if tpv is dict
            else f&#34;[{vRep}]&#34;
            if tpv is list
            else f&#34;({vRep})&#34;
            if tpv is tuple
            else f&#34;{{{vRep}}}&#34;
        )
        if simple
        else (
            f&#34;&#34;&#34;&lt;li&gt;&lt;details open&gt;
                &lt;summary&gt;&lt;b&gt;{k}&lt;/b&gt;:&lt;/summary&gt;
                {vRep}
                &lt;/details&gt;&lt;/li&gt;&#34;&#34;&#34;
            if tpv is dict
            else f&#34;&#34;&#34;&lt;li&gt;&lt;details open&gt;
                &lt;summary&gt;:&lt;/summary&gt;
                {vRep}
                &lt;/details&gt;&lt;/li&gt;&#34;&#34;&#34;
        )
    )
    return (simple, html)</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.hasData"><code class="name flex">
<span>def <span class="ident">hasData</span></span>(<span>backend, local, org, repo, version, relative)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L184-L196" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hasData(backend, local, org, repo, version, relative):
    versionRep = f&#34;/{version}&#34; if version else &#34;&#34;
    if local == &#34;clone&#34;:
        cloneBase = backendRep(backend, &#34;clone&#34;)
        ghTarget = f&#34;{cloneBase}/{org}/{repo}{relative}{versionRep}&#34;
        if dirExists(ghTarget):
            return cloneBase

    cacheBase = backendRep(backend, &#34;cache&#34;)
    cacheTarget = f&#34;{cacheBase}/{org}/{repo}{relative}{versionRep}&#34;
    if dirExists(cacheTarget):
        return cacheBase
    return False</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.htmlSafe"><code class="name flex">
<span>def <span class="ident">htmlSafe</span></span>(<span>text, isHtml, math=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L322-L323" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def htmlSafe(text, isHtml, math=False):
    return text.replace(&#34;\n&#34;, &#34;&lt;br&gt;&#34;) if isHtml else htmlEsc(text, math=math)</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.isUniform"><code class="name flex">
<span>def <span class="ident">isUniform</span></span>(<span>app, tuples)</span>
</code></dt>
<dd>
<div class="desc"><p>Whether the members of tuples are uniform.</p>
<p>An iterable of tuples of nodes is uniform, if each
tuple has the same number of nodes,
and if the type of a node at position <code>i</code> in the tuple
is the same for all tuples.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L463-L492" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isUniform(app, tuples):
    &#34;&#34;&#34;Whether the members of tuples are uniform.

    An iterable of tuples of nodes is uniform, if each
    tuple has the same number of nodes,
    and if the type of a node at position `i` in the tuple
    is the same for all tuples.
    &#34;&#34;&#34;
    api = app.api
    F = api.F
    fOtype = F.otype.v

    uniform = True
    fixedLength = None
    fixedTypes = None

    for tup in tuples:
        thisLength = len(tup)
        theseTypes = tuple(fOtype(n) for n in tup)

        if fixedLength is None:
            fixedLength = thisLength
        if fixedTypes is None:
            fixedTypes = theseTypes

        if thisLength != fixedLength or theseTypes != fixedTypes:
            uniform = False
            break

    return uniform</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.parseFeatures"><code class="name flex">
<span>def <span class="ident">parseFeatures</span></span>(<span>features)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L230-L246" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parseFeatures(features):
    if (
        type(features) in SEQ_TYPES1
        and len(features) == 2
        and type(features[0]) in SEQ_TYPES2
        and type(features[1]) is dict
    ):
        return features

    feats = (
        ()
        if not features
        else features.split()
        if type(features) is str
        else tuple(features)
    )
    return parseFeaturesLogical(feats)</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.parseFeaturesLogical"><code class="name flex">
<span>def <span class="ident">parseFeaturesLogical</span></span>(<span>feats)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L249-L261" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parseFeaturesLogical(feats):
    bare = []
    indirect = {}

    for feat in feats:
        if not feat:
            continue
        parts = feat.split(&#34;:&#34;, 1)
        feat = parts[-1]
        bare.append(feat)
        if len(parts) &gt; 1:
            indirect[feat] = parts[0]
    return (bare, indirect)</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.runsInNotebook"><code class="name flex">
<span>def <span class="ident">runsInNotebook</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Determines whether the program runs in an interactive shell.</p>
<p>From
<a href="https://stackoverflow.com/questions/15411967/how-can-i-check-if-code-is-executed-in-the-ipython-notebook/24937408">stackoverflow</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L30-L46" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def runsInNotebook():
    &#34;&#34;&#34;Determines whether the program runs in an interactive shell.

    From
    [stackoverflow](https://stackoverflow.com/questions/15411967/how-can-i-check-if-code-is-executed-in-the-ipython-notebook/24937408)
    &#34;&#34;&#34;
    try:
        runcontext = get_ipython()
        shell = runcontext.__class__.__name__
        if shell == &#34;ZMQInteractiveShell&#34;:
            return True  # Jupyter notebook or qtconsole
        elif shell == &#34;TerminalInteractiveShell&#34;:
            return False  # Terminal running IPython
        else:
            return False  # Other type (?)
    except NameError:
        return False  # Probably standard Python interpreter</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.showDict"><code class="name flex">
<span>def <span class="ident">showDict</span></span>(<span>title, data, _browse, inNb, *keys)</span>
</code></dt>
<dd>
<div class="desc"><p>Shows selected keys of a dictionary in a pretty way.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>_browse</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether we are in the TF browser.</dd>
<dt><strong><code>inNb</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether we run in a notebook.</dd>
<dt><strong><code>keys</code></strong> :&ensp;<code>iterable</code> of <code>string</code></dt>
<dd>For each key passed to this function, the information for that key
will be displayed. If no keys are passed, all keys will be displayed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>displayed HTML</code></dt>
<dd>An expandable list of the key-value pair for the requested keys.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L767-L795" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def showDict(title, data, _browse, inNb, *keys):
    &#34;&#34;&#34;Shows selected keys of a dictionary in a pretty way.

    Parameters
    ----------
    _browse: boolean
        Whether we are in the TF browser.
    inNb: boolean
        Whether we run in a notebook.
    keys: iterable of string
        For each key passed to this function, the information for that key
        will be displayed. If no keys are passed, all keys will be displayed.

    Returns
    -------
    displayed HTML
        An expandable list of the key-value pair for the requested keys.
    &#34;&#34;&#34;

    keys = set(keys)

    html = hDict({k: v for (k, v) in data.items() if not keys or k in keys}, outer=True)
    openRep = &#34;open&#34; if keys else &#34;&#34;
    html = f&#34;&lt;details {openRep}&gt;&lt;summary&gt;{title}&lt;/summary&gt;{html}&lt;/details&gt;&#34;

    if _browse:
        return html
    else:
        dh(html, inNb=inNb)</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.splitModRef"><code class="name flex">
<span>def <span class="ident">splitModRef</span></span>(<span>moduleRef)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L131-L164" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def splitModRef(moduleRef):
    thisBackend.clear()
    theBackend = None
    bareModuleRef = BACKEND_RE.sub(backendRepl, moduleRef)
    if len(thisBackend):
        theBackend = thisBackend[0]
        if len(thisBackend) &gt; 1:
            console(
                f&#34;Multiple &lt;backend&gt; in {moduleRef}: &#34;
                f&#34;{&#39;, &#39;.join(thisBackend)}; using &lt;{theBackend}&gt; only &#34;,
                error=True,
            )

    bRep = f&#34;&lt;{theBackend}&gt;&#34; if theBackend else &#34;&#34;

    parts = bareModuleRef.split(&#34;:&#34;, 1)
    if len(parts) == 1:
        parts.append(&#34;&#34;)
    (ref, specifier) = parts
    parts = ref.split(&#34;/&#34;, 2)

    if len(parts) &lt; 2:
        console(
            f&#34;&#34;&#34;
Module ref &#34;{bRep}{bareModuleRef}&#34; is not &#34;{{org}}/{{repo}}/{{path}}&#34;
&#34;&#34;&#34;,
            error=True,
        )
        return None

    if len(parts) == 2:
        parts.append(&#34;&#34;)

    return [*parts, specifier, theBackend]</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.transitiveClosure"><code class="name flex">
<span>def <span class="ident">transitiveClosure</span></span>(<span>relation, reflexiveExceptions)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce the reflexive transitive closure of a relation.</p>
<p>The transitive closure of a relation <code>R</code> is the relation <code>TR</code>
such that <code>a TR b</code> if and only if there is a chain of <code>c1</code>, <code>c2</code>, &hellip;, <code>cn</code>
such that <code>a Rc1</code>, <code>c1 R c2</code>, &hellip;, <code>cn R b</code>.</p>
<p>If we allow the chain to have length zero, we effectively have that
<code>a TR a</code> for all elements. That is the reflexive, transitive closure.</p>
<p>This function builds the latter, but we allow for exceptions to the
reflexivity.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>relation</code></strong> :&ensp;<code>dict</code></dt>
<dd>The input relation, keyed by elements, valued by the set of
elements that stand in relation to the key.</dd>
<dt><strong><code>reflexiveExceptions</code></strong> :&ensp;<code>set</code></dt>
<dd>The set of elements that will not be reflexively closed.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>The transitive reflexive closure (with possible exceptions to
the reflexivity) of the given relation.</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>We use this function to build the closure of the <code>childType</code> relation
between node types. We want to exclude the slot type from the
reflexivity. The closure of the <code>childType</code> relation is the descendant type
relation.
The display algorithm uses this to unravel nodes.</p>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="tf.advanced.display" href="display.html">tf.advanced.display</a></code></dt>
<dd>Display algorithm</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L264-L319" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def transitiveClosure(relation, reflexiveExceptions):
    &#34;&#34;&#34;Produce the reflexive transitive closure of a relation.

    The transitive closure of a relation `R` is the relation `TR`
    such that `a TR b` if and only if there is a chain of `c1`, `c2`, ..., `cn`
    such that `a Rc1`, `c1 R c2`, ..., `cn R b`.

    If we allow the chain to have length zero, we effectively have that
    `a TR a` for all elements. That is the reflexive, transitive closure.

    This function builds the latter, but we allow for exceptions to the
    reflexivity.

    Parameters
    ----------
    relation: dict
        The input relation, keyed by elements, valued by the set of
        elements that stand in relation to the key.
    reflexiveExceptions: set
        The set of elements that will not be reflexively closed.

    Returns
    -------
    dict
        The transitive reflexive closure (with possible exceptions to
        the reflexivity) of the given relation.

    Notes
    -----
    We use this function to build the closure of the `childType` relation
    between node types. We want to exclude the slot type from the
    reflexivity. The closure of the `childType` relation is the descendant type
    relation.
    The display algorithm uses this to unravel nodes.

    See also
    --------
    tf.advanced.display: Display algorithm
    &#34;&#34;&#34;

    descendants = {parent: set(children) for (parent, children) in relation.items()}

    changed = True
    while changed:
        changed = False
        for (parent, children) in relation.items():
            for child in children:
                if child in descendants:
                    for grandChild in descendants[child]:
                        if grandChild not in descendants[parent]:
                            descendants[parent].add(grandChild)
                            changed = True
    for parent in relation:
        if parent not in reflexiveExceptions:
            descendants[parent].add(parent)
    return descendants</code></pre>
</details>
</dd>
<dt id="tf.advanced.helpers.tupleEnum"><code class="name flex">
<span>def <span class="ident">tupleEnum</span></span>(<span>tuples, start, end, limit, item, inNb)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/d242901055fb9fd65dd9af8d50a1290309372cce/tf/advanced/helpers.py#L199-L227" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tupleEnum(tuples, start, end, limit, item, inNb):
    if start is None:
        start = 1
    i = -1
    if not hasattr(tuples, &#34;__len__&#34;):
        if end is None or end - start + 1 &gt; limit:
            end = start - 1 + limit
        for tup in tuples:
            i += 1
            if i &lt; start - 1:
                continue
            if i &gt;= end:
                break
            yield (i + 1, tup)
    else:
        if end is None or end &gt; len(tuples):
            end = len(tuples)
        rest = 0
        if end - (start - 1) &gt; limit:
            rest = end - (start - 1) - limit
            end = start - 1 + limit
        for i in range(start - 1, end):
            yield (i + 1, tuples[i])
        if rest:
            dh(
                f&#34;&lt;b&gt;{rest} more {item}s skipped&lt;/b&gt; because we show a maximum of&#34;
                f&#34; {limit} {item}s at a time&#34;,
                inNb=inNb,
            )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder=" Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.advanced" href="index.html">tf.advanced</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tf.advanced.helpers.backendRepl" href="#tf.advanced.helpers.backendRepl">backendRepl</a></code></li>
<li><code><a title="tf.advanced.helpers.dh" href="#tf.advanced.helpers.dh">dh</a></code></li>
<li><code><a title="tf.advanced.helpers.dm" href="#tf.advanced.helpers.dm">dm</a></code></li>
<li><code><a title="tf.advanced.helpers.getHeaderTypes" href="#tf.advanced.helpers.getHeaderTypes">getHeaderTypes</a></code></li>
<li><code><a title="tf.advanced.helpers.getHeaders" href="#tf.advanced.helpers.getHeaders">getHeaders</a></code></li>
<li><code><a title="tf.advanced.helpers.getLocalDir" href="#tf.advanced.helpers.getLocalDir">getLocalDir</a></code></li>
<li><code><a title="tf.advanced.helpers.getResultsX" href="#tf.advanced.helpers.getResultsX">getResultsX</a></code></li>
<li><code><a title="tf.advanced.helpers.getRowsX" href="#tf.advanced.helpers.getRowsX">getRowsX</a></code></li>
<li><code><a title="tf.advanced.helpers.getText" href="#tf.advanced.helpers.getText">getText</a></code></li>
<li><code><a title="tf.advanced.helpers.getTuplesX" href="#tf.advanced.helpers.getTuplesX">getTuplesX</a></code></li>
<li><code><a title="tf.advanced.helpers.getValue" href="#tf.advanced.helpers.getValue">getValue</a></code></li>
<li><code><a title="tf.advanced.helpers.hData" href="#tf.advanced.helpers.hData">hData</a></code></li>
<li><code><a title="tf.advanced.helpers.hDict" href="#tf.advanced.helpers.hDict">hDict</a></code></li>
<li><code><a title="tf.advanced.helpers.hEmpty" href="#tf.advanced.helpers.hEmpty">hEmpty</a></code></li>
<li><code><a title="tf.advanced.helpers.hList" href="#tf.advanced.helpers.hList">hList</a></code></li>
<li><code><a title="tf.advanced.helpers.hScalar" href="#tf.advanced.helpers.hScalar">hScalar</a></code></li>
<li><code><a title="tf.advanced.helpers.hScalar0" href="#tf.advanced.helpers.hScalar0">hScalar0</a></code></li>
<li><code><a title="tf.advanced.helpers.hasData" href="#tf.advanced.helpers.hasData">hasData</a></code></li>
<li><code><a title="tf.advanced.helpers.htmlSafe" href="#tf.advanced.helpers.htmlSafe">htmlSafe</a></code></li>
<li><code><a title="tf.advanced.helpers.isUniform" href="#tf.advanced.helpers.isUniform">isUniform</a></code></li>
<li><code><a title="tf.advanced.helpers.parseFeatures" href="#tf.advanced.helpers.parseFeatures">parseFeatures</a></code></li>
<li><code><a title="tf.advanced.helpers.parseFeaturesLogical" href="#tf.advanced.helpers.parseFeaturesLogical">parseFeaturesLogical</a></code></li>
<li><code><a title="tf.advanced.helpers.runsInNotebook" href="#tf.advanced.helpers.runsInNotebook">runsInNotebook</a></code></li>
<li><code><a title="tf.advanced.helpers.showDict" href="#tf.advanced.helpers.showDict">showDict</a></code></li>
<li><code><a title="tf.advanced.helpers.splitModRef" href="#tf.advanced.helpers.splitModRef">splitModRef</a></code></li>
<li><code><a title="tf.advanced.helpers.transitiveClosure" href="#tf.advanced.helpers.transitiveClosure">transitiveClosure</a></code></li>
<li><code><a title="tf.advanced.helpers.tupleEnum" href="#tf.advanced.helpers.tupleEnum">tupleEnum</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>