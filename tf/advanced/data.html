<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>tf.advanced.data API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.advanced.data</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.advanced.data.getModulesData"><code class="name flex">
<span>def <span class="ident">getModulesData</span></span>(<span>*args, dest=None, source=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4b9dcc7b03d4874f519835911e678912bd615207/tf/advanced/data.py#L483-L499" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def getModulesData(*args, dest=None, source=None):
    &#34;&#34;&#34;Retrieve all data for a corpus.

    Parameters
    ----------
    args: list
        All parameters needed to retrieve all associated data.
        They are the same as are needed to construct an `AppData` object.
    &#34;&#34;&#34;

    mData = AppData(*args, dest=dest, source=source)
    mData.getModules()

    if not mData.good or mData.locations is None:
        return None

    return (mData.locations, mData.modules)</code></pre>
</details>
<div class="desc"><p>Retrieve all data for a corpus.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>args</code></strong> :&ensp;<code>list</code></dt>
<dd>All parameters needed to retrieve all associated data.
They are the same as are needed to construct an <code><a title="tf.advanced.data.AppData" href="#tf.advanced.data.AppData">AppData</a></code> object.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.advanced.data.AppData"><code class="flex name class">
<span>class <span class="ident">AppData</span></span>
<span>(</span><span>app,<br>backend,<br>moduleRefs,<br>bare,<br>locations,<br>modules,<br>version,<br>checkout,<br>silent,<br>dest=None,<br>source=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4b9dcc7b03d4874f519835911e678912bd615207/tf/advanced/data.py#L11-L480" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class AppData:
    def __init__(
        self,
        app,
        backend,
        moduleRefs,
        bare,
        locations,
        modules,
        version,
        checkout,
        silent,
        dest=None,
        source=None,
    ):
        &#34;&#34;&#34;Collects TF data according to specifications.

        The specifications are passed as arguments when the object is initialized.

        Parameters
        ----------
        backend: string
            `github` or `gitlab` or a GitLab instance such as `gitlab.huc.knaw.nl`.
        app: obj
            The high-level API object
        moduleRefs: tuple
            Each member consists of a module ref, which is a tuple of information
            that defines a module.
        bare: whether to load the standard modules
            If False, only modules explicitly given in moduleRefs are loaded.
            Standard modules will only be loaded if they are explicitly passed by
            moduleRefs.
            If True, standatd modules will always be loaded.
        locations: string|tuple
            One or more directory paths. They will be combined with the `modules`
            argument and used as locations to search for TF data files.
        modules: string|tuple
            One or more directory path segments. They will be appended to the
            paths given by the `locations` argument to form search locations
            for TF data files.
        version: string
            The version of TF data that should be retrieved. Version is a directory
            level just below the search locations.
        checkout: string
            A specifier to use a specific release or commit of a data repository.
        silent: string, optional tf.core.timestamp.SILENT_D
            See `tf.core.timestamp.Timestamp`
        dest: string, optional None
            The location where the text-fabric-data cache is.
        source: string, optional None
            The base of your local repository clones.

        &#34;&#34;&#34;
        self.backend = backend
        self.app = app
        self.moduleRefs = (
            []
            if moduleRefs is None
            else moduleRefs.split(&#34;,&#34;)
            if type(moduleRefs) is str
            else list(moduleRefs)
        )
        self.bare = bare
        self.locationsArg = locations
        self.modulesArg = modules
        self.version = version
        self.checkout = checkout
        self.dest = dest
        self.source = source
        self.silent = silent

    def getMain(self):
        &#34;&#34;&#34;Get the main data of the corpus.

        This is specified by the `org`, `repo` and `relative` settings under
        `provenanceSpec` in `config.yaml`.

        See Also
        --------
        tf.advanced.settings: options allowed in `config.yaml`
        &#34;&#34;&#34;

        app = self.app
        source = self.source
        checkout = self.checkout
        aContext = app.context
        org = aContext.org
        repo = aContext.repo
        relative = prefixSlash(aContext.relative)
        appPath = aContext.appPath
        appName = aContext.appName

        if appName.startswith(&#34;app:&#34;):
            appParent = appPath.rsplit(&#34;/&#34;, 1)[0]
            relative = f&#34;{appParent}{relative}&#34;
        elif org is None or repo is None:
            appPathRep = f&#34;{appPath}/&#34; if appPath else &#34;&#34;
            appParent = None
            relative = f&#34;{appPathRep}{appName}&#34;
            self.checkout = &#34;local&#34;
        else:
            appParent = None

        if not self.getModule(
            org,
            repo,
            prefixSlash(relative),
            checkout,
            isBase=True,
            appParent=appParent,
            versionOverride=app.versionOverride,
            allowExpress=True,
            source=source,
        ):
            self.good = False

    def getStandard(self):
        &#34;&#34;&#34;Get the data of the standard modules specified by the settings of the corpus.

        These are specified in the `moduleSpecs` setting under
        `provenanceSpecs` in `config.yaml`.

        They will be loaded *after* the extra modules specified in the `mod`
        parameter, and only in as far they have not been specified in the
        `mod` parameter. In this way you can pass overriding
        checkout specifiers to the standard modules.

        See Also
        --------
        tf.advanced.settings: options allowed in `config.yaml`
        &#34;&#34;&#34;

        bare = self.bare

        if not bare:
            return

        app = self.app
        source = self.source
        loadData = app.loadData

        if not loadData or loadData == &#34;core&#34;:
            return

        aContext = app.context
        moduleSpecs = aContext.moduleSpecs
        seen = self.seen
        checkout = self.checkout
        backend = self.backend

        for m in moduleSpecs or []:
            org = m[&#34;org&#34;]
            repo = m[&#34;repo&#34;]
            relative = m[&#34;relative&#34;]
            theCheckout = m.get(&#34;checkout&#34;, checkout)
            theBackend = m.get(&#34;backend&#34;, backend)
            bRep = backendRep(theBackend, &#34;spec&#34;, default=backend)

            ref = f&#34;{bRep}{org}/{repo}{relative}&#34;
            if ref in seen:
                continue

            if not self.getModule(
                org,
                repo,
                relative,
                theCheckout,
                backend=theBackend,
                specs=m,
                versionOverride=app.versionOverride,
                allowExpress=True,
                source=source,
            ):
                self.good = False

    def getExtra(self):
        &#34;&#34;&#34;Get the extra data specified by the settings of the corpus.

        These are specified in the `extraData` setting under
        `provenanceSpecs` in `config.yaml`.

        This data will be downloaded if needed, but it will not be loaded.
        It probably is not even TF data.

        See Also
        --------
        tf.advanced.settings: options allowed in `config.yaml`
        &#34;&#34;&#34;

        bare = self.bare

        if not bare:
            return

        app = self.app
        source = self.source
        loadData = app.loadData

        if not loadData or loadData == &#34;core&#34;:
            return

        aContext = app.context
        extraData = aContext.extraData

        if not extraData:
            return

        checkout = self.checkout
        backend = self.backend

        org = aContext.org
        repo = aContext.repo
        relative = extraData

        if not self.getModule(
            org,
            repo,
            relative,
            checkout,
            backend=backend,
            isExtra=True,
            versionOverride=app.versionOverride,
            allowExpress=True,
            source=source,
        ):
            self.good = False

    def getRefs(self):
        &#34;&#34;&#34;Get data from additional modules.

        These are specified in the `moduleRefs` parameter of `AppData`.
        We store the set of special modules in order to skip them
        later when we are loading the standard modules.
        &#34;&#34;&#34;

        app = self.app
        source = self.source
        backend = self.backend
        refs = self.moduleRefs

        for ref in refs:
            refPure = ref.rsplit(&#34;:&#34;, 1)[0]
            if refPure in self.seen:
                continue

            parts = splitModRef(ref)
            if not parts:
                self.good = False
                continue

            parts[2] = prefixSlash(normpath(parts[2]))  # the relative bit
            theBackend = (
                None if parts[-1] is None or parts[-1] == backend else parts[-1]
            )

            if not self.getModule(
                *parts[0:-1],
                backend=theBackend,
                versionOverride=app.versionOverride,
                allowExpress=False,
                source=source,
            ):
                self.good = False

    def getModules(self):
        &#34;&#34;&#34;Get data from additional local directories.

        These are specified in the `locations` and `modules` parameters of `AppData`.
        &#34;&#34;&#34;

        self.provenance = []
        provenance = self.provenance
        self.mLocations = []
        mLocations = self.mLocations

        self.locations = None
        self.modules = None

        self.good = True
        self.seen = set()

        self.getMain()
        self.getRefs()
        self.getStandard()
        self.getExtra()

        version = self.version
        good = self.good
        app = self.app

        if good:
            app.mLocations = mLocations
            app.provenance = provenance
        else:
            return

        mModules = []
        if mLocations:
            mModules.append(version or &#34;&#34;)

        locations = self.locationsArg
        modules = self.modulesArg

        givenLocations = (
            []
            if locations is None
            else [expandDir(app, x.strip()) for x in itemize(locations, &#34;\n&#34;)]
            if type(locations) is str
            else [str(x) for x in locations]
        )
        givenModules = (
            []
            if modules is None
            else [normpath(x.strip()) for x in itemize(modules, &#34;\n&#34;)]
            if type(modules) is str
            else [normpath(str(x)) for x in modules]
        )

        self.locations = mLocations + givenLocations
        self.modules = mModules + givenModules

    def getModule(
        self,
        org,
        repo,
        relative,
        checkout,
        backend=None,
        isBase=False,
        appParent=None,
        isExtra=False,
        specs=None,
        versionOverride=False,
        allowExpress=True,
        source=None,
    ):
        &#34;&#34;&#34;Prepare to load a single module.

        Eventually, all TF data will be downloaded from local directories, bases
        on a list of location paths and module paths.

        This function computes the contribution of a single module to both the
        location paths and the module paths.

        Parameters
        ----------
        org: string
            GitHub organization or GitLab group of the module
        repo: string:
            GitHub repository or GitLab project of the module
        relative: string
            Path within the repository of the module
        checkout: string
            A specifier to use a specific release or commit of a data repository.
        backend: string
            The back-end if different from the back-end of the main module
        isExtra: boolean, optional False
            If this is True, we are dealing with extra (non-TF) data.
            The data must be obtained, but not loaded.
        isBase: boolean, optional False
            Whether this module is the main data of the corpus.
        appParent: string, optional None
            Only relevant if `isBase` is `True`. Normally, the repoLocation attribute
            of the app will be set to the `relative` of the main module.
            But if the app has been specified with `app:`, the repoLocation is
            slightly different, and it will be taken from this parameter.
        specs: dict, optional False
            Additional informational attributes of the module, e.g. a DOI
        versionOverride: boolean, optional False
            Whether we ask for the data of a non-standard version
        allowExpress: boolean, optional True
            Whether express downloading of the whole corpus may be triggered
        source: string, optional None
            The base of your local repository clones.
        &#34;&#34;&#34;

        backend = self.backend if backend is None else backendRep(backend, &#34;norm&#34;)
        bRep = backendRep(backend, &#34;spec&#34;, default=self.backend)
        dest = self.dest
        version = self.version
        silent = self.silent
        mLocations = self.mLocations
        provenance = self.provenance
        seen = self.seen
        app = self.app
        _browse = app._browse
        aContext = app.context
        branch = aContext.provenanceSpec[&#34;branch&#34;]

        relative = prefixSlash(normpath(relative))

        moduleRef = f&#34;{bRep}{org}/{repo}{relative}&#34;

        if moduleRef in self.seen:
            return True

        if org is None or repo is None:
            relativeBare = relative if isBase else relative.removeprefix(&#34;/&#34;)
            repoLocation = relativeBare
            if not isExtra:
                mLocations.append(relativeBare)
            (commit, local, release) = (None, None, None)
        else:
            (commit, release, local, localBase, localDir) = checkoutRepo(
                backend,
                _browse=_browse,
                org=org,
                repo=repo,
                folder=relative,
                version=None if isExtra else version,
                versionOverride=versionOverride,
                checkout=checkout,
                dest=dest,
                withPaths=True if isExtra else False,
                keep=True if isExtra else False,
                silent=silent,
                allowExpress=allowExpress,
                source=source,
            )
            if not localBase:
                return False

            repoLocation = f&#34;{localBase}/{org}/{repo}&#34;
            if not isExtra:
                mLocations.append(f&#34;{localBase}/{localDir}&#34;)

        seen.add(moduleRef)
        if isBase:
            app.repoLocation = repoLocation if appParent is None else appParent

        if isExtra:
            return True

        info = {}
        for item in (
            (&#34;doi&#34;, None),
            (&#34;corpus&#34;, f&#34;{org}/{repo}{relative}&#34;),
        ):
            (key, default) = item
            info[key] = (
                getattr(aContext, key)
                if isBase
                else specs[key]
                if specs and key in specs
                else default
            )
        provenance.append(
            (
                (&#34;corpus&#34;, info[&#34;corpus&#34;]),
                (&#34;version&#34;, version),
                (&#34;commit&#34;, commit or &#34;??&#34;),
                (&#34;release&#34;, release or &#34;none&#34;),
                (
                    &#34;live&#34;,
                    provenanceLink(
                        backend,
                        org,
                        repo,
                        version,
                        branch,
                        commit,
                        local,
                        release,
                        relative,
                    ),
                ),
                (&#34;doi&#34;, info[&#34;doi&#34;]),
            )
        )
        return True</code></pre>
</details>
<div class="desc"><p>Collects TF data according to specifications.</p>
<p>The specifications are passed as arguments when the object is initialized.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>backend</code></strong> :&ensp;<code>string</code></dt>
<dd><code>github</code> or <code>gitlab</code> or a GitLab instance such as <code>gitlab.huc.knaw.nl</code>.</dd>
<dt><strong><code>app</code></strong> :&ensp;<code>obj</code></dt>
<dd>The high-level API object</dd>
<dt><strong><code>moduleRefs</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Each member consists of a module ref, which is a tuple of information
that defines a module.</dd>
<dt><strong><code>bare</code></strong> :&ensp;<code>whether to load the standard modules</code></dt>
<dd>If False, only modules explicitly given in moduleRefs are loaded.
Standard modules will only be loaded if they are explicitly passed by
moduleRefs.
If True, standatd modules will always be loaded.</dd>
<dt><strong><code>locations</code></strong> :&ensp;<code>string|tuple</code></dt>
<dd>One or more directory paths. They will be combined with the <code>modules</code>
argument and used as locations to search for TF data files.</dd>
<dt><strong><code>modules</code></strong> :&ensp;<code>string|tuple</code></dt>
<dd>One or more directory path segments. They will be appended to the
paths given by the <code>locations</code> argument to form search locations
for TF data files.</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>string</code></dt>
<dd>The version of TF data that should be retrieved. Version is a directory
level just below the search locations.</dd>
<dt><strong><code>checkout</code></strong> :&ensp;<code>string</code></dt>
<dd>A specifier to use a specific release or commit of a data repository.</dd>
<dt><strong><code>silent</code></strong> :&ensp;<code>string</code>, optional <code><a title="tf.core.timestamp.SILENT_D" href="../core/timestamp.html#tf.core.timestamp.SILENT_D">SILENT_D</a></code></dt>
<dd>See <code><a title="tf.core.timestamp.Timestamp" href="../core/timestamp.html#tf.core.timestamp.Timestamp">Timestamp</a></code></dd>
<dt><strong><code>dest</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>The location where the text-fabric-data cache is.</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>The base of your local repository clones.</dd>
</dl></div>
<h3>Methods</h3>
<dl>
<dt id="tf.advanced.data.AppData.getExtra"><code class="name flex">
<span>def <span class="ident">getExtra</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4b9dcc7b03d4874f519835911e678912bd615207/tf/advanced/data.py#L186-L236" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def getExtra(self):
    &#34;&#34;&#34;Get the extra data specified by the settings of the corpus.

    These are specified in the `extraData` setting under
    `provenanceSpecs` in `config.yaml`.

    This data will be downloaded if needed, but it will not be loaded.
    It probably is not even TF data.

    See Also
    --------
    tf.advanced.settings: options allowed in `config.yaml`
    &#34;&#34;&#34;

    bare = self.bare

    if not bare:
        return

    app = self.app
    source = self.source
    loadData = app.loadData

    if not loadData or loadData == &#34;core&#34;:
        return

    aContext = app.context
    extraData = aContext.extraData

    if not extraData:
        return

    checkout = self.checkout
    backend = self.backend

    org = aContext.org
    repo = aContext.repo
    relative = extraData

    if not self.getModule(
        org,
        repo,
        relative,
        checkout,
        backend=backend,
        isExtra=True,
        versionOverride=app.versionOverride,
        allowExpress=True,
        source=source,
    ):
        self.good = False</code></pre>
</details>
<div class="desc"><p>Get the extra data specified by the settings of the corpus.</p>
<p>These are specified in the <code>extraData</code> setting under
<code>provenanceSpecs</code> in <code>config.yaml</code>.</p>
<p>This data will be downloaded if needed, but it will not be loaded.
It probably is not even TF data.</p>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="tf.advanced.settings" href="settings.html">tf.advanced.settings</a></code></dt>
<dd>options allowed in <code>config.yaml</code></dd>
</dl></div>
</dd>
<dt id="tf.advanced.data.AppData.getMain"><code class="name flex">
<span>def <span class="ident">getMain</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4b9dcc7b03d4874f519835911e678912bd615207/tf/advanced/data.py#L82-L125" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def getMain(self):
    &#34;&#34;&#34;Get the main data of the corpus.

    This is specified by the `org`, `repo` and `relative` settings under
    `provenanceSpec` in `config.yaml`.

    See Also
    --------
    tf.advanced.settings: options allowed in `config.yaml`
    &#34;&#34;&#34;

    app = self.app
    source = self.source
    checkout = self.checkout
    aContext = app.context
    org = aContext.org
    repo = aContext.repo
    relative = prefixSlash(aContext.relative)
    appPath = aContext.appPath
    appName = aContext.appName

    if appName.startswith(&#34;app:&#34;):
        appParent = appPath.rsplit(&#34;/&#34;, 1)[0]
        relative = f&#34;{appParent}{relative}&#34;
    elif org is None or repo is None:
        appPathRep = f&#34;{appPath}/&#34; if appPath else &#34;&#34;
        appParent = None
        relative = f&#34;{appPathRep}{appName}&#34;
        self.checkout = &#34;local&#34;
    else:
        appParent = None

    if not self.getModule(
        org,
        repo,
        prefixSlash(relative),
        checkout,
        isBase=True,
        appParent=appParent,
        versionOverride=app.versionOverride,
        allowExpress=True,
        source=source,
    ):
        self.good = False</code></pre>
</details>
<div class="desc"><p>Get the main data of the corpus.</p>
<p>This is specified by the <code>org</code>, <code>repo</code> and <code>relative</code> settings under
<code>provenanceSpec</code> in <code>config.yaml</code>.</p>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="tf.advanced.settings" href="settings.html">tf.advanced.settings</a></code></dt>
<dd>options allowed in <code>config.yaml</code></dd>
</dl></div>
</dd>
<dt id="tf.advanced.data.AppData.getModule"><code class="name flex">
<span>def <span class="ident">getModule</span></span>(<span>self,<br>org,<br>repo,<br>relative,<br>checkout,<br>backend=None,<br>isBase=False,<br>appParent=None,<br>isExtra=False,<br>specs=None,<br>versionOverride=False,<br>allowExpress=True,<br>source=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4b9dcc7b03d4874f519835911e678912bd615207/tf/advanced/data.py#L332-L480" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def getModule(
    self,
    org,
    repo,
    relative,
    checkout,
    backend=None,
    isBase=False,
    appParent=None,
    isExtra=False,
    specs=None,
    versionOverride=False,
    allowExpress=True,
    source=None,
):
    &#34;&#34;&#34;Prepare to load a single module.

    Eventually, all TF data will be downloaded from local directories, bases
    on a list of location paths and module paths.

    This function computes the contribution of a single module to both the
    location paths and the module paths.

    Parameters
    ----------
    org: string
        GitHub organization or GitLab group of the module
    repo: string:
        GitHub repository or GitLab project of the module
    relative: string
        Path within the repository of the module
    checkout: string
        A specifier to use a specific release or commit of a data repository.
    backend: string
        The back-end if different from the back-end of the main module
    isExtra: boolean, optional False
        If this is True, we are dealing with extra (non-TF) data.
        The data must be obtained, but not loaded.
    isBase: boolean, optional False
        Whether this module is the main data of the corpus.
    appParent: string, optional None
        Only relevant if `isBase` is `True`. Normally, the repoLocation attribute
        of the app will be set to the `relative` of the main module.
        But if the app has been specified with `app:`, the repoLocation is
        slightly different, and it will be taken from this parameter.
    specs: dict, optional False
        Additional informational attributes of the module, e.g. a DOI
    versionOverride: boolean, optional False
        Whether we ask for the data of a non-standard version
    allowExpress: boolean, optional True
        Whether express downloading of the whole corpus may be triggered
    source: string, optional None
        The base of your local repository clones.
    &#34;&#34;&#34;

    backend = self.backend if backend is None else backendRep(backend, &#34;norm&#34;)
    bRep = backendRep(backend, &#34;spec&#34;, default=self.backend)
    dest = self.dest
    version = self.version
    silent = self.silent
    mLocations = self.mLocations
    provenance = self.provenance
    seen = self.seen
    app = self.app
    _browse = app._browse
    aContext = app.context
    branch = aContext.provenanceSpec[&#34;branch&#34;]

    relative = prefixSlash(normpath(relative))

    moduleRef = f&#34;{bRep}{org}/{repo}{relative}&#34;

    if moduleRef in self.seen:
        return True

    if org is None or repo is None:
        relativeBare = relative if isBase else relative.removeprefix(&#34;/&#34;)
        repoLocation = relativeBare
        if not isExtra:
            mLocations.append(relativeBare)
        (commit, local, release) = (None, None, None)
    else:
        (commit, release, local, localBase, localDir) = checkoutRepo(
            backend,
            _browse=_browse,
            org=org,
            repo=repo,
            folder=relative,
            version=None if isExtra else version,
            versionOverride=versionOverride,
            checkout=checkout,
            dest=dest,
            withPaths=True if isExtra else False,
            keep=True if isExtra else False,
            silent=silent,
            allowExpress=allowExpress,
            source=source,
        )
        if not localBase:
            return False

        repoLocation = f&#34;{localBase}/{org}/{repo}&#34;
        if not isExtra:
            mLocations.append(f&#34;{localBase}/{localDir}&#34;)

    seen.add(moduleRef)
    if isBase:
        app.repoLocation = repoLocation if appParent is None else appParent

    if isExtra:
        return True

    info = {}
    for item in (
        (&#34;doi&#34;, None),
        (&#34;corpus&#34;, f&#34;{org}/{repo}{relative}&#34;),
    ):
        (key, default) = item
        info[key] = (
            getattr(aContext, key)
            if isBase
            else specs[key]
            if specs and key in specs
            else default
        )
    provenance.append(
        (
            (&#34;corpus&#34;, info[&#34;corpus&#34;]),
            (&#34;version&#34;, version),
            (&#34;commit&#34;, commit or &#34;??&#34;),
            (&#34;release&#34;, release or &#34;none&#34;),
            (
                &#34;live&#34;,
                provenanceLink(
                    backend,
                    org,
                    repo,
                    version,
                    branch,
                    commit,
                    local,
                    release,
                    relative,
                ),
            ),
            (&#34;doi&#34;, info[&#34;doi&#34;]),
        )
    )
    return True</code></pre>
</details>
<div class="desc"><p>Prepare to load a single module.</p>
<p>Eventually, all TF data will be downloaded from local directories, bases
on a list of location paths and module paths.</p>
<p>This function computes the contribution of a single module to both the
location paths and the module paths.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>org</code></strong> :&ensp;<code>string</code></dt>
<dd>GitHub organization or GitLab group of the module</dd>
<dt><strong><code>repo</code></strong> :&ensp;<code>string:</code></dt>
<dd>GitHub repository or GitLab project of the module</dd>
<dt><strong><code>relative</code></strong> :&ensp;<code>string</code></dt>
<dd>Path within the repository of the module</dd>
<dt><strong><code>checkout</code></strong> :&ensp;<code>string</code></dt>
<dd>A specifier to use a specific release or commit of a data repository.</dd>
<dt><strong><code>backend</code></strong> :&ensp;<code>string</code></dt>
<dd>The back-end if different from the back-end of the main module</dd>
<dt><strong><code>isExtra</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If this is True, we are dealing with extra (non-TF) data.
The data must be obtained, but not loaded.</dd>
<dt><strong><code>isBase</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether this module is the main data of the corpus.</dd>
<dt><strong><code>appParent</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>Only relevant if <code>isBase</code> is <code>True</code>. Normally, the repoLocation attribute
of the app will be set to the <code>relative</code> of the main module.
But if the app has been specified with <code>app:</code>, the repoLocation is
slightly different, and it will be taken from this parameter.</dd>
<dt><strong><code>specs</code></strong> :&ensp;<code>dict</code>, optional <code>False</code></dt>
<dd>Additional informational attributes of the module, e.g. a DOI</dd>
<dt><strong><code>versionOverride</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether we ask for the data of a non-standard version</dd>
<dt><strong><code>allowExpress</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>Whether express downloading of the whole corpus may be triggered</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>The base of your local repository clones.</dd>
</dl></div>
</dd>
<dt id="tf.advanced.data.AppData.getModules"><code class="name flex">
<span>def <span class="ident">getModules</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4b9dcc7b03d4874f519835911e678912bd615207/tf/advanced/data.py#L275-L330" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def getModules(self):
    &#34;&#34;&#34;Get data from additional local directories.

    These are specified in the `locations` and `modules` parameters of `AppData`.
    &#34;&#34;&#34;

    self.provenance = []
    provenance = self.provenance
    self.mLocations = []
    mLocations = self.mLocations

    self.locations = None
    self.modules = None

    self.good = True
    self.seen = set()

    self.getMain()
    self.getRefs()
    self.getStandard()
    self.getExtra()

    version = self.version
    good = self.good
    app = self.app

    if good:
        app.mLocations = mLocations
        app.provenance = provenance
    else:
        return

    mModules = []
    if mLocations:
        mModules.append(version or &#34;&#34;)

    locations = self.locationsArg
    modules = self.modulesArg

    givenLocations = (
        []
        if locations is None
        else [expandDir(app, x.strip()) for x in itemize(locations, &#34;\n&#34;)]
        if type(locations) is str
        else [str(x) for x in locations]
    )
    givenModules = (
        []
        if modules is None
        else [normpath(x.strip()) for x in itemize(modules, &#34;\n&#34;)]
        if type(modules) is str
        else [normpath(str(x)) for x in modules]
    )

    self.locations = mLocations + givenLocations
    self.modules = mModules + givenModules</code></pre>
</details>
<div class="desc"><p>Get data from additional local directories.</p>
<p>These are specified in the <code>locations</code> and <code>modules</code> parameters of <code><a title="tf.advanced.data.AppData" href="#tf.advanced.data.AppData">AppData</a></code>.</p></div>
</dd>
<dt id="tf.advanced.data.AppData.getRefs"><code class="name flex">
<span>def <span class="ident">getRefs</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4b9dcc7b03d4874f519835911e678912bd615207/tf/advanced/data.py#L238-L273" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def getRefs(self):
    &#34;&#34;&#34;Get data from additional modules.

    These are specified in the `moduleRefs` parameter of `AppData`.
    We store the set of special modules in order to skip them
    later when we are loading the standard modules.
    &#34;&#34;&#34;

    app = self.app
    source = self.source
    backend = self.backend
    refs = self.moduleRefs

    for ref in refs:
        refPure = ref.rsplit(&#34;:&#34;, 1)[0]
        if refPure in self.seen:
            continue

        parts = splitModRef(ref)
        if not parts:
            self.good = False
            continue

        parts[2] = prefixSlash(normpath(parts[2]))  # the relative bit
        theBackend = (
            None if parts[-1] is None or parts[-1] == backend else parts[-1]
        )

        if not self.getModule(
            *parts[0:-1],
            backend=theBackend,
            versionOverride=app.versionOverride,
            allowExpress=False,
            source=source,
        ):
            self.good = False</code></pre>
</details>
<div class="desc"><p>Get data from additional modules.</p>
<p>These are specified in the <code>moduleRefs</code> parameter of <code><a title="tf.advanced.data.AppData" href="#tf.advanced.data.AppData">AppData</a></code>.
We store the set of special modules in order to skip them
later when we are loading the standard modules.</p></div>
</dd>
<dt id="tf.advanced.data.AppData.getStandard"><code class="name flex">
<span>def <span class="ident">getStandard</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/4b9dcc7b03d4874f519835911e678912bd615207/tf/advanced/data.py#L127-L184" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def getStandard(self):
    &#34;&#34;&#34;Get the data of the standard modules specified by the settings of the corpus.

    These are specified in the `moduleSpecs` setting under
    `provenanceSpecs` in `config.yaml`.

    They will be loaded *after* the extra modules specified in the `mod`
    parameter, and only in as far they have not been specified in the
    `mod` parameter. In this way you can pass overriding
    checkout specifiers to the standard modules.

    See Also
    --------
    tf.advanced.settings: options allowed in `config.yaml`
    &#34;&#34;&#34;

    bare = self.bare

    if not bare:
        return

    app = self.app
    source = self.source
    loadData = app.loadData

    if not loadData or loadData == &#34;core&#34;:
        return

    aContext = app.context
    moduleSpecs = aContext.moduleSpecs
    seen = self.seen
    checkout = self.checkout
    backend = self.backend

    for m in moduleSpecs or []:
        org = m[&#34;org&#34;]
        repo = m[&#34;repo&#34;]
        relative = m[&#34;relative&#34;]
        theCheckout = m.get(&#34;checkout&#34;, checkout)
        theBackend = m.get(&#34;backend&#34;, backend)
        bRep = backendRep(theBackend, &#34;spec&#34;, default=backend)

        ref = f&#34;{bRep}{org}/{repo}{relative}&#34;
        if ref in seen:
            continue

        if not self.getModule(
            org,
            repo,
            relative,
            theCheckout,
            backend=theBackend,
            specs=m,
            versionOverride=app.versionOverride,
            allowExpress=True,
            source=source,
        ):
            self.good = False</code></pre>
</details>
<div class="desc"><p>Get the data of the standard modules specified by the settings of the corpus.</p>
<p>These are specified in the <code>moduleSpecs</code> setting under
<code>provenanceSpecs</code> in <code>config.yaml</code>.</p>
<p>They will be loaded <em>after</em> the extra modules specified in the <code>mod</code>
parameter, and only in as far they have not been specified in the
<code>mod</code> parameter. In this way you can pass overriding
checkout specifiers to the standard modules.</p>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="tf.advanced.settings" href="settings.html">tf.advanced.settings</a></code></dt>
<dd>options allowed in <code>config.yaml</code></dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.css" integrity="sha512-b+T2i3P45i1LZM7I00Ci5QquB9szqaxu+uuk5TUSGjZQ4w4n+qujQiIuvTv2BxE7WCGQCifNMksyKILDiHzsOg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.js" integrity="sha512-2B9/byNV1KKRm5nQ2RLViPFD6U4dUjDGwuW1GU+ImJh8YinPU9Zlq1GzdTMO+G2ROrB5o1qasJBy1ttYz0wCug==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.advanced" href="index.html">tf.advanced</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tf.advanced.data.getModulesData" href="#tf.advanced.data.getModulesData">getModulesData</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.advanced.data.AppData" href="#tf.advanced.data.AppData">AppData</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.advanced.data.AppData.getExtra" href="#tf.advanced.data.AppData.getExtra">getExtra</a></code></li>
<li><code><a title="tf.advanced.data.AppData.getMain" href="#tf.advanced.data.AppData.getMain">getMain</a></code></li>
<li><code><a title="tf.advanced.data.AppData.getModule" href="#tf.advanced.data.AppData.getModule">getModule</a></code></li>
<li><code><a title="tf.advanced.data.AppData.getModules" href="#tf.advanced.data.AppData.getModules">getModules</a></code></li>
<li><code><a title="tf.advanced.data.AppData.getRefs" href="#tf.advanced.data.AppData.getRefs">getRefs</a></code></li>
<li><code><a title="tf.advanced.data.AppData.getStandard" href="#tf.advanced.data.AppData.getStandard">getStandard</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
