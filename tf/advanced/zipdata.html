<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.1" />
<title>tf.advanced.zipdata API documentation</title>
<meta name="description" content="" />
<!-- integrity SRI from https://cdnjs.com/libraries/10up-sanitize.css/11.0.1 -->
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css"
integrity="sha512-kcbluZFacWN57NgWZ4aH6eUMBEaTyErFhIFD3y5qYZbKuuyImH0K/AKsBbfXlivh2z5C+3IDTIhI11YmKomzmA=="
crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css"
integrity="sha512-uVeAgzAmieLUTGba0qr9vXQgVD7fko2kcbYIKIraXUIDg9iJLxveTFUrg3DJhqn3cAf3HFDbgmhq0eGko5wEAA=="
crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.advanced.zipdata</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/ce7c0368bb6ad51ddc8bedd9836c469789403bdb/tf/advanced/zipdata.py#L1-L434" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import sys
import types
from zipfile import ZipFile

from .helpers import splitModRef
from ..parameters import ZIP_OPTIONS, RELATIVE
from ..core.helpers import console, run
from ..core.files import (
    fileOpen,
    normpath,
    expanduser as ex,
    unexpanduser as ux,
    backendRep,
    DOWNLOADS,
    TEMP_DIR,
    APP_APP,
    APP_EXPRESS_ZIP,
    EXPRESS_SYNC,
    prefixSlash,
    dirExists,
    dirMake,
    scanDir,
    initTree,
)

HOME = ex(&#34;~&#34;)
DW = ex(DOWNLOADS)

__pdoc__ = {}

HELP = &#34;&#34;&#34;
### USAGE

``` sh
tf-zip --help

tf-zip {org}/{repo}{relative}

tf-zip {org}/{repo}{relative} --backend=gitlab.huc.knaw.nl
```

### EFFECT

Zips TF data from your local GitHub / GitLab repository into
a release file, ready to be attached to a GitHub release.

Your repo must sit in `~/github/*org*/*repo*` or in `~/gitlab/*org*/*repo*`
or in whatever GitLab back-end you have chosen.

Your TF data is assumed to sit in the toplevel TF directory of your repo.
But if it is somewhere else, you can pass relative, e.g phrases/heads/tf

It is assumed that your TF directory contains subdirectories according to
the versions of the main data source.
The actual `.tf` files are in those version directories.

Each of these version directories will be zipped into a separate file.

The resulting zip files end up in `~/Downloads/backend/org-release/repo`
and the are named `relative-version.zip`
(where the / in relative have been replaced by -)

&#34;&#34;&#34;

EXCLUDE = {&#34;.DS_Store&#34;, &#34;.tf&#34;, &#34;__pycache__&#34;, &#34;_local&#34;, &#34;_temp&#34;, &#34;.ipynb_checkpoints&#34;}


def zipApi(app):
    &#34;&#34;&#34;Produce the zip creation API.

    Parameters
    ----------
    app: obj
        The high-level API object of a loaded TF dataset
    &#34;&#34;&#34;

    app.zipAll = types.MethodType(zipAll, app)


def zipAll(app):
    &#34;&#34;&#34;Gathers all data for a TF resource and zips it into one file.

    The data gathered is:

    *   the app
    *   the main data module
    *   all modules mentioned in the `moduleSpecs` in the `provenanceSpec` of the app
    *   all graphics data mentioned in the `graphicsRelative` of the `provenanceSpec`
    *   all extra data mentioned in the `extraData` of the `provenanceSpec`

    The data will be zipped in a file complete.zip which can be unpacked
    in the `~/text-fabric-data` directory.

    Go to the toplevel of your local clone and say:

    ```
    tf-zipall
    ```

    The complete.zip is created in your downloads folder, under your backend,
    org, and repo.

    !!! hint
        You can attach this file straight to the latest release of of dataset
        on GitHub. This makes that users can download the dataset from GitHub
        without problems such as bumping against the GitHub API rate limit.

    !!! caution
        All data should reside on the same back-end.

    !!! note &#34;checkout files&#34;
        There will be `__checkout__.txt` files included in the zip file,
        so that after unpacking TF detects from which release the data is
        coming.

    Parameters
    ----------
    app: object
        A loaded TF data source or None.
    &#34;&#34;&#34;
    context = app.context

    backend = app.backend
    base = backendRep(backend, &#34;clone&#34;)
    org = context.org
    repo = context.repo
    relative = context.relative
    relative = prefixSlash(normpath(relative))
    version = context.version

    graphics = context.graphicsRelative
    graphics = prefixSlash(normpath(graphics))
    extra = context.extraData
    extra = prefixSlash(normpath(extra))

    prov = context.provenanceSpec
    mods = prov.get(&#34;moduleSpecs&#34;, [])

    repoDir = f&#34;{base}/{org}/{repo}&#34;

    dataItems = [
        (&#34;app&#34;, f&#34;{repoDir}/{APP_APP}&#34;),
        (&#34;main data&#34;, f&#34;{repoDir}{relative}/{version}&#34;),
    ]
    if graphics:
        dataItems.append((&#34;graphics&#34;, f&#34;{repoDir}{graphics}&#34;))
    if extra:
        dataItems.append((&#34;extra&#34;, f&#34;{repoDir}{extra}&#34;))

    good = True

    for mod in mods:
        mbackend = mod[&#34;backend&#34;]
        if mbackend is None:
            mbackend = app.backend
        mbase = backendRep(mbackend, &#34;clone&#34;)
        morg = mod[&#34;org&#34;]
        mrepo = mod[&#34;repo&#34;]
        mrelative = mod[&#34;relative&#34;]
        mrelative = prefixSlash(normpath(mrelative))
        mrepoDir = f&#34;{mbase}/{morg}/{mrepo}&#34;
        labelItems = []
        if mbase != base:
            labelItems.append(mbase)
        if morg != org:
            labelItems.append(morg)
        if mrepo != repo:
            labelItems.append(mrepo)
        if mrelative != relative:
            labelItems.append(mrelative)
        label = &#34;-&#34;.join(labelItems)
        if mbase != base:
            good = False
            console(f&#34;ERROR: module {label} not on expected back-end {backend}&#34;)
        dataItems.append((f&#34;module {label}&#34;, f&#34;{mrepoDir}{mrelative}/{version}&#34;))

    if not good:
        return

    destBase = f&#34;{DW}/{backendRep(backend, &#39;norm&#39;)}&#34;
    dest = normpath(f&#34;{destBase}/{org}/{repo}&#34;)
    destFile = f&#34;{dest}/{APP_EXPRESS_ZIP}&#34;

    console(&#34;Data to be zipped:&#34;)
    results = []

    for label, path in dataItems:
        if dirExists(path):
            (release, commit) = addCheckout(path)
            checkout = f&#34;({release or &#39;v??&#39;} {commit[-6:] if commit else &#39;??&#39;})&#34;
            zipBase = path.removeprefix(f&#34;{base}/&#34;)
            collectFiles(path, &#34;&#34;, results, zipBase=zipBase)
            status = &#34;OK&#34;
        else:
            good = False
            status = &#34;missing&#34;
            checkout = &#34;(??)&#34;
        console(f&#34;\t{status:&lt;8} {label:&lt;24} {checkout:&lt;20}: {path}&#34;)

    if not good:
        return

    if not dirExists(dest):
        dirMake(dest)
    console(&#34;Writing zip file ...&#34;)
    with ZipFile(destFile, &#34;w&#34;, **ZIP_OPTIONS) as zipFile:
        for internalPath, path in sorted(results):
            zipFile.write(
                path,
                arcname=internalPath,
            )
    return ux(destFile)


def addCheckout(path):
    release = None
    commit = None

    (good, returnCode, gitInfo, stdErr) = run(
        &#34;git describe --tags --abbrev=1000 --long&#34;, workDir=path
    )
    if good:
        (release, n, commit) = [x.strip() for x in gitInfo.split(&#34;-&#34;, 2)]
    else:
        if &#34;cannot describe&#34; in stdErr.lower():
            console(&#34;WARNING: no local release info found.&#34;, error=True)
            console(&#34;Maybe you have to do go to this repo and do `git pull --tags`&#34;)
            console(&#34;We&#39;ll fetch the local commit info anyway.&#34;)
            (good, returnCode, gitInfo, stdErr) = run(&#34;git rev-parse HEAD&#34;, workDir=path)
            if good:
                commit = gitInfo
            else:
                console(stdErr, error=True)
        else:
            console(stdErr, error=True)

    if release is not None or commit is not None:
        with fileOpen(f&#34;{path}/{EXPRESS_SYNC}&#34;, mode=&#34;w&#34;) as fh:
            if release is not None:
                fh.write(f&#34;{release}\n&#34;)
            if commit is not None:
                fh.write(f&#34;{commit}\n&#34;)
    return (release, commit)


def collectFiles(base, path, results, zipBase=None):
    if zipBase is None:
        zipBase = base

    sep = &#34;/&#34; if path else &#34;&#34;
    thisPath = f&#34;{base}{sep}{path}&#34; if path else base
    internalBase = f&#34;{zipBase}{sep}{path}&#34;
    with scanDir(thisPath) as sd:
        for e in sd:
            name = e.name
            if name in EXCLUDE:
                continue
            if e.is_file():
                results.append((f&#34;{internalBase}/{name}&#34;, f&#34;{thisPath}/{name}&#34;))
            elif e.is_dir():
                collectFiles(base, f&#34;{path}{sep}{name}&#34;, results, zipBase=zipBase)


def zipDataPart(source, results):
    if not dirExists(source):
        return (False, &#34;missing&#34;)
    zipBase = source.removeprefix(f&#34;{HOME}/&#34;)
    collectFiles(source, &#34;&#34;, results, zipBase=zipBase)
    return (True, &#34;OK&#34;)


def zipData(
    backend,
    org,
    repo,
    relative=RELATIVE,
    version=None,
    tf=True,
    keep=True,
    source=None,
    dest=None,
):
    &#34;&#34;&#34;Zips TF data into a single file, ready to be attached to a release.

    Parameters
    ----------
    backend: string
        The back-end for which the zip file is meant (`github`, `gitlab`, etc).
    org, repo: string
        Where the corpus is located on the back-end,
    relative: string, optional &#34;tf&#34;
        The subdirectory of the repo that will be zipped.
    version: string, optional None
        If passed, only data of this version is zipped, otherwise all versions
        will be zipped.
    tf: boolean, optional True
        Whether the data to be zipped are TF feature files or other kinds of data.
    keep: boolean, optional True
        Whether previously generated zip files in the destination directory should
        be kept or deleted.
    source: string, optional None
        Top directory under which the repository is found, if None; this directory
        is given by the back-end: `~/github`, `~/gitlab`, etc.
    dest: string, optional None
        Top directory under which the generated zip files are saved; if None,
        this directory under the user&#39;s Downloads directory and further determined by
        the back-end: `~/Downloads/github`, `~/Downloads/gitlab`, etc.
    &#34;&#34;&#34;

    if source is None:
        source = backendRep(backend, &#34;clone&#34;)
    if dest is None:
        dest = f&#34;{DW}/{backendRep(backend, &#39;norm&#39;)}&#34;
    relative = prefixSlash(normpath(relative))
    console(f&#34;Create release data for {org}/{repo}{relative}&#34;)
    sourceBase = normpath(f&#34;{source}/{org}&#34;)
    destBase = normpath(f&#34;{dest}/{org}-release&#34;)
    sourceDir = f&#34;{sourceBase}/{repo}{relative}&#34;
    destDir = f&#34;{destBase}/{repo}&#34;
    dataFiles = {}

    initTree(destDir, fresh=not keep)
    relativeDest = relative.removeprefix(&#34;/&#34;).replace(&#34;/&#34;, &#34;-&#34;)

    if tf:
        if not dirExists(sourceDir):
            return
        with scanDir(sourceDir) as sd:
            versionEntries = [(sourceDir, e.name) for e in sd if e.is_dir()]
        if versionEntries:
            console(f&#34;Found {len(versionEntries)} versions&#34;)
        else:
            versionEntries.append((sourceDir, &#34;&#34;))
            console(&#34;Found unversioned features&#34;)
        for versionDir, ver in versionEntries:
            if ver == TEMP_DIR:
                continue
            if version is not None and version != ver:
                continue
            versionRep = f&#34;/{ver}&#34; if ver else &#34;&#34;
            versionRep2 = f&#34;{ver}/&#34; if ver else &#34;&#34;
            versionRep3 = f&#34;-{ver}&#34; if ver else &#34;&#34;
            tfDir = f&#34;{versionDir}{versionRep}&#34;
            with scanDir(tfDir) as sd:
                for e in sd:
                    if not e.is_file():
                        continue
                    featureFile = e.name
                    if featureFile in EXCLUDE:
                        continue
                    if not featureFile.endswith(&#34;.tf&#34;):
                        console(
                            f&#39;WARNING: non feature file &#34;{versionRep2}{featureFile}&#34;&#39;,
                            error=True,
                        )
                        continue
                    dataFiles.setdefault(ver, set()).add(featureFile)

        console(f&#34;zip files end up in {destDir}&#34;)
        for ver, features in sorted(dataFiles.items()):
            item = f&#34;{org}/{repo}&#34;
            versionRep = f&#34;/{ver}&#34; if ver else &#34;&#34;
            versionRep3 = f&#34;-{ver}&#34; if ver else &#34;&#34;
            target = f&#34;{relativeDest}{versionRep3}.zip&#34;
            console(
                f&#34;zipping {item:&lt;25} {ver:&gt;4} with {len(features):&gt;3} features ==&gt; {target}&#34;
            )
            with ZipFile(f&#34;{destDir}/{target}&#34;, &#34;w&#34;, **ZIP_OPTIONS) as zipFile:
                for featureFile in sorted(features):
                    zipFile.write(
                        f&#34;{sourceDir}{versionRep}/{featureFile}&#34;,
                        arcname=featureFile,
                    )
    else:
        results = []
        versionRep = f&#34;/{version}&#34; if version else &#34;&#34;
        sourceDir = f&#34;{sourceDir}{versionRep}&#34;
        collectFiles(sourceDir, &#34;&#34;, results)
        if not relativeDest:
            relativeDest = &#34;-&#34;
        console(f&#34;zipping {org}/{repo}{relative}{versionRep} with {len(results)} files&#34;)
        console(f&#34;zip file is {destDir}/{relativeDest}.zip&#34;)
        with ZipFile(f&#34;{destDir}/{relativeDest}.zip&#34;, &#34;w&#34;, **ZIP_OPTIONS) as zipFile:
            for internalPath, path in sorted(results):
                zipFile.write(
                    path,
                    arcname=internalPath,
                )


def main(cargs=sys.argv):
    if len(cargs) &lt; 2 or any(
        arg in {&#34;--help&#34;, &#34;-help&#34;, &#34;-h&#34;, &#34;?&#34;, &#34;-?&#34;} for arg in cargs
    ):
        console(HELP)
        return

    backend = None

    newArgs = []
    for arg in cargs:
        if arg.startswith(&#34;--backend=&#34;):
            backend = arg[10:]
        else:
            newArgs.append(arg)
    cargs = newArgs

    moduleRef = cargs[1]

    parts = splitModRef(moduleRef)
    if not parts:
        console(HELP)
        return

    (org, repo, relative, checkout, theBackend) = parts
    relative = prefixSlash(normpath(relative))

    tf = (
        relative.removeprefix(&#34;/&#34;) == RELATIVE
        or relative.endswith(RELATIVE)
        or relative.startswith(f&#34;{RELATIVE}/&#34;)
        or f&#34;/{RELATIVE}/&#34; in relative
    )
    tfMsg = &#34;This is a TF dataset&#34; if tf else &#34;These are additional files&#34;
    sys.stdout.write(f&#34;{tfMsg}\n&#34;)

    zipData(theBackend or backend, org, repo, relative=relative, tf=tf)


__pdoc__[&#34;main&#34;] = HELP


if __name__ == &#34;__main__&#34;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.advanced.zipdata.addCheckout"><code class="name flex">
<span>def <span class="ident">addCheckout</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tf.advanced.zipdata.collectFiles"><code class="name flex">
<span>def <span class="ident">collectFiles</span></span>(<span>base, path, results, zipBase=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tf.advanced.zipdata.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>cargs=['/Library/Frameworks/Python.framework/Versions/3.13/bin/pdoc3', '--force', '--html', '--output-dir', 'site', '--template-dir', 'tf/docs/templates', 'tf'])</span>
</code></dt>
<dd>
<div class="desc"><h3 id="usage">USAGE</h3>
<pre><code class="language-sh">tf-zip --help

tf-zip {org}/{repo}{relative}

tf-zip {org}/{repo}{relative} --backend=gitlab.huc.knaw.nl
</code></pre>
<h3 id="effect">EFFECT</h3>
<p>Zips TF data from your local GitHub / GitLab repository into
a release file, ready to be attached to a GitHub release.</p>
<p>Your repo must sit in <code>~/github/*org*/*repo*</code> or in <code>~/gitlab/*org*/*repo*</code>
or in whatever GitLab back-end you have chosen.</p>
<p>Your TF data is assumed to sit in the toplevel TF directory of your repo.
But if it is somewhere else, you can pass relative, e.g phrases/heads/tf</p>
<p>It is assumed that your TF directory contains subdirectories according to
the versions of the main data source.
The actual <code>.<a title="tf" href="../index.html">tf</a></code> files are in those version directories.</p>
<p>Each of these version directories will be zipped into a separate file.</p>
<p>The resulting zip files end up in <code>~/Downloads/backend/org-release/repo</code>
and the are named <code>relative-version.zip</code>
(where the / in relative have been replaced by -)</p></div>
</dd>
<dt id="tf.advanced.zipdata.zipAll"><code class="name flex">
<span>def <span class="ident">zipAll</span></span>(<span>app)</span>
</code></dt>
<dd>
<div class="desc"><p>Gathers all data for a TF resource and zips it into one file.</p>
<p>The data gathered is:</p>
<ul>
<li>the app</li>
<li>the main data module</li>
<li>all modules mentioned in the <code>moduleSpecs</code> in the <code>provenanceSpec</code> of the app</li>
<li>all graphics data mentioned in the <code>graphicsRelative</code> of the <code>provenanceSpec</code></li>
<li>all extra data mentioned in the <code>extraData</code> of the <code>provenanceSpec</code></li>
</ul>
<p>The data will be zipped in a file complete.zip which can be unpacked
in the <code>~/text-fabric-data</code> directory.</p>
<p>Go to the toplevel of your local clone and say:</p>
<pre><code>tf-zipall
</code></pre>
<p>The complete.zip is created in your downloads folder, under your backend,
org, and repo.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>You can attach this file straight to the latest release of of dataset
on GitHub. This makes that users can download the dataset from GitHub
without problems such as bumping against the GitHub API rate limit.</p>
</div>
<div class="admonition caution">
<p class="admonition-title">Caution</p>
<p>All data should reside on the same back-end.</p>
</div>
<div class="admonition note">
<p class="admonition-title">checkout files</p>
<p>There will be <code>__checkout__.txt</code> files included in the zip file,
so that after unpacking TF detects from which release the data is
coming.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>app</code></strong> :&ensp;<code>object</code></dt>
<dd>A loaded TF data source or None.</dd>
</dl></div>
</dd>
<dt id="tf.advanced.zipdata.zipApi"><code class="name flex">
<span>def <span class="ident">zipApi</span></span>(<span>app)</span>
</code></dt>
<dd>
<div class="desc"><p>Produce the zip creation API.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>app</code></strong> :&ensp;<code>obj</code></dt>
<dd>The high-level API object of a loaded TF dataset</dd>
</dl></div>
</dd>
<dt id="tf.advanced.zipdata.zipData"><code class="name flex">
<span>def <span class="ident">zipData</span></span>(<span>backend, org, repo, relative='tf', version=None, tf=True, keep=True, source=None, dest=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Zips TF data into a single file, ready to be attached to a release.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>backend</code></strong> :&ensp;<code>string</code></dt>
<dd>The back-end for which the zip file is meant (<code>github</code>, <code>gitlab</code>, etc).</dd>
<dt><strong><code>org</code></strong>, <strong><code>repo</code></strong> :&ensp;<code>string</code></dt>
<dd>Where the corpus is located on the back-end,</dd>
<dt><strong><code>relative</code></strong> :&ensp;<code>string</code>, optional <code>"tf"</code></dt>
<dd>The subdirectory of the repo that will be zipped.</dd>
<dt><strong><code>version</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>If passed, only data of this version is zipped, otherwise all versions
will be zipped.</dd>
<dt><strong><code>tf</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>Whether the data to be zipped are TF feature files or other kinds of data.</dd>
<dt><strong><code>keep</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>Whether previously generated zip files in the destination directory should
be kept or deleted.</dd>
<dt><strong><code>source</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>Top directory under which the repository is found, if None; this directory
is given by the back-end: <code>~/github</code>, <code>~/gitlab</code>, etc.</dd>
<dt><strong><code>dest</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>Top directory under which the generated zip files are saved; if None,
this directory under the user's Downloads directory and further determined by
the back-end: <code>~/Downloads/github</code>, <code>~/Downloads/gitlab</code>, etc.</dd>
</dl></div>
</dd>
<dt id="tf.advanced.zipdata.zipDataPart"><code class="name flex">
<span>def <span class="ident">zipDataPart</span></span>(<span>source, results)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.advanced" href="index.html">tf.advanced</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="tf.advanced.zipdata.addCheckout" href="#tf.advanced.zipdata.addCheckout">addCheckout</a></code></li>
<li><code><a title="tf.advanced.zipdata.collectFiles" href="#tf.advanced.zipdata.collectFiles">collectFiles</a></code></li>
<li><code><a title="tf.advanced.zipdata.main" href="#tf.advanced.zipdata.main">main</a></code></li>
<li><code><a title="tf.advanced.zipdata.zipAll" href="#tf.advanced.zipdata.zipAll">zipAll</a></code></li>
<li><code><a title="tf.advanced.zipdata.zipApi" href="#tf.advanced.zipdata.zipApi">zipApi</a></code></li>
<li><code><a title="tf.advanced.zipdata.zipData" href="#tf.advanced.zipdata.zipData">zipData</a></code></li>
<li><code><a title="tf.advanced.zipdata.zipDataPart" href="#tf.advanced.zipdata.zipDataPart">zipDataPart</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
