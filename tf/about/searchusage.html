<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.about.searchusage API documentation</title>
<meta name="description" content="Usage â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.about.searchusage</code></h1>
</header>
<section id="section-intro">
<h1 id="usage">Usage</h1>
<h2 id="what-is-text-fabric-search">What is Text-Fabric Search?</h2>
<p>You can query for graph like structures
in your data set. The structure you are interested in has to be written as a
<em>search template</em>.</p>
<p>A search template expresses a pattern of nodes and edges with additional conditions
also known as <em>quantifiers</em>.</p>
<p>You can query a TF corpus in the TF browser.</p>
<p>You can also run queries on arbitrary TF corpora programmatically, e.g. in a Jupyter
notebook, by using the <code>S</code> Api, documented here.</p>
<h2 id="search-primer">Search primer</h2>
<p>A search template consists of a bunch of lines,
possibly indented, that specify objects to look for. Here is a simple example:</p>
<pre><code>book name=Genesis|Exodus
   chapter number=2
      sentence
        word pos=verb gender=feminine number=plural
        word pos=noun gender=feminine number=singular
</code></pre>
<p>This template looks for word combinations within a sentence within chapter 2 of
either Genesis or Exodus, where one of the words is a verb and the other is a
noun. Both have a feminine inflection, but the verb is plural and the noun is
singular.</p>
<p>The indentation signifies embedding, i.e. containment. The two words are
contained in the same sentence, the sentence is contained in the chapter, the
chapter in the book.</p>
<p>The conditions you specify on book, chapter, word are all conditions in terms of
<a href="#feature-specifications">node features</a>.
You can use all features in the corpus for this.</p>
<p>The order of the two words is immaterial. If there are cases where the verb
follows the noun, they will be included in the results.</p>
<p>Also, the words do not have to be adjacent. If there are cases with words
intervening between the noun and the verb, they will be included in the results.</p>
<p>Speaking of results: the <code>search</code> function returns its results as tuples of
nodes:</p>
<pre><code class="language-python">(book, chapter, sentence, word1, word2)
</code></pre>
<p>With these nodes in hand, you can programmatically gather all information about
the results that the corpus provides.</p>
<p>If the order between the verb and the noun is important, you can specify that as
an additional constraint. You can give the words a name, and state a relational
condition. Here we state that the noun precedes the verb.</p>
<pre><code>book name=Genesis|Exodus
   chapter number=2
      sentence
        vb:word pos=verb gender=feminine number=plural
        nn:word pos=noun gender=feminine number=singular
nn &lt; vb
</code></pre>
<p>This can be written a bit more economically as:</p>
<pre><code>book name=Genesis|Exodus
   chapter number=2
      sentence
        word pos=verb gender=feminine number=plural
        &gt; word pos=noun gender=feminine number=singular
</code></pre>
<p>If you insist that the noun immediately precedes the verb, you can use a
different relational operator:</p>
<pre><code>book name=Genesis|Exodus
   chapter number=2
      sentence
        word pos=verb gender=feminine number=plural
        :&gt; word pos=noun gender=feminine number=singular
</code></pre>
<p>There are more kinds of
<a href="#relational-operators">relational operators</a>.</p>
<p>If the noun must be the first word in the sentence, you can specify it as</p>
<pre><code>book name=Genesis|Exodus
   chapter number=2
      s:sentence
        w:word pos=noun gender=feminine number=singular
        &lt;: word pos=verb gender=feminine number=plural
s =: w
</code></pre>
<p>or a bit more economically:</p>
<pre><code>book name=Genesis|Exodus
   chapter number=2
      sentence
        =: word pos=noun gender=feminine number=singular
        &lt;: word pos=verb gender=feminine number=plural
</code></pre>
<p>If the verb must be the last word in the sentence, you can specify it as</p>
<pre><code>book name=Genesis|Exodus
   chapter number=2
      s:sentence
        word pos=noun gender=feminine number=singular
        &lt;: w:word pos=verb gender=feminine number=plural
s := w
</code></pre>
<p>or a bit more economically:</p>
<pre><code>book name=Genesis|Exodus
   chapter number=2
      s:sentence
        word pos=noun gender=feminine number=singular
        &lt;: word pos=verb gender=feminine number=plural
        :=
</code></pre>
<p>You can also use the <a href="#relational-operators">edge features</a> in the corpus as
relational operators as well.</p>
<p>Suppose we have an edge feature <code>sub</code> between clauses, such that if main clause
<em>m</em> has subordinate clauses <em>s1</em>, <em>s2</em> and <em>s3</em>, then</p>
<pre><code>E.sub.f(m) = (s1, s2, s3)
</code></pre>
<p>You can use this relation in search. Suppose we want to find the noun verb pair
in subordinate clauses only. We can use this template:</p>
<pre><code>book name=Genesis|Exodus
   chapter number=2
      m:clause
        s:clause
          word pos=verb gender=feminine number=plural
          :&gt; word pos=noun gender=feminine number=singular
m -sub&gt; s
</code></pre>
<p>or a bit more economically:</p>
<pre><code>book name=Genesis|Exodus
  chapter number=2
    clause
      -sub&gt; clause
        word    pos=verb gender=feminine number=plural
        :&gt; word pos=noun gender=feminine number=singular
</code></pre>
<p>Read <code>m -sub&gt; s</code> as: there is a <code>sub</code>-arrow from <code>m</code> to <code>s</code>.</p>
<p>Edge features may have values.
For example, the
<a href="https://github.com/etcbc/parallels">crossref feature</a>
is a set of edges between parallel verses, with the levels of confidence
as values. This number is an integer between 0 and 100.
We can ask for parallel verses in an unqualified way:</p>
<pre><code>verse
&lt;crossref&gt; verse
</code></pre>
<p>But we can also ask for the cases with a specific confidence:</p>
<pre><code>verse
&lt;crossref=90&gt; verse
</code></pre>
<p>or cases with a high confidence:</p>
<pre><code>verse
&lt;crossref&gt;95&gt; verse
</code></pre>
<p>or cases with a low confidence:</p>
<pre><code>verse
&lt;crossref&lt;80&gt; verse
</code></pre>
<p>All feature conditions that you can assert on node features, you can also
assert for edge features. If an edge feature is integer valued, such as <code>crossref</code>
you can use comparisons; if it is string valued, you can use regular expressions.
In both cases you can also use the other constructs, such as</p>
<pre><code>verse
&lt;crossref=66|77&gt; verse
</code></pre>
<p>To get a more specific introduction to search, consult the search tutorials for
annotated corpora, see <code><a title="tf.about.corpora" href="corpora.html">tf.about.corpora</a></code>.</p>
<p>Finally an example with quantifiers. We want all clauses where Pred-phrases
consist of verbs only:</p>
<pre><code>  clause
  /where/
    phrase function=Pred
  /have/
    /without/
      word sp#verb
    /-/
  /-/
</code></pre>
<h2 id="search-template-reference">Search template reference</h2>
<h3 id="template-lines">Template lines</h3>
<p>We have these kinds of lines in a template:</p>
<h4 id="comment-lines"><em>comment</em> lines</h4>
<ul>
<li>if the first non-white character on a line is <code>%</code> it is a comment line;</li>
<li>you cannot comment out parts of lines after a non-white part;</li>
<li>if a line is empty or has whitespace only, it is a comment line;</li>
<li>comment lines are allowed everywhere;</li>
<li>comment lines are ignored.</li>
</ul>
<h4 id="atom-lines"><em>atom</em> lines</h4>
<h5 id="simple-indent-nameotype-or-set-features">(simple): <strong>indent name:otype-or-set features</strong></h5>
<p>Examples</p>
<ol>
<li><code>word pos=verb gender=feminine</code></li>
<li><code>vb:word pos=verb gender=feminine</code></li>
<li><code>vb pos=verb gender=feminine</code></li>
</ol>
<p>Notes</p>
<ul>
<li>The indent is significant. Indent is counted as the number of white space
characters, where tabs count for just 1. <strong>Avoid tabs!</strong>.</li>
<li>The <strong>name:</strong> part is optional.
If present, it defines a name for this atom that can be used
in relational comparisons and other atoms.</li>
<li>The <strong>otype-or-set</strong> part is optional.
If it is absent, the <strong>name</strong> part must be present.</li>
</ul>
<p>The meaning of</p>
<pre><code>p:phrase sp=verb
p vs=qal
</code></pre>
<p>is identical to the meaning of</p>
<pre><code>p:phrase sp=verb
pnew:phrase vs=qal
p = pnew
</code></pre>
<h5 id="with-relop-indent-op-nameotype-or-set-features">(with relop): <strong>indent op name:otype-or-set features</strong></h5>
<ul>
<li><code>&lt;: word pos=verb gender=feminine</code></li>
<li>The relation operator specifies an extra constraint between a preceding atom
and this atom.</li>
<li>The preceding atom may be the parent, provided we are at its first child, or
it may the preceding sibling.</li>
<li>You can leave out the <strong>name:otype-or-set features</strong> bit. In that case, the
relation holds between the preceding atom and its parent.</li>
<li>The <strong>name:</strong> part is optional. Exactly as in the case without relop.</li>
<li>The <strong>otype-or-set</strong> part is optional. Exactly as in the case without relop.</li>
</ul>
<p>The otype-or-set is either a node type that exists in your TF data set,
or it is the name of a set that you have passed in the <code>sets</code> parameter alongside
the query itself when you call <code>search</code> or <code>study</code>.</p>
<p>See <a href="#feature-specifications"><em>feature specifications</em></a> below for all
full variety of feature constraints on nodes and edges.</p>
<h4 id="feature-lines-features"><em>feature</em> lines: <strong>features</strong></h4>
<p>Indent is not significant. Continuation of feature constraints after a
preceding atom line or other feature line. This way you can divide lengthy
feature constraints over multiple lines.</p>
<p>See
<a href="#feature-specifications"><em>feature specifications</em></a>
below for the
full variety of feature constraints on nodes and edges.</p>
<h4 id="relation-lines-name-operator-name"><em>relation</em> lines: <strong>name operator name</strong></h4>
<ul>
<li><code>s := w</code></li>
<li><code>m -sub&gt; s</code></li>
<li><code>m &lt;sub- s</code></li>
<li><code>m &lt;sub&gt; s</code></li>
<li>Indents and spacing are ignored.</li>
<li>There must be white-space around the operator.</li>
<li>Operators that come from edge features may be enriched with values.</li>
</ul>
<p>See
<a href="#relational-operators"><em>relational operators</em></a>
below for the
whole spectrum of relational constraints on nodes.</p>
<h4 id="quantifier-sub-templates"><em>quantifier</em> sub-templates:</h4>
<p>Atom lines that contain an otype or set may be followed by <em>quantifiers</em>.
Quantifiers consist of search templates themselves, demarcated by some
special keywords:</p>
<ul>
<li><code>/without/</code></li>
<li><code>/where/</code> and <code>/have/</code></li>
<li><code>/with/</code> and <code>/or/</code></li>
<li><code>/-/</code></li>
</ul>
<p>N.B. Quantifiers are also allowed after the <em>feature lines</em> that may follow such atoms.
In that case, the quantifier is also associated with the atom.
So the following two are equivalent</p>
<pre><code>word gn=f
/without/
.. nu=pl
/-/
</code></pre>
<p>and</p>
<pre><code>word
  gn=f
/without/
.. nu=pl
/-/
</code></pre>
<p>See <a href="#quantifiers"><em>quantifiers</em></a> below for all the syntax and semantics.</p>
<h3 id="feature-specifications">Feature specifications</h3>
<p>The <strong>features</strong> above is a specification of what features with
which values to search for. This specification must be written as a white-space
separated list of <strong>feature specs</strong>.</p>
<p>A <strong>feature spec</strong> has the form <em>name</em> <em>valueSpec</em>, with no space between the <em>name</em>
and the <em>valueSpec</em>.</p>
<h4 id="value-specifications">Value specifications</h4>
<p>The <em>valueSpec</em> may have the following forms and
meanings:</p>
<table>
<thead>
<tr>
<th>form</th>
<th>the feature <em>name</em> &hellip;</th>
</tr>
</thead>
<tbody>
<tr>
<td><code> </code> (empty)</td>
<td>has any value except <code>None</code></td>
</tr>
<tr>
<td><code>#</code></td>
<td>has value <code>None</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>has arbitrary value</td>
</tr>
<tr>
<td><code>=</code><em>values</em></td>
<td>has one of the values specified</td>
</tr>
<tr>
<td><code>#</code><em>values</em></td>
<td>has none of the values specified</td>
</tr>
<tr>
<td><code>&gt;</code><em>value</em></td>
<td>is greater than <em>value</em></td>
</tr>
<tr>
<td><code>&lt;</code><em>value</em></td>
<td>is less than <em>value</em></td>
</tr>
<tr>
<td><code>~</code><em>regular expression</em></td>
<td>has a value and it matches <em>regular expression</em></td>
</tr>
</tbody>
</table>
<div class="admonition hint">
<p class="admonition-title">Why <code>*</code> ?</p>
<p>The operator <code>*</code> after a feature name does not pose any restriction at all.
It will not influence the search results.</p>
<p><em>Why would you want to include such a "criterion"?</em></p>
<p>Some applications, such as the Text-Fabric browser collect the features used in a query
to retrieve result information to be presented to the user. So if you want to include
the values of a particular feature, mention that feature with a <code>*</code>.</p>
</div>
<p>All these forms are also valid as
<code>-</code><em>name</em> <em>form</em><code>&gt;</code> and <code>&lt;</code><em>name</em> <em>form</em><code>-</code> and <code>&lt;</code><em>name</em> <em>form</em><code>&gt;</code>,
in which case
they specify value constraints on edge features.
This is only meaningful if the edge feature is declared to have values (most edge features
do not have values).</p>
<h4 id="additional-constraints">Additional constraints</h4>
<ul>
<li>There may be no space around the <code>=#&lt;&gt;~</code>. </li>
<li><em>name</em> must be a feature name that exists in the dataset. If it references a
feature that is not yet loaded, the feature will be loaded automatically.</li>
<li><em>values</em> must be a <code>|</code> separated list of feature values, no quotes. No spaces
around the <code>|</code>. If you need a space or <code>|</code> or <code>\</code> in a value, escape it by a
<code>\</code>. Escape tabs and newlines as <code>\t</code> and <code>\n</code>.</li>
<li>When comparing values with <code>&lt;</code> and <code>&gt;</code>:<ul>
<li><em>value</em> must be an integer (negative values allowed);</li>
<li>You can do numeric comparisons only on number-valued features,
not on string-valued features.</li>
<li>If the feature in question is not defined for a node, or has the value <code>None</code>
the outcome is always <code>False</code>.</li>
</ul>
</li>
<li><em>regular expression</em> must be a string that conforms to the Python
<a href="https://docs.python.org/3/library/re.html#regular-expression-syntax">regular expression syntax</a>.<ul>
<li>If you need a space in your regular expression, you have to escape it with a
<code>\</code>.</li>
<li>You can do regular expressions only on string-valued features, not on
number-valued features.</li>
</ul>
</li>
</ul>
<h3 id="relational-operators">Relational operators</h3>
<h4 id="node-comparison">Node comparison</h4>
<ul>
<li><code>=</code>: is equal (meaning the same node, a clause and a verse that occupy the
same slots are still unequal)
<img alt="op" src="../images/Spatial/Spatial.001.png"></li>
<li><code>#</code>: is unequal (meaning a different node, a clause and a verse that occupy
the same slots are still unequal)
<img alt="op" src="../images/Spatial/Spatial.002.png"></li>
<li><code>&lt;</code> <code>&gt;</code>: before and after (in the <em>canonical ordering</em>, see <code><a title="tf.core.nodes" href="../core/nodes.html">tf.core.nodes</a></code>)
<img alt="op" src="../images/Spatial/Spatial.003.png"></li>
</ul>
<h4 id="slot-comparison">Slot comparison</h4>
<ul>
<li><code>==</code>: occupy the same slots (identical slot sets)
<img alt="op" src="../images/Spatial/Spatial.004.png"></li>
<li><code>&amp;&amp;</code>: overlap (the intersection of both slot sets is not empty)
<img alt="op" src="../images/Spatial/Spatial.006.png"></li>
<li><code>##</code>: occupy different slots (but they may overlap, the set of slots of the
two are different as sets)
<img alt="op" src="../images/Spatial/Spatial.005.png"></li>
<li><code>||</code>: occupy disjoint slots (no slot occupied by the one is also occupied by
the other)
<img alt="op" src="../images/Spatial/Spatial.007.png"></li>
<li><code>[[ ]]</code>: embeds and contains (slot set inclusion, in both directions)
<img alt="op" src="../images/Spatial/Spatial.008.png">
Never holds between the same nodes. But it holds between different nodes
with the same slots. But a slot can never embed an other node.</li>
<li><code>&lt;&lt;</code> <code>&gt;&gt;</code>: before and after (with respect to the slots occupied: left ends
before right starts and vice versa)
<img alt="op" src="../images/Spatial/Spatial.009.png"></li>
<li><code>&lt;:</code> <code>:&gt;</code>: <em>adjacent</em> before and after (with respect to the slots occupied:
left ends immediately before right starts and vice versa)
<img alt="op" src="../images/Spatial/Spatial.013.png"></li>
<li><code>=:</code> left and right start at the same slot
<img alt="op" src="../images/Spatial/Spatial.010.png"></li>
<li><code>:=</code> left and right end at the same slot
<img alt="op" src="../images/Spatial/Spatial.011.png"></li>
<li><code>::</code> left and right start and end at the same slot
<img alt="op" src="../images/Spatial/Spatial.012.png"></li>
</ul>
<h4 id="nearness-comparison">Nearness comparison</h4>
<p>Some of the adjacency relations can actually be weakened. Instead of requiring
that one slot is equal to an other slot, you can require that they are <em>k-near</em>,
i.e. they are at most <em>k</em> apart. Here are the relationships where you can do
that. Instead of typing the letter <code>k</code>, provide the actual number you want.</p>
<ul>
<li><code>&lt;k:</code> <code>:k&gt;</code>: <code>k</code>-<em>adjacent</em> before and after (with respect to the slots
occupied: left ends <code>k</code>-near where right starts and vice versa)
<img alt="op" src="../images/Spatial/Spatial.017.png"></li>
<li><code>=k:</code> left and right start at <code>k</code>-near slots
<img alt="op" src="../images/Spatial/Spatial.014.png"></li>
<li><code>:k=</code> left and right end at <code>k</code>-near slots
<img alt="op" src="../images/Spatial/Spatial.015.png"></li>
<li><code>:k:</code> left and right start and end at <code>k</code>-near slots
<img alt="op" src="../images/Spatial/Spatial.016.png"></li>
</ul>
<h4 id="based-on-node-features">Based on node features</h4>
<p>Nodes can be compared on the basis of the features that they have.
For each pair of node features <em>f</em>, <em>g</em> there is a relation between nodes
that holds precisely when feature <em>f</em> of the first node has the same value as
feature <em>g</em> on the second node. This can be used in search templates.
Not only equality is covered, also inequality, comparison, and matching.</p>
<ul>
<li>
<p><code>.f.</code> and <code>.f=g.</code> feature equality:
the <code>f</code> value of the left node is equal to the <code>g</code> value of the right node.</p>
<p><code>.f.</code> is an abbreviation for <code>.f=f.</code>.
<img alt="op" src="../images/Spatial/Spatial.022.png"></p>
<div class="admonition caution">
<p class="admonition-title">None values</p>
<p>If one or both of the nodes does not have a value, the result is <code>False</code>.</p>
<p>In particular, two nodes that have both <code>None</code> for a feature <code>f</code>, count as
having unequal values for <code>f</code>.</p>
</div>
<ul>
<li><code>.f#g.</code> feature inequality:
the <code>f</code> value of the left node is unequal to the <code>g</code> value of the right node.
<img alt="op" src="../images/Spatial/Spatial.023.png"></li>
</ul>
<div class="admonition caution">
<p class="admonition-title">None values</p>
<p>If one or both of the nodes does not have a value, the result is <code>True</code>.</p>
<p>In particular, two nodes that have both <code>None</code> for a feature <code>f</code>, count as
having unequal values for <code>f</code>.</p>
</div>
<ul>
<li><code>.f&lt;g.</code> and <code>.f&gt;g.</code> feature less than and greater than:
the <code>f</code> value of the left node is less/greater than the <code>g</code> value of right node.
This is only legal if both <code>f</code> and <code>g</code> are integer valued features.
<img alt="op" src="../images/Spatial/Spatial.024.png"></li>
</ul>
<div class="admonition caution">
<p class="admonition-title">None values</p>
<p>If one or both of the nodes does not have a value, the result is <code>False</code>.</p>
</div>
<ul>
<li><code>.f~regex~g.</code> Features match:
they are equal modulo the replacement of the parts that match the <code>regex</code>.
This is only legal if both <code>f</code> and <code>g</code> are string valued features.
<img alt="op" src="../images/Spatial/Spatial.025.png"></li>
</ul>
<div class="admonition example">
<p class="admonition-title">Example</p>
<p>If node <code>n</code> has feature <code>lex</code> with value <code>donkey_1</code>
and node <code>m</code> has feature <code>lex</code> with value <code>donkey_2</code>,
then the following holds:</p>
<pre><code>n .lex~_[0-9]*$~lex. m
</code></pre>
<p>The values are stripped of their final <code>_1</code> and <code>_2</code> strings before they
are being compared, leaving the comparison <code>donkey</code> = <code>donkey</code>, which is True.</p>
</div>
<div class="admonition caution">
<p class="admonition-title">None values</p>
<p>If one or both of the nodes does not have a value, the result is <code>False</code>.</p>
</div>
</li>
</ul>
<h4 id="based-on-edge-features">Based on edge features</h4>
<p>Edge features are based on directed edges.
An edge from <code>n</code> to <code>m</code> is not the same as an edge from <code>m</code> to <code>n</code>.
For each direction there is a relation operator.
And there is an operator corresponding to the <em>symmetric closure</em>
of the edges.</p>
<ul>
<li>
<p>without values</p>
<ul>
<li>A <code>-</code><em>name</em><code>&gt;</code> B: edge from A to B</li>
<li>A <code>&lt;</code><em>name</em><code>-</code> B: edge from B to A</li>
<li>A <code>&lt;</code><em>name</em><code>&gt;</code> B: edge from A to B or from B to A or both</li>
</ul>
<p>These forms work for edges that do and do not have values;</p>
<p><img alt="op" src="../images/Spatial/Spatial.018.png"></p>
<p><img alt="op" src="../images/Spatial/Spatial.020.png"></p>
</li>
<li>
<p>with values</p>
<ul>
<li>A <code>-</code><em>name</em> <em>valueSpec</em><code>&gt;</code> B: edge with value from A to B</li>
<li>A <code>&lt;</code><em>name</em> <em>valueSpec</em><code>-</code> B: edge with value from B to A</li>
<li>A <code>&lt;</code><em>name</em> <em>valueSpec</em><code>&gt;</code> B: edge with value from A to B
or form B to A or both</li>
</ul>
<p>These forms work only for edges that do have values.</p>
<p><img alt="op" src="../images/Spatial/Spatial.019.png"></p>
<p><img alt="op" src="../images/Spatial/Spatial.021.png"></p>
</li>
</ul>
<h3 id="quantifiers">Quantifiers</h3>
<p>Quantifiers are powerful expressions in templates.</p>
<p>They state conditions on a given atom in your template.
The atom in question is called the <em>parent</em> atom.
The conditions may involve <em>many</em> nodes that are related to the parent,
as in:</p>
<p><em>all embedded words are a verb</em>;</p>
<p><em>without a following predicate phrase</em>;</p>
<p><em>with a mother clause or a mother phrase</em>.</p>
<p>That is where the term <em>quantifier</em> comes from.</p>
<p>A quantifier <em>quantifies</em> its parent atom.</p>
<h4 id="without">/without/</h4>
<p>Syntax:</p>
<pre><code>atom
/without/
templateN
/-/
</code></pre>
<p>or</p>
<pre><code>atom
  extra feature line 1
  extra feature line 2
  extra feature line n
/without/
templateN
/-/
</code></pre>
<p>In the following, when we say <code>atom</code>, we mean the atom line itself
plus all feature lines that follow it.</p>
<p>The Meaning is:</p>
<p>node <em>r</em> is a result of this template if and only if
<em>r</em> is a result of <code>atom</code> (with all its the extra feature lines) and
there is no tuple <em>RN</em> such that (<em>r</em>, <em>RN</em>) is a result of</p>
<pre><code>atom
templateN
</code></pre>
<h4 id="where">/where/</h4>
<p>Syntax:</p>
<pre><code>atom
/where/
templateA
/have/
templateH
/-/
</code></pre>
<p>Meaning:</p>
<p>node <em>r</em> is a result of this template if and only if <em>r</em> is a result of <code>atom</code> and
for all tuples (<em>RA</em>) such that (<em>r</em>, <em>RA</em>) is a result of</p>
<pre><code>atom
templateA
</code></pre>
<p>there is a tuple <em>RH</em> such that (<em>r</em>, <em>RA</em>, <em>RH</em>)
is a result of</p>
<pre><code>atom
templateA
templateH
</code></pre>
<h4 id="with">/with/</h4>
<p>Syntax:</p>
<pre><code>atom
/with/
templateO1
/or/
templateO2
/or/
templateO3
/-/
</code></pre>
<p>Meaning:</p>
<p>node <em>r</em> is a result of this template if and only if:
there is a tuple <em>R1</em> such that (<em>r</em>, <em>R1</em>) is a result of</p>
<pre><code>atom
templateO1
</code></pre>
<p>or there is a tuple <em>R2</em> such that (<em>r</em>, <em>R2</em>) is a result of</p>
<pre><code>atom
templateO2
</code></pre>
<p>or there is a tuple <em>R3</em> such that (<em>r</em>, <em>R3</em>) is a result of</p>
<pre><code>atom
templateO3
</code></pre>
<h5 id="1-or-more-alternatives">1 or more alternatives</h5>
<p>This quantifier can be used with any number of <code>/or/</code> keywords, including
none at all. If there is no <code>/or/</code>, there is just one alternative.
The only difference between</p>
<pre><code>atom
/with/
template
/-/
</code></pre>
<p>and</p>
<pre><code>atom
template
</code></pre>
<p>is that the results of the first query contain tuples with only one
element, corresponding to the <code>atom</code>.
The second query contains tuples of which the first element
corresponds to the <code>atom</code>, and the remaining members correspond to
the <code>template</code>.</p>
<h5 id="parent">Parent</h5>
<p>The <code>atom</code> bit is an atom line, it acts as the <em>parent</em> of the
quantifier. Inside a quantifier, you may refer to the parent by the special name
<code>..</code>. So you do not have to give a name to the parent.</p>
<h5 id="multiple-quantifiers">Multiple quantifiers</h5>
<p>You may have multiple quantifiers for one parent.</p>
<h5 id="not-in-result-tuples">Not in result tuples</h5>
<p>Whereas a the search for a normal template proceeds by finding a tuple
that instantiates all its nodes in such a way that
all relationships expressed in the template hold, a quantifier template is not
instantiated. It asserts a condition that has to be tested for all nodes
relative its parent. None of the atoms in a template of a quantifier corresponds
to a node in a final result tuple.</p>
<h5 id="may-be-nested">May be nested</h5>
<p>Templates within a quantifier may contain other
quantifiers. The idea is, that whenever a search template is evaluated,
quantifiers at the outer level of get interpreted. This interpretation gives
rise to one or more templates to be constructed and run. Those new templates
have been stripped of the outer layer of quantifiers, and when these templates
are executed, the quantifiers at the next level have become outer. And so on.</p>
<h5 id="restrictions">Restrictions</h5>
<p>Due to the implementation of quantifiers there are certain restrictions.</p>
<ul>
<li>Quantifiers must be put immediately below their parents or below
preceding quantifiers of the same parent.</li>
<li>The keywords of a quantifier must appear on lines with exactly the same indentation
as the atom they quantify.</li>
<li>The templates of a quantifier must have equal or greater indent than its keywords;</li>
<li>
<p>The names accessible to the templates inside a quantifier are:</p>
<ul>
<li>the name <code>..</code>, which is the name of the atom that is quantified;
this name is automagically valid in quantifier templates;</li>
<li>the name of the atom that is quantified (if that atom has a given name);</li>
<li>names defined in the template itself;</li>
<li>in <code>/where/</code>, <code>templateH</code> may use names defined in <code>templateA</code>;
but only if these names are defined outside any quantifier of
<code>templateA</code>.</li>
</ul>
</li>
<li>
<p>The following situations block the visibility of names:</p>
<ul>
<li>in <code>/with/</code>, <code>templateO</code><em>i</em> may not use names defined in <code>templateO</code><em>j</em> for <em>j</em> other than <em>i</em>;</li>
<li>names defined outer quantifiers are not accessible in inner quantifiers;</li>
<li>names defined inner quantifiers are not accessible in outer quantifiers.</li>
</ul>
</li>
</ul>
<p>When you nest quantifiers, think of the way they will be recomposed into
ordinary templates. This dictates whether your quantifier is syntactically valid or not.</p>
<h5 id="indentation">Indentation</h5>
<p>The indentation in quantifiers relative to their parent atom will be preserved.
</p>
<div class="admonition example">
<p class="admonition-title">Nested quantifiers</p>
<p>Consider</p>
</div>
<pre><code>clause
/where/
  phrase function=Pred
/have/
  /without/
    word sp#verb
  /-/
/-/
  phrase function=Subj
</code></pre>
<p>The auxiliary templates that will be run are:</p>
<p>For the outer quantifier:</p>
<pre><code>clause
  phrase function=Pred
</code></pre>
<p>and</p>
<pre><code>clause
  phrase function=Pred
  /without/
    word sp#verb
  /-/
</code></pre>
<p>For the inner quantifier:</p>
<pre><code>phrase function=Pred
  word sp#verb
</code></pre>
<p>Note that the auxiliary template for the inner quantifier
is shifted in its entirety to the left, but that the
relative indentation is exactly as it shows in the original template.</p>
<h5 id="implementation">Implementation</h5>
<p>Here is a description of the implementation of the
quantifiers. It is not the real implementation, but it makes clear what is going
on, and why the quantifiers have certain limitations, and how indentation works.</p>
<p>The basic idea is:</p>
<ul>
<li>a quantifier leads to the execution of one or more separate searche templates;</li>
<li>the results of these searches are combined by means of set operations:
<em>difference</em>, <em>intersection</em>, <em>union</em>, dependent on the nature of the quantifier;</li>
<li>the end result of this combination will fed as a custom set to
the original template after
stripping the whole quantifier from that template.
So we replace a quantifier by a custom set.</li>
</ul>
<p>Suppose we have</p>
<pre><code>clause typ=Wx0
QUANTIFIER1
QUANTIFIER2
...
QUANTIFIERn
  rest-of-template
</code></pre>
<p>We compute a set of clauses <code>filteredClauses1</code> based on</p>
<pre><code>clause typ=Wx0
QUANTIFIER1
</code></pre>
<p>and then compute a new set <code>filteredClauses2</code> based on</p>
<pre><code>S.search('''
fclause typ=Wx0
QUANTIFIER2
''',
    customSets=dict(fclause=filteredClauses1)
</code></pre>
<p>and so on until we have had QUANTIFIERn,
leading to a set <code>filteredClausesN</code> of clauses
that pass all filters set by the quantifiers.</p>
<p>Finally, we deliver the results of</p>
<pre><code>S.search('''
fclause
  rest-of-template
''',
    customSets=dict(fclause=filteredClausesN)
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/409ae3b2792052b5dcccc263b351384ce84b7bd5/tf/about/searchusage.py#L1-L3" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
.. include:: ../docs/about/searchusage.md
&#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#usage">Usage</a><ul>
<li><a href="#what-is-text-fabric-search">What is Text-Fabric Search?</a></li>
<li><a href="#search-primer">Search primer</a></li>
<li><a href="#search-template-reference">Search template reference</a><ul>
<li><a href="#template-lines">Template lines</a><ul>
<li><a href="#comment-lines">comment lines</a></li>
<li><a href="#atom-lines">atom lines</a><ul>
<li><a href="#simple-indent-nameotype-or-set-features">(simple): indent name:otype-or-set features</a></li>
<li><a href="#with-relop-indent-op-nameotype-or-set-features">(with relop): indent op name:otype-or-set features</a></li>
</ul>
</li>
<li><a href="#feature-lines-features">feature lines: features</a></li>
<li><a href="#relation-lines-name-operator-name">relation lines: name operator name</a></li>
<li><a href="#quantifier-sub-templates">quantifier sub-templates:</a></li>
</ul>
</li>
<li><a href="#feature-specifications">Feature specifications</a><ul>
<li><a href="#value-specifications">Value specifications</a></li>
<li><a href="#additional-constraints">Additional constraints</a></li>
</ul>
</li>
<li><a href="#relational-operators">Relational operators</a><ul>
<li><a href="#node-comparison">Node comparison</a></li>
<li><a href="#slot-comparison">Slot comparison</a></li>
<li><a href="#nearness-comparison">Nearness comparison</a></li>
<li><a href="#based-on-node-features">Based on node features</a></li>
<li><a href="#based-on-edge-features">Based on edge features</a></li>
</ul>
</li>
<li><a href="#quantifiers">Quantifiers</a><ul>
<li><a href="#without">/without/</a></li>
<li><a href="#where">/where/</a></li>
<li><a href="#with">/with/</a><ul>
<li><a href="#1-or-more-alternatives">1 or more alternatives</a></li>
<li><a href="#parent">Parent</a></li>
<li><a href="#multiple-quantifiers">Multiple quantifiers</a></li>
<li><a href="#not-in-result-tuples">Not in result tuples</a></li>
<li><a href="#may-be-nested">May be nested</a></li>
<li><a href="#restrictions">Restrictions</a></li>
<li><a href="#indentation">Indentation</a></li>
<li><a href="#implementation">Implementation</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.about" href="index.html">tf.about</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>