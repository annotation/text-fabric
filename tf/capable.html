<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.1" />
<title>tf.capable API documentation</title>
<meta name="description" content="Dependency management â€¦" />
<!-- integrity SRI from https://cdnjs.com/libraries/10up-sanitize.css/11.0.1 -->
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css"
integrity="sha512-kcbluZFacWN57NgWZ4aH6eUMBEaTyErFhIFD3y5qYZbKuuyImH0K/AKsBbfXlivh2z5C+3IDTIhI11YmKomzmA=="
crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css"
integrity="sha512-uVeAgzAmieLUTGba0qr9vXQgVD7fko2kcbYIKIraXUIDg9iJLxveTFUrg3DJhqn3cAf3HFDbgmhq0eGko5wEAA=="
crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.capable</code></h1>
</header>
<section id="section-intro">
<p>Dependency management.</p>
<p>TF is dependent on a number of external Python libraries, but not many.</p>
<p>However, for a number of specialized tasks, most having to do with corpus preparation,
extra libraries are involved.
We have chosen not to list them as dependencies, because if one of them does not install
for some reason or another, the installability of TF as a whole is compromised, even
for users that are not going to do the things for which those modules are needed.</p>
<p>We have two kinds of external dependencies in TF: optional and incidental.</p>
<h2 id="incidental-dependencies">Incidental
dependencies</h2>
<p>The class <code><a title="tf.capable.CheckImport" href="#tf.capable.CheckImport">CheckImport</a></code> deals with incidental dependencies.</p>
<p>These dependencies are needed by modules in the periphery of TF.
They are managed here. If a part of TF that needs them does not find them installed,
it will gracefully refuse to work and gives a hint to the user how to install
the module.</p>
<h2 id="optional-dependencies">Optional dependencies</h2>
<p>The class <code><a title="tf.capable.Capable" href="#tf.capable.Capable">Capable</a></code> deals with optional dependencies.</p>
<p>They correspond with options during the installation of TF, like</p>
<pre><code class="language-sh">pip install 'text-fabric[option]'
</code></pre>
<p>This will trigger <code>pip</code> to also install the <code>github</code> module.</p>
<p>TF knows 2 options:</p>
<table>
<thead>
<tr>
<th>option name</th>
<th>module name</th>
<th>installation name</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>github</code></td>
<td><code>github</code></td>
<td><code>pygithub</code></td>
</tr>
<tr>
<td><code>gitlab</code></td>
<td><code>gitlab</code></td>
<td><code>python-gitlab</code></td>
</tr>
<tr>
<td><code>all</code></td>
<td>both of the above</td>
<td>both of the above</td>
</tr>
</tbody>
</table>
<p>So if you do</p>
<pre><code class="language-sh">pip install 'text-fabric[all]'
</code></pre>
<p>both <code>pygithub</code> and <code>python-gitlab</code> will be installed as dependencies.</p>
<p>See also
<a href="https://github.com/annotation/text-fabric/blob/master/setup.cfg">setup.cfg</a>
under section <code>[options.extras_require]</code> .</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/76ac61c4c99cc11152ad95334f509f7542a77ef6/tf/capable.py#L1-L360" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;Dependency management.

TF is dependent on a number of external Python libraries, but not many.

However, for a number of specialized tasks, most having to do with corpus preparation,
extra libraries are involved.
We have chosen not to list them as dependencies, because if one of them does not install
for some reason or another, the installability of TF as a whole is compromised, even
for users that are not going to do the things for which those modules are needed.

We have two kinds of external dependencies in TF: optional and incidental.

## Incidental  dependencies

The class `CheckImport` deals with incidental dependencies.

These dependencies are needed by modules in the periphery of TF.
They are managed here. If a part of TF that needs them does not find them installed,
it will gracefully refuse to work and gives a hint to the user how to install
the module.

## Optional dependencies

The class `Capable` deals with optional dependencies.

They correspond with options during the installation of TF, like

``` sh
pip install &#39;text-fabric[option]&#39;
```

This will trigger `pip` to also install the `github` module.

TF knows 2 options:

option name | module name | installation name
--- | --- | ---
`github` | `github` | `pygithub`
`gitlab` | `gitlab` | `python-gitlab`
`all` | both of the above | both of the above

So if you do

``` sh
pip install &#39;text-fabric[all]&#39;
```

both `pygithub` and `python-gitlab` will be installed as dependencies.

See also
[setup.cfg](https://github.com/annotation/text-fabric/blob/master/setup.cfg)
under section `[options.extras_require]` .
&#34;&#34;&#34;

from textwrap import dedent
from importlib import import_module

from .core.helpers import console


HINTS = dict(
    pyarrow=dedent(
        &#34;&#34;&#34;\
        Sometimes pyarrow cannot be installed in the latest version of Python.
        Either revert to an earlier version of Python or wait till the
        developers have built wheels for pyarrow.
        See this issue: https://github.com/apache/arrow/issues/37880
        &#34;&#34;&#34;
    ),
)
&#34;&#34;&#34;Known issues during installation of dependencies.&#34;&#34;&#34;

INCIDENTAL_DEPS = dict(
    pandas=(&#34;pandas&#34;, &#34;pandas&#34;),
    pyarrow=(&#34;pyarrow&#34;, &#34;pyarrow&#34;),
    lxml=(&#34;lxml.etree&#34;, &#34;lxml&#34;),
    openpyxl=(&#34;openpyxl&#34;, &#34;openpyxl&#34;),
    spacy=(&#34;spacy&#34;, &#34;spacy&#34;),
    spacyd=(&#34;spacy.cli.download&#34;, &#34;spacy&#34;),
    pagexml=(&#34;pagexml.parser&#34;, &#34;pagexml-tools&#34;),
    marimo=(&#34;marimo&#34;, &#34;marimo&#34;),
    analiticcl=(&#34;analiticcl&#34;, &#34;analiticcl&#34;),
)
&#34;&#34;&#34;The incidendtal dependencies of TF.

Keys are labels indicating the module as a whole.

Values are tuples: the first part is what must be imported,
the second part is what should be installed.
&#34;&#34;&#34;


class CheckImport:
    def __init__(self, *modules, optional=False):
        &#34;&#34;&#34;Import modules if possible.

        You can use this class as a base class for each class you define where
        modules are needed whose presence is needed but not assumed.

        The sequence is this:

        Try to load a bunch of modules:

            CI = CheckImport(&#34;module1&#34;, &#34;module2&#34;, ...)

        Then check the success and load the modules by

            if CI.importOK(hint=True):
                (module1, module2, ...) = CI.importGet()
            else:
                return

        If all modules have successfully been imported, their semantics is now stored
        in the variables `module1`, `module2`, ...
        If one or more of them could not be imported, no semantics is stored,
        and the function in which you used this code is exited.

        The `hint=True` will print an installation instruction to the output.

        You can also use this class as the base class of another class.
        When you create an instance of the class, you check whether all modules
        can be loaded. The result of this check is now stored in the object.

        So, in the initialization function of your class, right at the beginning,
        say:

            super().__init__(&#34;module1&#34;, &#34;module2&#34;, ...)
            if self.importOK(hint=True):
                (module1, module2, ... ) = self.importGet()
            else:
                return

        You can put a check in every method invocation easily.
        Right at the beginning of each relevant method, say


            if not self.importOK():
                return

        At this point, you&#39;ll probably not need to repeat the installation hint.

        Parameters
        ----------
        modules: iterable
            Each item is a key in `tf.capable.INCIDENTAL_DEPS`

        optional: boolean, optional False
            If True, the loading of these modules is optional and will not generate
            warnings.
        &#34;&#34;&#34;
        self.optional = optional

        semantics = []
        mods = []
        pipmods = []

        self.semantics = semantics
        self.mods = mods
        self.pipmods = pipmods

        for module in modules:
            info = INCIDENTAL_DEPS.get(module, None)

            if info is None:
                console(&#34;Unknown module spec: {module}&#34;)
                semantic = None
            else:
                (mod, pipmod) = info
                try:
                    semantic = import_module(mod)
                except Exception:
                    semantic = None

            semantics.append(semantic)
            mods.append(mod)
            pipmods.append(pipmod)

        missingMods = []
        missingPipmods = []

        for mod, pipmod, sem in zip(mods, pipmods, semantics):
            if sem is not None:
                continue

            missingMods.append(mod)
            missingPipmods.append(pipmod)

        self.missingMods = missingMods
        self.missingPipmods = missingPipmods

        if len(missingMods):
            self.properlySetup = False

            modsRep = &#34;, &#34;.join(missingMods)

            self.message = (
                f&#34;Refuse to execute because of uninstalled modules:\n\t{modsRep}&#34;
            )
            pipmodsRep = &#34;\n&#34;.join(f&#34;\tpip install {pip}&#34; for pip in missingPipmods)

            self.imessage = f&#34;Install these modules as follows:\n{pipmodsRep}&#34;

            theseHints = []

            for mod in missingMods:
                if mod in HINTS:
                    hintRep = &#34;\n\t&#34;.join(HINTS[mod].split(&#34;\n&#34;))
                    theseHints.append(f&#34;{mod}: {hintRep}\n&#34;)

            if len(theseHints):
                hintRep = &#34;&#34;.join(theseHints)
                self.imessage += f&#34;\n\nAdditional installation hints:\n\n{hintRep}&#34;
        else:
            self.properlySetup = True

    def importOK(self, hint=False):
        &#34;&#34;&#34;Reports the result of the import attempts.

        It will print a message with the missing modules, if any.

        Parameters
        ----------
        hint: boolean, optional False
            If True, it will also print a `pip install` statement for each missing
            module.

        Returns
        -------
        boolean
            Whether all imports were successful.
        &#34;&#34;&#34;
        optional = self.optional
        properlySetup = self.properlySetup

        if not optional and not properlySetup:
            console(self.message)
            if hint:
                console(self.imessage)

        return properlySetup

    def importGet(self):
        &#34;&#34;&#34;Delivers the imported modules.

        Returns
        -------
        list | any
            For each item in the list of modules with which this instance was
            initialized, it returns the imported module object if successful,
            or None.

            If there is only one module in the list, it returns the single object,
            not packed in a 1-element list.
        &#34;&#34;&#34;
        semantics = self.semantics
        return semantics[0] if len(semantics) == 1 else semantics


class Capable:
    &#34;&#34;&#34;Import modules for back-end communication if possible.

    This class is meant to manage the back-end capabilities of TF and make them known
    to the rest of the application.

    When TF tries to download data from GitHub or GitLab, it first looks
    for the presence of a file `complete.zip` attached to the latest release.
    Most corpora in the `tf.about.corpora` provide that file.
    Users that just want the latest release of the latest version of the data are
    served in this way.

    Users that want to go back to previous versions or commits need the modules
    `pygithub` and/or `python-gitlab`.
    They are *optional* dependencies of TF.

    For most users, in most cases a plain installation of TF without the extra options
    will suffice.

    Only a fraction of users will need to do one of the following

    ``` sh
    pip install `text-fabric[github]`
    pip install `text-fabric[gitlab]`
    pip install `text-fabric[gitall]`
    ```

    When TF is asked to perform operations that need these modules, it will
    import them if possible, and otherwise ask the user to install them.
    &#34;&#34;&#34;

    def __init__(self, *extras):
        self.backendProviders = set()
        self.modules = {}
        self.tryImport(*extras)

    def tryImport(self, *extras):
        backendProviders = self.backendProviders
        modules = self.modules

        for kind in extras:
            if kind == &#34;github&#34;:
                try:
                    import github

                    modules[&#34;github&#34;] = github
                    backendProviders.add(kind)
                except Exception:
                    pass

            elif kind == &#34;gitlab&#34;:
                try:
                    import gitlab

                    modules[&#34;gitlab&#34;] = gitlab
                    backendProviders.add(kind)
                except Exception:
                    pass

    def load(self, module):
        modules = self.modules
        loaded = modules.get(module, None)

        if loaded:
            return loaded

        try:
            loaded = import_module(module)
        except Exception:
            pass

        return loaded

    def loadFrom(self, module, *members):
        loaded = self.load(module)

        result = (
            tuple(getattr(loaded, member, None) for member in members)
            if loaded
            else tuple(None for x in members)
        )
        return result[0] if len(result) == 1 else result

    def can(self, extra):
        if extra in {&#34;github&#34;, &#34;gitlab&#34;}:
            backendProviders = self.backendProviders

            if extra in backendProviders:
                return True

            console(
                dedent(
                    f&#34;&#34;&#34;
                    Backend provider {extra} not supported.
                    Cannot reach online data on {extra}
                    Try installing text-fabric one of the following:
                    pip install text-fabric[{extra}]
                    pip install text-fabric[all]
            &#34;&#34;&#34;
                )
            )
            return False</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="tf.capable.HINTS"><code class="name">var <span class="ident">HINTS</span></code></dt>
<dd>
<div class="desc"><p>Known issues during installation of dependencies.</p></div>
</dd>
<dt id="tf.capable.INCIDENTAL_DEPS"><code class="name">var <span class="ident">INCIDENTAL_DEPS</span></code></dt>
<dd>
<div class="desc"><p>The incidendtal dependencies of TF.</p>
<p>Keys are labels indicating the module as a whole.</p>
<p>Values are tuples: the first part is what must be imported,
the second part is what should be installed.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.capable.Capable"><code class="flex name class">
<span>class <span class="ident">Capable</span></span>
<span>(</span><span>*extras)</span>
</code></dt>
<dd>
<div class="desc"><p>Import modules for back-end communication if possible.</p>
<p>This class is meant to manage the back-end capabilities of TF and make them known
to the rest of the application.</p>
<p>When TF tries to download data from GitHub or GitLab, it first looks
for the presence of a file <code>complete.zip</code> attached to the latest release.
Most corpora in the <code><a title="tf.about.corpora" href="about/corpora.html">tf.about.corpora</a></code> provide that file.
Users that just want the latest release of the latest version of the data are
served in this way.</p>
<p>Users that want to go back to previous versions or commits need the modules
<code>pygithub</code> and/or <code>python-gitlab</code>.
They are <em>optional</em> dependencies of TF.</p>
<p>For most users, in most cases a plain installation of TF without the extra options
will suffice.</p>
<p>Only a fraction of users will need to do one of the following</p>
<pre><code class="language-sh">pip install `text-fabric[github]`
pip install `text-fabric[gitlab]`
pip install `text-fabric[gitall]`
</code></pre>
<p>When TF is asked to perform operations that need these modules, it will
import them if possible, and otherwise ask the user to install them.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/76ac61c4c99cc11152ad95334f509f7542a77ef6/tf/capable.py#L259-L360" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Capable:
    &#34;&#34;&#34;Import modules for back-end communication if possible.

    This class is meant to manage the back-end capabilities of TF and make them known
    to the rest of the application.

    When TF tries to download data from GitHub or GitLab, it first looks
    for the presence of a file `complete.zip` attached to the latest release.
    Most corpora in the `tf.about.corpora` provide that file.
    Users that just want the latest release of the latest version of the data are
    served in this way.

    Users that want to go back to previous versions or commits need the modules
    `pygithub` and/or `python-gitlab`.
    They are *optional* dependencies of TF.

    For most users, in most cases a plain installation of TF without the extra options
    will suffice.

    Only a fraction of users will need to do one of the following

    ``` sh
    pip install `text-fabric[github]`
    pip install `text-fabric[gitlab]`
    pip install `text-fabric[gitall]`
    ```

    When TF is asked to perform operations that need these modules, it will
    import them if possible, and otherwise ask the user to install them.
    &#34;&#34;&#34;

    def __init__(self, *extras):
        self.backendProviders = set()
        self.modules = {}
        self.tryImport(*extras)

    def tryImport(self, *extras):
        backendProviders = self.backendProviders
        modules = self.modules

        for kind in extras:
            if kind == &#34;github&#34;:
                try:
                    import github

                    modules[&#34;github&#34;] = github
                    backendProviders.add(kind)
                except Exception:
                    pass

            elif kind == &#34;gitlab&#34;:
                try:
                    import gitlab

                    modules[&#34;gitlab&#34;] = gitlab
                    backendProviders.add(kind)
                except Exception:
                    pass

    def load(self, module):
        modules = self.modules
        loaded = modules.get(module, None)

        if loaded:
            return loaded

        try:
            loaded = import_module(module)
        except Exception:
            pass

        return loaded

    def loadFrom(self, module, *members):
        loaded = self.load(module)

        result = (
            tuple(getattr(loaded, member, None) for member in members)
            if loaded
            else tuple(None for x in members)
        )
        return result[0] if len(result) == 1 else result

    def can(self, extra):
        if extra in {&#34;github&#34;, &#34;gitlab&#34;}:
            backendProviders = self.backendProviders

            if extra in backendProviders:
                return True

            console(
                dedent(
                    f&#34;&#34;&#34;
                    Backend provider {extra} not supported.
                    Cannot reach online data on {extra}
                    Try installing text-fabric one of the following:
                    pip install text-fabric[{extra}]
                    pip install text-fabric[all]
            &#34;&#34;&#34;
                )
            )
            return False</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tf.capable.Capable.can"><code class="name flex">
<span>def <span class="ident">can</span></span>(<span>self, extra)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tf.capable.Capable.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, module)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tf.capable.Capable.loadFrom"><code class="name flex">
<span>def <span class="ident">loadFrom</span></span>(<span>self, module, *members)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tf.capable.Capable.tryImport"><code class="name flex">
<span>def <span class="ident">tryImport</span></span>(<span>self, *extras)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="tf.capable.CheckImport"><code class="flex name class">
<span>class <span class="ident">CheckImport</span></span>
<span>(</span><span>*modules, optional=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Import modules if possible.</p>
<p>You can use this class as a base class for each class you define where
modules are needed whose presence is needed but not assumed.</p>
<p>The sequence is this:</p>
<p>Try to load a bunch of modules:</p>
<pre><code>CI = CheckImport("module1", "module2", ...)
</code></pre>
<p>Then check the success and load the modules by</p>
<pre><code>if CI.importOK(hint=True):
    (module1, module2, ...) = CI.importGet()
else:
    return
</code></pre>
<p>If all modules have successfully been imported, their semantics is now stored
in the variables <code>module1</code>, <code>module2</code>, &hellip;
If one or more of them could not be imported, no semantics is stored,
and the function in which you used this code is exited.</p>
<p>The <code>hint=True</code> will print an installation instruction to the output.</p>
<p>You can also use this class as the base class of another class.
When you create an instance of the class, you check whether all modules
can be loaded. The result of this check is now stored in the object.</p>
<p>So, in the initialization function of your class, right at the beginning,
say:</p>
<pre><code>super().__init__("module1", "module2", ...)
if self.importOK(hint=True):
    (module1, module2, ... ) = self.importGet()
else:
    return
</code></pre>
<p>You can put a check in every method invocation easily.
Right at the beginning of each relevant method, say</p>
<pre><code>if not self.importOK():
    return
</code></pre>
<p>At this point, you'll probably not need to repeat the installation hint.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>modules</code></strong> :&ensp;<code>iterable</code></dt>
<dd>Each item is a key in <code><a title="tf.capable.INCIDENTAL_DEPS" href="#tf.capable.INCIDENTAL_DEPS">INCIDENTAL_DEPS</a></code></dd>
<dt><strong><code>optional</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If True, the loading of these modules is optional and will not generate
warnings.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/76ac61c4c99cc11152ad95334f509f7542a77ef6/tf/capable.py#L93-L256" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class CheckImport:
    def __init__(self, *modules, optional=False):
        &#34;&#34;&#34;Import modules if possible.

        You can use this class as a base class for each class you define where
        modules are needed whose presence is needed but not assumed.

        The sequence is this:

        Try to load a bunch of modules:

            CI = CheckImport(&#34;module1&#34;, &#34;module2&#34;, ...)

        Then check the success and load the modules by

            if CI.importOK(hint=True):
                (module1, module2, ...) = CI.importGet()
            else:
                return

        If all modules have successfully been imported, their semantics is now stored
        in the variables `module1`, `module2`, ...
        If one or more of them could not be imported, no semantics is stored,
        and the function in which you used this code is exited.

        The `hint=True` will print an installation instruction to the output.

        You can also use this class as the base class of another class.
        When you create an instance of the class, you check whether all modules
        can be loaded. The result of this check is now stored in the object.

        So, in the initialization function of your class, right at the beginning,
        say:

            super().__init__(&#34;module1&#34;, &#34;module2&#34;, ...)
            if self.importOK(hint=True):
                (module1, module2, ... ) = self.importGet()
            else:
                return

        You can put a check in every method invocation easily.
        Right at the beginning of each relevant method, say


            if not self.importOK():
                return

        At this point, you&#39;ll probably not need to repeat the installation hint.

        Parameters
        ----------
        modules: iterable
            Each item is a key in `tf.capable.INCIDENTAL_DEPS`

        optional: boolean, optional False
            If True, the loading of these modules is optional and will not generate
            warnings.
        &#34;&#34;&#34;
        self.optional = optional

        semantics = []
        mods = []
        pipmods = []

        self.semantics = semantics
        self.mods = mods
        self.pipmods = pipmods

        for module in modules:
            info = INCIDENTAL_DEPS.get(module, None)

            if info is None:
                console(&#34;Unknown module spec: {module}&#34;)
                semantic = None
            else:
                (mod, pipmod) = info
                try:
                    semantic = import_module(mod)
                except Exception:
                    semantic = None

            semantics.append(semantic)
            mods.append(mod)
            pipmods.append(pipmod)

        missingMods = []
        missingPipmods = []

        for mod, pipmod, sem in zip(mods, pipmods, semantics):
            if sem is not None:
                continue

            missingMods.append(mod)
            missingPipmods.append(pipmod)

        self.missingMods = missingMods
        self.missingPipmods = missingPipmods

        if len(missingMods):
            self.properlySetup = False

            modsRep = &#34;, &#34;.join(missingMods)

            self.message = (
                f&#34;Refuse to execute because of uninstalled modules:\n\t{modsRep}&#34;
            )
            pipmodsRep = &#34;\n&#34;.join(f&#34;\tpip install {pip}&#34; for pip in missingPipmods)

            self.imessage = f&#34;Install these modules as follows:\n{pipmodsRep}&#34;

            theseHints = []

            for mod in missingMods:
                if mod in HINTS:
                    hintRep = &#34;\n\t&#34;.join(HINTS[mod].split(&#34;\n&#34;))
                    theseHints.append(f&#34;{mod}: {hintRep}\n&#34;)

            if len(theseHints):
                hintRep = &#34;&#34;.join(theseHints)
                self.imessage += f&#34;\n\nAdditional installation hints:\n\n{hintRep}&#34;
        else:
            self.properlySetup = True

    def importOK(self, hint=False):
        &#34;&#34;&#34;Reports the result of the import attempts.

        It will print a message with the missing modules, if any.

        Parameters
        ----------
        hint: boolean, optional False
            If True, it will also print a `pip install` statement for each missing
            module.

        Returns
        -------
        boolean
            Whether all imports were successful.
        &#34;&#34;&#34;
        optional = self.optional
        properlySetup = self.properlySetup

        if not optional and not properlySetup:
            console(self.message)
            if hint:
                console(self.imessage)

        return properlySetup

    def importGet(self):
        &#34;&#34;&#34;Delivers the imported modules.

        Returns
        -------
        list | any
            For each item in the list of modules with which this instance was
            initialized, it returns the imported module object if successful,
            or None.

            If there is only one module in the list, it returns the single object,
            not packed in a 1-element list.
        &#34;&#34;&#34;
        semantics = self.semantics
        return semantics[0] if len(semantics) == 1 else semantics</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="tf.capable.CheckImport.importGet"><code class="name flex">
<span>def <span class="ident">importGet</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Delivers the imported modules.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list | any</code></dt>
<dd>
<p>For each item in the list of modules with which this instance was
initialized, it returns the imported module object if successful,
or None.</p>
<p>If there is only one module in the list, it returns the single object,
not packed in a 1-element list.</p>
</dd>
</dl></div>
</dd>
<dt id="tf.capable.CheckImport.importOK"><code class="name flex">
<span>def <span class="ident">importOK</span></span>(<span>self, hint=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Reports the result of the import attempts.</p>
<p>It will print a message with the missing modules, if any.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>hint</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If True, it will also print a <code>pip install</code> statement for each missing
module.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>Whether all imports were successful.</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../tf/index.html">tf home</a> -
<a href="../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#incidental-dependencies">Incidental dependencies</a></li>
<li><a href="#optional-dependencies">Optional dependencies</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf" href="index.html">tf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="tf.capable.HINTS" href="#tf.capable.HINTS">HINTS</a></code></li>
<li><code><a title="tf.capable.INCIDENTAL_DEPS" href="#tf.capable.INCIDENTAL_DEPS">INCIDENTAL_DEPS</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.capable.Capable" href="#tf.capable.Capable">Capable</a></code></h4>
<ul class="">
<li><code><a title="tf.capable.Capable.can" href="#tf.capable.Capable.can">can</a></code></li>
<li><code><a title="tf.capable.Capable.load" href="#tf.capable.Capable.load">load</a></code></li>
<li><code><a title="tf.capable.Capable.loadFrom" href="#tf.capable.Capable.loadFrom">loadFrom</a></code></li>
<li><code><a title="tf.capable.Capable.tryImport" href="#tf.capable.Capable.tryImport">tryImport</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tf.capable.CheckImport" href="#tf.capable.CheckImport">CheckImport</a></code></h4>
<ul class="">
<li><code><a title="tf.capable.CheckImport.importGet" href="#tf.capable.CheckImport.importGet">importGet</a></code></li>
<li><code><a title="tf.capable.CheckImport.importOK" href="#tf.capable.CheckImport.importOK">importOK</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
