<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.1" />
<title>tf.fabric API documentation</title>
<meta name="description" content="`Fabric` â€¦" />
<!-- integrity SRI from https://cdnjs.com/libraries/10up-sanitize.css/11.0.1 -->
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css"
integrity="sha512-kcbluZFacWN57NgWZ4aH6eUMBEaTyErFhIFD3y5qYZbKuuyImH0K/AKsBbfXlivh2z5C+3IDTIhI11YmKomzmA=="
crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css"
integrity="sha512-uVeAgzAmieLUTGba0qr9vXQgVD7fko2kcbYIKIraXUIDg9iJLxveTFUrg3DJhqn3cAf3HFDbgmhq0eGko5wEAA=="
crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.fabric</code></h1>
</header>
<section id="section-intro">
<h1 id="fabric"><code><a title="tf.fabric.Fabric" href="#tf.fabric.Fabric">Fabric</a></code></h1>
<p>The main class that works the core API is <code><a title="tf.fabric.Fabric" href="#tf.fabric.Fabric">Fabric</a></code>.</p>
<p>It is responsible for feature data loading and saving.</p>
<div class="admonition note">
<p class="admonition-title">Tutorial</p>
<p>The tutorials for specific annotated corpora (see <code><a title="tf.about.corpora" href="about/corpora.html">tf.about.corpora</a></code>)
put the TF API on show for vastly different corpora.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Generic API versus apps</p>
<p>This is the API of TF in general.
TF has no baked in knowledge of particular corpora.</p>
<p>However, TF comes with several <em>apps</em> that make working
with specific <code><a title="tf.about.corpora" href="about/corpora.html">tf.about.corpora</a></code> easier.
Such an app may be as simple as a <em>config.yaml</em> file, even an empty one.
The extra functions of those apps
are available through the advanced API: <code>A</code>, see <code><a title="tf.app" href="app.html">tf.app</a></code>.</p>
</div>
<p><code><a title="tf.fabric.Fabric" href="#tf.fabric.Fabric">Fabric</a></code> has built-in volume support: it can load volumes of a work and it can
collect volumes into a new work.</p>
<p><code><a title="tf.fabric.Fabric" href="#tf.fabric.Fabric">Fabric</a></code> is an extension of <code><a title="tf.core.fabric" href="core/fabric.html">tf.core.fabric</a></code> where volume support is added.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/347f60c74816f85bed834a76f14fde6a06aeb4e0/tf/fabric.py#L1-L246" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# `Fabric`

The main class that works the core API is `tf.fabric.Fabric`.

It is responsible for feature data loading and saving.

!!! note &#34;Tutorial&#34;
    The tutorials for specific annotated corpora (see `tf.about.corpora`)
    put the TF API on show for vastly different corpora.

!!! note &#34;Generic API versus apps&#34;
    This is the API of TF in general.
    TF has no baked in knowledge of particular corpora.

    However, TF comes with several *apps* that make working
    with specific `tf.about.corpora` easier.
    Such an app may be as simple as a *config.yaml* file, even an empty one.
    The extra functions of those apps
    are available through the advanced API: `A`, see `tf.app`.

`Fabric` has built-in volume support: it can load volumes of a work and it can
collect volumes into a new work.

`Fabric` is an extension of `tf.core.fabric` where volume support is added.
&#34;&#34;&#34;

import types

from .parameters import OTYPE
from .core.helpers import itemize
from .core.fabric import FabricCore
from .core.files import (
    LOCATIONS,
    LOCAL,
    normpath,
    unexpanduser as ux,
    setDir,
    expandDir,
    dirExists,
)
from .core.timestamp import Timestamp, SILENT_D, silentConvert
from .volumes import extract, collect, getVolumes
from .convert.mql import exportMQL


class Fabric(FabricCore):
    &#34;&#34;&#34;Initialize the core API for a corpus.

    !!! note &#34;Implementation&#34;
        `Fabric` is implemented as a subclass of `tf.core.fabric.FabricCore`

    See `tf.core.fabric.FabricCore` for most of the functionality.
    Here we document the volume support only.

    Parameters
    ----------
    collection: string, optional None
        If the collection exists, it will be loaded instead of the whole corpus.
        If the collection does not exist an error will be generated.

    volume: string, optional None
        If the volume exists, it will be loaded instead of the whole corpus.
        If the volume does not exist an error will be generated.

    When determining whether the volume exists, only the first members of `locations`
    and `modules` will be used.
    There the volumes reside under a directory `_local`.
    You may want to add `_local` to your `.gitignore`, so that volumes generated
    in a back-end directory will not be pushed.

    !!! caution &#34;Volumes and collections&#34;
        It is an error to load a volume as a collection and vice-versa

        You get a warning if you pass both a volume and a collection.
        The collection takes precedence, and the volume is ignored in that case.
    &#34;&#34;&#34;

    def __init__(
        self,
        locations=None,
        modules=None,
        silent=SILENT_D,
        volume=None,
        collection=None,
        **kwargs,
    ):

        if modules is None:
            module = [&#34;&#34;]
        elif type(modules) is str:
            module = [normpath(x.strip()) for x in itemize(modules, &#34;\n&#34;)]
        else:
            module = [normpath(str(x)) for x in modules]
        module = module[0] if module else &#34;&#34;
        module = module.strip(&#34;/&#34;)

        if locations is None:
            location = LOCATIONS if LOCATIONS else [&#34;&#34;]
        elif type(locations) is str:
            location = [normpath(x.strip()) for x in itemize(locations, &#34;\n&#34;)]
        else:
            location = [normpath(str(x)) for x in locations]
        location = location[0] if location else &#34;&#34;
        location = location.rstrip(&#34;/&#34;)

        setDir(self)
        location = expandDir(self, location)
        sep = &#34;/&#34; if location and module else &#34;&#34;

        location = f&#34;{location}{sep}{module}&#34;
        sep = &#34;/&#34; if location else &#34;&#34;
        volumeBase = f&#34;{location}{sep}{LOCAL}&#34;
        collectionBase = f&#34;{location}{sep}{LOCAL}&#34;

        TM = Timestamp(silent=silent)

        if collection:
            collectionLoc = f&#34;{collectionBase}/{collection}&#34;
            self.collectionLoc = collectionLoc
            locations = collectionLoc
            modules = [&#34;&#34;]
            if not dirExists(locations):
                TM = Timestamp(silent=silent)
                TM.error(f&#34;Collection {collection} not found under {ux(collectionLoc)}&#34;)
        elif volume:
            volumeLoc = f&#34;{volumeBase}/{volume}&#34;
            self.volumeLoc = volumeLoc
            locations = volumeLoc
            modules = [&#34;&#34;]
            if not dirExists(locations):
                TM.error(f&#34;Volume {volume} not found under {ux(volumeLoc)}&#34;)

        if collection and volume:
            TM.warning(
                f&#34;Both collection={collection} and volume={volume} specified.&#34;, tm=False
            )
            TM.warning(&#34;Ignoring the volume&#34;, tm=False)

        super().__init__(locations=locations, modules=modules, silent=silent, **kwargs)
        self.volumeBase = volumeBase
        self.collectionBase = collectionBase
        self.collection = collection
        self.volume = None if collection else volume
        self.exportMQL = types.MethodType(exportMQL, self)

    def _makeApi(self):
        api = super()._makeApi()

        if self.collection:
            self.collectionInfo = self.features[OTYPE].metaData.get(&#34;collection&#34;, None)
            if self.collectionInfo is None:
                self.error(&#34;This is not a collection!&#34;)
                self.good = False
                return None

        elif self.volume:
            self.volumeInfo = self.features[OTYPE].metaData.get(&#34;volume&#34;, None)
            if self.volumeInfo is None:
                self.error(&#34;This is not a volume!&#34;)
                self.good = False
                return None
        return api

    def getVolumes(self):
        &#34;&#34;&#34;Lists available volumes within the dataset.

        See `tf.volumes.extract.getVolumes`.
        &#34;&#34;&#34;

        volumeBase = self.volumeBase
        return getVolumes(volumeBase)

    def extract(
        self, volumes=True, byTitle=True, silent=SILENT_D, overwrite=None, show=False
    ):
        &#34;&#34;&#34;Extract volumes from the currently loaded work.

        This function is only provided if the dataset is a work,
        i.e. it is loaded as a whole.
        When a single volume of a work is loaded, there is no `extract` method.

        See `tf.volumes.extract` and note that parameters
        `workLocation`, `volumesLocation`, `api`
        will be supplied automatically.
        &#34;&#34;&#34;

        silent = silentConvert(silent)
        volume = self.volume
        volumeBase = self.volumeBase
        api = self.api

        if volume:
            self.error(&#34;Cannot extract volumes from a single volume of a work&#34;)
            return

        return extract(
            None,
            volumeBase,
            volumes=volumes,
            byTitle=byTitle,
            silent=silent,
            api=api,
            overwrite=overwrite,
            checkOnly=False,
            show=show,
        )

    def collect(
        self,
        volumes,
        collection,
        volumeType=None,
        volumeFeature=None,
        mergeTypes=None,
        featureMeta=None,
        silent=SILENT_D,
        overwrite=None,
    ):
        &#34;&#34;&#34;Creates a work out of a number of volumes.

        Parameters
        ----------

        volumes: tuple
            Just the names of the volumes that you want to collect.

        collection: string
            The name of the new collection

        See `tf.volumes.collect` for the other parameters and note that parameter
        `workLocation` will be supplied automatically from `collection`.
        &#34;&#34;&#34;

        volumeBase = self.volumeBase

        return collect(
            tuple(f&#34;{volumeBase}/{name}&#34; for name in volumes),
            f&#34;{volumeBase}/{collection}&#34;,
            volumeType=volumeType,
            volumeFeature=volumeFeature,
            mergeTypes=mergeTypes,
            featureMeta=featureMeta,
            silent=silent,
            overwrite=overwrite,
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.fabric.Fabric"><code class="flex name class">
<span>class <span class="ident">Fabric</span></span>
<span>(</span><span>locations=None, modules=None, silent='auto', volume=None, collection=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the core API for a corpus.</p>
<div class="admonition note">
<p class="admonition-title">Implementation</p>
<p><code><a title="tf.fabric.Fabric" href="#tf.fabric.Fabric">Fabric</a></code> is implemented as a subclass of <code><a title="tf.core.fabric.FabricCore" href="core/fabric.html#tf.core.fabric.FabricCore">FabricCore</a></code></p>
</div>
<p>See <code><a title="tf.core.fabric.FabricCore" href="core/fabric.html#tf.core.fabric.FabricCore">FabricCore</a></code> for most of the functionality.
Here we document the volume support only.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>collection</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>If the collection exists, it will be loaded instead of the whole corpus.
If the collection does not exist an error will be generated.</dd>
<dt><strong><code>volume</code></strong> :&ensp;<code>string</code>, optional <code>None</code></dt>
<dd>If the volume exists, it will be loaded instead of the whole corpus.
If the volume does not exist an error will be generated.</dd>
</dl>
<p>When determining whether the volume exists, only the first members of <code>locations</code>
and <code>modules</code> will be used.
There the volumes reside under a directory <code>_local</code>.
You may want to add <code>_local</code> to your <code>.gitignore</code>, so that volumes generated
in a back-end directory will not be pushed.</p>
<div class="admonition caution">
<p class="admonition-title">Volumes and collections</p>
<p>It is an error to load a volume as a collection and vice-versa</p>
<p>You get a warning if you pass both a volume and a collection.
The collection takes precedence, and the volume is ignored in that case.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/347f60c74816f85bed834a76f14fde6a06aeb4e0/tf/fabric.py#L47-L246" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Fabric(FabricCore):
    &#34;&#34;&#34;Initialize the core API for a corpus.

    !!! note &#34;Implementation&#34;
        `Fabric` is implemented as a subclass of `tf.core.fabric.FabricCore`

    See `tf.core.fabric.FabricCore` for most of the functionality.
    Here we document the volume support only.

    Parameters
    ----------
    collection: string, optional None
        If the collection exists, it will be loaded instead of the whole corpus.
        If the collection does not exist an error will be generated.

    volume: string, optional None
        If the volume exists, it will be loaded instead of the whole corpus.
        If the volume does not exist an error will be generated.

    When determining whether the volume exists, only the first members of `locations`
    and `modules` will be used.
    There the volumes reside under a directory `_local`.
    You may want to add `_local` to your `.gitignore`, so that volumes generated
    in a back-end directory will not be pushed.

    !!! caution &#34;Volumes and collections&#34;
        It is an error to load a volume as a collection and vice-versa

        You get a warning if you pass both a volume and a collection.
        The collection takes precedence, and the volume is ignored in that case.
    &#34;&#34;&#34;

    def __init__(
        self,
        locations=None,
        modules=None,
        silent=SILENT_D,
        volume=None,
        collection=None,
        **kwargs,
    ):

        if modules is None:
            module = [&#34;&#34;]
        elif type(modules) is str:
            module = [normpath(x.strip()) for x in itemize(modules, &#34;\n&#34;)]
        else:
            module = [normpath(str(x)) for x in modules]
        module = module[0] if module else &#34;&#34;
        module = module.strip(&#34;/&#34;)

        if locations is None:
            location = LOCATIONS if LOCATIONS else [&#34;&#34;]
        elif type(locations) is str:
            location = [normpath(x.strip()) for x in itemize(locations, &#34;\n&#34;)]
        else:
            location = [normpath(str(x)) for x in locations]
        location = location[0] if location else &#34;&#34;
        location = location.rstrip(&#34;/&#34;)

        setDir(self)
        location = expandDir(self, location)
        sep = &#34;/&#34; if location and module else &#34;&#34;

        location = f&#34;{location}{sep}{module}&#34;
        sep = &#34;/&#34; if location else &#34;&#34;
        volumeBase = f&#34;{location}{sep}{LOCAL}&#34;
        collectionBase = f&#34;{location}{sep}{LOCAL}&#34;

        TM = Timestamp(silent=silent)

        if collection:
            collectionLoc = f&#34;{collectionBase}/{collection}&#34;
            self.collectionLoc = collectionLoc
            locations = collectionLoc
            modules = [&#34;&#34;]
            if not dirExists(locations):
                TM = Timestamp(silent=silent)
                TM.error(f&#34;Collection {collection} not found under {ux(collectionLoc)}&#34;)
        elif volume:
            volumeLoc = f&#34;{volumeBase}/{volume}&#34;
            self.volumeLoc = volumeLoc
            locations = volumeLoc
            modules = [&#34;&#34;]
            if not dirExists(locations):
                TM.error(f&#34;Volume {volume} not found under {ux(volumeLoc)}&#34;)

        if collection and volume:
            TM.warning(
                f&#34;Both collection={collection} and volume={volume} specified.&#34;, tm=False
            )
            TM.warning(&#34;Ignoring the volume&#34;, tm=False)

        super().__init__(locations=locations, modules=modules, silent=silent, **kwargs)
        self.volumeBase = volumeBase
        self.collectionBase = collectionBase
        self.collection = collection
        self.volume = None if collection else volume
        self.exportMQL = types.MethodType(exportMQL, self)

    def _makeApi(self):
        api = super()._makeApi()

        if self.collection:
            self.collectionInfo = self.features[OTYPE].metaData.get(&#34;collection&#34;, None)
            if self.collectionInfo is None:
                self.error(&#34;This is not a collection!&#34;)
                self.good = False
                return None

        elif self.volume:
            self.volumeInfo = self.features[OTYPE].metaData.get(&#34;volume&#34;, None)
            if self.volumeInfo is None:
                self.error(&#34;This is not a volume!&#34;)
                self.good = False
                return None
        return api

    def getVolumes(self):
        &#34;&#34;&#34;Lists available volumes within the dataset.

        See `tf.volumes.extract.getVolumes`.
        &#34;&#34;&#34;

        volumeBase = self.volumeBase
        return getVolumes(volumeBase)

    def extract(
        self, volumes=True, byTitle=True, silent=SILENT_D, overwrite=None, show=False
    ):
        &#34;&#34;&#34;Extract volumes from the currently loaded work.

        This function is only provided if the dataset is a work,
        i.e. it is loaded as a whole.
        When a single volume of a work is loaded, there is no `extract` method.

        See `tf.volumes.extract` and note that parameters
        `workLocation`, `volumesLocation`, `api`
        will be supplied automatically.
        &#34;&#34;&#34;

        silent = silentConvert(silent)
        volume = self.volume
        volumeBase = self.volumeBase
        api = self.api

        if volume:
            self.error(&#34;Cannot extract volumes from a single volume of a work&#34;)
            return

        return extract(
            None,
            volumeBase,
            volumes=volumes,
            byTitle=byTitle,
            silent=silent,
            api=api,
            overwrite=overwrite,
            checkOnly=False,
            show=show,
        )

    def collect(
        self,
        volumes,
        collection,
        volumeType=None,
        volumeFeature=None,
        mergeTypes=None,
        featureMeta=None,
        silent=SILENT_D,
        overwrite=None,
    ):
        &#34;&#34;&#34;Creates a work out of a number of volumes.

        Parameters
        ----------

        volumes: tuple
            Just the names of the volumes that you want to collect.

        collection: string
            The name of the new collection

        See `tf.volumes.collect` for the other parameters and note that parameter
        `workLocation` will be supplied automatically from `collection`.
        &#34;&#34;&#34;

        volumeBase = self.volumeBase

        return collect(
            tuple(f&#34;{volumeBase}/{name}&#34; for name in volumes),
            f&#34;{volumeBase}/{collection}&#34;,
            volumeType=volumeType,
            volumeFeature=volumeFeature,
            mergeTypes=mergeTypes,
            featureMeta=featureMeta,
            silent=silent,
            overwrite=overwrite,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="tf.core.fabric.FabricCore" href="core/fabric.html#tf.core.fabric.FabricCore">FabricCore</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="tf.fabric.Fabric.collect"><code class="name flex">
<span>def <span class="ident">collect</span></span>(<span>self, volumes, collection, volumeType=None, volumeFeature=None, mergeTypes=None, featureMeta=None, silent='auto', overwrite=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a work out of a number of volumes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>volumes</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Just the names of the volumes that you want to collect.</dd>
<dt><strong><code>collection</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the new collection</dd>
</dl>
<p>See <code><a title="tf.volumes.collect" href="volumes/collect.html">tf.volumes.collect</a></code> for the other parameters and note that parameter
<code>workLocation</code> will be supplied automatically from <code>collection</code>.</p></div>
</dd>
<dt id="tf.fabric.Fabric.extract"><code class="name flex">
<span>def <span class="ident">extract</span></span>(<span>self, volumes=True, byTitle=True, silent='auto', overwrite=None, show=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract volumes from the currently loaded work.</p>
<p>This function is only provided if the dataset is a work,
i.e. it is loaded as a whole.
When a single volume of a work is loaded, there is no <code>extract</code> method.</p>
<p>See <code><a title="tf.volumes.extract" href="volumes/extract.html">tf.volumes.extract</a></code> and note that parameters
<code>workLocation</code>, <code>volumesLocation</code>, <code>api</code>
will be supplied automatically.</p></div>
</dd>
<dt id="tf.fabric.Fabric.getVolumes"><code class="name flex">
<span>def <span class="ident">getVolumes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Lists available volumes within the dataset.</p>
<p>See <code><a title="tf.volumes.extract.getVolumes" href="volumes/extract.html#tf.volumes.extract.getVolumes">getVolumes()</a></code>.</p></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="tf.core.fabric.FabricCore" href="core/fabric.html#tf.core.fabric.FabricCore">FabricCore</a></b></code>:
<ul class="hlist">
<li><code><a title="tf.core.fabric.FabricCore.banner" href="core/fabric.html#tf.core.fabric.FabricCore.banner">banner</a></code></li>
<li><code><a title="tf.core.fabric.FabricCore.clearCache" href="core/fabric.html#tf.core.fabric.FabricCore.clearCache">clearCache</a></code></li>
<li><code><a title="tf.core.fabric.FabricCore.explore" href="core/fabric.html#tf.core.fabric.FabricCore.explore">explore</a></code></li>
<li><code><a title="tf.core.fabric.FabricCore.features" href="core/fabric.html#tf.core.fabric.FabricCore.features">features</a></code></li>
<li><code><a title="tf.core.fabric.FabricCore.load" href="core/fabric.html#tf.core.fabric.FabricCore.load">load</a></code></li>
<li><code><a title="tf.core.fabric.FabricCore.loadAll" href="core/fabric.html#tf.core.fabric.FabricCore.loadAll">loadAll</a></code></li>
<li><code><a title="tf.core.fabric.FabricCore.save" href="core/fabric.html#tf.core.fabric.FabricCore.save">save</a></code></li>
<li><code><a title="tf.core.fabric.FabricCore.version" href="core/fabric.html#tf.core.fabric.FabricCore.version">version</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../tf/index.html">tf home</a> -
<a href="../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#fabric">Fabric</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf" href="index.html">tf</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.fabric.Fabric" href="#tf.fabric.Fabric">Fabric</a></code></h4>
<ul class="">
<li><code><a title="tf.fabric.Fabric.collect" href="#tf.fabric.Fabric.collect">collect</a></code></li>
<li><code><a title="tf.fabric.Fabric.extract" href="#tf.fabric.Fabric.extract">extract</a></code></li>
<li><code><a title="tf.fabric.Fabric.getVolumes" href="#tf.fabric.Fabric.getVolumes">getVolumes</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
