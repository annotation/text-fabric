<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.core.nodes API documentation</title>
<meta name="description" content="Node organization â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-GjqubOlYA6/wOZV7F31o2t4ogk4JGDGFa6XmL+BfAG0=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-qDPJ4nH38AgHyK3U6cvI6DBifA+7hPBo8mVoH6pyN9c=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.core.nodes</code></h1>
</header>
<section id="section-intro">
<h1 id="node-organization">Node organization</h1>
<p>This module is about ordering nodes in terms of the slot nodes they are attached to.</p>
<h2 id="canonical-order">Canonical Order</h2>
<p>Nodes are linked to subsets of slots, and there is a canonical ordering
on subsets of integers that is inherited by the nodes.</p>
<p>The canonical order is a way to sort the nodes in your corpus in such a way
that you can enumerate all nodes in the order you encounter them if you
walk through your corpus.</p>
<dl>
<dt>Formally</dt>
<dd>A node <code>A</code> comes before a node <code>B</code> if <code>A</code> contains the smallest slot
that occurs in only one of <code>A</code> and <code>B</code>.</dd>
</dl>
<p>Briefly this means:</p>
<ul>
<li>embedder nodes come before the nodes that lie embedded in them;</li>
<li>earlier stuff comes before later stuff,</li>
<li>if a verse coincides with a sentence, the verse comes before the sentence,
because verses generally contain sentences and not the other way round;</li>
<li>if two objects are intersecting, but none embeds the other, the one with the
smallest slot that does not occur in the other, comes first.</li>
</ul>
<div class="admonition note">
<p class="admonition-title">first things first, big things first</p>
<p>That means, roughly, that you start with a
book node (Genesis), then a chapter node (Genesis 1), then a verse node, Genesis
1:1, then a sentence node, then a clause node, a phrase node, and the first word
node. Then follow all word nodes in the first phrase, then the phrase node of
the second phrase, followed by the word nodes in that phrase. When ever you
enter a higher structure, you will first get the node corresponding to that
structure, and after that the nodes corresponding to the building blocks of that
structure.</p>
</div>
<p>This concept follows the intuition that slot sets with smaller elements come
before slot set with bigger elements, and embedding slot sets come before
embedded slot sets. Hence, if you enumerate a set of nodes that happens to
constitute a tree hierarchy based on slot set embedding, and you enumerate those
nodes in the slot set order, you will walk the tree in pre-order.</p>
<p>This order is a modification of the one as described in (Doedens 1994, 3.6.3).</p>
<p><img alt="fabric" src="../images/DoedensLO.png"></p>
<blockquote>
<p>Doedens, Crist-Jan (1994), <em>Text Databases. One Database Model and Several
Retrieval Languages</em>, number 14 in Language and Computers, Editions Rodopi,
Amsterdam, Netherlands and Atlanta, USA. ISBN: 90-5183-729-1,
<a href="https://books.google.nl/books?id=9ggOBRz1dO4C">Google books</a>.
The order as defined by Doedens corresponds to walking trees in post-order.</p>
</blockquote>
<p>For a lot of processing, it is handy to have the stack of embedding elements
available when working with an element. That is the advantage of pre-order over
post-order. It is very much like SAX parsing in the XML world.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/6e363a4d004478c07d52ac30b1434f8959a1e9a2/tf/core/nodes.py#L1-L296" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# Node organization

This module is about ordering nodes in terms of the slot nodes they are attached to.

## Canonical Order

Nodes are linked to subsets of slots, and there is a canonical ordering
on subsets of integers that is inherited by the nodes.

The canonical order is a way to sort the nodes in your corpus in such a way
that you can enumerate all nodes in the order you encounter them if you
walk through your corpus.

Formally
:   A node `A` comes before a node `B` if `A` contains the smallest slot
    that occurs in only one of `A` and `B`.

Briefly this means:

*   embedder nodes come before the nodes that lie embedded in them;
*   earlier stuff comes before later stuff,
*   if a verse coincides with a sentence, the verse comes before the sentence,
    because verses generally contain sentences and not the other way round;
*   if two objects are intersecting, but none embeds the other, the one with the
    smallest slot that does not occur in the other, comes first.

!!! note &#34;first things first, big things first&#34;
    That means, roughly, that you start with a
    book node (Genesis), then a chapter node (Genesis 1), then a verse node, Genesis
    1:1, then a sentence node, then a clause node, a phrase node, and the first word
    node. Then follow all word nodes in the first phrase, then the phrase node of
    the second phrase, followed by the word nodes in that phrase. When ever you
    enter a higher structure, you will first get the node corresponding to that
    structure, and after that the nodes corresponding to the building blocks of that
    structure.

This concept follows the intuition that slot sets with smaller elements come
before slot set with bigger elements, and embedding slot sets come before
embedded slot sets. Hence, if you enumerate a set of nodes that happens to
constitute a tree hierarchy based on slot set embedding, and you enumerate those
nodes in the slot set order, you will walk the tree in pre-order.

This order is a modification of the one as described in (Doedens 1994, 3.6.3).

![fabric](../images/DoedensLO.png)

&gt; Doedens, Crist-Jan (1994), *Text Databases. One Database Model and Several
&gt; Retrieval Languages*, number 14 in Language and Computers, Editions Rodopi,
&gt; Amsterdam, Netherlands and Atlanta, USA. ISBN: 90-5183-729-1,
&gt; [Google books](https://books.google.nl/books?id=9ggOBRz1dO4C).
&gt; The order as defined by Doedens corresponds to walking trees in post-order.

For a lot of processing, it is handy to have the stack of embedding elements
available when working with an element. That is the advantage of pre-order over
post-order. It is very much like SAX parsing in the XML world.
&#34;&#34;&#34;

import functools


class Nodes:
    def __init__(self, api):
        self.api = api
        C = api.C
        Crank = C.rank.data

        self.otypeRank = {d[0]: i for (i, d) in enumerate(reversed(C.levels.data))}
        &#34;&#34;&#34;Dictionary that provides a ranking of the node types.

        The node types are ordered in `C.levels.data`, and if you reverse that list,
        you get the rank of a type by looking at the position in which that type occurs.

        The `slotType` has rank 0 (`otypeRank[F.otype.slotType] == 0`),
        and the more comprehensive a type is, the higher its rank.
        &#34;&#34;&#34;

        self.sortKey = lambda n: Crank[n - 1]
        &#34;&#34;&#34;Sort key function for the canonical ordering between nodes.


        !!! hint &#34;usage&#34;
            The following two pieces of code do the same thing:
            `sortNodes(nodeSet)` and `sorted(nodeSet, key=sortKey)`.

        See Also
        --------
        tf.core.nodes: canonical ordering
        tf.core.nodes.Nodes.sortNodes: sorting nodes
        &#34;&#34;&#34;

        self.sortKeyTuple = lambda tup: tuple(Crank[n - 1] for n in tup)
        &#34;&#34;&#34;Sort key function for the canonical ordering between tuples of nodes.
        It applies `sortKey` to each member of the tuple.
        Handy to sort search results. We can sort them in canonical order like this:

            sorted(results, key=lambda tup: tuple(sortKey(n) for n in tup))

        This is exactly what `sortKeyTuple` does, but then a bit more efficient:

            sorted(results, key=sortKeyTuple)

        See Also
        --------
        tf.core.nodes: canonical ordering
        &#34;&#34;&#34;

        (sortKeyChunk, sortKeyChunkLength) = self.makeSortKeyChunk()

        self.sortKeyChunk = sortKeyChunk
        &#34;&#34;&#34;Sort key function for the canonical ordering between chunks of nodes.

            sorted(chunks, key=sortKeyChunk)

        A chunk is a tuple consisting of a node and a subset of its slots.
        Mostly, this subset of slots is contiguous (no gaps), and mostly it is
        maximal: the slots immediately before and after the chunk do not belong to the node.

        But the sort key also works if these conditions are not met.

        Notes
        -----
        The use case for this function is that we have a bunch of nodes,
        each linked to a set of slots.
        For each node, we have split its slot set in maximal contiguous parts, its chunks.
        Now we want to order those chunks in the canonical ordering.

        See Also
        --------
        tf.core.nodes: canonical ordering
        &#34;&#34;&#34;

        self.sortKeyChunkLength = sortKeyChunkLength

    def makeSortKeyChunk(self):
        api = self.api

        fOtype = api.F.otype
        otypeRank = self.otypeRank
        fOtypev = fOtype.v

        def beforePosition(chunk1, chunk2):
            (n1, (b1, e1)) = chunk1
            (n2, (b2, e2)) = chunk2
            if b1 &lt; b2:
                return -1
            elif b1 &gt; b2:
                return 1

            r1 = otypeRank[fOtypev(n1)]
            r2 = otypeRank[fOtypev(n2)]

            if r1 &gt; r2:
                return -1
            elif r1 &lt; r2:
                return 1

            return (
                -1
                if e1 &gt; e2
                else 1
                if e1 &lt; e2
                else -1
                if n1 &lt; n2
                else 1
                if n1 &gt; n2
                else 0
            )

        def beforeLength(chunk1, chunk2):
            (n1, (b1, e1)) = chunk1
            (n2, (b2, e2)) = chunk2

            size1 = e1 - b1
            size2 = e2 - b2

            if size1 &gt; size2:
                return -1
            elif size2 &gt; size1:
                return 1
            elif b1 &lt; b2:
                return -1
            elif b1 &gt; b2:
                return 1

            r1 = otypeRank[fOtypev(n1)]
            r2 = otypeRank[fOtypev(n2)]

            if r2 &gt; r1:
                return -1
            elif r1 &gt; r2:
                return 1

            return -1 if n1 &lt; n2 else 1 if n1 &gt; n2 else 0

        return (
            functools.cmp_to_key(beforePosition),
            functools.cmp_to_key(beforeLength),
        )

    def sortNodes(self, nodeSet):
        &#34;&#34;&#34;Delivers a tuple of nodes sorted by the *canonical ordering*.

        Parameters
        ----------
        nodeSet: iterable
            An iterable of nodes to be sorted.

        Returns
        -------
        list
            The sorted nodes as list

        See Also
        --------
        tf.core.nodes: canonical ordering
        &#34;&#34;&#34;

        api = self.api

        Crank = api.C.rank.data
        return sorted(nodeSet, key=lambda n: Crank[n - 1])

    def walk(self, nodes=None, events=False):
        &#34;&#34;&#34;Generates all nodes in the *canonical order*.
        (`tf.core.nodes`)

        By `walk()` you traverse all nodes of your corpus
        in a very natural order. See `tf.core.nodes`.

        The order is much like walking a tree in pre-order: first parents,
        then children from left to right.

        The thing is: in general the nodes do not form a tree, but a more
        liberal structure: a graph.

        But even then we can order the nodes in such a way that nodes that embed
        slots from other nodes come before those other nodes, provided those other
        nodes start later.

        When we generate those nodes and consume them, we now when each node starts,
        but we loose track of where exactly they end.

        To remedy that, you can call this function with `events=True`.
        In that case, a stream of events is generated, where each event has the
        form `(node, False)` or `(node, True)`, where `False` means: beginning of
        node and `True` means: end of node.

        In case of slot nodes, only one event per slot is generated: `(node, None)`.

        !!! hint &#34;More ways of walking&#34;
            Under `tf.core.nodefeature.NodeFeatures` there is another convenient way
            to walk through subsets of nodes.

        Parameters
        ----------
        nodes: iterable of int, optional None
            If `None`, walks through all nodes of the corpus in canonical order.
            Otherwise, walks through the given nodes in canonical order.
        events: boolean, optional False
            If True, wraps the generated nodes in event tuples as described above.

        Returns
        -------
        nodes: int
            One at a time.
        &#34;&#34;&#34;

        api = self.api
        C = api.C

        if nodes is None:
            walkNodes = C.order.data
        else:
            walkNodes = self.sortNodes(nodes)
            walkNodeSet = set(nodes)

        if events:
            endSlots = C.boundary.data[1]

            otype = api.F.otype
            Fotypev = otype.v
            slotType = otype.slotType

            for n in walkNodes:
                if Fotypev(n) == slotType:
                    yield (n, None)
                    for m in reversed(endSlots[n - 1]):
                        if nodes is None or m in walkNodeSet:
                            yield (m, True)
                else:
                    yield (n, False)

        else:
            for n in walkNodes:
                yield n</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.core.nodes.Nodes"><code class="flex name class">
<span>class <span class="ident">Nodes</span></span>
<span>(</span><span>api)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/6e363a4d004478c07d52ac30b1434f8959a1e9a2/tf/core/nodes.py#L62-L296" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Nodes:
    def __init__(self, api):
        self.api = api
        C = api.C
        Crank = C.rank.data

        self.otypeRank = {d[0]: i for (i, d) in enumerate(reversed(C.levels.data))}
        &#34;&#34;&#34;Dictionary that provides a ranking of the node types.

        The node types are ordered in `C.levels.data`, and if you reverse that list,
        you get the rank of a type by looking at the position in which that type occurs.

        The `slotType` has rank 0 (`otypeRank[F.otype.slotType] == 0`),
        and the more comprehensive a type is, the higher its rank.
        &#34;&#34;&#34;

        self.sortKey = lambda n: Crank[n - 1]
        &#34;&#34;&#34;Sort key function for the canonical ordering between nodes.


        !!! hint &#34;usage&#34;
            The following two pieces of code do the same thing:
            `sortNodes(nodeSet)` and `sorted(nodeSet, key=sortKey)`.

        See Also
        --------
        tf.core.nodes: canonical ordering
        tf.core.nodes.Nodes.sortNodes: sorting nodes
        &#34;&#34;&#34;

        self.sortKeyTuple = lambda tup: tuple(Crank[n - 1] for n in tup)
        &#34;&#34;&#34;Sort key function for the canonical ordering between tuples of nodes.
        It applies `sortKey` to each member of the tuple.
        Handy to sort search results. We can sort them in canonical order like this:

            sorted(results, key=lambda tup: tuple(sortKey(n) for n in tup))

        This is exactly what `sortKeyTuple` does, but then a bit more efficient:

            sorted(results, key=sortKeyTuple)

        See Also
        --------
        tf.core.nodes: canonical ordering
        &#34;&#34;&#34;

        (sortKeyChunk, sortKeyChunkLength) = self.makeSortKeyChunk()

        self.sortKeyChunk = sortKeyChunk
        &#34;&#34;&#34;Sort key function for the canonical ordering between chunks of nodes.

            sorted(chunks, key=sortKeyChunk)

        A chunk is a tuple consisting of a node and a subset of its slots.
        Mostly, this subset of slots is contiguous (no gaps), and mostly it is
        maximal: the slots immediately before and after the chunk do not belong to the node.

        But the sort key also works if these conditions are not met.

        Notes
        -----
        The use case for this function is that we have a bunch of nodes,
        each linked to a set of slots.
        For each node, we have split its slot set in maximal contiguous parts, its chunks.
        Now we want to order those chunks in the canonical ordering.

        See Also
        --------
        tf.core.nodes: canonical ordering
        &#34;&#34;&#34;

        self.sortKeyChunkLength = sortKeyChunkLength

    def makeSortKeyChunk(self):
        api = self.api

        fOtype = api.F.otype
        otypeRank = self.otypeRank
        fOtypev = fOtype.v

        def beforePosition(chunk1, chunk2):
            (n1, (b1, e1)) = chunk1
            (n2, (b2, e2)) = chunk2
            if b1 &lt; b2:
                return -1
            elif b1 &gt; b2:
                return 1

            r1 = otypeRank[fOtypev(n1)]
            r2 = otypeRank[fOtypev(n2)]

            if r1 &gt; r2:
                return -1
            elif r1 &lt; r2:
                return 1

            return (
                -1
                if e1 &gt; e2
                else 1
                if e1 &lt; e2
                else -1
                if n1 &lt; n2
                else 1
                if n1 &gt; n2
                else 0
            )

        def beforeLength(chunk1, chunk2):
            (n1, (b1, e1)) = chunk1
            (n2, (b2, e2)) = chunk2

            size1 = e1 - b1
            size2 = e2 - b2

            if size1 &gt; size2:
                return -1
            elif size2 &gt; size1:
                return 1
            elif b1 &lt; b2:
                return -1
            elif b1 &gt; b2:
                return 1

            r1 = otypeRank[fOtypev(n1)]
            r2 = otypeRank[fOtypev(n2)]

            if r2 &gt; r1:
                return -1
            elif r1 &gt; r2:
                return 1

            return -1 if n1 &lt; n2 else 1 if n1 &gt; n2 else 0

        return (
            functools.cmp_to_key(beforePosition),
            functools.cmp_to_key(beforeLength),
        )

    def sortNodes(self, nodeSet):
        &#34;&#34;&#34;Delivers a tuple of nodes sorted by the *canonical ordering*.

        Parameters
        ----------
        nodeSet: iterable
            An iterable of nodes to be sorted.

        Returns
        -------
        list
            The sorted nodes as list

        See Also
        --------
        tf.core.nodes: canonical ordering
        &#34;&#34;&#34;

        api = self.api

        Crank = api.C.rank.data
        return sorted(nodeSet, key=lambda n: Crank[n - 1])

    def walk(self, nodes=None, events=False):
        &#34;&#34;&#34;Generates all nodes in the *canonical order*.
        (`tf.core.nodes`)

        By `walk()` you traverse all nodes of your corpus
        in a very natural order. See `tf.core.nodes`.

        The order is much like walking a tree in pre-order: first parents,
        then children from left to right.

        The thing is: in general the nodes do not form a tree, but a more
        liberal structure: a graph.

        But even then we can order the nodes in such a way that nodes that embed
        slots from other nodes come before those other nodes, provided those other
        nodes start later.

        When we generate those nodes and consume them, we now when each node starts,
        but we loose track of where exactly they end.

        To remedy that, you can call this function with `events=True`.
        In that case, a stream of events is generated, where each event has the
        form `(node, False)` or `(node, True)`, where `False` means: beginning of
        node and `True` means: end of node.

        In case of slot nodes, only one event per slot is generated: `(node, None)`.

        !!! hint &#34;More ways of walking&#34;
            Under `tf.core.nodefeature.NodeFeatures` there is another convenient way
            to walk through subsets of nodes.

        Parameters
        ----------
        nodes: iterable of int, optional None
            If `None`, walks through all nodes of the corpus in canonical order.
            Otherwise, walks through the given nodes in canonical order.
        events: boolean, optional False
            If True, wraps the generated nodes in event tuples as described above.

        Returns
        -------
        nodes: int
            One at a time.
        &#34;&#34;&#34;

        api = self.api
        C = api.C

        if nodes is None:
            walkNodes = C.order.data
        else:
            walkNodes = self.sortNodes(nodes)
            walkNodeSet = set(nodes)

        if events:
            endSlots = C.boundary.data[1]

            otype = api.F.otype
            Fotypev = otype.v
            slotType = otype.slotType

            for n in walkNodes:
                if Fotypev(n) == slotType:
                    yield (n, None)
                    for m in reversed(endSlots[n - 1]):
                        if nodes is None or m in walkNodeSet:
                            yield (m, True)
                else:
                    yield (n, False)

        else:
            for n in walkNodes:
                yield n</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tf.core.nodes.Nodes.otypeRank"><code class="name">var <span class="ident">otypeRank</span></code></dt>
<dd>
<div class="desc"><p>Dictionary that provides a ranking of the node types.</p>
<p>The node types are ordered in <code>C.levels.data</code>, and if you reverse that list,
you get the rank of a type by looking at the position in which that type occurs.</p>
<p>The <code>slotType</code> has rank 0 (<code>otypeRank[F.otype.slotType] == 0</code>),
and the more comprehensive a type is, the higher its rank.</p></div>
</dd>
<dt id="tf.core.nodes.Nodes.sortKey"><code class="name">var <span class="ident">sortKey</span></code></dt>
<dd>
<div class="desc"><p>Sort key function for the canonical ordering between nodes.</p>
<div class="admonition hint">
<p class="admonition-title">usage</p>
<p>The following two pieces of code do the same thing:
<code>sortNodes(nodeSet)</code> and <code>sorted(nodeSet, key=sortKey)</code>.</p>
</div>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="tf.core.nodes" href="#tf.core.nodes">tf.core.nodes</a></code></dt>
<dd>canonical ordering</dd>
<dt><code><a title="tf.core.nodes.Nodes.sortNodes" href="#tf.core.nodes.Nodes.sortNodes">Nodes.sortNodes()</a></code></dt>
<dd>sorting nodes</dd>
</dl></div>
</dd>
<dt id="tf.core.nodes.Nodes.sortKeyChunk"><code class="name">var <span class="ident">sortKeyChunk</span></code></dt>
<dd>
<div class="desc"><p>Sort key function for the canonical ordering between chunks of nodes.</p>
<pre><code>sorted(chunks, key=sortKeyChunk)
</code></pre>
<p>A chunk is a tuple consisting of a node and a subset of its slots.
Mostly, this subset of slots is contiguous (no gaps), and mostly it is
maximal: the slots immediately before and after the chunk do not belong to the node.</p>
<p>But the sort key also works if these conditions are not met.</p>
<h2 id="notes">Notes</h2>
<p>The use case for this function is that we have a bunch of nodes,
each linked to a set of slots.
For each node, we have split its slot set in maximal contiguous parts, its chunks.
Now we want to order those chunks in the canonical ordering.</p>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="tf.core.nodes" href="#tf.core.nodes">tf.core.nodes</a></code></dt>
<dd>canonical ordering</dd>
</dl></div>
</dd>
<dt id="tf.core.nodes.Nodes.sortKeyTuple"><code class="name">var <span class="ident">sortKeyTuple</span></code></dt>
<dd>
<div class="desc"><p>Sort key function for the canonical ordering between tuples of nodes.
It applies <code>sortKey</code> to each member of the tuple.
Handy to sort search results. We can sort them in canonical order like this:</p>
<pre><code>sorted(results, key=lambda tup: tuple(sortKey(n) for n in tup))
</code></pre>
<p>This is exactly what <code>sortKeyTuple</code> does, but then a bit more efficient:</p>
<pre><code>sorted(results, key=sortKeyTuple)
</code></pre>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="tf.core.nodes" href="#tf.core.nodes">tf.core.nodes</a></code></dt>
<dd>canonical ordering</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tf.core.nodes.Nodes.makeSortKeyChunk"><code class="name flex">
<span>def <span class="ident">makeSortKeyChunk</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/6e363a4d004478c07d52ac30b1434f8959a1e9a2/tf/core/nodes.py#L135-L199" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def makeSortKeyChunk(self):
    api = self.api

    fOtype = api.F.otype
    otypeRank = self.otypeRank
    fOtypev = fOtype.v

    def beforePosition(chunk1, chunk2):
        (n1, (b1, e1)) = chunk1
        (n2, (b2, e2)) = chunk2
        if b1 &lt; b2:
            return -1
        elif b1 &gt; b2:
            return 1

        r1 = otypeRank[fOtypev(n1)]
        r2 = otypeRank[fOtypev(n2)]

        if r1 &gt; r2:
            return -1
        elif r1 &lt; r2:
            return 1

        return (
            -1
            if e1 &gt; e2
            else 1
            if e1 &lt; e2
            else -1
            if n1 &lt; n2
            else 1
            if n1 &gt; n2
            else 0
        )

    def beforeLength(chunk1, chunk2):
        (n1, (b1, e1)) = chunk1
        (n2, (b2, e2)) = chunk2

        size1 = e1 - b1
        size2 = e2 - b2

        if size1 &gt; size2:
            return -1
        elif size2 &gt; size1:
            return 1
        elif b1 &lt; b2:
            return -1
        elif b1 &gt; b2:
            return 1

        r1 = otypeRank[fOtypev(n1)]
        r2 = otypeRank[fOtypev(n2)]

        if r2 &gt; r1:
            return -1
        elif r1 &gt; r2:
            return 1

        return -1 if n1 &lt; n2 else 1 if n1 &gt; n2 else 0

    return (
        functools.cmp_to_key(beforePosition),
        functools.cmp_to_key(beforeLength),
    )</code></pre>
</details>
</dd>
<dt id="tf.core.nodes.Nodes.sortNodes"><code class="name flex">
<span>def <span class="ident">sortNodes</span></span>(<span>self, nodeSet)</span>
</code></dt>
<dd>
<div class="desc"><p>Delivers a tuple of nodes sorted by the <em>canonical ordering</em>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nodeSet</code></strong> :&ensp;<code>iterable</code></dt>
<dd>An iterable of nodes to be sorted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>The sorted nodes as list</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="tf.core.nodes" href="#tf.core.nodes">tf.core.nodes</a></code></dt>
<dd>canonical ordering</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/6e363a4d004478c07d52ac30b1434f8959a1e9a2/tf/core/nodes.py#L201-L222" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sortNodes(self, nodeSet):
    &#34;&#34;&#34;Delivers a tuple of nodes sorted by the *canonical ordering*.

    Parameters
    ----------
    nodeSet: iterable
        An iterable of nodes to be sorted.

    Returns
    -------
    list
        The sorted nodes as list

    See Also
    --------
    tf.core.nodes: canonical ordering
    &#34;&#34;&#34;

    api = self.api

    Crank = api.C.rank.data
    return sorted(nodeSet, key=lambda n: Crank[n - 1])</code></pre>
</details>
</dd>
<dt id="tf.core.nodes.Nodes.walk"><code class="name flex">
<span>def <span class="ident">walk</span></span>(<span>self, nodes=None, events=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates all nodes in the <em>canonical order</em>.
(<code><a title="tf.core.nodes" href="#tf.core.nodes">tf.core.nodes</a></code>)</p>
<p>By <code>walk()</code> you traverse all nodes of your corpus
in a very natural order. See <code><a title="tf.core.nodes" href="#tf.core.nodes">tf.core.nodes</a></code>.</p>
<p>The order is much like walking a tree in pre-order: first parents,
then children from left to right.</p>
<p>The thing is: in general the nodes do not form a tree, but a more
liberal structure: a graph.</p>
<p>But even then we can order the nodes in such a way that nodes that embed
slots from other nodes come before those other nodes, provided those other
nodes start later.</p>
<p>When we generate those nodes and consume them, we now when each node starts,
but we loose track of where exactly they end.</p>
<p>To remedy that, you can call this function with <code>events=True</code>.
In that case, a stream of events is generated, where each event has the
form <code>(node, False)</code> or <code>(node, True)</code>, where <code>False</code> means: beginning of
node and <code>True</code> means: end of node.</p>
<p>In case of slot nodes, only one event per slot is generated: <code>(node, None)</code>.</p>
<div class="admonition hint">
<p class="admonition-title">More ways of walking</p>
<p>Under <code><a title="tf.core.nodefeature.NodeFeatures" href="nodefeature.html#tf.core.nodefeature.NodeFeatures">NodeFeatures</a></code> there is another convenient way
to walk through subsets of nodes.</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nodes</code></strong> :&ensp;<code>iterable</code> of <code>int</code>, optional <code>None</code></dt>
<dd>If <code>None</code>, walks through all nodes of the corpus in canonical order.
Otherwise, walks through the given nodes in canonical order.</dd>
<dt><strong><code>events</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If True, wraps the generated nodes in event tuples as described above.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>nodes</code></strong> :&ensp;<code>int</code></dt>
<dd>One at a time.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/6e363a4d004478c07d52ac30b1434f8959a1e9a2/tf/core/nodes.py#L224-L296" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def walk(self, nodes=None, events=False):
    &#34;&#34;&#34;Generates all nodes in the *canonical order*.
    (`tf.core.nodes`)

    By `walk()` you traverse all nodes of your corpus
    in a very natural order. See `tf.core.nodes`.

    The order is much like walking a tree in pre-order: first parents,
    then children from left to right.

    The thing is: in general the nodes do not form a tree, but a more
    liberal structure: a graph.

    But even then we can order the nodes in such a way that nodes that embed
    slots from other nodes come before those other nodes, provided those other
    nodes start later.

    When we generate those nodes and consume them, we now when each node starts,
    but we loose track of where exactly they end.

    To remedy that, you can call this function with `events=True`.
    In that case, a stream of events is generated, where each event has the
    form `(node, False)` or `(node, True)`, where `False` means: beginning of
    node and `True` means: end of node.

    In case of slot nodes, only one event per slot is generated: `(node, None)`.

    !!! hint &#34;More ways of walking&#34;
        Under `tf.core.nodefeature.NodeFeatures` there is another convenient way
        to walk through subsets of nodes.

    Parameters
    ----------
    nodes: iterable of int, optional None
        If `None`, walks through all nodes of the corpus in canonical order.
        Otherwise, walks through the given nodes in canonical order.
    events: boolean, optional False
        If True, wraps the generated nodes in event tuples as described above.

    Returns
    -------
    nodes: int
        One at a time.
    &#34;&#34;&#34;

    api = self.api
    C = api.C

    if nodes is None:
        walkNodes = C.order.data
    else:
        walkNodes = self.sortNodes(nodes)
        walkNodeSet = set(nodes)

    if events:
        endSlots = C.boundary.data[1]

        otype = api.F.otype
        Fotypev = otype.v
        slotType = otype.slotType

        for n in walkNodes:
            if Fotypev(n) == slotType:
                yield (n, None)
                for m in reversed(endSlots[n - 1]):
                    if nodes is None or m in walkNodeSet:
                        yield (m, True)
            else:
                yield (n, False)

    else:
        for n in walkNodes:
            yield n</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#node-organization">Node organization</a><ul>
<li><a href="#canonical-order">Canonical Order</a></li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.core" href="index.html">tf.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.core.nodes.Nodes" href="#tf.core.nodes.Nodes">Nodes</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.core.nodes.Nodes.makeSortKeyChunk" href="#tf.core.nodes.Nodes.makeSortKeyChunk">makeSortKeyChunk</a></code></li>
<li><code><a title="tf.core.nodes.Nodes.otypeRank" href="#tf.core.nodes.Nodes.otypeRank">otypeRank</a></code></li>
<li><code><a title="tf.core.nodes.Nodes.sortKey" href="#tf.core.nodes.Nodes.sortKey">sortKey</a></code></li>
<li><code><a title="tf.core.nodes.Nodes.sortKeyChunk" href="#tf.core.nodes.Nodes.sortKeyChunk">sortKeyChunk</a></code></li>
<li><code><a title="tf.core.nodes.Nodes.sortKeyTuple" href="#tf.core.nodes.Nodes.sortKeyTuple">sortKeyTuple</a></code></li>
<li><code><a title="tf.core.nodes.Nodes.sortNodes" href="#tf.core.nodes.Nodes.sortNodes">sortNodes</a></code></li>
<li><code><a title="tf.core.nodes.Nodes.walk" href="#tf.core.nodes.Nodes.walk">walk</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>