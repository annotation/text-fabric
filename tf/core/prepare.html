<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.core.prepare API documentation</title>
<meta name="description" content="Precompute data â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.core.prepare</code></h1>
</header>
<section id="section-intro">
<h1 id="precompute-data">Precompute data.</h1>
<p>For Text-Fabric to work efficiently, some
derived data needs to be precomputed.
The precomputed data has a similar function as indexes in a database.</p>
<p>Precomputation is triggered when <code><a title="tf.fabric.Fabric" href="../fabric.html#tf.fabric.Fabric">Fabric</a></code> loads features, and
the order and nature of the steps is configured in
<code><a title="tf.core.fabric.PRECOMPUTE" href="fabric.html#tf.core.fabric.PRECOMPUTE">PRECOMPUTE</a></code>.</p>
<p>The functions in this module implement those tasks.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/032a9079f5468bfcac04aa9be26a85c125f09dfd/tf/core/prepare.py#L1-L756" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# Precompute data.

For Text-Fabric to work efficiently, some  derived data needs to be precomputed.
The precomputed data has a similar function as indexes in a database.

Precomputation is triggered when `tf.fabric.Fabric` loads features, and
the order and nature of the steps is configured in
`tf.core.fabric.PRECOMPUTE`.

The functions in this module implement those tasks.
&#34;&#34;&#34;

import collections
import functools
from array import array
from .helpers import itemize


def levels(info, error, otype, oslots, otext):
    &#34;&#34;&#34;Computes level data.

    For each node type, compute the average number of slots occupied by its nodes,
    and order the node types on that.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    oslots: iterable
        The data of the *oslots* feature.
    otext: iterable
        The data of the *otext* feature.

    Returns
    -------
    tuple
        An ordered tuple, each member with the information of a node type:

        *   node type name
        *   average number of slots contained in the nodes of this type
        *   first node of this type
        *   last node of this type

    The order of the tuple is descending by average number of slots per node of that
    type.

    Notes
    -----
    !!! explanation &#34;Level computation and customization&#34;
        All node types have a level, defined by the average amount of slots object of
        that type usually occupy. The bigger the average object, the lower the levels.
        Books have the lowest level, words the highest level.

        However, this can be overruled. Suppose you have a node type *phrase* and above
        it a node type *cluster*, i.e. phrases are contained in clusters, but not vice
        versa. If all phrases are contained in clusters, and some clusters have more
        than one phrase, the automatic level ranking of node types works out well in
        this case. But if clusters only have very small phrases, and the big phrases do
        not occur in clusters, then the algorithm may assign a lower rank to clusters
        than to phrases.

        In general, it is too expensive to try to compute the levels in a sophisticated
        way. In order to remedy cases where the algorithm assigns wrong levels, you can
        add a `@levels` key to the `otext` config feature.
        See `tf.core.text`.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    levelOrder = otext.get(&#34;levels&#34;, None)
    if levelOrder is not None:
        levelRank = {level: i for (i, level) in enumerate(levelOrder.split(&#34;,&#34;))}
    otypeCount = collections.Counter()
    otypeMin = {}
    otypeMax = {}
    slotSetLengths = collections.Counter()
    info(&#34;get ranking of otypes&#34;)
    for k in range(len(oslots)):
        ntp = otype[k]
        otypeCount[ntp] += 1
        slotSetLengths[ntp] += len(oslots[k])
        tfn = k + maxSlot + 1
        if ntp not in otypeMin:
            otypeMin[ntp] = tfn
        if ntp not in otypeMax or otypeMax[ntp] &lt; tfn:
            otypeMax[ntp] = tfn
    sortKey = (lambda x: -x[1]) if levelOrder is None else (lambda x: levelRank[x[0]])
    result = tuple(
        sorted(
            (
                (
                    ntp,
                    slotSetLengths[ntp] / otypeCount[ntp],
                    otypeMin[ntp],
                    otypeMax[ntp],
                )
                for ntp in otypeCount
            ),
            key=sortKey,
        )
        + [(slotType, 1, 1, maxSlot)]
    )
    info(&#34;results:&#34;)
    for (otp, av, omin, omax) in result:
        info(f&#34;{otp:&lt;15}: {round(av, 2):&gt;8} {{{omin}-{omax}}}&#34;, tm=False)
    return result


def order(info, error, otype, oslots, levels):
    &#34;&#34;&#34;Computes order data for the canonical ordering.

    The canonical ordering between nodes is defined in terms of the slots that
    nodes contain, and if that is not decisive, the rank of the node type is taken
    into account, and if that is still not decisive, the node itself is taken into
    account.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    oslots: iterable
        The data of the *oslots* feature.
    levels: tuple
        The data of the *levels* precompute step.

    Returns
    -------
    tuple
        All nodes, slot and nonslot, in canonical order.

    See Also
    --------
    tf.core.nodes: canonical ordering
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    info(&#34;assigning otype levels to nodes&#34;)
    otypeLevels = dict(((x[0], i) for (i, x) in enumerate(reversed(levels))))

    def otypeRank(n):
        return otypeLevels[slotType if n &lt; maxSlot + 1 else otype[n - maxSlot - 1]]

    def before(na, nb):
        if na &lt; maxSlot + 1:
            a = na
            sa = {a}
        else:
            a = na - maxSlot
            sa = set(oslots[a - 1])
        if nb &lt; maxSlot + 1:
            b = nb
            sb = {b}
        else:
            b = nb - maxSlot
            sb = set(oslots[b - 1])
        oa = otypeRank(na)
        ob = otypeRank(nb)
        if sa == sb:
            return (
                (-1 if na &lt; nb else 1 if na &gt; nb else 0)
                if oa == ob
                else -1
                if oa &gt; ob
                else 1
            )
        if sa &gt; sb:
            return -1
        if sa &lt; sb:
            return 1
        am = min(sa - sb)
        bm = min(sb - sa)
        return -1 if am &lt; bm else 1 if bm &lt; am else 0

    canonKey = functools.cmp_to_key(before)
    info(&#34;sorting nodes&#34;)
    nodes = sorted(range(1, maxNode + 1), key=canonKey)
    # return array(&#34;I&#34;, nodes)
    return tuple(nodes)


def rank(info, error, otype, order):
    &#34;&#34;&#34;Computes rank data.

    The rank of a node is its place in among the other nodes in the
    canonical order (see `tf.core.nodes`).

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    order: tuple
        The data of the *order* feature.

    Returns
    -------
    tuple
        The ranks of all nodes, slot and nonslot, with respect to the canonical order.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    info(&#34;ranking nodes&#34;)
    nodesRank = dict(((n, i) for (i, n) in enumerate(order)))
    return array(&#34;I&#34;, (nodesRank[n] for n in range(1, maxNode + 1)))
    # return tuple((nodesRank[n] for n in range(1, maxNode + 1)))


def levUp(info, error, otype, oslots, rank):
    &#34;&#34;&#34;Computes level-up data.

    Level-up data is used by the API function `tf.core.locality.Locality.u`.

    This function computes the embedders of a node by looking them up from
    the level-up data.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    oslots: iterable
        The data of the *oslots* feature.
    rank: tuple
        The data of the *rank* precompute step.

    Returns
    -------
    tuple
        The n-th member is an tuple of the embedder nodes of n.
        Those tuples are sorted in canonical order (`tf.core.nodes`).

    Notes
    -----
    !!! hint &#34;Memory efficiency&#34;
        Many nodes have the same tuple of embedders.
        Those embedder tuples will be reused for those nodes.

    Warnings
    --------
    It is not advisable to this data directly by `C.levUp.data`,
    it is far better to use the `tf.core.locality.Locality.u` function.

    Only when every bit of performance waste has to be squeezed out,
    this raw data might be a deal.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    info(&#34;making inverse of edge feature oslots&#34;)
    oslotsInv = {}
    for (k, mList) in enumerate(oslots):
        for m in mList:
            oslotsInv.setdefault(m, set()).add(k + 1 + maxSlot)
    info(&#34;listing embedders of all nodes&#34;)
    embedders = []
    for n in range(1, maxSlot + 1):
        contentEmbedders = oslotsInv.get(n, tuple())
        embedders.append(
            tuple(
                sorted(
                    [m for m in contentEmbedders if m != n], key=lambda k: -rank[k - 1],
                )
            )
        )
    for n in range(maxSlot + 1, maxNode + 1):
        mList = oslots[n - maxSlot - 1]
        if len(mList) == 0:
            embedders.append(tuple())
        else:
            contentEmbedders = functools.reduce(
                lambda x, y: x &amp; oslotsInv[y], mList[1:], oslotsInv[mList[0]],
            )
            embedders.append(
                tuple(
                    sorted(
                        [m for m in contentEmbedders if m != n],
                        key=lambda k: -rank[k - 1],
                    )
                )
            )
    # reuse embedder tuples, because lots of nodes share embedders
    seen = {}
    embeddersx = []
    for t in embedders:
        if t not in seen:
            # seen[t] = array(&#34;I&#34;, t)
            seen[t] = tuple(t)
        embeddersx.append(seen[t])
    return tuple(embeddersx)


def levDown(info, error, otype, levUp, rank):
    &#34;&#34;&#34;Computes level-down data.

    Level-down data is used by the API function `tf.core.locality.Locality.d`.

    This function computes the embedded nodes of a node by looking them up from
    the level-down data.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    levUp: iterable
        The data of the *levUp* precompute step.
    rank: tuple
        The data of the *rank* precompute step.

    Returns
    -------
    tuple
        The *n*-th member is an tuple of the embedded nodes of *n + maxSlot*.
        Those tuples are sorted in canonical order (`tf.core.nodes`).

    !!! hint &#34;Memory efficiency&#34;
        Slot nodes do not have embedded nodes, so they do not have to occupy
        space in this tuple. Hence the first member are the embedded nodes
        of node *maxSlot + 1*.

    !!! caution &#34;Use with care&#34;
        It is not advisable to this data directly by `C.levDown.data`,
        it is far better to use the `tf.core.locality.Locality.d` function.

        Only when every bit of performance waste has to be squeezed out,
        this raw data might be a deal.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    info(&#34;inverting embedders&#34;)
    inverse = {}
    for n in range(maxSlot + 1, maxNode + 1):
        for m in levUp[n - 1]:
            inverse.setdefault(m, set()).add(n)
    info(&#34;turning embeddees into list&#34;)
    embeddees = []
    for n in range(maxSlot + 1, maxNode + 1):
        embeddees.append(
            array(&#34;I&#34;, sorted(inverse.get(n, []), key=lambda m: rank[m - 1]))
            # tuple(sorted(inverse.get(n, []), key=lambda m: rank[m - 1]))
        )
    return tuple(embeddees)


def characters(info, error, otext, tFormats, *tFeats):
    &#34;&#34;&#34;Computes character data.

    For each text format, a frequency list of the characters in that format
    is made.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otext: iterable
        The data of the *otext* feature.
    tFormats:
        Dictionary keyed by text format and valued by the tuple of features
        used in that format.
    tFeats: iterable
        Each tFeat is the name and the data of a text feature.
        i.e. a feature used in text formats.

    Returns
    -------
    dict
        Keyed by format valued by a frequency dict, which is
        itself keyed by single characters and valued by the frequency
        of that character in the whole corpus when rendered with that format.
    &#34;&#34;&#34;

    charFreqsByFeature = {}

    for (tFeat, data) in tFeats:
        freqList = collections.Counter()
        if data is not None:
            for v in data.values():
                freqList[v] += 1
        charFreq = collections.defaultdict(lambda: 0)
        for (v, freq) in freqList.items():
            for c in str(v):
                charFreq[c] += freq
        charFreqsByFeature[tFeat] = charFreq

    charFreqsByFmt = {}

    for (fmt, tFeatures) in sorted(tFormats.items()):
        charFreq = collections.defaultdict(lambda: 0)
        for tFeat in tFeatures:
            thisCharFreq = charFreqsByFeature[tFeat]
            for (c, freq) in thisCharFreq.items():
                charFreq[c] += freq
        charFreqsByFmt[fmt] = sorted(x for x in charFreq.items())

    return charFreqsByFmt


def boundary(info, error, otype, oslots, rank):
    &#34;&#34;&#34;Computes boundary data.

    For each slot, the nodes that start at that slot and the nodes that end
    at that slot are collected.

    Boundary data is used by the API functions
    `tf.core.locality.Locality.p`.
    and
    `tf.core.locality.Locality.n`.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    oslots: iterable
        The data of the *oslots* feature.
    rank: tuple
        The data of the *rank* precompute step.

    Returns
    -------
    tuple
        *   first: tuple of tuple
            The *n*-th member is the tuple of nodes that start at slot *n*,
            ordered in *reversed* canonical order (`tf.core.nodes`);
        *   last: tuple of tuple
            The *n*-th member is the tuple of nodes that end at slot *n*,
            ordered in canonical order;

    Notes
    -----
    !!! hint &#34;why  reversed canonical order?&#34;
        Just for symmetry.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    firstSlotsD = {}
    lastSlotsD = {}

    for (node, slots) in enumerate(oslots):
        realNode = node + 1 + maxSlot
        firstSlotsD.setdefault(slots[0], []).append(realNode)
        lastSlotsD.setdefault(slots[-1], []).append(realNode)

    firstSlots = tuple(
        tuple(sorted(firstSlotsD.get(n, []), key=lambda node: -rank[node - 1]))
        # array(&#34;I&#34;, sorted(firstSlotsD.get(n, []), key=lambda node: -rank[node - 1]))
        for n in range(1, maxSlot + 1)
    )
    lastSlots = tuple(
        tuple(sorted(lastSlotsD.get(n, []), key=lambda node: rank[node - 1]))
        # array(&#34;I&#34;, sorted(lastSlotsD.get(n, []), key=lambda node: rank[node - 1]))
        for n in range(1, maxSlot + 1)
    )
    return (firstSlots, lastSlots)


def sections(info, error, otype, oslots, otext, levUp, levels, *sFeats):
    &#34;&#34;&#34;Computes section data.

    Text-Fabric datasets may define up to three section levels, roughly corresponding
    with a volume, a chapter, a paragraph.

    If the corpus has a richer section structure, it is also possible
    a different, more flexible and more extensive nest of structural sections.
    See `structure`.

    Text-Fabric must be able to go from sections at one level to the sections
    at one level lower. It must also be able to map section headings
    to nodes. For this, the section features are needed, since they
    contain the section headings.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    oslots: iterable
        The data of the *oslots* feature.
    otext: iterable
        The data of the *otext* feature.
    levUp: tuple
        The data of the *levUp* precompute step.
    levels: tuple
        The data of the *levels* precompute step.
    sFeats: iterable
        Each sFeat is the data of a section feature.

    Returns
    -------
    tuple
        *   sec1
            Mapping from section-level-1 nodes to mappings from
            section-level-2 headings to section-level2 nodes.
        *   sec2
            Mapping from section-level-1 nodes to mappings from
            section-level-2 headings to mappings from
            section-level3 headings to section-level-3 nodes.

    Warnings
    --------
    Note that the terms `book`, `chapter`, `verse` are not baked into Text-Fabric.
    It is the corpus data, especially the `otext` config feature that
    spells out the names of the sections.

    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    support = {level[0]: (level[2], level[3]) for level in levels}
    sTypes = itemize(otext[&#34;sectionTypes&#34;], &#34;,&#34;)
    sec1 = {}
    sec2 = {}
    nestingProblems = collections.Counter()

    if len(sTypes) &lt; 2:
        pass

    elif len(sTypes) &lt; 3:
        c1 = 0
        support1 = support[sTypes[1]]
        for n1 in range(support1[0], support1[1] + 1):
            n0s = tuple(x for x in levUp[n1 - 1] if otype[x - maxSlot - 1] == sTypes[0])
            if not n0s:
                nestingProblems[
                    f&#34;section {sTypes[1]} without containing {sTypes[0]}&#34;
                ] += 1
                continue
            n0 = n0s[0]
            n1head = sFeats[1].get(n1, None)
            if n1head is None:
                nestingProblems[
                    f&#34;{sTypes[1]}-node {n1} has no section heading&#34;
                ] += 1
            if n0 not in sec1:
                sec1[n0] = {}
            if n1head not in sec1[n0]:
                sec1[n0][n1head] = n1
                c1 += 1
        info(f&#34;{c1} {sTypes[1]}s indexed&#34;)

    else:
        c1 = 0
        c2 = 0
        support2 = support[sTypes[2]]
        for n2 in range(support2[0], support2[1] + 1):
            n0s = tuple(x for x in levUp[n2 - 1] if otype[x - maxSlot - 1] == sTypes[0])
            if not n0s:
                nestingProblems[
                    f&#34;section {sTypes[2]} without containing {sTypes[0]}&#34;
                ] += 1
                continue
            n0 = n0s[0]

            n1s = tuple(x for x in levUp[n2 - 1] if otype[x - maxSlot - 1] == sTypes[1])
            if not n1s:
                nestingProblems[
                    f&#34;section {sTypes[2]} without containing {sTypes[1]}&#34;
                ] += 1
                continue
            n1 = n1s[0]

            n1head = sFeats[1].get(n1, None)
            if n1head is None:
                nestingProblems[
                    f&#34;{sTypes[1]}-node {n1} has no section heading&#34;
                ] += 1
            n2head = sFeats[2].get(n2, None)
            if n2head is None:
                nestingProblems[
                    f&#34;{sTypes[2]}-node {n2} has no section heading&#34;
                ] += 1

            if n0 not in sec1:
                sec1[n0] = {}
            if n1head not in sec1[n0]:
                sec1[n0][n1head] = n1
                c1 += 1
            sec2.setdefault(n0, {}).setdefault(n1head, {})[n2head] = n2
            c2 += 1
        info(f&#34;{c1} {sTypes[1]}s and {c2} {sTypes[2]}s indexed&#34;)

    if nestingProblems:
        for (msg, amount) in sorted(nestingProblems.items()):
            error(f&#34;WARNING: {amount:&gt;4} x {msg}&#34;)

    return (sec1, sec2)


def structure(info, error, otype, oslots, otext, rank, levUp, *sFeats):
    &#34;&#34;&#34;Computes structure data.

    If the corpus has a rich section structure, it is possible to define
    a flexible and extensive nest of structural sections.

    Independent of this,
    Text-Fabric datasets may also define up to three section levels,
    roughly corresponding with a volume, a chapter, a paragraph.
    See `sections`.

    Text-Fabric must be able to go from sections at one level to the sections
    at one level lower. It must also be able to map section headings
    to nodes. For this, the section features are needed, since they
    contain the section headings.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    oslots: iterable
        The data of the *oslots* feature.
    otext: iterable
        The data of the *otext* feature.
    rank: tuple
        The data of the *rank* precompute step.
    levUp: tuple
        The data of the *levUp* precompute step.
    sFeats: iterable
        Each sFeat the data of a section feature.

    Returns
    -------
    tuple
        *   headingFromNode
            (Mapping from nodes to section keys)
        *   nodeFromHeading
            (Mapping from section keys to nodes)
        *   multiple
        *   top
        *   up
        *   down

    Notes
    -----
    A section key of a structural node is obtained by going a level up from
    that node, retrieving the heading of that structural node, then going up again,
    and so on till a top node is reached. The tuple of headings obtained in this way
    is the  section key.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    sTypeList = itemize(otext[&#34;structureTypes&#34;], &#34;,&#34;)
    nsTypes = len(sTypeList)
    nsFeats = len(sFeats)

    if nsTypes != nsFeats:
        error(
            f&#34;WARNING: {nsTypes} structure levels but {nsFeats} corresponding features&#34;
        )
        return ({}, {})

    sTypes = set(sTypeList)
    if len(sTypes) != nsTypes:
        error(&#34;WARNING: duplicate structure levels&#34;)
        return ({}, {})

    higherTypes = collections.defaultdict(set)
    for (i, highType) in enumerate(sTypeList):
        for lowType in sTypeList[i:]:
            higherTypes[lowType].add(highType)

    featFromType = {sTypeList[i]: sFeats[i] for i in range(nsTypes)}

    multiple = collections.defaultdict(list)
    headingFromNode = {}
    nodeFromHeading = {}

    for n in range(maxSlot + 1, maxNode + 1):
        nType = otype[n - maxSlot - 1]
        if nType not in sTypes:
            continue
        ups = (u for u in levUp[n - 1] if otype[u - maxSlot - 1] in higherTypes[nType])
        sKey = tuple(
            reversed(
                tuple(
                    (
                        otype[x - maxSlot - 1],
                        featFromType[otype[x - maxSlot - 1]].get(x, None),
                    )
                    for x in (n, *ups)
                )
            )
        )

        if sKey in nodeFromHeading:
            if sKey not in multiple:
                multiple[sKey].append(nodeFromHeading[sKey])
            multiple[sKey].append(n)
        nodeFromHeading[sKey] = n
        headingFromNode[n] = sKey
    multiple = {
        sKey: tuple(sorted(ns, key=lambda n: rank[n - 1]))
        for (sKey, ns) in multiple.items()
    }

    top = tuple(
        sorted(
            (n for (n, h) in headingFromNode.items() if len(h) == 1),
            key=lambda n: rank[n - 1],
        )
    )

    up = {}
    for (n, heading) in headingFromNode.items():
        lHeading = len(heading)
        if lHeading == 1:
            continue
        upNode = None
        for i in range(lHeading - 1, 0, -1):
            upHeading = heading[0:i]
            upNode = nodeFromHeading.get(upHeading, None)
            if upNode is not None:
                up[n] = upNode
                break

    down = {}
    for (n, heading) in headingFromNode.items():
        if len(heading) == 1:
            continue
        down.setdefault(up[n], []).append(n)

    down = {n: tuple(sorted(ms, key=lambda m: rank[m - 1])) for (n, ms) in down.items()}

    return (headingFromNode, nodeFromHeading, multiple, top, up, down)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.core.prepare.boundary"><code class="name flex">
<span>def <span class="ident">boundary</span></span>(<span>info, error, otype, oslots, rank)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes boundary data.</p>
<p>For each slot, the nodes that start at that slot and the nodes that end
at that slot are collected.</p>
<p>Boundary data is used by the API functions
<code><a title="tf.core.locality.Locality.p" href="locality.html#tf.core.locality.Locality.p">Locality.p()</a></code>.
and
<code><a title="tf.core.locality.Locality.n" href="locality.html#tf.core.locality.Locality.n">Locality.n()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otype</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>otype</em> feature.</dd>
<dt><strong><code>oslots</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>oslots</em> feature.</dd>
<dt><strong><code>rank</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The data of the <em>rank</em> precompute step.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>
<ul>
<li>first: tuple of tuple
The <em>n</em>-th member is the tuple of nodes that start at slot <em>n</em>,
ordered in <em>reversed</em> canonical order (<code><a title="tf.core.nodes" href="nodes.html">tf.core.nodes</a></code>);</li>
<li>last: tuple of tuple
The <em>n</em>-th member is the tuple of nodes that end at slot <em>n</em>,
ordered in canonical order;</li>
</ul>
</dd>
</dl>
<h2 id="notes">Notes</h2>
<div class="admonition hint">
<p class="admonition-title">why
reversed canonical order?</p>
<p>Just for symmetry.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/032a9079f5468bfcac04aa9be26a85c125f09dfd/tf/core/prepare.py#L419-L479" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def boundary(info, error, otype, oslots, rank):
    &#34;&#34;&#34;Computes boundary data.

    For each slot, the nodes that start at that slot and the nodes that end
    at that slot are collected.

    Boundary data is used by the API functions
    `tf.core.locality.Locality.p`.
    and
    `tf.core.locality.Locality.n`.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    oslots: iterable
        The data of the *oslots* feature.
    rank: tuple
        The data of the *rank* precompute step.

    Returns
    -------
    tuple
        *   first: tuple of tuple
            The *n*-th member is the tuple of nodes that start at slot *n*,
            ordered in *reversed* canonical order (`tf.core.nodes`);
        *   last: tuple of tuple
            The *n*-th member is the tuple of nodes that end at slot *n*,
            ordered in canonical order;

    Notes
    -----
    !!! hint &#34;why  reversed canonical order?&#34;
        Just for symmetry.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    firstSlotsD = {}
    lastSlotsD = {}

    for (node, slots) in enumerate(oslots):
        realNode = node + 1 + maxSlot
        firstSlotsD.setdefault(slots[0], []).append(realNode)
        lastSlotsD.setdefault(slots[-1], []).append(realNode)

    firstSlots = tuple(
        tuple(sorted(firstSlotsD.get(n, []), key=lambda node: -rank[node - 1]))
        # array(&#34;I&#34;, sorted(firstSlotsD.get(n, []), key=lambda node: -rank[node - 1]))
        for n in range(1, maxSlot + 1)
    )
    lastSlots = tuple(
        tuple(sorted(lastSlotsD.get(n, []), key=lambda node: rank[node - 1]))
        # array(&#34;I&#34;, sorted(lastSlotsD.get(n, []), key=lambda node: rank[node - 1]))
        for n in range(1, maxSlot + 1)
    )
    return (firstSlots, lastSlots)</code></pre>
</details>
</dd>
<dt id="tf.core.prepare.characters"><code class="name flex">
<span>def <span class="ident">characters</span></span>(<span>info, error, otext, tFormats, *tFeats)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes character data.</p>
<p>For each text format, a frequency list of the characters in that format
is made.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otext</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>otext</em> feature.</dd>
<dt>tFormats:</dt>
<dt>Dictionary keyed by text format and valued by the tuple of features</dt>
<dt>used in that format.</dt>
<dt><strong><code>tFeats</code></strong> :&ensp;<code>iterable</code></dt>
<dd>Each tFeat is the name and the data of a text feature.
i.e. a feature used in text formats.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Keyed by format valued by a frequency dict, which is
itself keyed by single characters and valued by the frequency
of that character in the whole corpus when rendered with that format.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/032a9079f5468bfcac04aa9be26a85c125f09dfd/tf/core/prepare.py#L364-L416" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def characters(info, error, otext, tFormats, *tFeats):
    &#34;&#34;&#34;Computes character data.

    For each text format, a frequency list of the characters in that format
    is made.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otext: iterable
        The data of the *otext* feature.
    tFormats:
        Dictionary keyed by text format and valued by the tuple of features
        used in that format.
    tFeats: iterable
        Each tFeat is the name and the data of a text feature.
        i.e. a feature used in text formats.

    Returns
    -------
    dict
        Keyed by format valued by a frequency dict, which is
        itself keyed by single characters and valued by the frequency
        of that character in the whole corpus when rendered with that format.
    &#34;&#34;&#34;

    charFreqsByFeature = {}

    for (tFeat, data) in tFeats:
        freqList = collections.Counter()
        if data is not None:
            for v in data.values():
                freqList[v] += 1
        charFreq = collections.defaultdict(lambda: 0)
        for (v, freq) in freqList.items():
            for c in str(v):
                charFreq[c] += freq
        charFreqsByFeature[tFeat] = charFreq

    charFreqsByFmt = {}

    for (fmt, tFeatures) in sorted(tFormats.items()):
        charFreq = collections.defaultdict(lambda: 0)
        for tFeat in tFeatures:
            thisCharFreq = charFreqsByFeature[tFeat]
            for (c, freq) in thisCharFreq.items():
                charFreq[c] += freq
        charFreqsByFmt[fmt] = sorted(x for x in charFreq.items())

    return charFreqsByFmt</code></pre>
</details>
</dd>
<dt id="tf.core.prepare.levDown"><code class="name flex">
<span>def <span class="ident">levDown</span></span>(<span>info, error, otype, levUp, rank)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes level-down data.</p>
<p>Level-down data is used by the API function <code><a title="tf.core.locality.Locality.d" href="locality.html#tf.core.locality.Locality.d">Locality.d()</a></code>.</p>
<p>This function computes the embedded nodes of a node by looking them up from
the level-down data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otype</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>otype</em> feature.</dd>
<dt><strong><code>levUp</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>levUp</em> precompute step.</dd>
<dt><strong><code>rank</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The data of the <em>rank</em> precompute step.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>The <em>n</em>-th member is an tuple of the embedded nodes of <em>n + maxSlot</em>.
Those tuples are sorted in canonical order (<code><a title="tf.core.nodes" href="nodes.html">tf.core.nodes</a></code>).</dd>
</dl>
<div class="admonition hint">
<p class="admonition-title">Memory efficiency</p>
<p>Slot nodes do not have embedded nodes, so they do not have to occupy
space in this tuple. Hence the first member are the embedded nodes
of node <em>maxSlot + 1</em>.</p>
</div>
<div class="admonition caution">
<p class="admonition-title">Use with care</p>
<p>It is not advisable to this data directly by <code>C.levDown.data</code>,
it is far better to use the <code><a title="tf.core.locality.Locality.d" href="locality.html#tf.core.locality.Locality.d">Locality.d()</a></code> function.</p>
<p>Only when every bit of performance waste has to be squeezed out,
this raw data might be a deal.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/032a9079f5468bfcac04aa9be26a85c125f09dfd/tf/core/prepare.py#L308-L361" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def levDown(info, error, otype, levUp, rank):
    &#34;&#34;&#34;Computes level-down data.

    Level-down data is used by the API function `tf.core.locality.Locality.d`.

    This function computes the embedded nodes of a node by looking them up from
    the level-down data.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    levUp: iterable
        The data of the *levUp* precompute step.
    rank: tuple
        The data of the *rank* precompute step.

    Returns
    -------
    tuple
        The *n*-th member is an tuple of the embedded nodes of *n + maxSlot*.
        Those tuples are sorted in canonical order (`tf.core.nodes`).

    !!! hint &#34;Memory efficiency&#34;
        Slot nodes do not have embedded nodes, so they do not have to occupy
        space in this tuple. Hence the first member are the embedded nodes
        of node *maxSlot + 1*.

    !!! caution &#34;Use with care&#34;
        It is not advisable to this data directly by `C.levDown.data`,
        it is far better to use the `tf.core.locality.Locality.d` function.

        Only when every bit of performance waste has to be squeezed out,
        this raw data might be a deal.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    info(&#34;inverting embedders&#34;)
    inverse = {}
    for n in range(maxSlot + 1, maxNode + 1):
        for m in levUp[n - 1]:
            inverse.setdefault(m, set()).add(n)
    info(&#34;turning embeddees into list&#34;)
    embeddees = []
    for n in range(maxSlot + 1, maxNode + 1):
        embeddees.append(
            array(&#34;I&#34;, sorted(inverse.get(n, []), key=lambda m: rank[m - 1]))
            # tuple(sorted(inverse.get(n, []), key=lambda m: rank[m - 1]))
        )
    return tuple(embeddees)</code></pre>
</details>
</dd>
<dt id="tf.core.prepare.levUp"><code class="name flex">
<span>def <span class="ident">levUp</span></span>(<span>info, error, otype, oslots, rank)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes level-up data.</p>
<p>Level-up data is used by the API function <code><a title="tf.core.locality.Locality.u" href="locality.html#tf.core.locality.Locality.u">Locality.u()</a></code>.</p>
<p>This function computes the embedders of a node by looking them up from
the level-up data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otype</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>otype</em> feature.</dd>
<dt><strong><code>oslots</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>oslots</em> feature.</dd>
<dt><strong><code>rank</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The data of the <em>rank</em> precompute step.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>The n-th member is an tuple of the embedder nodes of n.
Those tuples are sorted in canonical order (<code><a title="tf.core.nodes" href="nodes.html">tf.core.nodes</a></code>).</dd>
</dl>
<h2 id="notes">Notes</h2>
<div class="admonition hint">
<p class="admonition-title">Memory efficiency</p>
<p>Many nodes have the same tuple of embedders.
Those embedder tuples will be reused for those nodes.</p>
</div>
<h2 id="warnings">Warnings</h2>
<p>It is not advisable to this data directly by <code>C.levUp.data</code>,
it is far better to use the <code><a title="tf.core.locality.Locality.u" href="locality.html#tf.core.locality.Locality.u">Locality.u()</a></code> function.</p>
<p>Only when every bit of performance waste has to be squeezed out,
this raw data might be a deal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/032a9079f5468bfcac04aa9be26a85c125f09dfd/tf/core/prepare.py#L221-L305" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def levUp(info, error, otype, oslots, rank):
    &#34;&#34;&#34;Computes level-up data.

    Level-up data is used by the API function `tf.core.locality.Locality.u`.

    This function computes the embedders of a node by looking them up from
    the level-up data.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    oslots: iterable
        The data of the *oslots* feature.
    rank: tuple
        The data of the *rank* precompute step.

    Returns
    -------
    tuple
        The n-th member is an tuple of the embedder nodes of n.
        Those tuples are sorted in canonical order (`tf.core.nodes`).

    Notes
    -----
    !!! hint &#34;Memory efficiency&#34;
        Many nodes have the same tuple of embedders.
        Those embedder tuples will be reused for those nodes.

    Warnings
    --------
    It is not advisable to this data directly by `C.levUp.data`,
    it is far better to use the `tf.core.locality.Locality.u` function.

    Only when every bit of performance waste has to be squeezed out,
    this raw data might be a deal.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    info(&#34;making inverse of edge feature oslots&#34;)
    oslotsInv = {}
    for (k, mList) in enumerate(oslots):
        for m in mList:
            oslotsInv.setdefault(m, set()).add(k + 1 + maxSlot)
    info(&#34;listing embedders of all nodes&#34;)
    embedders = []
    for n in range(1, maxSlot + 1):
        contentEmbedders = oslotsInv.get(n, tuple())
        embedders.append(
            tuple(
                sorted(
                    [m for m in contentEmbedders if m != n], key=lambda k: -rank[k - 1],
                )
            )
        )
    for n in range(maxSlot + 1, maxNode + 1):
        mList = oslots[n - maxSlot - 1]
        if len(mList) == 0:
            embedders.append(tuple())
        else:
            contentEmbedders = functools.reduce(
                lambda x, y: x &amp; oslotsInv[y], mList[1:], oslotsInv[mList[0]],
            )
            embedders.append(
                tuple(
                    sorted(
                        [m for m in contentEmbedders if m != n],
                        key=lambda k: -rank[k - 1],
                    )
                )
            )
    # reuse embedder tuples, because lots of nodes share embedders
    seen = {}
    embeddersx = []
    for t in embedders:
        if t not in seen:
            # seen[t] = array(&#34;I&#34;, t)
            seen[t] = tuple(t)
        embeddersx.append(seen[t])
    return tuple(embeddersx)</code></pre>
</details>
</dd>
<dt id="tf.core.prepare.levels"><code class="name flex">
<span>def <span class="ident">levels</span></span>(<span>info, error, otype, oslots, otext)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes level data.</p>
<p>For each node type, compute the average number of slots occupied by its nodes,
and order the node types on that.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otype</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>otype</em> feature.</dd>
<dt><strong><code>oslots</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>oslots</em> feature.</dd>
<dt><strong><code>otext</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>otext</em> feature.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>
<p>An ordered tuple, each member with the information of a node type:</p>
<ul>
<li>node type name</li>
<li>average number of slots contained in the nodes of this type</li>
<li>first node of this type</li>
<li>last node of this type</li>
</ul>
</dd>
<dt><code>The <a title="tf.core.prepare.order" href="#tf.core.prepare.order">order()</a></code> of <code>the tuple is descending by average number</code> of <code>slots per node</code> of <code>that</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>type.</p>
<h2 id="notes">Notes</h2>
<div class="admonition explanation">
<p class="admonition-title">Level computation and customization</p>
<p>All node types have a level, defined by the average amount of slots object of
that type usually occupy. The bigger the average object, the lower the levels.
Books have the lowest level, words the highest level.</p>
<p>However, this can be overruled. Suppose you have a node type <em>phrase</em> and above
it a node type <em>cluster</em>, i.e. phrases are contained in clusters, but not vice
versa. If all phrases are contained in clusters, and some clusters have more
than one phrase, the automatic level ranking of node types works out well in
this case. But if clusters only have very small phrases, and the big phrases do
not occur in clusters, then the algorithm may assign a lower rank to clusters
than to phrases.</p>
<p>In general, it is too expensive to try to compute the levels in a sophisticated
way. In order to remedy cases where the algorithm assigns wrong levels, you can
add a <code>@levels</code> key to the <code>otext</code> config feature.
See <code><a title="tf.core.text" href="text.html">tf.core.text</a></code>.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/032a9079f5468bfcac04aa9be26a85c125f09dfd/tf/core/prepare.py#L20-L111" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def levels(info, error, otype, oslots, otext):
    &#34;&#34;&#34;Computes level data.

    For each node type, compute the average number of slots occupied by its nodes,
    and order the node types on that.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    oslots: iterable
        The data of the *oslots* feature.
    otext: iterable
        The data of the *otext* feature.

    Returns
    -------
    tuple
        An ordered tuple, each member with the information of a node type:

        *   node type name
        *   average number of slots contained in the nodes of this type
        *   first node of this type
        *   last node of this type

    The order of the tuple is descending by average number of slots per node of that
    type.

    Notes
    -----
    !!! explanation &#34;Level computation and customization&#34;
        All node types have a level, defined by the average amount of slots object of
        that type usually occupy. The bigger the average object, the lower the levels.
        Books have the lowest level, words the highest level.

        However, this can be overruled. Suppose you have a node type *phrase* and above
        it a node type *cluster*, i.e. phrases are contained in clusters, but not vice
        versa. If all phrases are contained in clusters, and some clusters have more
        than one phrase, the automatic level ranking of node types works out well in
        this case. But if clusters only have very small phrases, and the big phrases do
        not occur in clusters, then the algorithm may assign a lower rank to clusters
        than to phrases.

        In general, it is too expensive to try to compute the levels in a sophisticated
        way. In order to remedy cases where the algorithm assigns wrong levels, you can
        add a `@levels` key to the `otext` config feature.
        See `tf.core.text`.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    levelOrder = otext.get(&#34;levels&#34;, None)
    if levelOrder is not None:
        levelRank = {level: i for (i, level) in enumerate(levelOrder.split(&#34;,&#34;))}
    otypeCount = collections.Counter()
    otypeMin = {}
    otypeMax = {}
    slotSetLengths = collections.Counter()
    info(&#34;get ranking of otypes&#34;)
    for k in range(len(oslots)):
        ntp = otype[k]
        otypeCount[ntp] += 1
        slotSetLengths[ntp] += len(oslots[k])
        tfn = k + maxSlot + 1
        if ntp not in otypeMin:
            otypeMin[ntp] = tfn
        if ntp not in otypeMax or otypeMax[ntp] &lt; tfn:
            otypeMax[ntp] = tfn
    sortKey = (lambda x: -x[1]) if levelOrder is None else (lambda x: levelRank[x[0]])
    result = tuple(
        sorted(
            (
                (
                    ntp,
                    slotSetLengths[ntp] / otypeCount[ntp],
                    otypeMin[ntp],
                    otypeMax[ntp],
                )
                for ntp in otypeCount
            ),
            key=sortKey,
        )
        + [(slotType, 1, 1, maxSlot)]
    )
    info(&#34;results:&#34;)
    for (otp, av, omin, omax) in result:
        info(f&#34;{otp:&lt;15}: {round(av, 2):&gt;8} {{{omin}-{omax}}}&#34;, tm=False)
    return result</code></pre>
</details>
</dd>
<dt id="tf.core.prepare.order"><code class="name flex">
<span>def <span class="ident">order</span></span>(<span>info, error, otype, oslots, levels)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes order data for the canonical ordering.</p>
<p>The canonical ordering between nodes is defined in terms of the slots that
nodes contain, and if that is not decisive, the rank of the node type is taken
into account, and if that is still not decisive, the node itself is taken into
account.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otype</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>otype</em> feature.</dd>
<dt><strong><code>oslots</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>oslots</em> feature.</dd>
<dt><strong><code>levels</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The data of the <em>levels</em> precompute step.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>All nodes, slot and nonslot, in canonical order.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="tf.core.nodes" href="nodes.html">tf.core.nodes</a></code></dt>
<dd>canonical ordering</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/032a9079f5468bfcac04aa9be26a85c125f09dfd/tf/core/prepare.py#L114-L188" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def order(info, error, otype, oslots, levels):
    &#34;&#34;&#34;Computes order data for the canonical ordering.

    The canonical ordering between nodes is defined in terms of the slots that
    nodes contain, and if that is not decisive, the rank of the node type is taken
    into account, and if that is still not decisive, the node itself is taken into
    account.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    oslots: iterable
        The data of the *oslots* feature.
    levels: tuple
        The data of the *levels* precompute step.

    Returns
    -------
    tuple
        All nodes, slot and nonslot, in canonical order.

    See Also
    --------
    tf.core.nodes: canonical ordering
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    info(&#34;assigning otype levels to nodes&#34;)
    otypeLevels = dict(((x[0], i) for (i, x) in enumerate(reversed(levels))))

    def otypeRank(n):
        return otypeLevels[slotType if n &lt; maxSlot + 1 else otype[n - maxSlot - 1]]

    def before(na, nb):
        if na &lt; maxSlot + 1:
            a = na
            sa = {a}
        else:
            a = na - maxSlot
            sa = set(oslots[a - 1])
        if nb &lt; maxSlot + 1:
            b = nb
            sb = {b}
        else:
            b = nb - maxSlot
            sb = set(oslots[b - 1])
        oa = otypeRank(na)
        ob = otypeRank(nb)
        if sa == sb:
            return (
                (-1 if na &lt; nb else 1 if na &gt; nb else 0)
                if oa == ob
                else -1
                if oa &gt; ob
                else 1
            )
        if sa &gt; sb:
            return -1
        if sa &lt; sb:
            return 1
        am = min(sa - sb)
        bm = min(sb - sa)
        return -1 if am &lt; bm else 1 if bm &lt; am else 0

    canonKey = functools.cmp_to_key(before)
    info(&#34;sorting nodes&#34;)
    nodes = sorted(range(1, maxNode + 1), key=canonKey)
    # return array(&#34;I&#34;, nodes)
    return tuple(nodes)</code></pre>
</details>
</dd>
<dt id="tf.core.prepare.rank"><code class="name flex">
<span>def <span class="ident">rank</span></span>(<span>info, error, otype, order)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes rank data.</p>
<p>The rank of a node is its place in among the other nodes in the
canonical order (see <code><a title="tf.core.nodes" href="nodes.html">tf.core.nodes</a></code>).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otype</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>otype</em> feature.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The data of the <em>order</em> feature.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>The ranks of all nodes, slot and nonslot, with respect to the canonical order.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/032a9079f5468bfcac04aa9be26a85c125f09dfd/tf/core/prepare.py#L191-L218" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rank(info, error, otype, order):
    &#34;&#34;&#34;Computes rank data.

    The rank of a node is its place in among the other nodes in the
    canonical order (see `tf.core.nodes`).

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    order: tuple
        The data of the *order* feature.

    Returns
    -------
    tuple
        The ranks of all nodes, slot and nonslot, with respect to the canonical order.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    info(&#34;ranking nodes&#34;)
    nodesRank = dict(((n, i) for (i, n) in enumerate(order)))
    return array(&#34;I&#34;, (nodesRank[n] for n in range(1, maxNode + 1)))
    # return tuple((nodesRank[n] for n in range(1, maxNode + 1)))</code></pre>
</details>
</dd>
<dt id="tf.core.prepare.sections"><code class="name flex">
<span>def <span class="ident">sections</span></span>(<span>info, error, otype, oslots, otext, levUp, levels, *sFeats)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes section data.</p>
<p>Text-Fabric datasets may define up to three section levels, roughly corresponding
with a volume, a chapter, a paragraph.</p>
<p>If the corpus has a richer section structure, it is also possible
a different, more flexible and more extensive nest of structural sections.
See <code><a title="tf.core.prepare.structure" href="#tf.core.prepare.structure">structure()</a></code>.</p>
<p>Text-Fabric must be able to go from sections at one level to the sections
at one level lower. It must also be able to map section headings
to nodes. For this, the section features are needed, since they
contain the section headings.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otype</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>otype</em> feature.</dd>
<dt><strong><code>oslots</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>oslots</em> feature.</dd>
<dt><strong><code>otext</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>otext</em> feature.</dd>
<dt><strong><code>levUp</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The data of the <em>levUp</em> precompute step.</dd>
<dt><strong><code>levels</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The data of the <em>levels</em> precompute step.</dd>
<dt><strong><code>sFeats</code></strong> :&ensp;<code>iterable</code></dt>
<dd>Each sFeat is the data of a section feature.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>
<ul>
<li>sec1
Mapping from section-level-1 nodes to mappings from
section-level-2 headings to section-level2 nodes.</li>
<li>sec2
Mapping from section-level-1 nodes to mappings from
section-level-2 headings to mappings from
section-level3 headings to section-level-3 nodes.</li>
</ul>
</dd>
</dl>
<h2 id="warnings">Warnings</h2>
<p>Note that the terms <code>book</code>, <code>chapter</code>, <code>verse</code> are not baked into Text-Fabric.
It is the corpus data, especially the <code>otext</code> config feature that
spells out the names of the sections.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/032a9079f5468bfcac04aa9be26a85c125f09dfd/tf/core/prepare.py#L482-L614" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sections(info, error, otype, oslots, otext, levUp, levels, *sFeats):
    &#34;&#34;&#34;Computes section data.

    Text-Fabric datasets may define up to three section levels, roughly corresponding
    with a volume, a chapter, a paragraph.

    If the corpus has a richer section structure, it is also possible
    a different, more flexible and more extensive nest of structural sections.
    See `structure`.

    Text-Fabric must be able to go from sections at one level to the sections
    at one level lower. It must also be able to map section headings
    to nodes. For this, the section features are needed, since they
    contain the section headings.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    oslots: iterable
        The data of the *oslots* feature.
    otext: iterable
        The data of the *otext* feature.
    levUp: tuple
        The data of the *levUp* precompute step.
    levels: tuple
        The data of the *levels* precompute step.
    sFeats: iterable
        Each sFeat is the data of a section feature.

    Returns
    -------
    tuple
        *   sec1
            Mapping from section-level-1 nodes to mappings from
            section-level-2 headings to section-level2 nodes.
        *   sec2
            Mapping from section-level-1 nodes to mappings from
            section-level-2 headings to mappings from
            section-level3 headings to section-level-3 nodes.

    Warnings
    --------
    Note that the terms `book`, `chapter`, `verse` are not baked into Text-Fabric.
    It is the corpus data, especially the `otext` config feature that
    spells out the names of the sections.

    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    support = {level[0]: (level[2], level[3]) for level in levels}
    sTypes = itemize(otext[&#34;sectionTypes&#34;], &#34;,&#34;)
    sec1 = {}
    sec2 = {}
    nestingProblems = collections.Counter()

    if len(sTypes) &lt; 2:
        pass

    elif len(sTypes) &lt; 3:
        c1 = 0
        support1 = support[sTypes[1]]
        for n1 in range(support1[0], support1[1] + 1):
            n0s = tuple(x for x in levUp[n1 - 1] if otype[x - maxSlot - 1] == sTypes[0])
            if not n0s:
                nestingProblems[
                    f&#34;section {sTypes[1]} without containing {sTypes[0]}&#34;
                ] += 1
                continue
            n0 = n0s[0]
            n1head = sFeats[1].get(n1, None)
            if n1head is None:
                nestingProblems[
                    f&#34;{sTypes[1]}-node {n1} has no section heading&#34;
                ] += 1
            if n0 not in sec1:
                sec1[n0] = {}
            if n1head not in sec1[n0]:
                sec1[n0][n1head] = n1
                c1 += 1
        info(f&#34;{c1} {sTypes[1]}s indexed&#34;)

    else:
        c1 = 0
        c2 = 0
        support2 = support[sTypes[2]]
        for n2 in range(support2[0], support2[1] + 1):
            n0s = tuple(x for x in levUp[n2 - 1] if otype[x - maxSlot - 1] == sTypes[0])
            if not n0s:
                nestingProblems[
                    f&#34;section {sTypes[2]} without containing {sTypes[0]}&#34;
                ] += 1
                continue
            n0 = n0s[0]

            n1s = tuple(x for x in levUp[n2 - 1] if otype[x - maxSlot - 1] == sTypes[1])
            if not n1s:
                nestingProblems[
                    f&#34;section {sTypes[2]} without containing {sTypes[1]}&#34;
                ] += 1
                continue
            n1 = n1s[0]

            n1head = sFeats[1].get(n1, None)
            if n1head is None:
                nestingProblems[
                    f&#34;{sTypes[1]}-node {n1} has no section heading&#34;
                ] += 1
            n2head = sFeats[2].get(n2, None)
            if n2head is None:
                nestingProblems[
                    f&#34;{sTypes[2]}-node {n2} has no section heading&#34;
                ] += 1

            if n0 not in sec1:
                sec1[n0] = {}
            if n1head not in sec1[n0]:
                sec1[n0][n1head] = n1
                c1 += 1
            sec2.setdefault(n0, {}).setdefault(n1head, {})[n2head] = n2
            c2 += 1
        info(f&#34;{c1} {sTypes[1]}s and {c2} {sTypes[2]}s indexed&#34;)

    if nestingProblems:
        for (msg, amount) in sorted(nestingProblems.items()):
            error(f&#34;WARNING: {amount:&gt;4} x {msg}&#34;)

    return (sec1, sec2)</code></pre>
</details>
</dd>
<dt id="tf.core.prepare.structure"><code class="name flex">
<span>def <span class="ident">structure</span></span>(<span>info, error, otype, oslots, otext, rank, levUp, *sFeats)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes structure data.</p>
<p>If the corpus has a rich section structure, it is possible to define
a flexible and extensive nest of structural sections.</p>
<p>Independent of this,
Text-Fabric datasets may also define up to three section levels,
roughly corresponding with a volume, a chapter, a paragraph.
See <code><a title="tf.core.prepare.sections" href="#tf.core.prepare.sections">sections()</a></code>.</p>
<p>Text-Fabric must be able to go from sections at one level to the sections
at one level lower. It must also be able to map section headings
to nodes. For this, the section features are needed, since they
contain the section headings.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otype</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>otype</em> feature.</dd>
<dt><strong><code>oslots</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>oslots</em> feature.</dd>
<dt><strong><code>otext</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <em>otext</em> feature.</dd>
<dt><strong><code>rank</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The data of the <em>rank</em> precompute step.</dd>
<dt><strong><code>levUp</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The data of the <em>levUp</em> precompute step.</dd>
<dt><strong><code>sFeats</code></strong> :&ensp;<code>iterable</code></dt>
<dd>Each sFeat the data of a section feature.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>
<ul>
<li>headingFromNode
(Mapping from nodes to section keys)</li>
<li>nodeFromHeading
(Mapping from section keys to nodes)</li>
<li>multiple</li>
<li>top</li>
<li>up</li>
<li>down</li>
</ul>
</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>A section key of a structural node is obtained by going a level up from
that node, retrieving the heading of that structural node, then going up again,
and so on till a top node is reached. The tuple of headings obtained in this way
is the
section key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/032a9079f5468bfcac04aa9be26a85c125f09dfd/tf/core/prepare.py#L617-L756" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def structure(info, error, otype, oslots, otext, rank, levUp, *sFeats):
    &#34;&#34;&#34;Computes structure data.

    If the corpus has a rich section structure, it is possible to define
    a flexible and extensive nest of structural sections.

    Independent of this,
    Text-Fabric datasets may also define up to three section levels,
    roughly corresponding with a volume, a chapter, a paragraph.
    See `sections`.

    Text-Fabric must be able to go from sections at one level to the sections
    at one level lower. It must also be able to map section headings
    to nodes. For this, the section features are needed, since they
    contain the section headings.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the *otype* feature.
    oslots: iterable
        The data of the *oslots* feature.
    otext: iterable
        The data of the *otext* feature.
    rank: tuple
        The data of the *rank* precompute step.
    levUp: tuple
        The data of the *levUp* precompute step.
    sFeats: iterable
        Each sFeat the data of a section feature.

    Returns
    -------
    tuple
        *   headingFromNode
            (Mapping from nodes to section keys)
        *   nodeFromHeading
            (Mapping from section keys to nodes)
        *   multiple
        *   top
        *   up
        *   down

    Notes
    -----
    A section key of a structural node is obtained by going a level up from
    that node, retrieving the heading of that structural node, then going up again,
    and so on till a top node is reached. The tuple of headings obtained in this way
    is the  section key.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    sTypeList = itemize(otext[&#34;structureTypes&#34;], &#34;,&#34;)
    nsTypes = len(sTypeList)
    nsFeats = len(sFeats)

    if nsTypes != nsFeats:
        error(
            f&#34;WARNING: {nsTypes} structure levels but {nsFeats} corresponding features&#34;
        )
        return ({}, {})

    sTypes = set(sTypeList)
    if len(sTypes) != nsTypes:
        error(&#34;WARNING: duplicate structure levels&#34;)
        return ({}, {})

    higherTypes = collections.defaultdict(set)
    for (i, highType) in enumerate(sTypeList):
        for lowType in sTypeList[i:]:
            higherTypes[lowType].add(highType)

    featFromType = {sTypeList[i]: sFeats[i] for i in range(nsTypes)}

    multiple = collections.defaultdict(list)
    headingFromNode = {}
    nodeFromHeading = {}

    for n in range(maxSlot + 1, maxNode + 1):
        nType = otype[n - maxSlot - 1]
        if nType not in sTypes:
            continue
        ups = (u for u in levUp[n - 1] if otype[u - maxSlot - 1] in higherTypes[nType])
        sKey = tuple(
            reversed(
                tuple(
                    (
                        otype[x - maxSlot - 1],
                        featFromType[otype[x - maxSlot - 1]].get(x, None),
                    )
                    for x in (n, *ups)
                )
            )
        )

        if sKey in nodeFromHeading:
            if sKey not in multiple:
                multiple[sKey].append(nodeFromHeading[sKey])
            multiple[sKey].append(n)
        nodeFromHeading[sKey] = n
        headingFromNode[n] = sKey
    multiple = {
        sKey: tuple(sorted(ns, key=lambda n: rank[n - 1]))
        for (sKey, ns) in multiple.items()
    }

    top = tuple(
        sorted(
            (n for (n, h) in headingFromNode.items() if len(h) == 1),
            key=lambda n: rank[n - 1],
        )
    )

    up = {}
    for (n, heading) in headingFromNode.items():
        lHeading = len(heading)
        if lHeading == 1:
            continue
        upNode = None
        for i in range(lHeading - 1, 0, -1):
            upHeading = heading[0:i]
            upNode = nodeFromHeading.get(upHeading, None)
            if upNode is not None:
                up[n] = upNode
                break

    down = {}
    for (n, heading) in headingFromNode.items():
        if len(heading) == 1:
            continue
        down.setdefault(up[n], []).append(n)

    down = {n: tuple(sorted(ms, key=lambda m: rank[m - 1])) for (n, ms) in down.items()}

    return (headingFromNode, nodeFromHeading, multiple, top, up, down)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#precompute-data">Precompute data.</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.core" href="index.html">tf.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="tf.core.prepare.boundary" href="#tf.core.prepare.boundary">boundary</a></code></li>
<li><code><a title="tf.core.prepare.characters" href="#tf.core.prepare.characters">characters</a></code></li>
<li><code><a title="tf.core.prepare.levDown" href="#tf.core.prepare.levDown">levDown</a></code></li>
<li><code><a title="tf.core.prepare.levUp" href="#tf.core.prepare.levUp">levUp</a></code></li>
<li><code><a title="tf.core.prepare.levels" href="#tf.core.prepare.levels">levels</a></code></li>
<li><code><a title="tf.core.prepare.order" href="#tf.core.prepare.order">order</a></code></li>
<li><code><a title="tf.core.prepare.rank" href="#tf.core.prepare.rank">rank</a></code></li>
<li><code><a title="tf.core.prepare.sections" href="#tf.core.prepare.sections">sections</a></code></li>
<li><code><a title="tf.core.prepare.structure" href="#tf.core.prepare.structure">structure</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>