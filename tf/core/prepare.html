<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>tf.core.prepare API documentation</title>
<meta name="description" content="Pre-compute data â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.core.prepare</code></h1>
</header>
<section id="section-intro">
<h1 id="pre-compute-data">Pre-compute data.</h1>
<p>For TF to work efficiently, some
derived data needs to be pre-computed.
The pre-computed data has a similar function as indexes in a database.</p>
<p>Pre-computation is triggered when <code><a title="tf.fabric.Fabric" href="../fabric.html#tf.fabric.Fabric">Fabric</a></code> loads features, and
the order and nature of the steps is configured in
<code><a title="tf.core.fabric.PRECOMPUTE" href="fabric.html#tf.core.fabric.PRECOMPUTE">PRECOMPUTE</a></code>.</p>
<p>The functions in this module implement those tasks.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.core.prepare.boundary"><code class="name flex">
<span>def <span class="ident">boundary</span></span>(<span>info, error, otype, oslots, rank)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/48722101caea31f5eabbadcea25817621f7425af/tf/core/prepare.py#L442-L504" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def boundary(info, error, otype, oslots, rank):
    &#34;&#34;&#34;Computes boundary data.

    For each slot, the nodes that start at that slot and the nodes that end
    at that slot are collected.

    Boundary data is used by the API functions
    `tf.core.locality.Locality.p`.
    and
    `tf.core.locality.Locality.n`.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the `otype` feature.
    oslots: iterable
        The data of the `oslots` feature.
    rank: tuple
        The data of the `rank` pre-computation step.

    Returns
    -------
    tuple
        *   first: tuple of tuple
            The `n`-th member is the tuple of nodes that start at slot `n`,
            ordered in *reversed* canonical order (`tf.core.nodes`);
        *   last: tuple of tuple
            The `n`-th member is the tuple of nodes that end at slot `n`,
            ordered in canonical order;

    Notes
    -----
    !!! hint &#34;why  reversed canonical order?&#34;
        Just for symmetry.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    firstSlotsD = {}
    lastSlotsD = {}

    for node, slots in enumerate(oslots):
        realNode = node + 1 + maxSlot
        firstSlotsD.setdefault(slots[0], []).append(realNode)
        lastSlotsD.setdefault(slots[-1], []).append(realNode)

    firstSlots = tuple(
        tuple(sorted(firstSlotsD.get(n, []), key=lambda node: -rank[node - 1]))
        # array.array(&#34;I&#34;, sorted(firstSlotsD.get(n, []),
        # key=lambda node: -rank[node - 1]))
        for n in range(1, maxSlot + 1)
    )
    lastSlots = tuple(
        tuple(sorted(lastSlotsD.get(n, []), key=lambda node: rank[node - 1]))
        # array.array(&#34;I&#34;, sorted(lastSlotsD.get(n, []),
        # key=lambda node: rank[node - 1]))
        for n in range(1, maxSlot + 1)
    )
    return (firstSlots, lastSlots)</code></pre>
</details>
<div class="desc"><p>Computes boundary data.</p>
<p>For each slot, the nodes that start at that slot and the nodes that end
at that slot are collected.</p>
<p>Boundary data is used by the API functions
<code><a title="tf.core.locality.Locality.p" href="locality.html#tf.core.locality.Locality.p">Locality.p()</a></code>.
and
<code><a title="tf.core.locality.Locality.n" href="locality.html#tf.core.locality.Locality.n">Locality.n()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otype</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <code>otype</code> feature.</dd>
<dt><strong><code>oslots</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <code>oslots</code> feature.</dd>
<dt><strong><code>rank</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The data of the <code><a title="tf.core.prepare.rank" href="#tf.core.prepare.rank">rank()</a></code> pre-computation step.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>
<ul>
<li>first: tuple of tuple
The <code>n</code>-th member is the tuple of nodes that start at slot <code>n</code>,
ordered in <em>reversed</em> canonical order (<code><a title="tf.core.nodes" href="nodes.html">tf.core.nodes</a></code>);</li>
<li>last: tuple of tuple
The <code>n</code>-th member is the tuple of nodes that end at slot <code>n</code>,
ordered in canonical order;</li>
</ul>
</dd>
</dl>
<h2 id="notes">Notes</h2>
<div class="admonition hint">
<p class="admonition-title">why
reversed canonical order?</p>
<p>Just for symmetry.</p>
</div></div>
</dd>
<dt id="tf.core.prepare.characters"><code class="name flex">
<span>def <span class="ident">characters</span></span>(<span>info, error, otext, tFormats, *tFeats)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/48722101caea31f5eabbadcea25817621f7425af/tf/core/prepare.py#L387-L439" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def characters(info, error, otext, tFormats, *tFeats):
    &#34;&#34;&#34;Computes character data.

    For each text format, a frequency list of the characters in that format
    is made.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otext: iterable
        The data of the `otext` feature.
    tFormats: dict
        Dictionary keyed by text format and valued by the tuple of features
        used in that format.
    tFeats: iterable
        Each `tFeat` is the name and the data of a text feature.
        i.e. a feature used in text formats.

    Returns
    -------
    dict
        Keyed by format valued by a frequency dict, which is
        itself keyed by single characters and valued by the frequency
        of that character in the whole corpus when rendered with that format.
    &#34;&#34;&#34;

    charFreqsByFeature = {}

    for tFeat, data in tFeats:
        freqList = collections.Counter()
        if data is not None:
            for v in data.values():
                freqList[v] += 1
        charFreq = collections.defaultdict(lambda: 0)
        for v, freq in freqList.items():
            for c in str(v):
                charFreq[c] += freq
        charFreqsByFeature[tFeat] = charFreq

    charFreqsByFmt = {}

    for fmt, tFeatures in sorted(tFormats.items()):
        charFreq = collections.defaultdict(lambda: 0)
        for tFeat in tFeatures:
            thisCharFreq = charFreqsByFeature[tFeat]
            for c, freq in thisCharFreq.items():
                charFreq[c] += freq
        charFreqsByFmt[fmt] = sorted(x for x in charFreq.items())

    return charFreqsByFmt</code></pre>
</details>
<div class="desc"><p>Computes character data.</p>
<p>For each text format, a frequency list of the characters in that format
is made.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otext</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <code>otext</code> feature.</dd>
<dt><strong><code>tFormats</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary keyed by text format and valued by the tuple of features
used in that format.</dd>
<dt><strong><code>tFeats</code></strong> :&ensp;<code>iterable</code></dt>
<dd>Each <code>tFeat</code> is the name and the data of a text feature.
i.e. a feature used in text formats.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Keyed by format valued by a frequency dict, which is
itself keyed by single characters and valued by the frequency
of that character in the whole corpus when rendered with that format.</dd>
</dl></div>
</dd>
<dt id="tf.core.prepare.levDown"><code class="name flex">
<span>def <span class="ident">levDown</span></span>(<span>info, error, otype, levUp, rank)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/48722101caea31f5eabbadcea25817621f7425af/tf/core/prepare.py#L331-L384" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def levDown(info, error, otype, levUp, rank):
    &#34;&#34;&#34;Computes level-down data.

    Level-down data is used by the API function `tf.core.locality.Locality.d`.

    This function computes the embedded nodes of a node by looking them up from
    the level-down data.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the `otype` feature.
    levUp: iterable
        The data of the `levUp` pre-computation step.
    rank: tuple
        The data of the `rank` pre-computation step.

    Returns
    -------
    tuple
        The `n`-th member is an tuple of the embedded nodes of `n + maxSlot`.
        Those tuples are sorted in canonical order (`tf.core.nodes`).

    !!! hint &#34;Memory efficiency&#34;
        Slot nodes do not have embedded nodes, so they do not have to occupy
        space in this tuple. Hence the first member are the embedded nodes
        of node `maxSlot + 1`.

    !!! caution &#34;Use with care&#34;
        It is not advisable to use this data directly by `C.levDown.data`,
        it is far better to use the `tf.core.locality.Locality.d` function.

        Only when every bit of performance waste has to be squeezed out,
        this raw data might be a deal.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    info(&#34;inverting embedders&#34;)
    inverse = {}
    for n in range(maxSlot + 1, maxNode + 1):
        for m in levUp[n - 1]:
            inverse.setdefault(m, set()).add(n)
    info(&#34;turning embeddees into list&#34;)
    embeddees = []
    for n in range(maxSlot + 1, maxNode + 1):
        embeddees.append(
            array.array(&#34;I&#34;, sorted(inverse.get(n, []), key=lambda m: rank[m - 1]))
            # tuple(sorted(inverse.get(n, []), key=lambda m: rank[m - 1]))
        )
    return tuple(embeddees)</code></pre>
</details>
<div class="desc"><p>Computes level-down data.</p>
<p>Level-down data is used by the API function <code><a title="tf.core.locality.Locality.d" href="locality.html#tf.core.locality.Locality.d">Locality.d()</a></code>.</p>
<p>This function computes the embedded nodes of a node by looking them up from
the level-down data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otype</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <code>otype</code> feature.</dd>
<dt><strong><code>levUp</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <code><a title="tf.core.prepare.levUp" href="#tf.core.prepare.levUp">levUp()</a></code> pre-computation step.</dd>
<dt><strong><code>rank</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The data of the <code><a title="tf.core.prepare.rank" href="#tf.core.prepare.rank">rank()</a></code> pre-computation step.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>The <code>n</code>-th member is an tuple of the embedded nodes of <code>n + maxSlot</code>.
Those tuples are sorted in canonical order (<code><a title="tf.core.nodes" href="nodes.html">tf.core.nodes</a></code>).</dd>
</dl>
<div class="admonition hint">
<p class="admonition-title">Memory efficiency</p>
<p>Slot nodes do not have embedded nodes, so they do not have to occupy
space in this tuple. Hence the first member are the embedded nodes
of node <code>maxSlot + 1</code>.</p>
</div>
<div class="admonition caution">
<p class="admonition-title">Use with care</p>
<p>It is not advisable to use this data directly by <code>C.levDown.data</code>,
it is far better to use the <code><a title="tf.core.locality.Locality.d" href="locality.html#tf.core.locality.Locality.d">Locality.d()</a></code> function.</p>
<p>Only when every bit of performance waste has to be squeezed out,
this raw data might be a deal.</p>
</div></div>
</dd>
<dt id="tf.core.prepare.levUp"><code class="name flex">
<span>def <span class="ident">levUp</span></span>(<span>info, error, otype, oslots, rank)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/48722101caea31f5eabbadcea25817621f7425af/tf/core/prepare.py#L241-L328" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def levUp(info, error, otype, oslots, rank):
    &#34;&#34;&#34;Computes level-up data.

    Level-up data is used by the API function `tf.core.locality.Locality.u`.

    This function computes the embedders of a node by looking them up from
    the level-up data.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the `otype` feature.
    oslots: iterable
        The data of the `oslots` feature.
    rank: tuple
        The data of the `rank` pre-computation step.

    Returns
    -------
    tuple
        The `n`-th member is a tuple of the embedder nodes of `n`.
        Those tuples are sorted in canonical order (`tf.core.nodes`).

    Notes
    -----
    !!! hint &#34;Memory efficiency&#34;
        Many nodes have the same tuple of embedders.
        Those embedder tuples will be reused for those nodes.

    Warnings
    --------
    It is not advisable to use this data directly by `C.levUp.data`,
    it is far better to use the `tf.core.locality.Locality.u` function.

    Only when every bit of performance waste has to be squeezed out,
    this raw data might be a deal.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    info(&#34;making inverse of edge feature oslots&#34;)
    oslotsInv = {}
    for k, mList in enumerate(oslots):
        for m in mList:
            oslotsInv.setdefault(m, set()).add(k + 1 + maxSlot)
    info(&#34;listing embedders of all nodes&#34;)
    embedders = []
    for n in range(1, maxSlot + 1):
        contentEmbedders = oslotsInv.get(n, tuple())
        embedders.append(
            tuple(
                sorted(
                    (m for m in contentEmbedders if m != n),
                    key=lambda k: -rank[k - 1],
                )
            )
        )
    for n in range(maxSlot + 1, maxNode + 1):
        mList = oslots[n - maxSlot - 1]
        if len(mList) == 0:
            embedders.append(tuple())
        else:
            contentEmbedders = functools.reduce(
                lambda x, y: x &amp; oslotsInv[y],
                mList[1:],
                oslotsInv[mList[0]],
            )
            embedders.append(
                tuple(
                    sorted(
                        (m for m in contentEmbedders if m != n),
                        key=lambda k: -rank[k - 1],
                    )
                )
            )
    # reuse embedder tuples, because lots of nodes share embedders
    seen = {}
    embeddersx = []
    for t in embedders:
        if t not in seen:
            # seen[t] = array.array(&#34;I&#34;, t)
            seen[t] = tuple(t)
        embeddersx.append(seen[t])
    return tuple(embeddersx)</code></pre>
</details>
<div class="desc"><p>Computes level-up data.</p>
<p>Level-up data is used by the API function <code><a title="tf.core.locality.Locality.u" href="locality.html#tf.core.locality.Locality.u">Locality.u()</a></code>.</p>
<p>This function computes the embedders of a node by looking them up from
the level-up data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otype</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <code>otype</code> feature.</dd>
<dt><strong><code>oslots</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <code>oslots</code> feature.</dd>
<dt><strong><code>rank</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The data of the <code><a title="tf.core.prepare.rank" href="#tf.core.prepare.rank">rank()</a></code> pre-computation step.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>The <code>n</code>-th member is a tuple of the embedder nodes of <code>n</code>.
Those tuples are sorted in canonical order (<code><a title="tf.core.nodes" href="nodes.html">tf.core.nodes</a></code>).</dd>
</dl>
<h2 id="notes">Notes</h2>
<div class="admonition hint">
<p class="admonition-title">Memory efficiency</p>
<p>Many nodes have the same tuple of embedders.
Those embedder tuples will be reused for those nodes.</p>
</div>
<h2 id="warnings">Warnings</h2>
<p>It is not advisable to use this data directly by <code>C.levUp.data</code>,
it is far better to use the <code><a title="tf.core.locality.Locality.u" href="locality.html#tf.core.locality.Locality.u">Locality.u()</a></code> function.</p>
<p>Only when every bit of performance waste has to be squeezed out,
this raw data might be a deal.</p></div>
</dd>
<dt id="tf.core.prepare.levels"><code class="name flex">
<span>def <span class="ident">levels</span></span>(<span>info, error, otype, oslots, otext)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/48722101caea31f5eabbadcea25817621f7425af/tf/core/prepare.py#L21-L133" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def levels(info, error, otype, oslots, otext):
    &#34;&#34;&#34;Computes level data.

    For each node type, compute the average number of slots occupied by its nodes,
    and order the node types on that.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the `otype` feature.
    oslots: iterable
        The data of the `oslots` feature.
    otext: iterable
        The data of the `otext` feature.

    Returns
    -------
    tuple
        An ordered tuple, each member with the information of a node type:

        *   node type name
        *   average number of slots contained in the nodes of this type
        *   first node of this type
        *   last node of this type

    The order of the tuple is descending by average number of slots per node of that
    type.

    Notes
    -----
    !!! explanation &#34;Level computation and customization&#34;
        All node types have a level, defined by the average amount of slots object of
        that type usually occupy. The bigger the average object, the lower the levels.
        Books have the lowest level, words the highest level.

        However, this can be overruled. Suppose you have a node type `phrase` and above
        it a node type `cluster`, i.e. phrases are contained in clusters, but not vice
        versa. If all phrases are contained in clusters, and some clusters have more
        than one phrase, the automatic level ranking of node types works out well in
        this case. But if clusters only have very small phrases, and the big phrases do
        not occur in clusters, then the algorithm may assign a lower rank to clusters
        than to phrases.

        In general, it is too expensive to try to compute the levels in a sophisticated
        way. In order to remedy cases where the algorithm assigns wrong levels, you can
        add a `@levels` and / or `@levelsConstraint` key to the `otext`
        configuration feature.
        See `tf.core.text`.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    levelOrder = otext.get(&#34;levels&#34;, None)

    if levelOrder is not None:
        levelRank = {level: i for (i, level) in enumerate(levelOrder.split(&#34;,&#34;))}
    otypeCount = collections.Counter()
    otypeMin = {}
    otypeMax = {}
    slotSetLengths = collections.Counter()
    info(&#34;get ranking of otypes&#34;)
    for k in range(len(oslots)):
        ntp = otype[k]
        otypeCount[ntp] += 1
        slotSetLengths[ntp] += len(oslots[k])
        tfn = k + maxSlot + 1
        if ntp not in otypeMin:
            otypeMin[ntp] = tfn
        if ntp not in otypeMax or otypeMax[ntp] &lt; tfn:
            otypeMax[ntp] = tfn
    sortKey = (
        (lambda x: -x[1])
        if levelOrder is None
        else (lambda x: (-1, levelRank[x[0]]) if x[0] in levelRank else (1, -x[1]))
    )
    result = sorted(
        (
            (
                ntp,
                slotSetLengths[ntp] / otypeCount[ntp],
                otypeMin[ntp],
                otypeMax[ntp],
            )
            for ntp in otypeCount
        ),
        key=sortKey,
    ) + [(slotType, 1, 1, maxSlot)]
    resultIndex = {r[0]: i for (i, r) in enumerate(result)}

    levelConstraintsSpec = otext.get(&#34;levelConstraints&#34;, None)

    if levelConstraintsSpec:
        levelConstraints = levelConstraintsSpec.split(&#34;;&#34;)

        for levelConstraint in levelConstraints:
            (smaller, biggerSpec) = levelConstraint.strip().split(&#34;&lt;&#34;)
            smaller = smaller.strip()
            biggers = {b.strip() for b in biggerSpec.strip().split(&#34;,&#34;)}
            highestBigIndex = max(resultIndex.get(tp, 0) for tp in biggers)
            smallerIndex = resultIndex.get(smaller, len(result))
            if smallerIndex &lt;= highestBigIndex:
                x = result.pop(smallerIndex)
                result.insert(highestBigIndex, x)
            resultIndex = {r[0]: i for (i, r) in enumerate(result)}

    info(&#34;results:&#34;)
    for otp, av, omin, omax in result:
        info(f&#34;{otp:&lt;15}: {round(av, 2):&gt;8} {{{omin}-{omax}}}&#34;, tm=False)
    return tuple(result)</code></pre>
</details>
<div class="desc"><p>Computes level data.</p>
<p>For each node type, compute the average number of slots occupied by its nodes,
and order the node types on that.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otype</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <code>otype</code> feature.</dd>
<dt><strong><code>oslots</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <code>oslots</code> feature.</dd>
<dt><strong><code>otext</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <code>otext</code> feature.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>
<p>An ordered tuple, each member with the information of a node type:</p>
<ul>
<li>node type name</li>
<li>average number of slots contained in the nodes of this type</li>
<li>first node of this type</li>
<li>last node of this type</li>
</ul>
</dd>
<dt><code>The <a title="tf.core.prepare.order" href="#tf.core.prepare.order">order()</a></code> of <code>the tuple is descending by average number</code> of <code>slots per node</code> of <code>that</code></dt>
<dd>&nbsp;</dd>
</dl>
<p>type.</p>
<h2 id="notes">Notes</h2>
<div class="admonition explanation">
<p class="admonition-title">Level computation and customization</p>
<p>All node types have a level, defined by the average amount of slots object of
that type usually occupy. The bigger the average object, the lower the levels.
Books have the lowest level, words the highest level.</p>
<p>However, this can be overruled. Suppose you have a node type <code>phrase</code> and above
it a node type <code>cluster</code>, i.e. phrases are contained in clusters, but not vice
versa. If all phrases are contained in clusters, and some clusters have more
than one phrase, the automatic level ranking of node types works out well in
this case. But if clusters only have very small phrases, and the big phrases do
not occur in clusters, then the algorithm may assign a lower rank to clusters
than to phrases.</p>
<p>In general, it is too expensive to try to compute the levels in a sophisticated
way. In order to remedy cases where the algorithm assigns wrong levels, you can
add a <code>@levels</code> and / or <code>@levelsConstraint</code> key to the <code>otext</code>
configuration feature.
See <code><a title="tf.core.text" href="text.html">tf.core.text</a></code>.</p>
</div></div>
</dd>
<dt id="tf.core.prepare.order"><code class="name flex">
<span>def <span class="ident">order</span></span>(<span>info, error, otype, oslots, levels)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/48722101caea31f5eabbadcea25817621f7425af/tf/core/prepare.py#L136-L208" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def order(info, error, otype, oslots, levels):
    &#34;&#34;&#34;Computes order data for the canonical ordering.

    The canonical ordering between nodes is defined in terms of the slots that
    nodes contain, and if that is not decisive, the rank of the node type is taken
    into account, and if that is still not decisive, the node itself is taken into
    account.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the `otype` feature.
    oslots: iterable
        The data of the `oslots` feature.
    levels: tuple
        The data of the `levels` pre-computation step.

    Returns
    -------
    tuple
        All nodes, slot and nonslot, in canonical order.

    See Also
    --------
    tf.core.nodes: canonical ordering
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    info(&#34;assigning otype levels to nodes&#34;)
    otypeLevels = dict(((x[0], i) for (i, x) in enumerate(reversed(levels))))

    def otypeRank(n):
        return otypeLevels[slotType if n &lt; maxSlot + 1 else otype[n - maxSlot - 1]]

    def before(na, nb):
        if na &lt; maxSlot + 1:
            a = na
            sa = {a}
        else:
            a = na - maxSlot
            sa = set(oslots[a - 1])
        if nb &lt; maxSlot + 1:
            b = nb
            sb = {b}
        else:
            b = nb - maxSlot
            sb = set(oslots[b - 1])
        oa = otypeRank(na)
        ob = otypeRank(nb)
        if sa == sb:
            return (
                (-1 if na &lt; nb else 1 if na &gt; nb else 0)
                if oa == ob
                else -1 if oa &gt; ob else 1
            )
        if sa &gt; sb:
            return -1
        if sa &lt; sb:
            return 1
        am = min(sa - sb)
        bm = min(sb - sa)
        return -1 if am &lt; bm else 1 if bm &lt; am else 0

    canonKey = functools.cmp_to_key(before)
    info(&#34;sorting nodes&#34;)
    nodes = sorted(range(1, maxNode + 1), key=canonKey)
    # return array.array(&#34;I&#34;, nodes)
    return tuple(nodes)</code></pre>
</details>
<div class="desc"><p>Computes order data for the canonical ordering.</p>
<p>The canonical ordering between nodes is defined in terms of the slots that
nodes contain, and if that is not decisive, the rank of the node type is taken
into account, and if that is still not decisive, the node itself is taken into
account.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otype</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <code>otype</code> feature.</dd>
<dt><strong><code>oslots</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <code>oslots</code> feature.</dd>
<dt><strong><code>levels</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The data of the <code><a title="tf.core.prepare.levels" href="#tf.core.prepare.levels">levels()</a></code> pre-computation step.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>All nodes, slot and nonslot, in canonical order.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="tf.core.nodes" href="nodes.html">tf.core.nodes</a></code></dt>
<dd>canonical ordering</dd>
</dl></div>
</dd>
<dt id="tf.core.prepare.rank"><code class="name flex">
<span>def <span class="ident">rank</span></span>(<span>info, error, otype, order)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/48722101caea31f5eabbadcea25817621f7425af/tf/core/prepare.py#L211-L238" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def rank(info, error, otype, order):
    &#34;&#34;&#34;Computes rank data.

    The rank of a node is its place in among the other nodes in the
    canonical order (see `tf.core.nodes`).

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the `otype` feature.
    order: tuple
        The data of the `order` feature.

    Returns
    -------
    tuple
        The ranks of all nodes, slot and nonslot, with respect to the canonical order.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    info(&#34;ranking nodes&#34;)
    nodesRank = dict(((n, i) for (i, n) in enumerate(order)))
    return array.array(&#34;I&#34;, (nodesRank[n] for n in range(1, maxNode + 1)))
    # return tuple((nodesRank[n] for n in range(1, maxNode + 1)))</code></pre>
</details>
<div class="desc"><p>Computes rank data.</p>
<p>The rank of a node is its place in among the other nodes in the
canonical order (see <code><a title="tf.core.nodes" href="nodes.html">tf.core.nodes</a></code>).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otype</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <code>otype</code> feature.</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The data of the <code><a title="tf.core.prepare.order" href="#tf.core.prepare.order">order()</a></code> feature.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>The ranks of all nodes, slot and nonslot, with respect to the canonical order.</dd>
</dl></div>
</dd>
<dt id="tf.core.prepare.sections"><code class="name flex">
<span>def <span class="ident">sections</span></span>(<span>info, error, otype, oslots, otext, levUp, levDown, levels, *sFeats)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/48722101caea31f5eabbadcea25817621f7425af/tf/core/prepare.py#L507-L683" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def sections(info, error, otype, oslots, otext, levUp, levDown, levels, *sFeats):
    &#34;&#34;&#34;Computes section data.

    TF datasets may define up to three section levels, roughly corresponding
    with a volume, a chapter, a paragraph.

    If the corpus has a richer section structure, it is also possible
    a different, more flexible and more extensive nest of structural sections.
    See `structure`.

    TF must be able to go from sections at one level to the sections
    at one level lower. It must also be able to map section headings
    to nodes. For this, the section features are needed, since they
    contain the section headings.

    We also map the sections to sequence numbers and back, at each level, e.g.
    in the Hebrew Bible `Genesis` is mapped to 1, `Exodus` to 2, etc.
    We also do it for integer values components, and we make sure that the first section
    at each level gets sequence number `1`.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the `otype` feature.
    oslots: iterable
        The data of the `oslots` feature.
    otext: iterable
        The data of the `otext` feature.
    levUp: tuple
        The data of the `levUp` pre-computation step.
    levDown: tuple
        The data of the `levDown` pre-computation step.
    levels: tuple
        The data of the `levels` pre-computation step.
    sFeats: iterable
        Each `sFeat` is the data of a section feature.

    Returns
    -------
    dict
        We have the following items:

        *   `sec1`:
            Mapping from section-level-1 nodes to mappings from
            section-level-2 headings to section-level-2 nodes.
        *   `sec2`:
            Mapping from section-level-1 nodes to mappings from
            section-level-2 headings to mappings from
            section-level-3 headings to section-level-3 nodes.
        *   `seqFromNode`:
            Mapping from tuples of section nodes to tuples of sequence numbers.
            Only if there are precisely 3 section levels, otherwise this is an
            empty dictionary.
        *   `nodeFromSeq`:
            Mapping from tuples of section sequence numbers to tuples of nodes.
            Only if there are precisely 3 section levels, otherwise this is an
            empty dictionary.

    Warnings
    --------
    Note that the terms `book`, `chapter`, `verse` are not baked into TF.
    It is the corpus data, especially the `otext` configuration feature that
    spells out the names of the sections.

    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    support = {level[0]: (level[2], level[3]) for level in levels}
    sTypes = itemize(otext[&#34;sectionTypes&#34;], &#34;,&#34;)
    sec1 = {}
    sec2 = {}
    seqFromNode = {}
    nodeFromSeq = {}
    nestingProblems = collections.Counter()

    if len(sTypes) &lt; 2:
        pass

    elif len(sTypes) &lt; 3:
        c1 = 0
        support1 = support[sTypes[1]]
        for n1 in range(support1[0], support1[1] + 1):
            n0s = tuple(x for x in levUp[n1 - 1] if otype[x - maxSlot - 1] == sTypes[0])
            if not n0s:
                nestingProblems[
                    f&#34;section {sTypes[1]} without containing {sTypes[0]}&#34;
                ] += 1
                continue
            n0 = n0s[0]
            n1head = sFeats[1].get(n1, None)
            if n1head is None:
                nestingProblems[f&#34;{sTypes[1]}-node {n1} has no section heading&#34;] += 1
            if n0 not in sec1:
                sec1[n0] = {}
            if n1head not in sec1[n0]:
                sec1[n0][n1head] = n1
                c1 += 1
        info(f&#34;{c1} {sTypes[1]}s indexed&#34;)

    else:
        c1 = 0
        c2 = 0
        support2 = support[sTypes[2]]
        for n2 in range(support2[0], support2[1] + 1):
            n0s = tuple(x for x in levUp[n2 - 1] if otype[x - maxSlot - 1] == sTypes[0])
            if not n0s:
                nestingProblems[
                    f&#34;section {sTypes[2]} without containing {sTypes[0]}&#34;
                ] += 1
                continue
            n0 = n0s[0]

            n1s = tuple(x for x in levUp[n2 - 1] if otype[x - maxSlot - 1] == sTypes[1])
            if not n1s:
                nestingProblems[
                    f&#34;section {sTypes[2]} without containing {sTypes[1]}&#34;
                ] += 1
                continue
            n1 = n1s[0]

            n1head = sFeats[1].get(n1, None)
            if n1head is None:
                nestingProblems[f&#34;{sTypes[1]}-node {n1} has no section heading&#34;] += 1
            n2head = sFeats[2].get(n2, None)
            if n2head is None:
                nestingProblems[f&#34;{sTypes[2]}-node {n2} has no section heading&#34;] += 1

            if n0 not in sec1:
                sec1[n0] = {}
            if n1head not in sec1[n0]:
                sec1[n0][n1head] = n1
                c1 += 1
            sec2.setdefault(n0, {}).setdefault(n1head, {})[n2head] = n2
            c2 += 1
        info(f&#34;{c1} {sTypes[1]}s and {c2} {sTypes[2]}s indexed&#34;)

    if nestingProblems:
        for msg, amount in sorted(nestingProblems.items()):
            error(f&#34;WARNING: {amount:&gt;4} x {msg}&#34;)

    c0 = 0

    if len(sTypes) == 3:
        support0 = support[sTypes[0]]

        for n0 in range(support0[0], support0[1] + 1):
            c0 += 1
            seqFromNode[n0] = (c0,)
            nodeFromSeq[(c0,)] = n0

            c1 = 0

            for n1 in (
                x
                for x in levDown[n0 - maxSlot - 1]
                if otype[x - maxSlot - 1] == sTypes[1]
            ):
                c1 += 1
                c2 = 0
                seqFromNode[n1] = (c0, c1)
                nodeFromSeq[(c0, c1)] = n1

                for n2 in (
                    x
                    for x in levDown[n1 - maxSlot - 1]
                    if otype[x - maxSlot - 1] == sTypes[2]
                ):
                    c2 += 1
                    seqFromNode[n2] = (c0, c1, c2)
                    nodeFromSeq[(c0, c1, c2)] = n2

    return dict(sec1=sec1, sec2=sec2, seqFromNode=seqFromNode, nodeFromSeq=nodeFromSeq)</code></pre>
</details>
<div class="desc"><p>Computes section data.</p>
<p>TF datasets may define up to three section levels, roughly corresponding
with a volume, a chapter, a paragraph.</p>
<p>If the corpus has a richer section structure, it is also possible
a different, more flexible and more extensive nest of structural sections.
See <code><a title="tf.core.prepare.structure" href="#tf.core.prepare.structure">structure()</a></code>.</p>
<p>TF must be able to go from sections at one level to the sections
at one level lower. It must also be able to map section headings
to nodes. For this, the section features are needed, since they
contain the section headings.</p>
<p>We also map the sections to sequence numbers and back, at each level, e.g.
in the Hebrew Bible <code>Genesis</code> is mapped to 1, <code>Exodus</code> to 2, etc.
We also do it for integer values components, and we make sure that the first section
at each level gets sequence number <code>1</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otype</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <code>otype</code> feature.</dd>
<dt><strong><code>oslots</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <code>oslots</code> feature.</dd>
<dt><strong><code>otext</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <code>otext</code> feature.</dd>
<dt><strong><code>levUp</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The data of the <code><a title="tf.core.prepare.levUp" href="#tf.core.prepare.levUp">levUp()</a></code> pre-computation step.</dd>
<dt><strong><code>levDown</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The data of the <code><a title="tf.core.prepare.levDown" href="#tf.core.prepare.levDown">levDown()</a></code> pre-computation step.</dd>
<dt><strong><code>levels</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The data of the <code><a title="tf.core.prepare.levels" href="#tf.core.prepare.levels">levels()</a></code> pre-computation step.</dd>
<dt><strong><code>sFeats</code></strong> :&ensp;<code>iterable</code></dt>
<dd>Each <code>sFeat</code> is the data of a section feature.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>
<p>We have the following items:</p>
<ul>
<li><code>sec1</code>:
Mapping from section-level-1 nodes to mappings from
section-level-2 headings to section-level-2 nodes.</li>
<li><code>sec2</code>:
Mapping from section-level-1 nodes to mappings from
section-level-2 headings to mappings from
section-level-3 headings to section-level-3 nodes.</li>
<li><code>seqFromNode</code>:
Mapping from tuples of section nodes to tuples of sequence numbers.
Only if there are precisely 3 section levels, otherwise this is an
empty dictionary.</li>
<li><code>nodeFromSeq</code>:
Mapping from tuples of section sequence numbers to tuples of nodes.
Only if there are precisely 3 section levels, otherwise this is an
empty dictionary.</li>
</ul>
</dd>
</dl>
<h2 id="warnings">Warnings</h2>
<p>Note that the terms <code>book</code>, <code>chapter</code>, <code>verse</code> are not baked into TF.
It is the corpus data, especially the <code>otext</code> configuration feature that
spells out the names of the sections.</p></div>
</dd>
<dt id="tf.core.prepare.structure"><code class="name flex">
<span>def <span class="ident">structure</span></span>(<span>info, error, otype, oslots, otext, rank, levUp, *sFeats)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/48722101caea31f5eabbadcea25817621f7425af/tf/core/prepare.py#L686-L823" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def structure(info, error, otype, oslots, otext, rank, levUp, *sFeats):
    &#34;&#34;&#34;Computes structure data.

    If the corpus has a rich section structure, it is possible to define
    a flexible and extensive nest of structural sections.

    Independent of this,
    TF datasets may also define up to three section levels,
    roughly corresponding with a volume, a chapter, a paragraph.
    See `sections`.

    TF must be able to go from sections at one level to the sections
    at one level lower. It must also be able to map section headings
    to nodes. For this, the section features are needed, since they
    contain the section headings.

    Parameters
    ----------
    info: function
        Method to write informational messages to the console.
    error: function
        Method to write error messages to the console.
    otype: iterable
        The data of the `otype` feature.
    oslots: iterable
        The data of the `oslots` feature.
    otext: iterable
        The data of the `otext` feature.
    rank: tuple
        The data of the `rank` pre-computation step.
    levUp: tuple
        The data of the `levUp` pre-computation step.
    sFeats: iterable
        Each `sFeat` the data of a section feature.

    Returns
    -------
    tuple
        *   `headingFromNode` (Mapping from nodes to section keys)
        *   `nodeFromHeading` (Mapping from section keys to nodes)
        *   `multiple`
        *   `top`
        *   `up`
        *   `down`

    Notes
    -----
    A section key of a structural node is obtained by going a level up from
    that node, retrieving the heading of that structural node, then going up again,
    and so on till a top node is reached. The tuple of headings obtained in this way
    is the  section key.
    &#34;&#34;&#34;

    (otype, maxSlot, maxNode, slotType) = otype
    oslots = oslots[0]
    sTypeList = itemize(otext[&#34;structureTypes&#34;], &#34;,&#34;)
    nsTypes = len(sTypeList)
    nsFeats = len(sFeats)

    if nsTypes != nsFeats:
        error(
            f&#34;WARNING: {nsTypes} structure levels but {nsFeats} corresponding features&#34;
        )
        return ({}, {})

    sTypes = set(sTypeList)
    if len(sTypes) != nsTypes:
        error(&#34;WARNING: duplicate structure levels&#34;)
        return ({}, {})

    higherTypes = collections.defaultdict(set)
    for i, highType in enumerate(sTypeList):
        for lowType in sTypeList[i:]:
            higherTypes[lowType].add(highType)

    featFromType = {sTypeList[i]: sFeats[i] for i in range(nsTypes)}

    multiple = collections.defaultdict(list)
    headingFromNode = {}
    nodeFromHeading = {}

    for n in range(maxSlot + 1, maxNode + 1):
        nType = otype[n - maxSlot - 1]
        if nType not in sTypes:
            continue
        ups = (u for u in levUp[n - 1] if otype[u - maxSlot - 1] in higherTypes[nType])
        sKey = tuple(
            reversed(
                tuple(
                    (
                        otype[x - maxSlot - 1],
                        featFromType[otype[x - maxSlot - 1]].get(x, None),
                    )
                    for x in (n, *ups)
                )
            )
        )

        if sKey in nodeFromHeading:
            if sKey not in multiple:
                multiple[sKey].append(nodeFromHeading[sKey])
            multiple[sKey].append(n)
        nodeFromHeading[sKey] = n
        headingFromNode[n] = sKey
    multiple = {
        sKey: tuple(sorted(ns, key=lambda n: rank[n - 1]))
        for (sKey, ns) in multiple.items()
    }

    top = tuple(
        sorted(
            (n for (n, h) in headingFromNode.items() if len(h) == 1),
            key=lambda n: rank[n - 1],
        )
    )

    up = {}
    for n, heading in headingFromNode.items():
        lHeading = len(heading)
        if lHeading == 1:
            continue
        upNode = None
        for i in range(lHeading - 1, 0, -1):
            upHeading = heading[0:i]
            upNode = nodeFromHeading.get(upHeading, None)
            if upNode is not None:
                up[n] = upNode
                break

    down = {}
    for n, heading in headingFromNode.items():
        if len(heading) == 1:
            continue
        down.setdefault(up[n], []).append(n)

    down = {n: tuple(sorted(ms, key=lambda m: rank[m - 1])) for (n, ms) in down.items()}

    return (headingFromNode, nodeFromHeading, multiple, top, up, down)</code></pre>
</details>
<div class="desc"><p>Computes structure data.</p>
<p>If the corpus has a rich section structure, it is possible to define
a flexible and extensive nest of structural sections.</p>
<p>Independent of this,
TF datasets may also define up to three section levels,
roughly corresponding with a volume, a chapter, a paragraph.
See <code><a title="tf.core.prepare.sections" href="#tf.core.prepare.sections">sections()</a></code>.</p>
<p>TF must be able to go from sections at one level to the sections
at one level lower. It must also be able to map section headings
to nodes. For this, the section features are needed, since they
contain the section headings.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>info</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write informational messages to the console.</dd>
<dt><strong><code>error</code></strong> :&ensp;<code>function</code></dt>
<dd>Method to write error messages to the console.</dd>
<dt><strong><code>otype</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <code>otype</code> feature.</dd>
<dt><strong><code>oslots</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <code>oslots</code> feature.</dd>
<dt><strong><code>otext</code></strong> :&ensp;<code>iterable</code></dt>
<dd>The data of the <code>otext</code> feature.</dd>
<dt><strong><code>rank</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The data of the <code><a title="tf.core.prepare.rank" href="#tf.core.prepare.rank">rank()</a></code> pre-computation step.</dd>
<dt><strong><code>levUp</code></strong> :&ensp;<code>tuple</code></dt>
<dd>The data of the <code><a title="tf.core.prepare.levUp" href="#tf.core.prepare.levUp">levUp()</a></code> pre-computation step.</dd>
<dt><strong><code>sFeats</code></strong> :&ensp;<code>iterable</code></dt>
<dd>Each <code>sFeat</code> the data of a section feature.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>
<ul>
<li><code>headingFromNode</code> (Mapping from nodes to section keys)</li>
<li><code>nodeFromHeading</code> (Mapping from section keys to nodes)</li>
<li><code>multiple</code></li>
<li><code>top</code></li>
<li><code>up</code></li>
<li><code>down</code></li>
</ul>
</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>A section key of a structural node is obtained by going a level up from
that node, retrieving the heading of that structural node, then going up again,
and so on till a top node is reached. The tuple of headings obtained in this way
is the
section key.</p></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.css" integrity="sha512-b+T2i3P45i1LZM7I00Ci5QquB9szqaxu+uuk5TUSGjZQ4w4n+qujQiIuvTv2BxE7WCGQCifNMksyKILDiHzsOg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.js" integrity="sha512-2B9/byNV1KKRm5nQ2RLViPFD6U4dUjDGwuW1GU+ImJh8YinPU9Zlq1GzdTMO+G2ROrB5o1qasJBy1ttYz0wCug==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<div class="toc">
<ul>
<li><a href="#pre-compute-data">Pre-compute data.</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.core" href="index.html">tf.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="tf.core.prepare.boundary" href="#tf.core.prepare.boundary">boundary</a></code></li>
<li><code><a title="tf.core.prepare.characters" href="#tf.core.prepare.characters">characters</a></code></li>
<li><code><a title="tf.core.prepare.levDown" href="#tf.core.prepare.levDown">levDown</a></code></li>
<li><code><a title="tf.core.prepare.levUp" href="#tf.core.prepare.levUp">levUp</a></code></li>
<li><code><a title="tf.core.prepare.levels" href="#tf.core.prepare.levels">levels</a></code></li>
<li><code><a title="tf.core.prepare.order" href="#tf.core.prepare.order">order</a></code></li>
<li><code><a title="tf.core.prepare.rank" href="#tf.core.prepare.rank">rank</a></code></li>
<li><code><a title="tf.core.prepare.sections" href="#tf.core.prepare.sections">sections</a></code></li>
<li><code><a title="tf.core.prepare.structure" href="#tf.core.prepare.structure">structure</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
