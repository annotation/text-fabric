<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>tf.core.api API documentation</title>
<meta name="description" content="The core API of TF â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.core.api</code></h1>
</header>
<section id="section-intro">
<h1 id="the-core-api-of-tf">The core API of TF.</h1>
<p>It provides methods to navigate nodes and edges and lookup features.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tf.core.api.addLocality"><code class="name flex">
<span>def <span class="ident">addLocality</span></span>(<span>api)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/83d1512535e43162a7288930a475e2f8e1c9f7d0/tf/core/api.py#L569-L571" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def addLocality(api):
    api.L = Locality(api)
    api.Locality = api.L</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tf.core.api.addNodes"><code class="name flex">
<span>def <span class="ident">addNodes</span></span>(<span>api)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/83d1512535e43162a7288930a475e2f8e1c9f7d0/tf/core/api.py#L574-L576" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def addNodes(api):
    api.N = Nodes(api)
    api.Nodes = api.N</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tf.core.api.addOtype"><code class="name flex">
<span>def <span class="ident">addOtype</span></span>(<span>api)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/83d1512535e43162a7288930a475e2f8e1c9f7d0/tf/core/api.py#L562-L566" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def addOtype(api):
    setattr(api.F.otype, &#34;all&#34;, tuple(o[0] for o in api.C.levels.data))
    setattr(
        api.F.otype, &#34;support&#34;, dict(((o[0], (o[2], o[3])) for o in api.C.levels.data))
    )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tf.core.api.addSearch"><code class="name flex">
<span>def <span class="ident">addSearch</span></span>(<span>api, silent='auto')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/83d1512535e43162a7288930a475e2f8e1c9f7d0/tf/core/api.py#L584-L587" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def addSearch(api, silent=SILENT_D):
    silent = silentConvert(silent)
    api.S = Search(api, silent)
    api.Search = api.S</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="tf.core.api.addText"><code class="name flex">
<span>def <span class="ident">addText</span></span>(<span>api)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/83d1512535e43162a7288930a475e2f8e1c9f7d0/tf/core/api.py#L579-L581" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def addText(api):
    api.T = Text(api)
    api.Text = api.T</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.core.api.Api"><code class="flex name class">
<span>class <span class="ident">Api</span></span>
<span>(</span><span>TF)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/83d1512535e43162a7288930a475e2f8e1c9f7d0/tf/core/api.py#L55-L559" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">class Api:
    def __init__(self, TF):
        self.TF = TF
        self.ignored = tuple(sorted(TF.featuresIgnored))
        &#34;&#34;&#34;Which features were found but ignored.

        Features are ignored if the feature is also present in another location
        that is loaded later.
        &#34;&#34;&#34;
        TF.ignored = self.ignored

        self.F = NodeFeatures()
        self.Feature = self.F
        self.E = EdgeFeatures()
        self.Edge = self.E
        self.C = Computeds()
        self.Computed = self.C
        tmObj = TF.tmObj
        TF.silentOn = tmObj.silentOn
        TF.silentOff = tmObj.silentOff
        TF.isSilent = tmObj.isSilent
        TF.setSilent = tmObj.setSilent
        TF.info = tmObj.info
        TF.warning = tmObj.warning
        TF.error = tmObj.error
        TF.cache = tmObj.cache
        TF.reset = tmObj.reset
        TF.indent = tmObj.indent

        &#34;&#34;&#34;All messages produced during the feature loading process.

        It also shows the messages that have been suppressed due to the `silent`
        parameter.
        &#34;&#34;&#34;

        TF.ensureLoaded = self.ensureLoaded
        TF.makeAvailableIn = self.makeAvailableIn
        TF.footprint = self.footprint

        setattr(self, &#34;FeatureString&#34;, self.Fs)
        setattr(self, &#34;EdgeString&#34;, self.Es)
        setattr(self, &#34;ComputedString&#34;, self.Cs)
        setattr(self, &#34;AllFeatures&#34;, self.Fall)
        setattr(self, &#34;AllEdges&#34;, self.Eall)
        setattr(self, &#34;AllComputeds&#34;, self.Call)
        setattr(self, &#34;loadLog&#34;, self.isLoaded)

    def Fs(self, fName, warn=True):
        &#34;&#34;&#34;Get the node feature sub API.

        If feature name is not a valid python identifier,
        or if you do not know its name in advance,
        you can not use `F.feature`, but you should use
        `Fs(feature)`.

        Parameters
        ----------
        fName: string
            The name of the feature.
        warn: boolean, optional `True`
            Whether to warn if the feature is not loaded.

        Returns
        -------
        The feature API, or `None` if the feature is not loaded.
        &#34;&#34;&#34;

        if not hasattr(self.F, fName):
            if warn:
                self.TF.error(f&#39;Node feature &#34;{fName}&#34; not loaded&#39;)
            return None
        return getattr(self.F, fName)

    def Es(self, fName, warn=True):
        &#34;&#34;&#34;Get the edge feature sub API.

        If feature name is not a valid python identifier,
        or if you do not know its name in advance,
        you can not use `E.feature`, but you should use
        `Es(feature)`.

        Parameters
        ----------
        fName: string
            The name of the feature.
        warn: boolean, optional `True`
            Whether to warn if the feature is not loaded.

        Returns
        -------
        The feature API, or `None` if the feature is not loaded.
        &#34;&#34;&#34;

        if not hasattr(self.E, fName):
            if warn:
                self.TF.error(f&#39;Edge feature &#34;{fName}&#34; not loaded&#39;)
            return None
        return getattr(self.E, fName)

    def Cs(self, fName, warn=True):
        &#34;&#34;&#34;Get the computed data sub API.

        If component name is not a valid python identifier,
        or if you do not know its name in advance,
        you can not use `C.component`, but you should use
        `Cs(component)`.

        Parameters
        ----------
        fName: string
            The name of the feature.
        warn: boolean, optional `True`
            Whether to warn if the feature is not loaded.

        Returns
        -------
        The feature API, or `None` if the feature is not loaded.
        &#34;&#34;&#34;

        if not hasattr(self.C, fName):
            if warn:
                self.TF.error(f&#39;Computed feature &#34;{fName}&#34; not loaded&#39;)
            return None
        return getattr(self.C, fName)

    def Fall(self, warp=True):
        &#34;&#34;&#34;Returns a sorted list of all usable, loaded node feature names.

        Parameters
        ----------
        warp: boolean, optional True
            Whether to include the warp features, i.e. `otype`.
        &#34;&#34;&#34;

        return sorted(x[0] for x in self.F.__dict__.items() if warp or x[0] != OTYPE)

    def Eall(self, warp=True):
        &#34;&#34;&#34;Returns a sorted list of all usable, loaded edge feature names.

        Parameters
        ----------
        warp: boolean, optional True
            Whether to include the warp features, i.e. `oslots`.
        &#34;&#34;&#34;

        return sorted(x[0] for x in self.E.__dict__.items() if warp or x[0] != OSLOTS)

    def Call(self):
        &#34;&#34;&#34;Returns a sorted list of all usable, loaded computed data names.&#34;&#34;&#34;

        return sorted(x[0] for x in self.C.__dict__.items())

    def isLoaded(
        self, features=None, pretty=True, valueType=True, path=False, meta=&#34;description&#34;
    ):
        &#34;&#34;&#34;Show information about loaded features.

        Parameters
        ----------
        features: iterable | string, optional None
            The features to get info for.
            If absent or None: all features seen by TF.
            If a string, it is a comma and / or space separated list of feature names.
            Otherwise the items of the iterable are feature names.

        pretty: boolean, optional True
            If True, it prints an overview of all features seen by TF with
            information about kind, type, source location and loaded status.
            The amount of information printed can be tweaked by other parameters.
            Otherwise, it returns this information as a dict.

        valueType: boolean, optional True
            Only relevant if `pretty=True`: whether to print the value type of
            the values in the feature file.

        path: boolean, optional True
            Only relevant if `pretty=True`: whether to print the path name of
            the feature file.

        meta: string|list|boolean, optional &#34;description&#34;
            Only relevant if `pretty=True`: controls what metadata of the feature
            should be printed.

            If it is None, False, or the empty string or empty list:
            no metadata will be printed.

            It it is the boolean value True: all metadata will be printed.

            If it is a list of key names or a string with key names
            separated by white-space and / or commas, only these metadata keys
            will be printed.

        Returns
        -------
        dict of dict
            The features are keys, the value per feature is None or a dict with the
            following information:

            `None` if  the feature is not loaded.

            If the feature is loaded:

            *   `kind`: `node`, `edge`, `config`, `computed`;
            *   `type` is the type of values: `int`, or `str` or `&#34;&#34;`;
            *   `edgeValues`: if an edge feature it indicates whether
                the edges have values. Otherwise `None`.
            *   `meta`: dictionary containing the metadata of the feature

            If `pretty`, nothing is returned, but the dict is pretty printed.
        &#34;&#34;&#34;

        fNames = list(self.TF.features) if features is None else fitemize(features)
        info = {}

        for fName in fNames:
            fMeta = {}
            fType = None
            edgeValues = None
            fSource = None
            hasInfo = True
            if fName in self.TF.features:
                fObj = self.TF.features[fName]
                fSource = ux(fObj.dirName)
                fMeta = fObj.metaData
                fType = fMeta.get(&#34;valueType&#34;, &#34;&#34;)
                fMeta = {k: v for (k, v) in fMeta.items() if k != &#34;valueType&#34;}

            isLoadedF = hasattr(self.F, fName)
            isLoadedE = hasattr(self.E, fName)
            if isLoadedF or isLoadedE:
                if isLoadedF:
                    fKind = &#34;node&#34;
                elif isLoadedE:
                    fKind = &#34;edge&#34;
                    flObj = getattr(self.E, fName)
                    edgeValues = False if fName == &#34;oslots&#34; else flObj.doValues
            elif (
                fName.startswith(&#34;__&#34;)
                and fName.endswith(&#34;__&#34;)
                and hasattr(self.C, fName.strip(&#34;_&#34;))
            ):
                fKind = &#34;computed&#34;
            elif fName in self.TF.features:
                if fObj.isConfig:
                    fKind = &#34;config&#34;
                else:
                    hasInfo = False
            else:
                hasInfo = False

            info[fName] = (
                dict(
                    kind=fKind,
                    type=fType,
                    meta=fMeta,
                    source=fSource,
                    edgeValues=edgeValues,
                )
                if hasInfo
                else None
            )
        if pretty:
            for (fName, fInfo) in sorted(info.items()):
                if fInfo is None:
                    kind = &#34;NOT LOADED&#34;
                    kind = f&#34; {kind:&lt;10}&#34;
                    fSource = &#34;&#34;
                    metaRep = &#34;&#34;
                    heading = f&#34;{fName:&lt;20}{kind}{fSource}&#34;
                else:
                    fKind = fInfo[&#34;kind&#34;]
                    fMeta = fInfo.get(&#34;meta&#34;, {})
                    fType = fInfo.get(&#34;type&#34;, &#34;&#34;)
                    fSource = fInfo.get(&#34;source&#34;, &#34;&#34;) if path else &#34;&#34;
                    fSource = f&#34; {fSource}&#34; if fSource else &#34;&#34;
                    fEV = fInfo.get(&#34;edgeValues&#34;, &#34;&#34;)
                    if valueType:
                        kind = (
                            f&#34;node ({fType})&#34;
                            if fKind == &#34;node&#34;
                            else f&#34;edge ({fType})&#34;
                            if fKind == &#34;edge&#34; and fEV
                            else &#34;edge&#34;
                            if fKind == &#34;edge&#34;
                            else f&#34;{fKind}&#34;
                        )
                        kind = f&#34; {kind:&lt;10}&#34; if kind else &#34;&#34;
                    else:
                        kind = &#34;&#34;
                    if meta is True:
                        metaKeys = sorted(fMeta.keys())
                        metaInfo = fMeta
                    elif not meta:
                        metaInfo = {}
                    else:
                        metaKeys = fitemize(meta)
                        metaInfo = {k: fMeta[k] for k in metaKeys if k in fMeta}

                    heading = f&#34;{fName:&lt;20}{kind}{fSource}&#34;
                    metaRep = &#34;&#34;
                    indent = &#34; &#34; * (len(heading) + 1)
                    if metaInfo:
                        if len(metaKeys) == 1:
                            value = metaInfo.get(metaKeys[0], &#34;&#34;)
                            value = &#34;\n&#34;.join(
                                wrap(value, width=80, subsequent_indent=indent)
                            )
                            metaRep = f&#34; {value}&#34; if value else &#34;&#34;
                        else:
                            indent = &#34; &#34; * 21
                            for k in metaKeys:
                                value = metaInfo.get(k, &#34;&#34;)
                                value = &#34;\n&#34;.join(
                                    wrap(
                                        value,
                                        width=80,
                                        subsequent_indent=f&#34;\t{indent}  &#34;,
                                    )
                                )
                                metaRep += f&#34;\n\t{k:&lt;20} = {value}&#34;

                msg = f&#34;{heading}{metaRep}&#34;
                console(msg)
            return None
        return info

    def makeAvailableIn(self, scope):
        &#34;&#34;&#34;Exports members of the API to the global namespace.

        Only the members whose names start with a capital are exported.

        If you are working with a single data source in your program, it is a bit
        tedious to write the initial `TF.api.` or `A.api` all the time.
        By this method you can avoid that.

        !!! explanation &#34;Longer names&#34;
            There are also longer names which can be used as aliases
            to the single capital letters.
            This might or might not improve the readability of your program.

            short name | long name
            --- | ---
            `N` | `Nodes`
            `F` | `Feature`
            `Fs` | `FeatureString`
            `Fall` | `AllFeatures`
            `E` | `Edge`
            `Es` | `EdgeString`
            `Eall`  `AllEdges`
            `C` | `Computed`
            `Cs`  `ComputedString`
            `Call` | `AllComputeds`
            `L` | `Locality`
            `T` | `Text`
            `S` | `Search`

        Parameters
        ----------
        scope: dict
            A dictionary into which the members of the core API will be inserted.
            The only sensible choice is: `globals()`.

        Returns
        -------
        tuple
            A grouped list of API members that has been hoisted to the global
            scope.

        Notes
        -----
        !!! explanation &#34;Why pass `globals()`?&#34;
            Although we know it should always be `globals()`, we cannot
            define a function that looks into the `globals()` of its caller.
            So we have to pass it on.
        &#34;&#34;&#34;

        for member in dir(self):
            if &#34;_&#34; not in member and member[0].isupper():
                scope[member] = getattr(self, member)
                if member not in API_REFS:
                    console(f&#39;WARNING: API member &#34;{member}&#34; not documented&#39;)

        grouped = {}
        for (member, (head, sub, ref)) in API_REFS.items():
            grouped.setdefault(ref, {}).setdefault((head, sub), []).append(member)

        # grouped
        # node-features=&gt;(Features, node)=&gt;[F, ...]

        docs = []
        for (ref, groups) in sorted(grouped.items()):
            chunks = []
            for ((head, sub), members) in sorted(groups.items()):
                chunks.append(&#34; &#34;.join(sorted(members, key=lambda x: (len(x), x))))
            docs.append((head, ref, tuple(chunks)))
        return docs

    # docs
    # (Features, node-features, (&#39;F ...&#39;, ...))

    def ensureLoaded(self, features):
        &#34;&#34;&#34;Checks if features are loaded and if not loads them.

        All features in question will be made available to the core API.

        Parameters
        ----------
        features: string | iterable of strings
            It is a string containing space separated feature names,
            or an iterable of feature names.
            The feature names are just the names of `.tf` files
            without directory information and without extension.

        Returns
        -------
        set
            The names of the features in question as a set of strings.
        &#34;&#34;&#34;

        F = self.F
        E = self.E
        TF = self.TF
        warning = TF.warning

        needToLoad = set()
        loadedFeatures = set()

        for fName in sorted(flattenToSet(features)):
            fObj = TF.features.get(fName, None)
            if not fObj:
                warning(f&#39;Cannot load feature &#34;{fName}&#34;: not in dataset&#39;)
                continue
            if fObj.dataLoaded and (hasattr(F, fName) or hasattr(E, fName)):
                loadedFeatures.add(fName)
            else:
                needToLoad.add(fName)
        if len(needToLoad):
            TF.load(
                needToLoad,
                add=True,
                silent=DEEP,
            )
            loadedFeatures |= needToLoad
        return loadedFeatures

    def footprint(self, recompute=False, bySize=True):
        &#34;&#34;&#34;Computes the memory footprint in RAM of the loaded TF data.

        This includes the pre-computed data.

        Parameters
        ----------
        recompute: boolean, optional False
            The function looks first for earlier computed size data.
            If that is found, it will be used, and no size computation will take place.
            Unless this parameter is True.
            If no earlier computed size data is found, sizes will be computed anyway.
        bySize: boolean, optional True
            Whether to sort the features by the size they occupy in RAM.
            If False, the features will be sorted alphabetically.
        &#34;&#34;&#34;
        if hasattr(self, &#34;sizes&#34;) and not recompute:
            sizes = self.sizes
        else:
            TF = self.TF
            features = TF.features
            nFeatures = len(features)
            sizes = {}

            for ft in sorted(features):
                console(f&#34;\rcomputing size of {ft:&lt;30}&#34;, newline=False)
                data = features[ft].data
                if data is None:
                    continue
                nData = len(data)
                sData = deepSize(data)
                sizes[ft] = (nData, sData)

            console(f&#39;\r{&#34;&#34;:&gt;40}&#39;, newline=False)
            self.sizes = sizes

        material = &#34;&#34;

        nFeatures = len(sizes)
        totals = collections.Counter()

        for (ft, (nData, sData)) in sorted(
            sizes.items(),
            key=(lambda x: (-x[1][1], x[0])) if bySize else lambda x: x[0],
        ):
            material += f&#34;{ft} | {nData:,} | {sData:,}\n&#34;
            totals[&#34;nData&#34;] += nData
            totals[&#34;sData&#34;] += sData

        material += f&#39;TOTAL | {totals[&#34;nData&#34;]:,} | {totals[&#34;sData&#34;]:,}&#39;
        header = dedent(
            f&#34;&#34;&#34;
            # {nFeatures} features

            feature | members | size in bytes
            --- | --- | ---
            &#34;&#34;&#34;
        )

        dm(header + material)</code></pre>
</details>
<div class="desc"></div>
<h3>Instance variables</h3>
<dl>
<dt id="tf.core.api.Api.ignored"><code class="name">var <span class="ident">ignored</span></code></dt>
<dd>
<div class="desc"><p>Which features were found but ignored.</p>
<p>Features are ignored if the feature is also present in another location
that is loaded later.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tf.core.api.Api.Call"><code class="name flex">
<span>def <span class="ident">Call</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/83d1512535e43162a7288930a475e2f8e1c9f7d0/tf/core/api.py#L202-L205" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def Call(self):
    &#34;&#34;&#34;Returns a sorted list of all usable, loaded computed data names.&#34;&#34;&#34;

    return sorted(x[0] for x in self.C.__dict__.items())</code></pre>
</details>
<div class="desc"><p>Returns a sorted list of all usable, loaded computed data names.</p></div>
</dd>
<dt id="tf.core.api.Api.Cs"><code class="name flex">
<span>def <span class="ident">Cs</span></span>(<span>self, fName, warn=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/83d1512535e43162a7288930a475e2f8e1c9f7d0/tf/core/api.py#L154-L178" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def Cs(self, fName, warn=True):
    &#34;&#34;&#34;Get the computed data sub API.

    If component name is not a valid python identifier,
    or if you do not know its name in advance,
    you can not use `C.component`, but you should use
    `Cs(component)`.

    Parameters
    ----------
    fName: string
        The name of the feature.
    warn: boolean, optional `True`
        Whether to warn if the feature is not loaded.

    Returns
    -------
    The feature API, or `None` if the feature is not loaded.
    &#34;&#34;&#34;

    if not hasattr(self.C, fName):
        if warn:
            self.TF.error(f&#39;Computed feature &#34;{fName}&#34; not loaded&#39;)
        return None
    return getattr(self.C, fName)</code></pre>
</details>
<div class="desc"><p>Get the computed data sub API.</p>
<p>If component name is not a valid python identifier,
or if you do not know its name in advance,
you can not use <code>C.component</code>, but you should use
<code>Cs(component)</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fName</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the feature.</dd>
<dt><strong><code>warn</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>Whether to warn if the feature is not loaded.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The feature API, or <code>None</code> if the feature is not loaded.</p></div>
</dd>
<dt id="tf.core.api.Api.Eall"><code class="name flex">
<span>def <span class="ident">Eall</span></span>(<span>self, warp=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/83d1512535e43162a7288930a475e2f8e1c9f7d0/tf/core/api.py#L191-L200" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def Eall(self, warp=True):
    &#34;&#34;&#34;Returns a sorted list of all usable, loaded edge feature names.

    Parameters
    ----------
    warp: boolean, optional True
        Whether to include the warp features, i.e. `oslots`.
    &#34;&#34;&#34;

    return sorted(x[0] for x in self.E.__dict__.items() if warp or x[0] != OSLOTS)</code></pre>
</details>
<div class="desc"><p>Returns a sorted list of all usable, loaded edge feature names.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>warp</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>Whether to include the warp features, i.e. <code>oslots</code>.</dd>
</dl></div>
</dd>
<dt id="tf.core.api.Api.Es"><code class="name flex">
<span>def <span class="ident">Es</span></span>(<span>self, fName, warn=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/83d1512535e43162a7288930a475e2f8e1c9f7d0/tf/core/api.py#L128-L152" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def Es(self, fName, warn=True):
    &#34;&#34;&#34;Get the edge feature sub API.

    If feature name is not a valid python identifier,
    or if you do not know its name in advance,
    you can not use `E.feature`, but you should use
    `Es(feature)`.

    Parameters
    ----------
    fName: string
        The name of the feature.
    warn: boolean, optional `True`
        Whether to warn if the feature is not loaded.

    Returns
    -------
    The feature API, or `None` if the feature is not loaded.
    &#34;&#34;&#34;

    if not hasattr(self.E, fName):
        if warn:
            self.TF.error(f&#39;Edge feature &#34;{fName}&#34; not loaded&#39;)
        return None
    return getattr(self.E, fName)</code></pre>
</details>
<div class="desc"><p>Get the edge feature sub API.</p>
<p>If feature name is not a valid python identifier,
or if you do not know its name in advance,
you can not use <code>E.feature</code>, but you should use
<code>Es(feature)</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fName</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the feature.</dd>
<dt><strong><code>warn</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>Whether to warn if the feature is not loaded.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The feature API, or <code>None</code> if the feature is not loaded.</p></div>
</dd>
<dt id="tf.core.api.Api.Fall"><code class="name flex">
<span>def <span class="ident">Fall</span></span>(<span>self, warp=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/83d1512535e43162a7288930a475e2f8e1c9f7d0/tf/core/api.py#L180-L189" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def Fall(self, warp=True):
    &#34;&#34;&#34;Returns a sorted list of all usable, loaded node feature names.

    Parameters
    ----------
    warp: boolean, optional True
        Whether to include the warp features, i.e. `otype`.
    &#34;&#34;&#34;

    return sorted(x[0] for x in self.F.__dict__.items() if warp or x[0] != OTYPE)</code></pre>
</details>
<div class="desc"><p>Returns a sorted list of all usable, loaded node feature names.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>warp</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>Whether to include the warp features, i.e. <code>otype</code>.</dd>
</dl></div>
</dd>
<dt id="tf.core.api.Api.Fs"><code class="name flex">
<span>def <span class="ident">Fs</span></span>(<span>self, fName, warn=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/83d1512535e43162a7288930a475e2f8e1c9f7d0/tf/core/api.py#L102-L126" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def Fs(self, fName, warn=True):
    &#34;&#34;&#34;Get the node feature sub API.

    If feature name is not a valid python identifier,
    or if you do not know its name in advance,
    you can not use `F.feature`, but you should use
    `Fs(feature)`.

    Parameters
    ----------
    fName: string
        The name of the feature.
    warn: boolean, optional `True`
        Whether to warn if the feature is not loaded.

    Returns
    -------
    The feature API, or `None` if the feature is not loaded.
    &#34;&#34;&#34;

    if not hasattr(self.F, fName):
        if warn:
            self.TF.error(f&#39;Node feature &#34;{fName}&#34; not loaded&#39;)
        return None
    return getattr(self.F, fName)</code></pre>
</details>
<div class="desc"><p>Get the node feature sub API.</p>
<p>If feature name is not a valid python identifier,
or if you do not know its name in advance,
you can not use <code>F.feature</code>, but you should use
<code>Fs(feature)</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>fName</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the feature.</dd>
<dt><strong><code>warn</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>Whether to warn if the feature is not loaded.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The feature API, or <code>None</code> if the feature is not loaded.</p></div>
</dd>
<dt id="tf.core.api.Api.ensureLoaded"><code class="name flex">
<span>def <span class="ident">ensureLoaded</span></span>(<span>self, features)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/83d1512535e43162a7288930a475e2f8e1c9f7d0/tf/core/api.py#L455-L498" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def ensureLoaded(self, features):
    &#34;&#34;&#34;Checks if features are loaded and if not loads them.

    All features in question will be made available to the core API.

    Parameters
    ----------
    features: string | iterable of strings
        It is a string containing space separated feature names,
        or an iterable of feature names.
        The feature names are just the names of `.tf` files
        without directory information and without extension.

    Returns
    -------
    set
        The names of the features in question as a set of strings.
    &#34;&#34;&#34;

    F = self.F
    E = self.E
    TF = self.TF
    warning = TF.warning

    needToLoad = set()
    loadedFeatures = set()

    for fName in sorted(flattenToSet(features)):
        fObj = TF.features.get(fName, None)
        if not fObj:
            warning(f&#39;Cannot load feature &#34;{fName}&#34;: not in dataset&#39;)
            continue
        if fObj.dataLoaded and (hasattr(F, fName) or hasattr(E, fName)):
            loadedFeatures.add(fName)
        else:
            needToLoad.add(fName)
    if len(needToLoad):
        TF.load(
            needToLoad,
            add=True,
            silent=DEEP,
        )
        loadedFeatures |= needToLoad
    return loadedFeatures</code></pre>
</details>
<div class="desc"><p>Checks if features are loaded and if not loads them.</p>
<p>All features in question will be made available to the core API.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>features</code></strong> :&ensp;<code>string | iterable</code> of <code>strings</code></dt>
<dd>It is a string containing space separated feature names,
or an iterable of feature names.
The feature names are just the names of <code>.<a title="tf" href="../index.html">tf</a></code> files
without directory information and without extension.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>set</code></dt>
<dd>The names of the features in question as a set of strings.</dd>
</dl></div>
</dd>
<dt id="tf.core.api.Api.footprint"><code class="name flex">
<span>def <span class="ident">footprint</span></span>(<span>self, recompute=False, bySize=True)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/83d1512535e43162a7288930a475e2f8e1c9f7d0/tf/core/api.py#L500-L559" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def footprint(self, recompute=False, bySize=True):
    &#34;&#34;&#34;Computes the memory footprint in RAM of the loaded TF data.

    This includes the pre-computed data.

    Parameters
    ----------
    recompute: boolean, optional False
        The function looks first for earlier computed size data.
        If that is found, it will be used, and no size computation will take place.
        Unless this parameter is True.
        If no earlier computed size data is found, sizes will be computed anyway.
    bySize: boolean, optional True
        Whether to sort the features by the size they occupy in RAM.
        If False, the features will be sorted alphabetically.
    &#34;&#34;&#34;
    if hasattr(self, &#34;sizes&#34;) and not recompute:
        sizes = self.sizes
    else:
        TF = self.TF
        features = TF.features
        nFeatures = len(features)
        sizes = {}

        for ft in sorted(features):
            console(f&#34;\rcomputing size of {ft:&lt;30}&#34;, newline=False)
            data = features[ft].data
            if data is None:
                continue
            nData = len(data)
            sData = deepSize(data)
            sizes[ft] = (nData, sData)

        console(f&#39;\r{&#34;&#34;:&gt;40}&#39;, newline=False)
        self.sizes = sizes

    material = &#34;&#34;

    nFeatures = len(sizes)
    totals = collections.Counter()

    for (ft, (nData, sData)) in sorted(
        sizes.items(),
        key=(lambda x: (-x[1][1], x[0])) if bySize else lambda x: x[0],
    ):
        material += f&#34;{ft} | {nData:,} | {sData:,}\n&#34;
        totals[&#34;nData&#34;] += nData
        totals[&#34;sData&#34;] += sData

    material += f&#39;TOTAL | {totals[&#34;nData&#34;]:,} | {totals[&#34;sData&#34;]:,}&#39;
    header = dedent(
        f&#34;&#34;&#34;
        # {nFeatures} features

        feature | members | size in bytes
        --- | --- | ---
        &#34;&#34;&#34;
    )

    dm(header + material)</code></pre>
</details>
<div class="desc"><p>Computes the memory footprint in RAM of the loaded TF data.</p>
<p>This includes the pre-computed data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>recompute</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>The function looks first for earlier computed size data.
If that is found, it will be used, and no size computation will take place.
Unless this parameter is True.
If no earlier computed size data is found, sizes will be computed anyway.</dd>
<dt><strong><code>bySize</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>Whether to sort the features by the size they occupy in RAM.
If False, the features will be sorted alphabetically.</dd>
</dl></div>
</dd>
<dt id="tf.core.api.Api.isLoaded"><code class="name flex">
<span>def <span class="ident">isLoaded</span></span>(<span>self, features=None, pretty=True, valueType=True, path=False, meta='description')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/83d1512535e43162a7288930a475e2f8e1c9f7d0/tf/core/api.py#L207-L379" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def isLoaded(
    self, features=None, pretty=True, valueType=True, path=False, meta=&#34;description&#34;
):
    &#34;&#34;&#34;Show information about loaded features.

    Parameters
    ----------
    features: iterable | string, optional None
        The features to get info for.
        If absent or None: all features seen by TF.
        If a string, it is a comma and / or space separated list of feature names.
        Otherwise the items of the iterable are feature names.

    pretty: boolean, optional True
        If True, it prints an overview of all features seen by TF with
        information about kind, type, source location and loaded status.
        The amount of information printed can be tweaked by other parameters.
        Otherwise, it returns this information as a dict.

    valueType: boolean, optional True
        Only relevant if `pretty=True`: whether to print the value type of
        the values in the feature file.

    path: boolean, optional True
        Only relevant if `pretty=True`: whether to print the path name of
        the feature file.

    meta: string|list|boolean, optional &#34;description&#34;
        Only relevant if `pretty=True`: controls what metadata of the feature
        should be printed.

        If it is None, False, or the empty string or empty list:
        no metadata will be printed.

        It it is the boolean value True: all metadata will be printed.

        If it is a list of key names or a string with key names
        separated by white-space and / or commas, only these metadata keys
        will be printed.

    Returns
    -------
    dict of dict
        The features are keys, the value per feature is None or a dict with the
        following information:

        `None` if  the feature is not loaded.

        If the feature is loaded:

        *   `kind`: `node`, `edge`, `config`, `computed`;
        *   `type` is the type of values: `int`, or `str` or `&#34;&#34;`;
        *   `edgeValues`: if an edge feature it indicates whether
            the edges have values. Otherwise `None`.
        *   `meta`: dictionary containing the metadata of the feature

        If `pretty`, nothing is returned, but the dict is pretty printed.
    &#34;&#34;&#34;

    fNames = list(self.TF.features) if features is None else fitemize(features)
    info = {}

    for fName in fNames:
        fMeta = {}
        fType = None
        edgeValues = None
        fSource = None
        hasInfo = True
        if fName in self.TF.features:
            fObj = self.TF.features[fName]
            fSource = ux(fObj.dirName)
            fMeta = fObj.metaData
            fType = fMeta.get(&#34;valueType&#34;, &#34;&#34;)
            fMeta = {k: v for (k, v) in fMeta.items() if k != &#34;valueType&#34;}

        isLoadedF = hasattr(self.F, fName)
        isLoadedE = hasattr(self.E, fName)
        if isLoadedF or isLoadedE:
            if isLoadedF:
                fKind = &#34;node&#34;
            elif isLoadedE:
                fKind = &#34;edge&#34;
                flObj = getattr(self.E, fName)
                edgeValues = False if fName == &#34;oslots&#34; else flObj.doValues
        elif (
            fName.startswith(&#34;__&#34;)
            and fName.endswith(&#34;__&#34;)
            and hasattr(self.C, fName.strip(&#34;_&#34;))
        ):
            fKind = &#34;computed&#34;
        elif fName in self.TF.features:
            if fObj.isConfig:
                fKind = &#34;config&#34;
            else:
                hasInfo = False
        else:
            hasInfo = False

        info[fName] = (
            dict(
                kind=fKind,
                type=fType,
                meta=fMeta,
                source=fSource,
                edgeValues=edgeValues,
            )
            if hasInfo
            else None
        )
    if pretty:
        for (fName, fInfo) in sorted(info.items()):
            if fInfo is None:
                kind = &#34;NOT LOADED&#34;
                kind = f&#34; {kind:&lt;10}&#34;
                fSource = &#34;&#34;
                metaRep = &#34;&#34;
                heading = f&#34;{fName:&lt;20}{kind}{fSource}&#34;
            else:
                fKind = fInfo[&#34;kind&#34;]
                fMeta = fInfo.get(&#34;meta&#34;, {})
                fType = fInfo.get(&#34;type&#34;, &#34;&#34;)
                fSource = fInfo.get(&#34;source&#34;, &#34;&#34;) if path else &#34;&#34;
                fSource = f&#34; {fSource}&#34; if fSource else &#34;&#34;
                fEV = fInfo.get(&#34;edgeValues&#34;, &#34;&#34;)
                if valueType:
                    kind = (
                        f&#34;node ({fType})&#34;
                        if fKind == &#34;node&#34;
                        else f&#34;edge ({fType})&#34;
                        if fKind == &#34;edge&#34; and fEV
                        else &#34;edge&#34;
                        if fKind == &#34;edge&#34;
                        else f&#34;{fKind}&#34;
                    )
                    kind = f&#34; {kind:&lt;10}&#34; if kind else &#34;&#34;
                else:
                    kind = &#34;&#34;
                if meta is True:
                    metaKeys = sorted(fMeta.keys())
                    metaInfo = fMeta
                elif not meta:
                    metaInfo = {}
                else:
                    metaKeys = fitemize(meta)
                    metaInfo = {k: fMeta[k] for k in metaKeys if k in fMeta}

                heading = f&#34;{fName:&lt;20}{kind}{fSource}&#34;
                metaRep = &#34;&#34;
                indent = &#34; &#34; * (len(heading) + 1)
                if metaInfo:
                    if len(metaKeys) == 1:
                        value = metaInfo.get(metaKeys[0], &#34;&#34;)
                        value = &#34;\n&#34;.join(
                            wrap(value, width=80, subsequent_indent=indent)
                        )
                        metaRep = f&#34; {value}&#34; if value else &#34;&#34;
                    else:
                        indent = &#34; &#34; * 21
                        for k in metaKeys:
                            value = metaInfo.get(k, &#34;&#34;)
                            value = &#34;\n&#34;.join(
                                wrap(
                                    value,
                                    width=80,
                                    subsequent_indent=f&#34;\t{indent}  &#34;,
                                )
                            )
                            metaRep += f&#34;\n\t{k:&lt;20} = {value}&#34;

            msg = f&#34;{heading}{metaRep}&#34;
            console(msg)
        return None
    return info</code></pre>
</details>
<div class="desc"><p>Show information about loaded features.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>features</code></strong> :&ensp;<code>iterable | string</code>, optional <code>None</code></dt>
<dd>The features to get info for.
If absent or None: all features seen by TF.
If a string, it is a comma and / or space separated list of feature names.
Otherwise the items of the iterable are feature names.</dd>
<dt><strong><code>pretty</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>If True, it prints an overview of all features seen by TF with
information about kind, type, source location and loaded status.
The amount of information printed can be tweaked by other parameters.
Otherwise, it returns this information as a dict.</dd>
<dt><strong><code>valueType</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>Only relevant if <code>pretty=True</code>: whether to print the value type of
the values in the feature file.</dd>
<dt><strong><code>path</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>Only relevant if <code>pretty=True</code>: whether to print the path name of
the feature file.</dd>
<dt><strong><code>meta</code></strong> :&ensp;<code>string|list|boolean</code>, optional <code>"description"</code></dt>
<dd>
<p>Only relevant if <code>pretty=True</code>: controls what metadata of the feature
should be printed.</p>
<p>If it is None, False, or the empty string or empty list:
no metadata will be printed.</p>
<p>It it is the boolean value True: all metadata will be printed.</p>
<p>If it is a list of key names or a string with key names
separated by white-space and / or commas, only these metadata keys
will be printed.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code> of <code>dict</code></dt>
<dd>
<p>The features are keys, the value per feature is None or a dict with the
following information:</p>
<p><code>None</code> if
the feature is not loaded.</p>
<p>If the feature is loaded:</p>
<ul>
<li><code>kind</code>: <code>node</code>, <code>edge</code>, <code>config</code>, <code>computed</code>;</li>
<li><code>type</code> is the type of values: <code>int</code>, or <code>str</code> or <code>""</code>;</li>
<li><code>edgeValues</code>: if an edge feature it indicates whether
the edges have values. Otherwise <code>None</code>.</li>
<li><code>meta</code>: dictionary containing the metadata of the feature</li>
</ul>
<p>If <code>pretty</code>, nothing is returned, but the dict is pretty printed.</p>
</dd>
</dl></div>
</dd>
<dt id="tf.core.api.Api.makeAvailableIn"><code class="name flex">
<span>def <span class="ident">makeAvailableIn</span></span>(<span>self, scope)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/83d1512535e43162a7288930a475e2f8e1c9f7d0/tf/core/api.py#L381-L450" class="git-link" target="_blank">Browse git</a>
</summary>
<pre><code class="python">def makeAvailableIn(self, scope):
    &#34;&#34;&#34;Exports members of the API to the global namespace.

    Only the members whose names start with a capital are exported.

    If you are working with a single data source in your program, it is a bit
    tedious to write the initial `TF.api.` or `A.api` all the time.
    By this method you can avoid that.

    !!! explanation &#34;Longer names&#34;
        There are also longer names which can be used as aliases
        to the single capital letters.
        This might or might not improve the readability of your program.

        short name | long name
        --- | ---
        `N` | `Nodes`
        `F` | `Feature`
        `Fs` | `FeatureString`
        `Fall` | `AllFeatures`
        `E` | `Edge`
        `Es` | `EdgeString`
        `Eall`  `AllEdges`
        `C` | `Computed`
        `Cs`  `ComputedString`
        `Call` | `AllComputeds`
        `L` | `Locality`
        `T` | `Text`
        `S` | `Search`

    Parameters
    ----------
    scope: dict
        A dictionary into which the members of the core API will be inserted.
        The only sensible choice is: `globals()`.

    Returns
    -------
    tuple
        A grouped list of API members that has been hoisted to the global
        scope.

    Notes
    -----
    !!! explanation &#34;Why pass `globals()`?&#34;
        Although we know it should always be `globals()`, we cannot
        define a function that looks into the `globals()` of its caller.
        So we have to pass it on.
    &#34;&#34;&#34;

    for member in dir(self):
        if &#34;_&#34; not in member and member[0].isupper():
            scope[member] = getattr(self, member)
            if member not in API_REFS:
                console(f&#39;WARNING: API member &#34;{member}&#34; not documented&#39;)

    grouped = {}
    for (member, (head, sub, ref)) in API_REFS.items():
        grouped.setdefault(ref, {}).setdefault((head, sub), []).append(member)

    # grouped
    # node-features=&gt;(Features, node)=&gt;[F, ...]

    docs = []
    for (ref, groups) in sorted(grouped.items()):
        chunks = []
        for ((head, sub), members) in sorted(groups.items()):
            chunks.append(&#34; &#34;.join(sorted(members, key=lambda x: (len(x), x))))
        docs.append((head, ref, tuple(chunks)))
    return docs</code></pre>
</details>
<div class="desc"><p>Exports members of the API to the global namespace.</p>
<p>Only the members whose names start with a capital are exported.</p>
<p>If you are working with a single data source in your program, it is a bit
tedious to write the initial <code>TF.api.</code> or <code>A.api</code> all the time.
By this method you can avoid that.</p>
<div class="admonition explanation">
<p class="admonition-title">Longer names</p>
<p>There are also longer names which can be used as aliases
to the single capital letters.
This might or might not improve the readability of your program.</p>
<table>
<thead>
<tr>
<th>short name</th>
<th>long name</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>N</code></td>
<td><code>Nodes</code></td>
</tr>
<tr>
<td><code>F</code></td>
<td><code>Feature</code></td>
</tr>
<tr>
<td><code>Fs</code></td>
<td><code>FeatureString</code></td>
</tr>
<tr>
<td><code>Fall</code></td>
<td><code>AllFeatures</code></td>
</tr>
<tr>
<td><code>E</code></td>
<td><code>Edge</code></td>
</tr>
<tr>
<td><code>Es</code></td>
<td><code>EdgeString</code></td>
</tr>
<tr>
<td><code>Eall</code>
<code>AllEdges</code></td>
<td></td>
</tr>
<tr>
<td><code>C</code></td>
<td><code>Computed</code></td>
</tr>
<tr>
<td><code>Cs</code>
<code>ComputedString</code></td>
<td></td>
</tr>
<tr>
<td><code>Call</code></td>
<td><code>AllComputeds</code></td>
</tr>
<tr>
<td><code>L</code></td>
<td><code>Locality</code></td>
</tr>
<tr>
<td><code>T</code></td>
<td><code>Text</code></td>
</tr>
<tr>
<td><code>S</code></td>
<td><code>Search</code></td>
</tr>
</tbody>
</table>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>scope</code></strong> :&ensp;<code>dict</code></dt>
<dd>A dictionary into which the members of the core API will be inserted.
The only sensible choice is: <code>globals()</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>A grouped list of API members that has been hoisted to the global
scope.</dd>
</dl>
<h2 id="notes">Notes</h2>
<div class="admonition explanation">
<p class="admonition-title">Why pass <code>globals()</code>?</p>
<p>Although we know it should always be <code>globals()</code>, we cannot
define a function that looks into the <code>globals()</code> of its caller.
So we have to pass it on.</p>
</div></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.css" integrity="sha512-b+T2i3P45i1LZM7I00Ci5QquB9szqaxu+uuk5TUSGjZQ4w4n+qujQiIuvTv2BxE7WCGQCifNMksyKILDiHzsOg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.16.0/tingle.min.js" integrity="sha512-2B9/byNV1KKRm5nQ2RLViPFD6U4dUjDGwuW1GU+ImJh8YinPU9Zlq1GzdTMO+G2ROrB5o1qasJBy1ttYz0wCug==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<div class="toc">
<ul>
<li><a href="#the-core-api-of-tf">The core API of TF.</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.core" href="index.html">tf.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tf.core.api.addLocality" href="#tf.core.api.addLocality">addLocality</a></code></li>
<li><code><a title="tf.core.api.addNodes" href="#tf.core.api.addNodes">addNodes</a></code></li>
<li><code><a title="tf.core.api.addOtype" href="#tf.core.api.addOtype">addOtype</a></code></li>
<li><code><a title="tf.core.api.addSearch" href="#tf.core.api.addSearch">addSearch</a></code></li>
<li><code><a title="tf.core.api.addText" href="#tf.core.api.addText">addText</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.core.api.Api" href="#tf.core.api.Api">Api</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.core.api.Api.Call" href="#tf.core.api.Api.Call">Call</a></code></li>
<li><code><a title="tf.core.api.Api.Cs" href="#tf.core.api.Api.Cs">Cs</a></code></li>
<li><code><a title="tf.core.api.Api.Eall" href="#tf.core.api.Api.Eall">Eall</a></code></li>
<li><code><a title="tf.core.api.Api.Es" href="#tf.core.api.Api.Es">Es</a></code></li>
<li><code><a title="tf.core.api.Api.Fall" href="#tf.core.api.Api.Fall">Fall</a></code></li>
<li><code><a title="tf.core.api.Api.Fs" href="#tf.core.api.Api.Fs">Fs</a></code></li>
<li><code><a title="tf.core.api.Api.ensureLoaded" href="#tf.core.api.Api.ensureLoaded">ensureLoaded</a></code></li>
<li><code><a title="tf.core.api.Api.footprint" href="#tf.core.api.Api.footprint">footprint</a></code></li>
<li><code><a title="tf.core.api.Api.ignored" href="#tf.core.api.Api.ignored">ignored</a></code></li>
<li><code><a title="tf.core.api.Api.isLoaded" href="#tf.core.api.Api.isLoaded">isLoaded</a></code></li>
<li><code><a title="tf.core.api.Api.makeAvailableIn" href="#tf.core.api.Api.makeAvailableIn">makeAvailableIn</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
