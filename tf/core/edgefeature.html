<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.core.edgefeature API documentation</title>
<meta name="description" content="Mappings from edges to values â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.core.edgefeature</code></h1>
</header>
<section id="section-intro">
<p>Mappings from edges to values.</p>
<p>Every edge feature is logically a mapping from pairs of nodes to values,
string or integer.</p>
<p>A feature object gives you methods that you can pass a node and that returns
its value for that node.</p>
<p>It is easiest to think of all edge features as a dictionary keyed by nodes.
The values are either sets or dictionaries.
If the value is a set, then the elements are the second node in the pair
and the value is <code>None</code>.
If the value is a dictionary, then the keys are the second node in the pair,
and the value is the value that the edge feature assigns to this pair.</p>
<p>However, some features have an optimized representation, and do not have
a dictionary underneath.</p>
<p>But you can still iterate over the data of a feature as if it were a
dictionary: <code><a title="tf.core.edgefeature.EdgeFeature.items" href="#tf.core.edgefeature.EdgeFeature.items">EdgeFeature.items()</a></code></p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/bf9d2409025fba80b200c076bcceb6a68c3ee5dc/tf/core/edgefeature.py#L1-L278" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Mappings from edges to values.

Every edge feature is logically a mapping from pairs of nodes to values,
string or integer.

A feature object gives you methods that you can pass a node and that returns
its value for that node.

It is easiest to think of all edge features as a dictionary keyed by nodes.
The values are either sets or dictionaries.
If the value is a set, then the elements are the second node in the pair
and the value is `None`.
If the value is a dictionary, then the keys are the second node in the pair,
and the value is the value that the edge feature assigns to this pair.

However, some features have an optimized representation, and do not have
a dictionary underneath.

But you can still iterate over the data of a feature as if it were a
dictionary: `tf.core.edgefeature.EdgeFeature.items`
&#34;&#34;&#34;

import collections

from .helpers import makeInverse, makeInverseVal


class EdgeFeatures(object):
    pass


class EdgeFeature(object):
    &#34;&#34;&#34;Provides access to (edge) feature data.

    For feature `fff` it is the result of `E.fff` or `Es(&#39;fff&#39;)`.
    &#34;&#34;&#34;

    def __init__(self, api, metaData, data, doValues):
        self.api = api
        self.meta = metaData
        &#34;&#34;&#34;Metadata of the feature.

        This is the information found in the lines starting with `@`
        in the `.tf` feature file.
        &#34;&#34;&#34;

        self.doValues = doValues
        if type(data) is tuple:
            self.data = data[0]
            self.dataInv = data[1]
        else:
            self.data = data
            self.dataInv = (
                makeInverseVal(self.data) if doValues else makeInverse(self.data)
            )

    def items(self):
        &#34;&#34;&#34;A generator that yields the items of the feature, seen as a mapping.

        This gives you a rather efficient way to iterate over
        just the feature data.

        If you need this repeatedly, or you need the whole dictionary,
        you can store the result as follows:

           data = dict(E.fff.items())

        &#34;&#34;&#34;

        return self.data.items()

    def f(self, n):
        &#34;&#34;&#34;Get outgoing edges *from* a node.

        The edges are those pairs of nodes specified in the feature data,
        whose first node is the `n`.

        Parameters
        ----------
        node: integer
            The node **from** which the edges in question start.

        Returns
        -------
        set | tuple
            The nodes reached by the edges **from** a certain node.
            The members of the result are just nodes, if this feature does not
            assign values to edges.
            Otherwise the members are tuples of the destination node and the
            value that the feature assigns to this pair of nodes.

            If there are no edges from the node, the empty tuple is returned,
            rather than `None`.
        &#34;&#34;&#34;

        if n not in self.data:
            return ()
        Crank = self.api.C.rank.data
        if self.doValues:
            return tuple(sorted(self.data[n].items(), key=lambda mv: Crank[mv[0] - 1]))
        else:
            return tuple(sorted(self.data[n], key=lambda m: Crank[m - 1]))

    def t(self, n):
        &#34;&#34;&#34;Get incoming edges *to* a node.

        The edges are those pairs of nodes specified in the feature data,
        whose second node is the `n`.

        Parameters
        ----------
        node: integer
            The node **to** which the edges in question connect.

        Returns
        -------
        set | tuple
            The nodes where the edges **to** a certain node start.
            The members of the result are just nodes, if this feature does not
            assign values to edges.
            Otherwise the members are tuples of the start node and the
            value that the feature assigns to this pair of nodes.

            If there are no edges to the node, the empty tuple is returned,
            rather than `None`.
        &#34;&#34;&#34;

        if n not in self.dataInv:
            return ()
        Crank = self.api.C.rank.data
        if self.doValues:
            return tuple(
                sorted(self.dataInv[n].items(), key=lambda mv: Crank[mv[0] - 1])
            )
        else:
            return tuple(sorted(self.dataInv[n], key=lambda m: Crank[m - 1]))

    def b(self, n):
        &#34;&#34;&#34;Query *both* incoming edges to, and outgoing edges from a node.

        The edges are those pairs of nodes specified in the feature data,
        whose first or second node is the `n`.

        Parameters
        ----------
        node: integer
            The node **from** which the edges in question start or
            **to** which the edges in question connect.

        Returns
        -------
        set | dict
            The nodes where the edges **to** a certain node start.
            The members of the result are just nodes, if this feature does not
            assign values to edges.
            Otherwise the members are tuples of the start node and the
            value that the feature assigns to this pair of nodes.

            If there are no edges to the node, the empty tuple is returned,
            rather than `None`.

        Notes
        -----
        !!! hint &#34;symmetric closure&#34;
            This method gives the *symmetric closure* of a set of edges:
            if there is an edge between *n* and *m*, this method will deliver
            its value, no matter the direction of the edge.

        !!! example &#34;symmetric edges&#34;
            Some edge sets are semantically symmetric, for example *similarity*.
            If *n* is similar to *m*, then *m* is similar to *n*.

            But if you store such an edge feature completely,
            half of the data is redundant.
            By virtue of this method you do not have to do that, you only need to store
            one of the edges between *n* and *m* (it does not matter which one),
            and `E.fff.b(n)` will nevertheless produce the complete results.

        !!! caution &#34;conflicting values&#34;
            If your set of edges is not symmetric, and edges carry values, it might
            very well be the case that edges between the same pair of nodes carry
            different values for the two directions.

            In that case, this method gives precedence to the edges that
            *depart* from the node to those that go *to* the node.

        !!! example &#34;conflicting values&#34;
            Suppose we have

                n == value=4 ==&gt; m
                m == value=6 ==&gt; n

            then

                E.b(n) = (m, 4)
                E.b(m) = (n, 6)

        &#34;&#34;&#34;

        if n not in self.data and n not in self.dataInv:
            return ()
        Crank = self.api.C.rank.data
        if self.doValues:
            result = {}
            if n in self.dataInv:
                result.update(self.dataInv[n].items())
            if n in self.data:
                result.update(self.data[n].items())
            return tuple(sorted(result.items(), key=lambda mv: Crank[mv[0] - 1]))
        else:
            result = set()
            if n in self.dataInv:
                result |= self.dataInv[n]
            if n in self.data:
                result |= self.data[n]
            return tuple(sorted(result, key=lambda m: Crank[m - 1]))

    def freqList(self, nodeTypesFrom=None, nodeTypesTo=None):
        &#34;&#34;&#34;Frequency list of the values of this feature.

        Inspect the values of this feature and see how often they occur.

        If the feature does not assign values, return the number of node pairs
        in this edge.

        If the edge feature does have values, inspect them and see
        how often they occur.
        The result is a list of pairs `(value, frequency)`, ordered by `frequency`,
        highest frequencies first.

        Parameters
        ----------
        nodeTypesFrom: set of string, optional `None`
            If you pass a set of nodeTypes here, only the values for edges
            that start *from* a node with such a type will be counted.
        nodeTypesTo: set of string, optional `None`
            If you pass a set of nodeTypes here, only the values for edges
            that go *to* a node with such a type will be counted.

        Returns
        -------
        tuple of 2-tuple
            A tuple of `(value, frequency)`, items, ordered by `frequency`,
            highest frequencies first.

        &#34;&#34;&#34;

        if nodeTypesFrom is None and nodeTypesTo is None:
            if self.doValues:
                fql = collections.Counter()
                for (n, vals) in self.data.items():
                    for val in vals.values():
                        fql[val] += 1
                return tuple(sorted(fql.items(), key=lambda x: (-x[1], x[0])))
            else:
                fql = 0
                for (n, ms) in self.data.items():
                    fql += len(ms)
                return fql
        else:
            fOtype = self.api.F.otype.v
            if self.doValues:
                fql = collections.Counter()
                for (n, vals) in self.data.items():
                    if nodeTypesFrom is None or fOtype(n) in nodeTypesFrom:
                        for (m, val) in vals.items():
                            if nodeTypesTo is None or fOtype(m) in nodeTypesTo:
                                fql[val] += 1
                return tuple(sorted(fql.items(), key=lambda x: (-x[1], x[0])))
            else:
                fql = 0
                for (n, ms) in self.data.items():
                    if nodeTypesFrom is None or fOtype(n) in nodeTypesFrom:
                        for m in ms:
                            if nodeTypesTo is None or fOtype(m) in nodeTypesTo:
                                fql += len(ms)
                return fql</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.core.edgefeature.EdgeFeature"><code class="flex name class">
<span>class <span class="ident">EdgeFeature</span></span>
<span>(</span><span>api, metaData, data, doValues)</span>
</code></dt>
<dd>
<div class="desc"><p>Provides access to (edge) feature data.</p>
<p>For feature <code>fff</code> it is the result of <code>E.fff</code> or <code>Es('fff')</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/bf9d2409025fba80b200c076bcceb6a68c3ee5dc/tf/core/edgefeature.py#L33-L278" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class EdgeFeature(object):
    &#34;&#34;&#34;Provides access to (edge) feature data.

    For feature `fff` it is the result of `E.fff` or `Es(&#39;fff&#39;)`.
    &#34;&#34;&#34;

    def __init__(self, api, metaData, data, doValues):
        self.api = api
        self.meta = metaData
        &#34;&#34;&#34;Metadata of the feature.

        This is the information found in the lines starting with `@`
        in the `.tf` feature file.
        &#34;&#34;&#34;

        self.doValues = doValues
        if type(data) is tuple:
            self.data = data[0]
            self.dataInv = data[1]
        else:
            self.data = data
            self.dataInv = (
                makeInverseVal(self.data) if doValues else makeInverse(self.data)
            )

    def items(self):
        &#34;&#34;&#34;A generator that yields the items of the feature, seen as a mapping.

        This gives you a rather efficient way to iterate over
        just the feature data.

        If you need this repeatedly, or you need the whole dictionary,
        you can store the result as follows:

           data = dict(E.fff.items())

        &#34;&#34;&#34;

        return self.data.items()

    def f(self, n):
        &#34;&#34;&#34;Get outgoing edges *from* a node.

        The edges are those pairs of nodes specified in the feature data,
        whose first node is the `n`.

        Parameters
        ----------
        node: integer
            The node **from** which the edges in question start.

        Returns
        -------
        set | tuple
            The nodes reached by the edges **from** a certain node.
            The members of the result are just nodes, if this feature does not
            assign values to edges.
            Otherwise the members are tuples of the destination node and the
            value that the feature assigns to this pair of nodes.

            If there are no edges from the node, the empty tuple is returned,
            rather than `None`.
        &#34;&#34;&#34;

        if n not in self.data:
            return ()
        Crank = self.api.C.rank.data
        if self.doValues:
            return tuple(sorted(self.data[n].items(), key=lambda mv: Crank[mv[0] - 1]))
        else:
            return tuple(sorted(self.data[n], key=lambda m: Crank[m - 1]))

    def t(self, n):
        &#34;&#34;&#34;Get incoming edges *to* a node.

        The edges are those pairs of nodes specified in the feature data,
        whose second node is the `n`.

        Parameters
        ----------
        node: integer
            The node **to** which the edges in question connect.

        Returns
        -------
        set | tuple
            The nodes where the edges **to** a certain node start.
            The members of the result are just nodes, if this feature does not
            assign values to edges.
            Otherwise the members are tuples of the start node and the
            value that the feature assigns to this pair of nodes.

            If there are no edges to the node, the empty tuple is returned,
            rather than `None`.
        &#34;&#34;&#34;

        if n not in self.dataInv:
            return ()
        Crank = self.api.C.rank.data
        if self.doValues:
            return tuple(
                sorted(self.dataInv[n].items(), key=lambda mv: Crank[mv[0] - 1])
            )
        else:
            return tuple(sorted(self.dataInv[n], key=lambda m: Crank[m - 1]))

    def b(self, n):
        &#34;&#34;&#34;Query *both* incoming edges to, and outgoing edges from a node.

        The edges are those pairs of nodes specified in the feature data,
        whose first or second node is the `n`.

        Parameters
        ----------
        node: integer
            The node **from** which the edges in question start or
            **to** which the edges in question connect.

        Returns
        -------
        set | dict
            The nodes where the edges **to** a certain node start.
            The members of the result are just nodes, if this feature does not
            assign values to edges.
            Otherwise the members are tuples of the start node and the
            value that the feature assigns to this pair of nodes.

            If there are no edges to the node, the empty tuple is returned,
            rather than `None`.

        Notes
        -----
        !!! hint &#34;symmetric closure&#34;
            This method gives the *symmetric closure* of a set of edges:
            if there is an edge between *n* and *m*, this method will deliver
            its value, no matter the direction of the edge.

        !!! example &#34;symmetric edges&#34;
            Some edge sets are semantically symmetric, for example *similarity*.
            If *n* is similar to *m*, then *m* is similar to *n*.

            But if you store such an edge feature completely,
            half of the data is redundant.
            By virtue of this method you do not have to do that, you only need to store
            one of the edges between *n* and *m* (it does not matter which one),
            and `E.fff.b(n)` will nevertheless produce the complete results.

        !!! caution &#34;conflicting values&#34;
            If your set of edges is not symmetric, and edges carry values, it might
            very well be the case that edges between the same pair of nodes carry
            different values for the two directions.

            In that case, this method gives precedence to the edges that
            *depart* from the node to those that go *to* the node.

        !!! example &#34;conflicting values&#34;
            Suppose we have

                n == value=4 ==&gt; m
                m == value=6 ==&gt; n

            then

                E.b(n) = (m, 4)
                E.b(m) = (n, 6)

        &#34;&#34;&#34;

        if n not in self.data and n not in self.dataInv:
            return ()
        Crank = self.api.C.rank.data
        if self.doValues:
            result = {}
            if n in self.dataInv:
                result.update(self.dataInv[n].items())
            if n in self.data:
                result.update(self.data[n].items())
            return tuple(sorted(result.items(), key=lambda mv: Crank[mv[0] - 1]))
        else:
            result = set()
            if n in self.dataInv:
                result |= self.dataInv[n]
            if n in self.data:
                result |= self.data[n]
            return tuple(sorted(result, key=lambda m: Crank[m - 1]))

    def freqList(self, nodeTypesFrom=None, nodeTypesTo=None):
        &#34;&#34;&#34;Frequency list of the values of this feature.

        Inspect the values of this feature and see how often they occur.

        If the feature does not assign values, return the number of node pairs
        in this edge.

        If the edge feature does have values, inspect them and see
        how often they occur.
        The result is a list of pairs `(value, frequency)`, ordered by `frequency`,
        highest frequencies first.

        Parameters
        ----------
        nodeTypesFrom: set of string, optional `None`
            If you pass a set of nodeTypes here, only the values for edges
            that start *from* a node with such a type will be counted.
        nodeTypesTo: set of string, optional `None`
            If you pass a set of nodeTypes here, only the values for edges
            that go *to* a node with such a type will be counted.

        Returns
        -------
        tuple of 2-tuple
            A tuple of `(value, frequency)`, items, ordered by `frequency`,
            highest frequencies first.

        &#34;&#34;&#34;

        if nodeTypesFrom is None and nodeTypesTo is None:
            if self.doValues:
                fql = collections.Counter()
                for (n, vals) in self.data.items():
                    for val in vals.values():
                        fql[val] += 1
                return tuple(sorted(fql.items(), key=lambda x: (-x[1], x[0])))
            else:
                fql = 0
                for (n, ms) in self.data.items():
                    fql += len(ms)
                return fql
        else:
            fOtype = self.api.F.otype.v
            if self.doValues:
                fql = collections.Counter()
                for (n, vals) in self.data.items():
                    if nodeTypesFrom is None or fOtype(n) in nodeTypesFrom:
                        for (m, val) in vals.items():
                            if nodeTypesTo is None or fOtype(m) in nodeTypesTo:
                                fql[val] += 1
                return tuple(sorted(fql.items(), key=lambda x: (-x[1], x[0])))
            else:
                fql = 0
                for (n, ms) in self.data.items():
                    if nodeTypesFrom is None or fOtype(n) in nodeTypesFrom:
                        for m in ms:
                            if nodeTypesTo is None or fOtype(m) in nodeTypesTo:
                                fql += len(ms)
                return fql</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tf.core.edgefeature.EdgeFeature.meta"><code class="name">var <span class="ident">meta</span></code></dt>
<dd>
<div class="desc"><p>Metadata of the feature.</p>
<p>This is the information found in the lines starting with <code>@</code>
in the <code>.<a title="tf" href="../index.html">tf</a></code> feature file.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tf.core.edgefeature.EdgeFeature.b"><code class="name flex">
<span>def <span class="ident">b</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Query <em>both</em> incoming edges to, and outgoing edges from a node.</p>
<p>The edges are those pairs of nodes specified in the feature data,
whose first or second node is the <code>n</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>integer</code></dt>
<dd>The node <strong>from</strong> which the edges in question start or
<strong>to</strong> which the edges in question connect.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>set | dict</code></dt>
<dd>
<p>The nodes where the edges <strong>to</strong> a certain node start.
The members of the result are just nodes, if this feature does not
assign values to edges.
Otherwise the members are tuples of the start node and the
value that the feature assigns to this pair of nodes.</p>
<p>If there are no edges to the node, the empty tuple is returned,
rather than <code>None</code>.</p>
</dd>
</dl>
<h2 id="notes">Notes</h2>
<div class="admonition hint">
<p class="admonition-title">symmetric closure</p>
<p>This method gives the <em>symmetric closure</em> of a set of edges:
if there is an edge between <em>n</em> and <em>m</em>, this method will deliver
its value, no matter the direction of the edge.</p>
</div>
<div class="admonition example">
<p class="admonition-title">symmetric edges</p>
<p>Some edge sets are semantically symmetric, for example <em>similarity</em>.
If <em>n</em> is similar to <em>m</em>, then <em>m</em> is similar to <em>n</em>.</p>
<p>But if you store such an edge feature completely,
half of the data is redundant.
By virtue of this method you do not have to do that, you only need to store
one of the edges between <em>n</em> and <em>m</em> (it does not matter which one),
and <code>E.fff.b(n)</code> will nevertheless produce the complete results.</p>
</div>
<div class="admonition caution">
<p class="admonition-title">conflicting values</p>
<p>If your set of edges is not symmetric, and edges carry values, it might
very well be the case that edges between the same pair of nodes carry
different values for the two directions.</p>
<p>In that case, this method gives precedence to the edges that
<em>depart</em> from the node to those that go <em>to</em> the node.</p>
</div>
<div class="admonition example">
<p class="admonition-title">conflicting values</p>
<p>Suppose we have</p>
<pre><code>n == value=4 ==&gt; m
m == value=6 ==&gt; n
</code></pre>
<p>then</p>
<pre><code>E.b(n) = (m, 4)
E.b(m) = (n, 6)
</code></pre>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/bf9d2409025fba80b200c076bcceb6a68c3ee5dc/tf/core/edgefeature.py#L139-L217" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def b(self, n):
    &#34;&#34;&#34;Query *both* incoming edges to, and outgoing edges from a node.

    The edges are those pairs of nodes specified in the feature data,
    whose first or second node is the `n`.

    Parameters
    ----------
    node: integer
        The node **from** which the edges in question start or
        **to** which the edges in question connect.

    Returns
    -------
    set | dict
        The nodes where the edges **to** a certain node start.
        The members of the result are just nodes, if this feature does not
        assign values to edges.
        Otherwise the members are tuples of the start node and the
        value that the feature assigns to this pair of nodes.

        If there are no edges to the node, the empty tuple is returned,
        rather than `None`.

    Notes
    -----
    !!! hint &#34;symmetric closure&#34;
        This method gives the *symmetric closure* of a set of edges:
        if there is an edge between *n* and *m*, this method will deliver
        its value, no matter the direction of the edge.

    !!! example &#34;symmetric edges&#34;
        Some edge sets are semantically symmetric, for example *similarity*.
        If *n* is similar to *m*, then *m* is similar to *n*.

        But if you store such an edge feature completely,
        half of the data is redundant.
        By virtue of this method you do not have to do that, you only need to store
        one of the edges between *n* and *m* (it does not matter which one),
        and `E.fff.b(n)` will nevertheless produce the complete results.

    !!! caution &#34;conflicting values&#34;
        If your set of edges is not symmetric, and edges carry values, it might
        very well be the case that edges between the same pair of nodes carry
        different values for the two directions.

        In that case, this method gives precedence to the edges that
        *depart* from the node to those that go *to* the node.

    !!! example &#34;conflicting values&#34;
        Suppose we have

            n == value=4 ==&gt; m
            m == value=6 ==&gt; n

        then

            E.b(n) = (m, 4)
            E.b(m) = (n, 6)

    &#34;&#34;&#34;

    if n not in self.data and n not in self.dataInv:
        return ()
    Crank = self.api.C.rank.data
    if self.doValues:
        result = {}
        if n in self.dataInv:
            result.update(self.dataInv[n].items())
        if n in self.data:
            result.update(self.data[n].items())
        return tuple(sorted(result.items(), key=lambda mv: Crank[mv[0] - 1]))
    else:
        result = set()
        if n in self.dataInv:
            result |= self.dataInv[n]
        if n in self.data:
            result |= self.data[n]
        return tuple(sorted(result, key=lambda m: Crank[m - 1]))</code></pre>
</details>
</dd>
<dt id="tf.core.edgefeature.EdgeFeature.f"><code class="name flex">
<span>def <span class="ident">f</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Get outgoing edges <em>from</em> a node.</p>
<p>The edges are those pairs of nodes specified in the feature data,
whose first node is the <code>n</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>integer</code></dt>
<dd>The node <strong>from</strong> which the edges in question start.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>set | tuple</code></dt>
<dd>
<p>The nodes reached by the edges <strong>from</strong> a certain node.
The members of the result are just nodes, if this feature does not
assign values to edges.
Otherwise the members are tuples of the destination node and the
value that the feature assigns to this pair of nodes.</p>
<p>If there are no edges from the node, the empty tuple is returned,
rather than <code>None</code>.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/bf9d2409025fba80b200c076bcceb6a68c3ee5dc/tf/core/edgefeature.py#L73-L103" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def f(self, n):
    &#34;&#34;&#34;Get outgoing edges *from* a node.

    The edges are those pairs of nodes specified in the feature data,
    whose first node is the `n`.

    Parameters
    ----------
    node: integer
        The node **from** which the edges in question start.

    Returns
    -------
    set | tuple
        The nodes reached by the edges **from** a certain node.
        The members of the result are just nodes, if this feature does not
        assign values to edges.
        Otherwise the members are tuples of the destination node and the
        value that the feature assigns to this pair of nodes.

        If there are no edges from the node, the empty tuple is returned,
        rather than `None`.
    &#34;&#34;&#34;

    if n not in self.data:
        return ()
    Crank = self.api.C.rank.data
    if self.doValues:
        return tuple(sorted(self.data[n].items(), key=lambda mv: Crank[mv[0] - 1]))
    else:
        return tuple(sorted(self.data[n], key=lambda m: Crank[m - 1]))</code></pre>
</details>
</dd>
<dt id="tf.core.edgefeature.EdgeFeature.freqList"><code class="name flex">
<span>def <span class="ident">freqList</span></span>(<span>self, nodeTypesFrom=None, nodeTypesTo=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Frequency list of the values of this feature.</p>
<p>Inspect the values of this feature and see how often they occur.</p>
<p>If the feature does not assign values, return the number of node pairs
in this edge.</p>
<p>If the edge feature does have values, inspect them and see
how often they occur.
The result is a list of pairs <code>(value, frequency)</code>, ordered by <code>frequency</code>,
highest frequencies first.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nodeTypesFrom</code></strong> :&ensp;<code>set</code> of <code>string</code>, optional <code>None</code></dt>
<dd>If you pass a set of nodeTypes here, only the values for edges
that start <em>from</em> a node with such a type will be counted.</dd>
<dt><strong><code>nodeTypesTo</code></strong> :&ensp;<code>set</code> of <code>string</code>, optional <code>None</code></dt>
<dd>If you pass a set of nodeTypes here, only the values for edges
that go <em>to</em> a node with such a type will be counted.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code> of <code>2-tuple</code></dt>
<dd>A tuple of <code>(value, frequency)</code>, items, ordered by <code>frequency</code>,
highest frequencies first.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/bf9d2409025fba80b200c076bcceb6a68c3ee5dc/tf/core/edgefeature.py#L219-L278" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def freqList(self, nodeTypesFrom=None, nodeTypesTo=None):
    &#34;&#34;&#34;Frequency list of the values of this feature.

    Inspect the values of this feature and see how often they occur.

    If the feature does not assign values, return the number of node pairs
    in this edge.

    If the edge feature does have values, inspect them and see
    how often they occur.
    The result is a list of pairs `(value, frequency)`, ordered by `frequency`,
    highest frequencies first.

    Parameters
    ----------
    nodeTypesFrom: set of string, optional `None`
        If you pass a set of nodeTypes here, only the values for edges
        that start *from* a node with such a type will be counted.
    nodeTypesTo: set of string, optional `None`
        If you pass a set of nodeTypes here, only the values for edges
        that go *to* a node with such a type will be counted.

    Returns
    -------
    tuple of 2-tuple
        A tuple of `(value, frequency)`, items, ordered by `frequency`,
        highest frequencies first.

    &#34;&#34;&#34;

    if nodeTypesFrom is None and nodeTypesTo is None:
        if self.doValues:
            fql = collections.Counter()
            for (n, vals) in self.data.items():
                for val in vals.values():
                    fql[val] += 1
            return tuple(sorted(fql.items(), key=lambda x: (-x[1], x[0])))
        else:
            fql = 0
            for (n, ms) in self.data.items():
                fql += len(ms)
            return fql
    else:
        fOtype = self.api.F.otype.v
        if self.doValues:
            fql = collections.Counter()
            for (n, vals) in self.data.items():
                if nodeTypesFrom is None or fOtype(n) in nodeTypesFrom:
                    for (m, val) in vals.items():
                        if nodeTypesTo is None or fOtype(m) in nodeTypesTo:
                            fql[val] += 1
            return tuple(sorted(fql.items(), key=lambda x: (-x[1], x[0])))
        else:
            fql = 0
            for (n, ms) in self.data.items():
                if nodeTypesFrom is None or fOtype(n) in nodeTypesFrom:
                    for m in ms:
                        if nodeTypesTo is None or fOtype(m) in nodeTypesTo:
                            fql += len(ms)
            return fql</code></pre>
</details>
</dd>
<dt id="tf.core.edgefeature.EdgeFeature.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A generator that yields the items of the feature, seen as a mapping.</p>
<p>This gives you a rather efficient way to iterate over
just the feature data.</p>
<p>If you need this repeatedly, or you need the whole dictionary,
you can store the result as follows:</p>
<p>data = dict(E.fff.items())</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/bf9d2409025fba80b200c076bcceb6a68c3ee5dc/tf/core/edgefeature.py#L58-L71" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def items(self):
    &#34;&#34;&#34;A generator that yields the items of the feature, seen as a mapping.

    This gives you a rather efficient way to iterate over
    just the feature data.

    If you need this repeatedly, or you need the whole dictionary,
    you can store the result as follows:

       data = dict(E.fff.items())

    &#34;&#34;&#34;

    return self.data.items()</code></pre>
</details>
</dd>
<dt id="tf.core.edgefeature.EdgeFeature.t"><code class="name flex">
<span>def <span class="ident">t</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Get incoming edges <em>to</em> a node.</p>
<p>The edges are those pairs of nodes specified in the feature data,
whose second node is the <code>n</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>integer</code></dt>
<dd>The node <strong>to</strong> which the edges in question connect.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>set | tuple</code></dt>
<dd>
<p>The nodes where the edges <strong>to</strong> a certain node start.
The members of the result are just nodes, if this feature does not
assign values to edges.
Otherwise the members are tuples of the start node and the
value that the feature assigns to this pair of nodes.</p>
<p>If there are no edges to the node, the empty tuple is returned,
rather than <code>None</code>.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/bf9d2409025fba80b200c076bcceb6a68c3ee5dc/tf/core/edgefeature.py#L105-L137" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def t(self, n):
    &#34;&#34;&#34;Get incoming edges *to* a node.

    The edges are those pairs of nodes specified in the feature data,
    whose second node is the `n`.

    Parameters
    ----------
    node: integer
        The node **to** which the edges in question connect.

    Returns
    -------
    set | tuple
        The nodes where the edges **to** a certain node start.
        The members of the result are just nodes, if this feature does not
        assign values to edges.
        Otherwise the members are tuples of the start node and the
        value that the feature assigns to this pair of nodes.

        If there are no edges to the node, the empty tuple is returned,
        rather than `None`.
    &#34;&#34;&#34;

    if n not in self.dataInv:
        return ()
    Crank = self.api.C.rank.data
    if self.doValues:
        return tuple(
            sorted(self.dataInv[n].items(), key=lambda mv: Crank[mv[0] - 1])
        )
    else:
        return tuple(sorted(self.dataInv[n], key=lambda m: Crank[m - 1]))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="tf.core.edgefeature.EdgeFeatures"><code class="flex name class">
<span>class <span class="ident">EdgeFeatures</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/bf9d2409025fba80b200c076bcceb6a68c3ee5dc/tf/core/edgefeature.py#L29-L30" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class EdgeFeatures(object):
    pass</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.core" href="index.html">tf.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.core.edgefeature.EdgeFeature" href="#tf.core.edgefeature.EdgeFeature">EdgeFeature</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.core.edgefeature.EdgeFeature.b" href="#tf.core.edgefeature.EdgeFeature.b">b</a></code></li>
<li><code><a title="tf.core.edgefeature.EdgeFeature.f" href="#tf.core.edgefeature.EdgeFeature.f">f</a></code></li>
<li><code><a title="tf.core.edgefeature.EdgeFeature.freqList" href="#tf.core.edgefeature.EdgeFeature.freqList">freqList</a></code></li>
<li><code><a title="tf.core.edgefeature.EdgeFeature.items" href="#tf.core.edgefeature.EdgeFeature.items">items</a></code></li>
<li><code><a title="tf.core.edgefeature.EdgeFeature.meta" href="#tf.core.edgefeature.EdgeFeature.meta">meta</a></code></li>
<li><code><a title="tf.core.edgefeature.EdgeFeature.t" href="#tf.core.edgefeature.EdgeFeature.t">t</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="tf.core.edgefeature.EdgeFeatures" href="#tf.core.edgefeature.EdgeFeatures">EdgeFeatures</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://www.dans.knaw.nl"><img alt="DANS" src="../../tf/images/DANS-logo.png" width="200" alt="DANS"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>