<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>tf.core.fabric API documentation</title>
<meta name="description" content="`FabricCore` â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-GjqubOlYA6/wOZV7F31o2t4ogk4JGDGFa6XmL+BfAG0=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-qDPJ4nH38AgHyK3U6cvI6DBifA+7hPBo8mVoH6pyN9c=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.core.fabric</code></h1>
</header>
<section id="section-intro">
<h1 id="fabriccore"><code><a title="tf.core.fabric.FabricCore" href="#tf.core.fabric.FabricCore">FabricCore</a></code></h1>
<p>The main class that works the core API is <code><a title="tf.fabric.Fabric" href="../fabric.html#tf.fabric.Fabric">Fabric</a></code>.
In this module we define <code><a title="tf.core.fabric.FabricCore" href="#tf.core.fabric.FabricCore">FabricCore</a></code>, which contains most of the
functionality of <code>Fabric</code>.</p>
<p>It does not contain the volume support.
Volume support requires <code><a title="tf.volumes.extract" href="../volumes/extract.html">tf.volumes.extract</a></code> and <code><a title="tf.volumes.collect" href="../volumes/collect.html">tf.volumes.collect</a></code> which
need to load and save TF datasets, and loading and saving are Fabric
functionalities.</p>
<p>Hence a Fabric with volume support would lead to circular imports.
By leaving out volume support, volume support can use <code><a title="tf.core.fabric.FabricCore" href="#tf.core.fabric.FabricCore">FabricCore</a></code> instead of Fabric.</p>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/5d2b5ddd19be981cf71dceb9798cd89b451058cd/tf/core/fabric.py#L1-L1054" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# `FabricCore`

The main class that works the core API is `tf.fabric.Fabric`.
In this module we define `FabricCore`, which contains most of the
functionality of `Fabric`.

It does not contain the volume support.
Volume support requires `tf.volumes.extract` and `tf.volumes.collect` which
need to load and save TF datasets, and loading and saving are Fabric
functionalities.

Hence a Fabric with volume support would lead to circular imports.
By leaving out volume support, volume support can use `FabricCore` instead of Fabric.
&#34;&#34;&#34;

import collections
from itertools import chain
from typing import Dict, Union, Set

from ..parameters import BANNER, VERSION, OTYPE, OSLOTS, OTEXT
from .data import Data, MEM_MSG
from .helpers import (
    itemize,
    fitemize,
    collectFormats,
    check32,
    console,
    makeExamples,
)
from .files import (
    expanduser as ex,
    LOCATIONS,
    setDir,
    expandDir,
    dirExists,
    normpath,
    splitExt,
    scanDir,
)
from .timestamp import Timestamp, SILENT_D, silentConvert
from .prepare import (
    levels,
    order,
    rank,
    levUp,
    levDown,
    boundary,
    characters,
    sections,
    structure,
)
from .computed import Computed
from .nodefeature import NodeFeature
from .edgefeature import EdgeFeature
from .otypefeature import OtypeFeature
from .oslotsfeature import OslotsFeature
from .api import (
    Api,
    addNodes,
    addOtype,
    addLocality,
    addText,
    addSearch,
)

# declare some types for type annotation
featureType = Union[str, int]
nodeFeatureDict = Dict[str, Dict[int, featureType]]
edgeFeatureDict = Dict[str, Dict[int, Union[Set[int], Dict[int, featureType]]]]
metaDataDict = Dict[str, Dict[str, str]]


OTEXT_DEFAULT = dict(sectionFeatures=&#34;&#34;, sectionTypes=&#34;&#34;)


PRECOMPUTE = (
    (0, &#34;__levels__&#34;, levels, (OTYPE, OSLOTS, OTEXT)),
    (0, &#34;__order__&#34;, order, (OTYPE, OSLOTS) + (&#34;__levels__&#34;,)),
    (0, &#34;__rank__&#34;, rank, (OTYPE, &#34;__order__&#34;)),
    (0, &#34;__levUp__&#34;, levUp, (OTYPE, OSLOTS) + (&#34;__rank__&#34;,)),
    (0, &#34;__levDown__&#34;, levDown, (OTYPE, &#34;__levUp__&#34;, &#34;__rank__&#34;)),
    (1, &#34;__characters__&#34;, characters, (OTEXT,)),
    (0, &#34;__boundary__&#34;, boundary, (OTYPE, OSLOTS) + (&#34;__rank__&#34;,)),
    (
        2,
        &#34;__sections__&#34;,
        sections,
        (OTYPE, OSLOTS, OTEXT) + (&#34;__levUp__&#34;, &#34;__levels__&#34;),
    ),
    (
        2,
        &#34;__structure__&#34;,
        structure,
        (OTYPE, OSLOTS, OTEXT)
        + (
            &#34;__rank__&#34;,
            &#34;__levUp__&#34;,
        ),
    ),
)
&#34;&#34;&#34;Pre-computation steps.

Each step corresponds to a pre-computation task.

A task is specified by a tuple containing:

Parameters
----------
dep: boolean
    Whether the step is dependent on the presence of additional features.
    Only relevant for the pre-computation of section structure:
    that should only happen if there are section features.
name: string
    The name of the result of a pre-computed task.
    The result is a blob of data that can be loaded and compressed just as ordinary features.
function: function
    The function that performs the pre-computation task.
    These functions are defined in `tf.core.prepare`.
dependencies: strings
    The remaining parts of the tuple are the names of pre-computed features
    that must be coomputed before and whose results are passed as argument
    to the function that executes the pre-computation.

For a description of what the steps are for, see the functions
in `tf.core.prepare`.
&#34;&#34;&#34;
KIND = dict(__sections__=&#34;section&#34;, __structure__=&#34;structure&#34;)


class FabricCore:
    &#34;&#34;&#34;Initialize the core API for a corpus.

    Top level management of

    *   locating TF feature files
    *   loading and saving feature data
    *   pre-computing auxiliary data
    *   caching pre-computed and compressed data

    TF is initialized for a corpus.
    It will search a set of directories and catalogue all `.tf` files it finds there.
    These are the features you can subsequently load.

    Here `directories` and `subdirectories` are strings with directory names
    separated by newlines, or iterables of directories.

    Parameters
    ----------
    locations: string | iterable of strings, optional
        The directories specified here are used as base locations
        in searching for TF feature files.
        In general, they will not searched directly, but certain subdirectories
        of them will be searched, specified by the `modules` parameter.

        Defaults:

        ``` sh
        ~/Downloads/text-fabric-data
        ~/text-fabric-data
        ~/github/text-fabric-data
        ```

        So if you have stored your main TF dataset in
        `text-fabric-data` in one of these directories
        you do not have to pass a location to Fabric.

    modules: string | iterable of strings
        The directories specified in here are used as sub directories
        appended to the directories given by the `locations` parameter.

        All `.tf` files (non-recursively) in any `location/module`
        will be added to the feature set to be loaded in this session.
        The order in `modules` is important, because if a feature occurs in
        multiple modules, the last one will be chosen.
        In this way you can easily override certain features in one module
        by features in an other module of your choice.

        Default: `[&#39;&#39;]`

        So if you leave it out, TF will just search the paths specified
        in `locations`.

    silent: string, optional tf.core.timestamp.SILENT_D
        See `tf.core.timestamp.Timestamp`

    _withGc: boolean, optional True
        If False, it disables the Python garbage collector before
        loading features. Used to experiment with performance.


    !!! note &#34;`otext@` in modules&#34;
        If modules contain features with a name starting with `otext@`, then the format
        definitions in these features will be added to the format definitions in the
        regular `otext` feature (which is a `tf.parameters.WARP` feature).
        In this way, modules that define new features for text representation,
        also can add new formats to the Text-API.

    Returns
    -------
    object
        An object from which you can call up all the of methods of the core API.
    &#34;&#34;&#34;

    def __init__(self, locations=None, modules=None, silent=SILENT_D, _withGc=True):
        silent = silentConvert(silent)
        self._withGc = _withGc
        self.silent = silent
        tmObj = Timestamp(silent=silent)
        self.tmObj = tmObj
        setSilent = tmObj.setSilent
        setSilent(silent)
        self.banner = BANNER
        &#34;&#34;&#34;The banner Text-Fabric.

        Will be shown just after start up, if the silence is not `deep`.
        &#34;&#34;&#34;

        self.version = VERSION
        &#34;&#34;&#34;The version number of the TF library.
        &#34;&#34;&#34;

        (on32, warn, msg) = check32()
        warning = tmObj.warning
        info = tmObj.info
        debug = tmObj.debug

        if on32:
            warning(warn, tm=False)
        if msg:
            info(msg, tm=False)
        debug(self.banner, tm=False)
        self.good = True

        if modules is None:
            modules = [&#34;&#34;]
        elif type(modules) is str:
            modules = [normpath(x.strip()) for x in itemize(modules, &#34;\n&#34;)]
        else:
            modules = [normpath(str(x)) for x in modules]
        self.modules = modules

        if locations is None:
            locations = LOCATIONS
        elif type(locations) is str:
            locations = [normpath(x.strip()) for x in itemize(locations, &#34;\n&#34;)]
        else:
            locations = [normpath(str(x)) for x in locations]
        setDir(self)
        self.locations = []
        for loc in locations:
            self.locations.append(expandDir(self, loc))

        self.locationRep = &#34;\n\t&#34;.join(
            &#34;\n\t&#34;.join(f&#34;{lc}/{f}&#34; for f in self.modules) for lc in self.locations
        )
        self.featuresRequested = []
        self.features = {}
        &#34;&#34;&#34;Dictionary of all features that TF has found, whether loaded or not.

        Under each feature name is all info about that feature.

        The best use of this is to get the metadata of features:

            TF.features[&#39;fff&#39;].metaData

        This works for all features `fff` that have been found,
        whether the feature is loaded or not.

        If a feature is loaded, you can also use

        `F.fff.meta` of `E.fff.meta` depending on whether `fff` is a node feature
        or an edge feature.

        !!! caution &#34;Do not print!&#34;
            If a feature is loaded, its data is also in the feature info.
            This can be an enormous amount of information, and you can easily
            overwhelm your notebook if you print it.
        &#34;&#34;&#34;

        self._makeIndex()

    def load(self, features, add=False, silent=SILENT_D):
        &#34;&#34;&#34;Loads features from disk into RAM memory.

        Parameters
        ----------

        features: string | iterable
            Either a string containing space separated feature names, or an
            iterable of feature names.
            The feature names are just the names of `.tf` files
            without directory information and without extension.
        add: boolean, optional False
            The features will be added to the same currently loaded features, managed
            by the current API.
            Meant to be able to dynamically load features without reloading lots
            of features for nothing.
        silent: string, optional tf.core.timestamp.SILENT_D
            See `tf.core.timestamp.Timestamp`

        Returns
        -------
        boolean | object
            If `add` is `True` a boolean indicating success is returned.
            Otherwise, the result is a new `tf.core.api.Api`
            if the feature could be loaded, else `False`.
        &#34;&#34;&#34;

        silent = silentConvert(silent)
        tmObj = self.tmObj
        isSilent = tmObj.isSilent
        setSilent = tmObj.setSilent
        indent = tmObj.indent
        debug = tmObj.debug
        warning = tmObj.warning
        error = tmObj.error
        cache = tmObj.cache
        reset = tmObj.reset
        featuresOnly = self.featuresOnly

        wasSilent = isSilent()
        setSilent(silent)
        indent(level=0, reset=True)
        self.sectionsOK = True
        self.structureOK = True
        self.good = True

        if self.good:
            featuresRequested = sorted(fitemize(features))
            if add:
                self.featuresRequested += featuresRequested
            else:
                self.featuresRequested = featuresRequested
            for fName in (OTYPE, OSLOTS, OTEXT):
                self._loadFeature(fName, optional=fName == OTEXT or featuresOnly)

        self.textFeatures = set()

        if self.good and not featuresOnly:
            if OTEXT in self.features:
                otextMeta = self.features[OTEXT].metaData
                for otextMod in self.features:
                    if otextMod.startswith(OTEXT + &#34;@&#34;):
                        self._loadFeature(otextMod)
                        otextMeta.update(self.features[otextMod].metaData)
                self.sectionFeats = itemize(otextMeta.get(&#34;sectionFeatures&#34;, &#34;&#34;), &#34;,&#34;)
                self.sectionTypes = itemize(otextMeta.get(&#34;sectionTypes&#34;, &#34;&#34;), &#34;,&#34;)
                self.structureFeats = itemize(
                    otextMeta.get(&#34;structureFeatures&#34;, &#34;&#34;), &#34;,&#34;
                )
                self.structureTypes = itemize(otextMeta.get(&#34;structureTypes&#34;, &#34;&#34;), &#34;,&#34;)
                (self.cformats, self.formatFeats) = collectFormats(otextMeta)

                if not (0 &lt; len(self.sectionTypes) &lt;= 3) or not (
                    0 &lt; len(self.sectionFeats) &lt;= 3
                ):
                    if not add:
                        warning(
                            f&#34;Dataset without sections in {OTEXT}:&#34;
                            f&#34;no section functions in the T-API&#34;
                        )
                    self.sectionsOK = False
                else:
                    self.textFeatures |= set(self.sectionFeats)
                    self.sectionFeatsWithLanguage = tuple(
                        f
                        for f in self.features
                        if f == self.sectionFeats[0]
                        or f.startswith(f&#34;{self.sectionFeats[0]}@&#34;)
                    )
                    self.textFeatures |= set(self.sectionFeatsWithLanguage)
                if not self.structureTypes or not self.structureFeats:
                    if not add:
                        debug(
                            f&#34;Dataset without structure sections in {OTEXT}:&#34;
                            f&#34;no structure functions in the T-API&#34;
                        )
                    self.structureOK = False
                else:
                    self.textFeatures |= set(self.structureFeats)

                formatFeats = set(self.formatFeats)
                self.textFeatures |= formatFeats

                for fName in self.textFeatures:
                    self._loadFeature(fName, optional=fName in formatFeats)

                dep1Feats = self.dep1Feats
                if dep1Feats:
                    cformats = self.cformats
                    tFormats = {}
                    tFeats = set()
                    for (fmt, (otpl, tpl, featData)) in cformats.items():
                        feats = set(chain.from_iterable(x[0] for x in featData))
                        tFormats[fmt] = tuple(sorted(feats))
                        tFeats |= feats
                    tFeats = tuple(sorted(tFeats))
                    extraDependencies = [tFormats]
                    for tFeat in tFeats:
                        featData = self.features[tFeat].data
                        extraDependencies.append((tFeat, featData))
                    for cFeat in dep1Feats:
                        self.features[cFeat].dependencies += extraDependencies

            else:
                self.sectionsOK = False
                self.structureOK = False

        if self.good and not featuresOnly:
            self._precompute()

        if self.good:
            reset()
            for fName in self.featuresRequested:
                self._loadFeature(fName)
                if not self.good:
                    indent(level=0)
                    cache()
                    error(&#34;Not all features could be loaded / computed&#34;)
                    result = False
                    break
                reset()

        if self.good:
            if add:
                try:
                    self._updateApi()
                    result = True
                except MemoryError:
                    console(MEM_MSG)
                    result = False
            else:
                try:
                    result = self._makeApi()
                except MemoryError:
                    console(MEM_MSG)
                    result = False
        else:
            result = False

        setSilent(wasSilent)
        return result

    def explore(self, silent=SILENT_D, show=True):
        &#34;&#34;&#34;Makes categorization of all features in the dataset.

        Parameters
        ----------
        silent: string, optional tf.core.timestamp.SILENT_D
            See `tf.core.timestamp.Timestamp`
        show: boolean, optional True
            If `False`, the resulting dictionary is delivered in `TF.featureSets`;
            if `True`, the dictionary is returned as function result.

        Returns
        -------
        dict | None
            A dictionary  with keys `nodes`, `edges`, `configs`, `computeds`.
            Under each key there is the set of feature names in that category.
            How this dictionary is delivered, depends on the parameter *show*.

        Notes
        -----
        !!! explanation &#34;`configs`&#34;
            These are configuration features, with metadata only, no data. E.g. `otext`.

        !!! explanation &#34;`computeds`&#34;
            These are blocks of pre-computed data, available under the `C` API,
            see `tf.core.computed.Computeds`.

        The sets do not indicate whether a feature is loaded or not.
        There are other functions that give you the loaded features:
        `tf.core.api.Api.Fall` for nodes and `tf.core.api.Api.Eall` for edges.
        &#34;&#34;&#34;

        silent = silentConvert(silent)
        tmObj = self.tmObj
        isSilent = tmObj.isSilent
        setSilent = tmObj.setSilent
        info = tmObj.info

        wasSilent = isSilent()
        setSilent(silent)
        nodes = set()
        edges = set()
        configs = set()
        computeds = set()
        for (fName, fObj) in self.features.items():
            fObj.load(silent=silent, metaOnly=True)
            dest = None
            if fObj.method:
                dest = computeds
            elif fObj.isConfig:
                dest = configs
            elif fObj.isEdge:
                dest = edges
            else:
                dest = nodes
            dest.add(fName)
        info(
            &#34;Feature overview: {} for nodes; {} for edges; {} configs; {} computed&#34;.format(
                len(nodes),
                len(edges),
                len(configs),
                len(computeds),
            )
        )
        self.featureSets = dict(
            nodes=nodes, edges=edges, configs=configs, computeds=computeds
        )
        setSilent(wasSilent)
        if show:
            return dict(
                (kind, tuple(sorted(kindSet)))
                for (kind, kindSet) in sorted(
                    self.featureSets.items(), key=lambda x: x[0]
                )
            )

    def loadAll(self, silent=SILENT_D):
        &#34;&#34;&#34;Load all loadable features.

        Parameters
        ----------
        silent: string, optional tf.core.timestamp.SILENT_D
            See `tf.core.timestamp.Timestamp`
        &#34;&#34;&#34;

        silent = silentConvert(silent)
        api = self.load(&#34;&#34;, silent=silent)
        allFeatures = self.explore(silent=silent, show=True)
        loadableFeatures = allFeatures[&#34;nodes&#34;] + allFeatures[&#34;edges&#34;]
        self.load(loadableFeatures, add=True, silent=silent)
        return api

    def clearCache(self):
        &#34;&#34;&#34;Clears the cache of compiled TF data.

        TF pre-computes data for you, so that it can be loaded faster.
        If the original data is updated, TF detects it,
        and will recompute that data.

        But there are cases, when the algorithms of TF have changed,
        without any changes in the data, where you might want to clear the cache
        of pre-computed results.

        Calling this function just does it, and it is equivalent with manually removing
        all `.tfx` files inside the hidden `.tf` directory inside your dataset.

        !!! hint &#34;No need to load&#34;
            It is not needed to execute a `TF.load()` first.

        See Also
        --------
        tf.clean
        &#34;&#34;&#34;

        for (fName, fObj) in self.features.items():
            fObj.cleanDataBin()

    def save(
        self,
        nodeFeatures: nodeFeatureDict = {},
        edgeFeatures: edgeFeatureDict = {},
        metaData: metaDataDict = {},
        location=None,
        module=None,
        silent=SILENT_D,
    ):
        &#34;&#34;&#34;Saves newly generated data to disk as TF features, nodes and / or edges.

        If you have collected feature data in dictionaries, keyed by the
        names of the features, and valued by their feature data,
        then you can save that data to `.tf` feature files on disk.

        It is this easy to export new data as features:
        collect the data and metadata of the features and feed it in an orderly way
        to `TF.save()` and there you go.

        Parameters
        ----------
        nodeFeatures: dict of dict
            The data of a node feature is a dictionary with nodes as keys (integers!)
            and strings or numbers as (feature) values.
            This parameter holds all those dictionaries, keyed by feature name.

        edgeFeatures: dict of dict
            The data of an edge feature is a dictionary with nodes as keys, and sets or
            dictionaries as values. These sets should be sets of nodes (integers!),
            and these dictionaries should have nodes as keys and strings or numbers
            as values.
            This parameter holds all those dictionaries, keyed by feature name.

        metaData: dict of  dict
            The meta data for every feature to be saved is a key-value dictionary.
            This parameter holds all those dictionaries, keyed by feature name.

            !!! explanation &#34;value types&#34;
                The type of the feature values (`int` or `str`) should be specified
                under key `valueType`.

            !!! explanation &#34;edge values&#34;
                If you save an edge feature, and there are values in that edge feature,
                you have to say so, by specifying `edgeValues=True`
                in the metadata for that feature.

            !!! explanation &#34;generic metadata&#34;
                This parameter may also contain fields under the empty name.
                These fields will be added to all features in `nodeFeatures` and
                `edgeFeatures`.

            !!! explanation &#34;configuration features&#34;
                If you need to write the *configuration* feature `otext`,
                which is a metadata-only feature, just
                add the metadata under key `otext` in this parameter and make sure
                that `otext` is not a key in `nodeFeatures` nor in
                `edgeFeatures`.
                These fields will be written into the separate configuration
                feature `otext`, with no data associated.

        location: dict
            The (meta)data will be written to the very last directory that TF searched
            when looking for features (this is determined by the
            `locations` and `modules` parameters in `tf.fabric.Fabric`.

            If both `locations` and `modules` are empty, writing will take place
            in the current directory.

            But you can override it:

            If you pass `location=something`, TF will save in `something/mod`,
            where `mod` is the last member of the `modules` parameter of TF.

        module: dict
            This is an additional way of overriding the default location
            where TF saves new features. See the *location* parameter.

            If you pass `module=something`, TF will save in `loc/something`,
            where `loc` is the last member of the `locations` parameter of TF.

            If you pass `location=path1` and `module=path2`,
            TF will save in `path1/path2`.

        silent: string, optional tf.core.timestamp.SILENT_D
            See `tf.core.timestamp.Timestamp`
        &#34;&#34;&#34;

        silent = silentConvert(silent)
        tmObj = self.tmObj
        isSilent = tmObj.isSilent
        setSilent = tmObj.setSilent
        indent = tmObj.indent
        info = tmObj.info
        error = tmObj.error

        good = True
        wasSilent = isSilent()
        setSilent(silent)
        indent(level=0, reset=True)
        self._getWriteLoc(location=location, module=module)
        configFeatures = dict(
            f
            for f in metaData.items()
            if f[0] != &#34;&#34; and f[0] not in nodeFeatures and f[0] not in edgeFeatures
        )
        info(
            &#34;Exporting {} node and {} edge and {} configuration features to {}:&#34;.format(
                len(nodeFeatures),
                len(edgeFeatures),
                len(configFeatures),
                self.writeDir,
            )
        )
        todo = []
        for fName in sorted(nodeFeatures):
            todo.append((fName, nodeFeatures[fName], False, False))
        for fName in sorted(edgeFeatures):
            todo.append((fName, edgeFeatures[fName], True, False))
        for fName in sorted(configFeatures):
            todo.append((fName, configFeatures[fName], None, True))
        total = collections.Counter()
        failed = collections.Counter()
        maxSlot = None
        maxNode = None
        slotType = None
        if OTYPE in nodeFeatures:
            info(f&#34;VALIDATING {OSLOTS} feature&#34;)
            otypeData = nodeFeatures[OTYPE]
            if type(otypeData) is tuple:
                (otypeData, slotType, maxSlot, maxNode) = otypeData
            elif 1 in otypeData:
                slotType = otypeData[1]
                maxSlot = max(n for n in otypeData if otypeData[n] == slotType)
                maxNode = max(otypeData)
        if OSLOTS in edgeFeatures:
            info(f&#34;VALIDATING {OSLOTS} feature&#34;)
            oslotsData = edgeFeatures[OSLOTS]
            if type(oslotsData) is tuple:
                (oslotsData, maxSlot, maxNode) = oslotsData
            if maxSlot is None or maxNode is None:
                error(f&#34;ERROR: cannot check validity of {OSLOTS} feature&#34;)
                good = False
            else:
                info(f&#34;maxSlot={maxSlot:&gt;11}&#34;)
                info(f&#34;maxNode={maxNode:&gt;11}&#34;)
                maxNodeInData = max(oslotsData)
                minNodeInData = min(oslotsData)

                mappedSlotNodes = []
                unmappedNodes = []
                fakeNodes = []

                start = min((maxSlot + 1, minNodeInData))
                end = max((maxNode, maxNodeInData))
                for n in range(start, end + 1):
                    if n in oslotsData:
                        if n &lt;= maxSlot:
                            mappedSlotNodes.append(n)
                        elif n &gt; maxNode:
                            fakeNodes.append(n)
                    else:
                        if maxSlot &lt; n &lt;= maxNode:
                            unmappedNodes.append(n)

                if mappedSlotNodes:
                    error(f&#34;ERROR: {OSLOTS} maps slot nodes&#34;)
                    error(makeExamples(mappedSlotNodes), tm=False)
                    good = False
                if fakeNodes:
                    error(f&#34;ERROR: {OSLOTS} maps nodes that are not in {OTYPE}&#34;)
                    error(makeExamples(fakeNodes), tm=False)
                    good = False
                if unmappedNodes:
                    error(f&#34;ERROR: {OSLOTS} fails to map nodes:&#34;)
                    unmappedByType = {}
                    for n in unmappedNodes:
                        unmappedByType.setdefault(
                            otypeData.get(n, &#34;_UNKNOWN_&#34;), []
                        ).append(n)
                    for (nType, nodes) in sorted(
                        unmappedByType.items(),
                        key=lambda x: (-len(x[1]), x[0]),
                    ):
                        error(f&#34;--- unmapped {nType:&lt;10} : {makeExamples(nodes)}&#34;)
                    good = False

            if good:
                info(f&#34;OK: {OSLOTS} is valid&#34;)

        for (fName, data, isEdge, isConfig) in todo:
            edgeValues = False
            fMeta = {}
            fMeta.update(metaData.get(&#34;&#34;, {}))
            fMeta.update(metaData.get(fName, {}))
            if fMeta.get(&#34;edgeValues&#34;, False):
                edgeValues = True
            if &#34;edgeValues&#34; in fMeta:
                del fMeta[&#34;edgeValues&#34;]
            fObj = Data(
                f&#34;{self.writeDir}/{fName}.tf&#34;,
                self.tmObj,
                data=data,
                metaData=fMeta,
                isEdge=isEdge,
                isConfig=isConfig,
                edgeValues=edgeValues,
            )
            tag = &#34;config&#34; if isConfig else &#34;edge&#34; if isEdge else &#34;node&#34;
            if fObj.save(nodeRanges=fName == OTYPE, overwrite=True, silent=silent):
                total[tag] += 1
            else:
                failed[tag] += 1
        indent(level=0)
        info(
            f&#34;&#34;&#34;Exported {total[&#34;node&#34;]} node features&#34;&#34;&#34;
            f&#34;&#34;&#34; and {total[&#34;edge&#34;]} edge features&#34;&#34;&#34;
            f&#34;&#34;&#34; and {total[&#34;config&#34;]} config features&#34;&#34;&#34;
            f&#34;&#34;&#34; to {self.writeDir}&#34;&#34;&#34;
        )
        if len(failed):
            for (tag, nf) in sorted(failed.items()):
                error(f&#34;Failed to export {nf} {tag} features&#34;)
            good = False

        setSilent(wasSilent)
        return good

    def _loadFeature(self, fName, optional=False):
        if not self.good:
            return False

        tmObj = self.tmObj
        isSilent = tmObj.isSilent
        error = tmObj.error

        silent = isSilent()
        if fName not in self.features:
            if not optional:
                error(f&#39;Feature &#34;{fName}&#34; not available in\n{self.locationRep}&#39;)
                self.good = False
        else:
            if not self.features[fName].load(silent=silent, _withGc=self._withGc):
                self.good = False

    def _makeIndex(self):
        tmObj = self.tmObj
        info = tmObj.info
        debug = tmObj.debug
        warning = tmObj.warning

        self.features = {}
        self.featuresIgnored = {}
        tfFiles = {}
        for loc in self.locations:
            for mod in self.modules:
                dirF = normpath(f&#34;{loc}/{mod}&#34;)
                if not dirExists(dirF):
                    continue
                with scanDir(dirF) as sd:
                    files = tuple(
                        e.name for e in sd if e.is_file() and e.name.endswith(&#34;.tf&#34;)
                    )
                for fileF in files:
                    (fName, ext) = splitExt(fileF)
                    tfFiles.setdefault(fName, []).append(f&#34;{dirF}/{fileF}&#34;)
        for (fName, featurePaths) in sorted(tfFiles.items()):
            chosenFPath = featurePaths[-1]
            for featurePath in sorted(set(featurePaths[0:-1])):
                if featurePath != chosenFPath:
                    self.featuresIgnored.setdefault(fName, []).append(featurePath)
            self.features[fName] = Data(chosenFPath, self.tmObj)
        self._getWriteLoc()
        debug(
            &#34;{} features found and {} ignored&#34;.format(
                len(tfFiles),
                sum(len(x) for x in self.featuresIgnored.values()),
            ),
            tm=False,
        )

        self.featuresOnly = False

        if OTYPE not in self.features or OSLOTS not in self.features:
            info(
                f&#34;Not all of the warp features {OTYPE} and {OSLOTS} &#34;
                f&#34;are present in\n{self.locationRep}&#34;
            )
            info(&#34;Only the Feature and Edge APIs will be enabled&#34;)
            self.featuresOnly = True
        if OTEXT in self.features:
            self._loadFeature(OTEXT, optional=True)
        else:
            info((f&#39;Warp feature &#34;{OTEXT}&#34; not found. Working without Text-API\n&#39;))
            self.features[OTEXT] = Data(
                f&#34;{OTEXT}.tf&#34;,
                self.tmObj,
                isConfig=True,
                metaData=OTEXT_DEFAULT,
            )
            self.features[OTEXT].dataLoaded = True

        good = True
        if not self.featuresOnly:
            self.warpDir = self.features[OTYPE].dirName
            self.precomputeList = []
            self.dep1Feats = []
            for (dep2, fName, method, dependencies) in PRECOMPUTE:
                thisGood = True
                if dep2 and OTEXT not in self.features:
                    continue
                if dep2 == 1:
                    self.dep1Feats.append(fName)
                elif dep2 == 2:
                    otextMeta = self.features[OTEXT].metaData
                    sFeatures = f&#34;{KIND[fName]}Features&#34;
                    sFeats = tuple(itemize(otextMeta.get(sFeatures, &#34;&#34;), &#34;,&#34;))
                    dependencies = dependencies + sFeats
                for dep in dependencies:
                    if dep not in self.features:
                        warning(
                            &#34;Missing dependency for computed data feature &#34;
                            f&#39;&#34;{fName}&#34;: &#34;{dep}&#34;&#39;
                        )
                        thisGood = False
                if not thisGood:
                    good = False
                self.features[fName] = Data(
                    f&#34;{self.warpDir}/{fName}.x&#34;,
                    self.tmObj,
                    method=method,
                    dependencies=[self.features.get(dep, None) for dep in dependencies],
                )
                self.precomputeList.append((fName, dep2))
        self.good = good

    def _getWriteLoc(self, location=None, module=None):
        writeLoc = (
            ex(location)
            if location is not None
            else &#34;&#34;
            if len(self.locations) == 0
            else self.locations[-1]
        )
        writeMod = (
            module
            if module is not None
            else &#34;&#34;
            if len(self.modules) == 0
            else self.modules[-1]
        )
        self.writeDir = (
            f&#34;{writeLoc}{writeMod}&#34;
            if writeLoc == &#34;&#34; or writeMod == &#34;&#34;
            else f&#34;{writeLoc}/{writeMod}&#34;
        )

    def _precompute(self):
        tmObj = self.tmObj
        isSilent = tmObj.isSilent
        good = True

        for (fName, dep2) in self.precomputeList:
            ok = getattr(self, f&#39;{fName.strip(&#34;_&#34;)}OK&#39;, False)
            if dep2 == 2 and not ok:
                continue
            if not self.features[fName].load(silent=isSilent()):
                good = False
                break
        self.good = good

    def _makeApi(self):
        if not self.good:
            return None

        tmObj = self.tmObj
        isSilent = tmObj.isSilent
        indent = tmObj.indent
        debug = tmObj.debug
        featuresOnly = self.featuresOnly

        silent = isSilent()
        api = Api(self)
        api.featuresOnly = featuresOnly

        if not featuresOnly:
            w0info = self.features[OTYPE]
            w1info = self.features[OSLOTS]

        if not featuresOnly:
            setattr(api.F, OTYPE, OtypeFeature(api, w0info.metaData, w0info.data))
            setattr(api.E, OSLOTS, OslotsFeature(api, w1info.metaData, w1info.data))

        requestedSet = set(self.featuresRequested)

        for fName in self.features:
            fObj = self.features[fName]
            if fObj.dataLoaded and not fObj.isConfig:
                if fObj.method:
                    if not featuresOnly:
                        feat = fName.strip(&#34;_&#34;)
                        ok = getattr(self, f&#34;{feat}OK&#34;, False)
                        ap = api.C
                        if fName in [
                            fn
                            for (fn, dep2) in self.precomputeList
                            if not dep2 == 2 or ok
                        ]:
                            setattr(ap, feat, Computed(api, fObj.data))
                        else:
                            fObj.unload()
                            if hasattr(ap, feat):
                                delattr(api.C, feat)
                else:
                    if fName in requestedSet | self.textFeatures:
                        if fName in (OTYPE, OSLOTS, OTEXT):
                            continue
                        elif fObj.isEdge:
                            setattr(
                                api.E,
                                fName,
                                EdgeFeature(
                                    api, fObj.metaData, fObj.data, fObj.edgeValues
                                ),
                            )
                        else:
                            setattr(
                                api.F, fName, NodeFeature(api, fObj.metaData, fObj.data)
                            )
                    else:
                        if (
                            fName in (OTYPE, OSLOTS, OTEXT)
                            or fName in self.textFeatures
                        ):
                            continue
                        elif fObj.isEdge:
                            if hasattr(api.E, fName):
                                delattr(api.E, fName)
                        else:
                            if hasattr(api.F, fName):
                                delattr(api.F, fName)
                        fObj.unload()
        if not featuresOnly:
            addOtype(api)
            addNodes(api)
            addLocality(api)
            addText(api)
            addSearch(api, silent)
        indent(level=0)
        debug(&#34;All features loaded / computed - for details use TF.isLoaded()&#34;)
        self.api = api
        setattr(self, &#34;isLoaded&#34;, self.api.isLoaded)
        return api

    def _updateApi(self):
        if not self.good:
            return None
        api = self.api
        tmObj = self.tmObj
        indent = tmObj.indent
        debug = tmObj.debug

        requestedSet = set(self.featuresRequested)

        for fName in self.features:
            fObj = self.features[fName]
            if fObj.dataLoaded and not fObj.isConfig:
                if not fObj.method:
                    if fName in requestedSet | self.textFeatures:
                        if fName in (OTYPE, OSLOTS, OTEXT):
                            continue
                        elif fObj.isEdge:
                            apiFobj = EdgeFeature(
                                api, fObj.metaData, fObj.data, fObj.edgeValues
                            )
                            setattr(api.E, fName, apiFobj)
                        else:
                            apiFobj = NodeFeature(api, fObj.metaData, fObj.data)
                            setattr(api.F, fName, apiFobj)
                    else:
                        if (
                            fName in (OTYPE, OSLOTS, OTEXT)
                            or fName in self.textFeatures
                        ):
                            continue
                        elif fObj.isEdge:
                            if hasattr(api.E, fName):
                                delattr(api.E, fName)
                        else:
                            if hasattr(api.F, fName):
                                delattr(api.F, fName)
                        fObj.unload()
        indent(level=0)
        debug(&#34;All additional features loaded - for details use TF.isLoaded()&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="tf.core.fabric.PRECOMPUTE"><code class="name">var <span class="ident">PRECOMPUTE</span></code></dt>
<dd>
<div class="desc"><p>Pre-computation steps.</p>
<p>Each step corresponds to a pre-computation task.</p>
<p>A task is specified by a tuple containing:</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dep</code></strong> :&ensp;<code>boolean</code></dt>
<dd>Whether the step is dependent on the presence of additional features.
Only relevant for the pre-computation of section structure:
that should only happen if there are section features.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of the result of a pre-computed task.
The result is a blob of data that can be loaded and compressed just as ordinary features.</dd>
<dt><strong><code>function</code></strong> :&ensp;<code>function</code></dt>
<dd>The function that performs the pre-computation task.
These functions are defined in <code><a title="tf.core.prepare" href="prepare.html">tf.core.prepare</a></code>.</dd>
<dt><strong><code>dependencies</code></strong> :&ensp;<code>strings</code></dt>
<dd>The remaining parts of the tuple are the names of pre-computed features
that must be coomputed before and whose results are passed as argument
to the function that executes the pre-computation.</dd>
</dl>
<p>For a description of what the steps are for, see the functions
in <code><a title="tf.core.prepare" href="prepare.html">tf.core.prepare</a></code>.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.core.fabric.FabricCore"><code class="flex name class">
<span>class <span class="ident">FabricCore</span></span>
<span>(</span><span>locations=None, modules=None, silent='auto')</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the core API for a corpus.</p>
<p>Top level management of</p>
<ul>
<li>locating TF feature files</li>
<li>loading and saving feature data</li>
<li>pre-computing auxiliary data</li>
<li>caching pre-computed and compressed data</li>
</ul>
<p>TF is initialized for a corpus.
It will search a set of directories and catalogue all <code>.<a title="tf" href="../index.html">tf</a></code> files it finds there.
These are the features you can subsequently load.</p>
<p>Here <code>directories</code> and <code>subdirectories</code> are strings with directory names
separated by newlines, or iterables of directories.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>locations</code></strong> :&ensp;<code>string | iterable</code> of <code>strings</code>, optional</dt>
<dd>
<p>The directories specified here are used as base locations
in searching for TF feature files.
In general, they will not searched directly, but certain subdirectories
of them will be searched, specified by the <code>modules</code> parameter.</p>
<p>Defaults:</p>
<p><code>sh
~/Downloads/text-fabric-data
~/text-fabric-data
~/github/text-fabric-data</code></p>
<p>So if you have stored your main TF dataset in
<code>text-fabric-data</code> in one of these directories
you do not have to pass a location to Fabric.</p>
</dd>
<dt><strong><code>modules</code></strong> :&ensp;<code>string | iterable</code> of <code>strings</code></dt>
<dd>
<p>The directories specified in here are used as sub directories
appended to the directories given by the <code>locations</code> parameter.</p>
<p>All <code>.<a title="tf" href="../index.html">tf</a></code> files (non-recursively) in any <code>location/module</code>
will be added to the feature set to be loaded in this session.
The order in <code>modules</code> is important, because if a feature occurs in
multiple modules, the last one will be chosen.
In this way you can easily override certain features in one module
by features in an other module of your choice.</p>
<p>Default: <code>['']</code></p>
<p>So if you leave it out, TF will just search the paths specified
in <code>locations</code>.</p>
</dd>
<dt><strong><code>silent</code></strong> :&ensp;<code>string</code>, optional <code><a title="tf.core.timestamp.SILENT_D" href="timestamp.html#tf.core.timestamp.SILENT_D">SILENT_D</a></code></dt>
<dd>See <code><a title="tf.core.timestamp.Timestamp" href="timestamp.html#tf.core.timestamp.Timestamp">Timestamp</a></code></dd>
<dt><strong><code>_withGc</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>If False, it disables the Python garbage collector before
loading features. Used to experiment with performance.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title"><code>otext@</code> in modules</p>
<p>If modules contain features with a name starting with <code>otext@</code>, then the format
definitions in these features will be added to the format definitions in the
regular <code>otext</code> feature (which is a <code><a title="tf.parameters.WARP" href="../parameters.html#tf.parameters.WARP">WARP</a></code> feature).
In this way, modules that define new features for text representation,
also can add new formats to the Text-API.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>object</code></dt>
<dd>An object from which you can call up all the of methods of the core API.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/5d2b5ddd19be981cf71dceb9798cd89b451058cd/tf/core/fabric.py#L131-L1054" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class FabricCore:
    &#34;&#34;&#34;Initialize the core API for a corpus.

    Top level management of

    *   locating TF feature files
    *   loading and saving feature data
    *   pre-computing auxiliary data
    *   caching pre-computed and compressed data

    TF is initialized for a corpus.
    It will search a set of directories and catalogue all `.tf` files it finds there.
    These are the features you can subsequently load.

    Here `directories` and `subdirectories` are strings with directory names
    separated by newlines, or iterables of directories.

    Parameters
    ----------
    locations: string | iterable of strings, optional
        The directories specified here are used as base locations
        in searching for TF feature files.
        In general, they will not searched directly, but certain subdirectories
        of them will be searched, specified by the `modules` parameter.

        Defaults:

        ``` sh
        ~/Downloads/text-fabric-data
        ~/text-fabric-data
        ~/github/text-fabric-data
        ```

        So if you have stored your main TF dataset in
        `text-fabric-data` in one of these directories
        you do not have to pass a location to Fabric.

    modules: string | iterable of strings
        The directories specified in here are used as sub directories
        appended to the directories given by the `locations` parameter.

        All `.tf` files (non-recursively) in any `location/module`
        will be added to the feature set to be loaded in this session.
        The order in `modules` is important, because if a feature occurs in
        multiple modules, the last one will be chosen.
        In this way you can easily override certain features in one module
        by features in an other module of your choice.

        Default: `[&#39;&#39;]`

        So if you leave it out, TF will just search the paths specified
        in `locations`.

    silent: string, optional tf.core.timestamp.SILENT_D
        See `tf.core.timestamp.Timestamp`

    _withGc: boolean, optional True
        If False, it disables the Python garbage collector before
        loading features. Used to experiment with performance.


    !!! note &#34;`otext@` in modules&#34;
        If modules contain features with a name starting with `otext@`, then the format
        definitions in these features will be added to the format definitions in the
        regular `otext` feature (which is a `tf.parameters.WARP` feature).
        In this way, modules that define new features for text representation,
        also can add new formats to the Text-API.

    Returns
    -------
    object
        An object from which you can call up all the of methods of the core API.
    &#34;&#34;&#34;

    def __init__(self, locations=None, modules=None, silent=SILENT_D, _withGc=True):
        silent = silentConvert(silent)
        self._withGc = _withGc
        self.silent = silent
        tmObj = Timestamp(silent=silent)
        self.tmObj = tmObj
        setSilent = tmObj.setSilent
        setSilent(silent)
        self.banner = BANNER
        &#34;&#34;&#34;The banner Text-Fabric.

        Will be shown just after start up, if the silence is not `deep`.
        &#34;&#34;&#34;

        self.version = VERSION
        &#34;&#34;&#34;The version number of the TF library.
        &#34;&#34;&#34;

        (on32, warn, msg) = check32()
        warning = tmObj.warning
        info = tmObj.info
        debug = tmObj.debug

        if on32:
            warning(warn, tm=False)
        if msg:
            info(msg, tm=False)
        debug(self.banner, tm=False)
        self.good = True

        if modules is None:
            modules = [&#34;&#34;]
        elif type(modules) is str:
            modules = [normpath(x.strip()) for x in itemize(modules, &#34;\n&#34;)]
        else:
            modules = [normpath(str(x)) for x in modules]
        self.modules = modules

        if locations is None:
            locations = LOCATIONS
        elif type(locations) is str:
            locations = [normpath(x.strip()) for x in itemize(locations, &#34;\n&#34;)]
        else:
            locations = [normpath(str(x)) for x in locations]
        setDir(self)
        self.locations = []
        for loc in locations:
            self.locations.append(expandDir(self, loc))

        self.locationRep = &#34;\n\t&#34;.join(
            &#34;\n\t&#34;.join(f&#34;{lc}/{f}&#34; for f in self.modules) for lc in self.locations
        )
        self.featuresRequested = []
        self.features = {}
        &#34;&#34;&#34;Dictionary of all features that TF has found, whether loaded or not.

        Under each feature name is all info about that feature.

        The best use of this is to get the metadata of features:

            TF.features[&#39;fff&#39;].metaData

        This works for all features `fff` that have been found,
        whether the feature is loaded or not.

        If a feature is loaded, you can also use

        `F.fff.meta` of `E.fff.meta` depending on whether `fff` is a node feature
        or an edge feature.

        !!! caution &#34;Do not print!&#34;
            If a feature is loaded, its data is also in the feature info.
            This can be an enormous amount of information, and you can easily
            overwhelm your notebook if you print it.
        &#34;&#34;&#34;

        self._makeIndex()

    def load(self, features, add=False, silent=SILENT_D):
        &#34;&#34;&#34;Loads features from disk into RAM memory.

        Parameters
        ----------

        features: string | iterable
            Either a string containing space separated feature names, or an
            iterable of feature names.
            The feature names are just the names of `.tf` files
            without directory information and without extension.
        add: boolean, optional False
            The features will be added to the same currently loaded features, managed
            by the current API.
            Meant to be able to dynamically load features without reloading lots
            of features for nothing.
        silent: string, optional tf.core.timestamp.SILENT_D
            See `tf.core.timestamp.Timestamp`

        Returns
        -------
        boolean | object
            If `add` is `True` a boolean indicating success is returned.
            Otherwise, the result is a new `tf.core.api.Api`
            if the feature could be loaded, else `False`.
        &#34;&#34;&#34;

        silent = silentConvert(silent)
        tmObj = self.tmObj
        isSilent = tmObj.isSilent
        setSilent = tmObj.setSilent
        indent = tmObj.indent
        debug = tmObj.debug
        warning = tmObj.warning
        error = tmObj.error
        cache = tmObj.cache
        reset = tmObj.reset
        featuresOnly = self.featuresOnly

        wasSilent = isSilent()
        setSilent(silent)
        indent(level=0, reset=True)
        self.sectionsOK = True
        self.structureOK = True
        self.good = True

        if self.good:
            featuresRequested = sorted(fitemize(features))
            if add:
                self.featuresRequested += featuresRequested
            else:
                self.featuresRequested = featuresRequested
            for fName in (OTYPE, OSLOTS, OTEXT):
                self._loadFeature(fName, optional=fName == OTEXT or featuresOnly)

        self.textFeatures = set()

        if self.good and not featuresOnly:
            if OTEXT in self.features:
                otextMeta = self.features[OTEXT].metaData
                for otextMod in self.features:
                    if otextMod.startswith(OTEXT + &#34;@&#34;):
                        self._loadFeature(otextMod)
                        otextMeta.update(self.features[otextMod].metaData)
                self.sectionFeats = itemize(otextMeta.get(&#34;sectionFeatures&#34;, &#34;&#34;), &#34;,&#34;)
                self.sectionTypes = itemize(otextMeta.get(&#34;sectionTypes&#34;, &#34;&#34;), &#34;,&#34;)
                self.structureFeats = itemize(
                    otextMeta.get(&#34;structureFeatures&#34;, &#34;&#34;), &#34;,&#34;
                )
                self.structureTypes = itemize(otextMeta.get(&#34;structureTypes&#34;, &#34;&#34;), &#34;,&#34;)
                (self.cformats, self.formatFeats) = collectFormats(otextMeta)

                if not (0 &lt; len(self.sectionTypes) &lt;= 3) or not (
                    0 &lt; len(self.sectionFeats) &lt;= 3
                ):
                    if not add:
                        warning(
                            f&#34;Dataset without sections in {OTEXT}:&#34;
                            f&#34;no section functions in the T-API&#34;
                        )
                    self.sectionsOK = False
                else:
                    self.textFeatures |= set(self.sectionFeats)
                    self.sectionFeatsWithLanguage = tuple(
                        f
                        for f in self.features
                        if f == self.sectionFeats[0]
                        or f.startswith(f&#34;{self.sectionFeats[0]}@&#34;)
                    )
                    self.textFeatures |= set(self.sectionFeatsWithLanguage)
                if not self.structureTypes or not self.structureFeats:
                    if not add:
                        debug(
                            f&#34;Dataset without structure sections in {OTEXT}:&#34;
                            f&#34;no structure functions in the T-API&#34;
                        )
                    self.structureOK = False
                else:
                    self.textFeatures |= set(self.structureFeats)

                formatFeats = set(self.formatFeats)
                self.textFeatures |= formatFeats

                for fName in self.textFeatures:
                    self._loadFeature(fName, optional=fName in formatFeats)

                dep1Feats = self.dep1Feats
                if dep1Feats:
                    cformats = self.cformats
                    tFormats = {}
                    tFeats = set()
                    for (fmt, (otpl, tpl, featData)) in cformats.items():
                        feats = set(chain.from_iterable(x[0] for x in featData))
                        tFormats[fmt] = tuple(sorted(feats))
                        tFeats |= feats
                    tFeats = tuple(sorted(tFeats))
                    extraDependencies = [tFormats]
                    for tFeat in tFeats:
                        featData = self.features[tFeat].data
                        extraDependencies.append((tFeat, featData))
                    for cFeat in dep1Feats:
                        self.features[cFeat].dependencies += extraDependencies

            else:
                self.sectionsOK = False
                self.structureOK = False

        if self.good and not featuresOnly:
            self._precompute()

        if self.good:
            reset()
            for fName in self.featuresRequested:
                self._loadFeature(fName)
                if not self.good:
                    indent(level=0)
                    cache()
                    error(&#34;Not all features could be loaded / computed&#34;)
                    result = False
                    break
                reset()

        if self.good:
            if add:
                try:
                    self._updateApi()
                    result = True
                except MemoryError:
                    console(MEM_MSG)
                    result = False
            else:
                try:
                    result = self._makeApi()
                except MemoryError:
                    console(MEM_MSG)
                    result = False
        else:
            result = False

        setSilent(wasSilent)
        return result

    def explore(self, silent=SILENT_D, show=True):
        &#34;&#34;&#34;Makes categorization of all features in the dataset.

        Parameters
        ----------
        silent: string, optional tf.core.timestamp.SILENT_D
            See `tf.core.timestamp.Timestamp`
        show: boolean, optional True
            If `False`, the resulting dictionary is delivered in `TF.featureSets`;
            if `True`, the dictionary is returned as function result.

        Returns
        -------
        dict | None
            A dictionary  with keys `nodes`, `edges`, `configs`, `computeds`.
            Under each key there is the set of feature names in that category.
            How this dictionary is delivered, depends on the parameter *show*.

        Notes
        -----
        !!! explanation &#34;`configs`&#34;
            These are configuration features, with metadata only, no data. E.g. `otext`.

        !!! explanation &#34;`computeds`&#34;
            These are blocks of pre-computed data, available under the `C` API,
            see `tf.core.computed.Computeds`.

        The sets do not indicate whether a feature is loaded or not.
        There are other functions that give you the loaded features:
        `tf.core.api.Api.Fall` for nodes and `tf.core.api.Api.Eall` for edges.
        &#34;&#34;&#34;

        silent = silentConvert(silent)
        tmObj = self.tmObj
        isSilent = tmObj.isSilent
        setSilent = tmObj.setSilent
        info = tmObj.info

        wasSilent = isSilent()
        setSilent(silent)
        nodes = set()
        edges = set()
        configs = set()
        computeds = set()
        for (fName, fObj) in self.features.items():
            fObj.load(silent=silent, metaOnly=True)
            dest = None
            if fObj.method:
                dest = computeds
            elif fObj.isConfig:
                dest = configs
            elif fObj.isEdge:
                dest = edges
            else:
                dest = nodes
            dest.add(fName)
        info(
            &#34;Feature overview: {} for nodes; {} for edges; {} configs; {} computed&#34;.format(
                len(nodes),
                len(edges),
                len(configs),
                len(computeds),
            )
        )
        self.featureSets = dict(
            nodes=nodes, edges=edges, configs=configs, computeds=computeds
        )
        setSilent(wasSilent)
        if show:
            return dict(
                (kind, tuple(sorted(kindSet)))
                for (kind, kindSet) in sorted(
                    self.featureSets.items(), key=lambda x: x[0]
                )
            )

    def loadAll(self, silent=SILENT_D):
        &#34;&#34;&#34;Load all loadable features.

        Parameters
        ----------
        silent: string, optional tf.core.timestamp.SILENT_D
            See `tf.core.timestamp.Timestamp`
        &#34;&#34;&#34;

        silent = silentConvert(silent)
        api = self.load(&#34;&#34;, silent=silent)
        allFeatures = self.explore(silent=silent, show=True)
        loadableFeatures = allFeatures[&#34;nodes&#34;] + allFeatures[&#34;edges&#34;]
        self.load(loadableFeatures, add=True, silent=silent)
        return api

    def clearCache(self):
        &#34;&#34;&#34;Clears the cache of compiled TF data.

        TF pre-computes data for you, so that it can be loaded faster.
        If the original data is updated, TF detects it,
        and will recompute that data.

        But there are cases, when the algorithms of TF have changed,
        without any changes in the data, where you might want to clear the cache
        of pre-computed results.

        Calling this function just does it, and it is equivalent with manually removing
        all `.tfx` files inside the hidden `.tf` directory inside your dataset.

        !!! hint &#34;No need to load&#34;
            It is not needed to execute a `TF.load()` first.

        See Also
        --------
        tf.clean
        &#34;&#34;&#34;

        for (fName, fObj) in self.features.items():
            fObj.cleanDataBin()

    def save(
        self,
        nodeFeatures: nodeFeatureDict = {},
        edgeFeatures: edgeFeatureDict = {},
        metaData: metaDataDict = {},
        location=None,
        module=None,
        silent=SILENT_D,
    ):
        &#34;&#34;&#34;Saves newly generated data to disk as TF features, nodes and / or edges.

        If you have collected feature data in dictionaries, keyed by the
        names of the features, and valued by their feature data,
        then you can save that data to `.tf` feature files on disk.

        It is this easy to export new data as features:
        collect the data and metadata of the features and feed it in an orderly way
        to `TF.save()` and there you go.

        Parameters
        ----------
        nodeFeatures: dict of dict
            The data of a node feature is a dictionary with nodes as keys (integers!)
            and strings or numbers as (feature) values.
            This parameter holds all those dictionaries, keyed by feature name.

        edgeFeatures: dict of dict
            The data of an edge feature is a dictionary with nodes as keys, and sets or
            dictionaries as values. These sets should be sets of nodes (integers!),
            and these dictionaries should have nodes as keys and strings or numbers
            as values.
            This parameter holds all those dictionaries, keyed by feature name.

        metaData: dict of  dict
            The meta data for every feature to be saved is a key-value dictionary.
            This parameter holds all those dictionaries, keyed by feature name.

            !!! explanation &#34;value types&#34;
                The type of the feature values (`int` or `str`) should be specified
                under key `valueType`.

            !!! explanation &#34;edge values&#34;
                If you save an edge feature, and there are values in that edge feature,
                you have to say so, by specifying `edgeValues=True`
                in the metadata for that feature.

            !!! explanation &#34;generic metadata&#34;
                This parameter may also contain fields under the empty name.
                These fields will be added to all features in `nodeFeatures` and
                `edgeFeatures`.

            !!! explanation &#34;configuration features&#34;
                If you need to write the *configuration* feature `otext`,
                which is a metadata-only feature, just
                add the metadata under key `otext` in this parameter and make sure
                that `otext` is not a key in `nodeFeatures` nor in
                `edgeFeatures`.
                These fields will be written into the separate configuration
                feature `otext`, with no data associated.

        location: dict
            The (meta)data will be written to the very last directory that TF searched
            when looking for features (this is determined by the
            `locations` and `modules` parameters in `tf.fabric.Fabric`.

            If both `locations` and `modules` are empty, writing will take place
            in the current directory.

            But you can override it:

            If you pass `location=something`, TF will save in `something/mod`,
            where `mod` is the last member of the `modules` parameter of TF.

        module: dict
            This is an additional way of overriding the default location
            where TF saves new features. See the *location* parameter.

            If you pass `module=something`, TF will save in `loc/something`,
            where `loc` is the last member of the `locations` parameter of TF.

            If you pass `location=path1` and `module=path2`,
            TF will save in `path1/path2`.

        silent: string, optional tf.core.timestamp.SILENT_D
            See `tf.core.timestamp.Timestamp`
        &#34;&#34;&#34;

        silent = silentConvert(silent)
        tmObj = self.tmObj
        isSilent = tmObj.isSilent
        setSilent = tmObj.setSilent
        indent = tmObj.indent
        info = tmObj.info
        error = tmObj.error

        good = True
        wasSilent = isSilent()
        setSilent(silent)
        indent(level=0, reset=True)
        self._getWriteLoc(location=location, module=module)
        configFeatures = dict(
            f
            for f in metaData.items()
            if f[0] != &#34;&#34; and f[0] not in nodeFeatures and f[0] not in edgeFeatures
        )
        info(
            &#34;Exporting {} node and {} edge and {} configuration features to {}:&#34;.format(
                len(nodeFeatures),
                len(edgeFeatures),
                len(configFeatures),
                self.writeDir,
            )
        )
        todo = []
        for fName in sorted(nodeFeatures):
            todo.append((fName, nodeFeatures[fName], False, False))
        for fName in sorted(edgeFeatures):
            todo.append((fName, edgeFeatures[fName], True, False))
        for fName in sorted(configFeatures):
            todo.append((fName, configFeatures[fName], None, True))
        total = collections.Counter()
        failed = collections.Counter()
        maxSlot = None
        maxNode = None
        slotType = None
        if OTYPE in nodeFeatures:
            info(f&#34;VALIDATING {OSLOTS} feature&#34;)
            otypeData = nodeFeatures[OTYPE]
            if type(otypeData) is tuple:
                (otypeData, slotType, maxSlot, maxNode) = otypeData
            elif 1 in otypeData:
                slotType = otypeData[1]
                maxSlot = max(n for n in otypeData if otypeData[n] == slotType)
                maxNode = max(otypeData)
        if OSLOTS in edgeFeatures:
            info(f&#34;VALIDATING {OSLOTS} feature&#34;)
            oslotsData = edgeFeatures[OSLOTS]
            if type(oslotsData) is tuple:
                (oslotsData, maxSlot, maxNode) = oslotsData
            if maxSlot is None or maxNode is None:
                error(f&#34;ERROR: cannot check validity of {OSLOTS} feature&#34;)
                good = False
            else:
                info(f&#34;maxSlot={maxSlot:&gt;11}&#34;)
                info(f&#34;maxNode={maxNode:&gt;11}&#34;)
                maxNodeInData = max(oslotsData)
                minNodeInData = min(oslotsData)

                mappedSlotNodes = []
                unmappedNodes = []
                fakeNodes = []

                start = min((maxSlot + 1, minNodeInData))
                end = max((maxNode, maxNodeInData))
                for n in range(start, end + 1):
                    if n in oslotsData:
                        if n &lt;= maxSlot:
                            mappedSlotNodes.append(n)
                        elif n &gt; maxNode:
                            fakeNodes.append(n)
                    else:
                        if maxSlot &lt; n &lt;= maxNode:
                            unmappedNodes.append(n)

                if mappedSlotNodes:
                    error(f&#34;ERROR: {OSLOTS} maps slot nodes&#34;)
                    error(makeExamples(mappedSlotNodes), tm=False)
                    good = False
                if fakeNodes:
                    error(f&#34;ERROR: {OSLOTS} maps nodes that are not in {OTYPE}&#34;)
                    error(makeExamples(fakeNodes), tm=False)
                    good = False
                if unmappedNodes:
                    error(f&#34;ERROR: {OSLOTS} fails to map nodes:&#34;)
                    unmappedByType = {}
                    for n in unmappedNodes:
                        unmappedByType.setdefault(
                            otypeData.get(n, &#34;_UNKNOWN_&#34;), []
                        ).append(n)
                    for (nType, nodes) in sorted(
                        unmappedByType.items(),
                        key=lambda x: (-len(x[1]), x[0]),
                    ):
                        error(f&#34;--- unmapped {nType:&lt;10} : {makeExamples(nodes)}&#34;)
                    good = False

            if good:
                info(f&#34;OK: {OSLOTS} is valid&#34;)

        for (fName, data, isEdge, isConfig) in todo:
            edgeValues = False
            fMeta = {}
            fMeta.update(metaData.get(&#34;&#34;, {}))
            fMeta.update(metaData.get(fName, {}))
            if fMeta.get(&#34;edgeValues&#34;, False):
                edgeValues = True
            if &#34;edgeValues&#34; in fMeta:
                del fMeta[&#34;edgeValues&#34;]
            fObj = Data(
                f&#34;{self.writeDir}/{fName}.tf&#34;,
                self.tmObj,
                data=data,
                metaData=fMeta,
                isEdge=isEdge,
                isConfig=isConfig,
                edgeValues=edgeValues,
            )
            tag = &#34;config&#34; if isConfig else &#34;edge&#34; if isEdge else &#34;node&#34;
            if fObj.save(nodeRanges=fName == OTYPE, overwrite=True, silent=silent):
                total[tag] += 1
            else:
                failed[tag] += 1
        indent(level=0)
        info(
            f&#34;&#34;&#34;Exported {total[&#34;node&#34;]} node features&#34;&#34;&#34;
            f&#34;&#34;&#34; and {total[&#34;edge&#34;]} edge features&#34;&#34;&#34;
            f&#34;&#34;&#34; and {total[&#34;config&#34;]} config features&#34;&#34;&#34;
            f&#34;&#34;&#34; to {self.writeDir}&#34;&#34;&#34;
        )
        if len(failed):
            for (tag, nf) in sorted(failed.items()):
                error(f&#34;Failed to export {nf} {tag} features&#34;)
            good = False

        setSilent(wasSilent)
        return good

    def _loadFeature(self, fName, optional=False):
        if not self.good:
            return False

        tmObj = self.tmObj
        isSilent = tmObj.isSilent
        error = tmObj.error

        silent = isSilent()
        if fName not in self.features:
            if not optional:
                error(f&#39;Feature &#34;{fName}&#34; not available in\n{self.locationRep}&#39;)
                self.good = False
        else:
            if not self.features[fName].load(silent=silent, _withGc=self._withGc):
                self.good = False

    def _makeIndex(self):
        tmObj = self.tmObj
        info = tmObj.info
        debug = tmObj.debug
        warning = tmObj.warning

        self.features = {}
        self.featuresIgnored = {}
        tfFiles = {}
        for loc in self.locations:
            for mod in self.modules:
                dirF = normpath(f&#34;{loc}/{mod}&#34;)
                if not dirExists(dirF):
                    continue
                with scanDir(dirF) as sd:
                    files = tuple(
                        e.name for e in sd if e.is_file() and e.name.endswith(&#34;.tf&#34;)
                    )
                for fileF in files:
                    (fName, ext) = splitExt(fileF)
                    tfFiles.setdefault(fName, []).append(f&#34;{dirF}/{fileF}&#34;)
        for (fName, featurePaths) in sorted(tfFiles.items()):
            chosenFPath = featurePaths[-1]
            for featurePath in sorted(set(featurePaths[0:-1])):
                if featurePath != chosenFPath:
                    self.featuresIgnored.setdefault(fName, []).append(featurePath)
            self.features[fName] = Data(chosenFPath, self.tmObj)
        self._getWriteLoc()
        debug(
            &#34;{} features found and {} ignored&#34;.format(
                len(tfFiles),
                sum(len(x) for x in self.featuresIgnored.values()),
            ),
            tm=False,
        )

        self.featuresOnly = False

        if OTYPE not in self.features or OSLOTS not in self.features:
            info(
                f&#34;Not all of the warp features {OTYPE} and {OSLOTS} &#34;
                f&#34;are present in\n{self.locationRep}&#34;
            )
            info(&#34;Only the Feature and Edge APIs will be enabled&#34;)
            self.featuresOnly = True
        if OTEXT in self.features:
            self._loadFeature(OTEXT, optional=True)
        else:
            info((f&#39;Warp feature &#34;{OTEXT}&#34; not found. Working without Text-API\n&#39;))
            self.features[OTEXT] = Data(
                f&#34;{OTEXT}.tf&#34;,
                self.tmObj,
                isConfig=True,
                metaData=OTEXT_DEFAULT,
            )
            self.features[OTEXT].dataLoaded = True

        good = True
        if not self.featuresOnly:
            self.warpDir = self.features[OTYPE].dirName
            self.precomputeList = []
            self.dep1Feats = []
            for (dep2, fName, method, dependencies) in PRECOMPUTE:
                thisGood = True
                if dep2 and OTEXT not in self.features:
                    continue
                if dep2 == 1:
                    self.dep1Feats.append(fName)
                elif dep2 == 2:
                    otextMeta = self.features[OTEXT].metaData
                    sFeatures = f&#34;{KIND[fName]}Features&#34;
                    sFeats = tuple(itemize(otextMeta.get(sFeatures, &#34;&#34;), &#34;,&#34;))
                    dependencies = dependencies + sFeats
                for dep in dependencies:
                    if dep not in self.features:
                        warning(
                            &#34;Missing dependency for computed data feature &#34;
                            f&#39;&#34;{fName}&#34;: &#34;{dep}&#34;&#39;
                        )
                        thisGood = False
                if not thisGood:
                    good = False
                self.features[fName] = Data(
                    f&#34;{self.warpDir}/{fName}.x&#34;,
                    self.tmObj,
                    method=method,
                    dependencies=[self.features.get(dep, None) for dep in dependencies],
                )
                self.precomputeList.append((fName, dep2))
        self.good = good

    def _getWriteLoc(self, location=None, module=None):
        writeLoc = (
            ex(location)
            if location is not None
            else &#34;&#34;
            if len(self.locations) == 0
            else self.locations[-1]
        )
        writeMod = (
            module
            if module is not None
            else &#34;&#34;
            if len(self.modules) == 0
            else self.modules[-1]
        )
        self.writeDir = (
            f&#34;{writeLoc}{writeMod}&#34;
            if writeLoc == &#34;&#34; or writeMod == &#34;&#34;
            else f&#34;{writeLoc}/{writeMod}&#34;
        )

    def _precompute(self):
        tmObj = self.tmObj
        isSilent = tmObj.isSilent
        good = True

        for (fName, dep2) in self.precomputeList:
            ok = getattr(self, f&#39;{fName.strip(&#34;_&#34;)}OK&#39;, False)
            if dep2 == 2 and not ok:
                continue
            if not self.features[fName].load(silent=isSilent()):
                good = False
                break
        self.good = good

    def _makeApi(self):
        if not self.good:
            return None

        tmObj = self.tmObj
        isSilent = tmObj.isSilent
        indent = tmObj.indent
        debug = tmObj.debug
        featuresOnly = self.featuresOnly

        silent = isSilent()
        api = Api(self)
        api.featuresOnly = featuresOnly

        if not featuresOnly:
            w0info = self.features[OTYPE]
            w1info = self.features[OSLOTS]

        if not featuresOnly:
            setattr(api.F, OTYPE, OtypeFeature(api, w0info.metaData, w0info.data))
            setattr(api.E, OSLOTS, OslotsFeature(api, w1info.metaData, w1info.data))

        requestedSet = set(self.featuresRequested)

        for fName in self.features:
            fObj = self.features[fName]
            if fObj.dataLoaded and not fObj.isConfig:
                if fObj.method:
                    if not featuresOnly:
                        feat = fName.strip(&#34;_&#34;)
                        ok = getattr(self, f&#34;{feat}OK&#34;, False)
                        ap = api.C
                        if fName in [
                            fn
                            for (fn, dep2) in self.precomputeList
                            if not dep2 == 2 or ok
                        ]:
                            setattr(ap, feat, Computed(api, fObj.data))
                        else:
                            fObj.unload()
                            if hasattr(ap, feat):
                                delattr(api.C, feat)
                else:
                    if fName in requestedSet | self.textFeatures:
                        if fName in (OTYPE, OSLOTS, OTEXT):
                            continue
                        elif fObj.isEdge:
                            setattr(
                                api.E,
                                fName,
                                EdgeFeature(
                                    api, fObj.metaData, fObj.data, fObj.edgeValues
                                ),
                            )
                        else:
                            setattr(
                                api.F, fName, NodeFeature(api, fObj.metaData, fObj.data)
                            )
                    else:
                        if (
                            fName in (OTYPE, OSLOTS, OTEXT)
                            or fName in self.textFeatures
                        ):
                            continue
                        elif fObj.isEdge:
                            if hasattr(api.E, fName):
                                delattr(api.E, fName)
                        else:
                            if hasattr(api.F, fName):
                                delattr(api.F, fName)
                        fObj.unload()
        if not featuresOnly:
            addOtype(api)
            addNodes(api)
            addLocality(api)
            addText(api)
            addSearch(api, silent)
        indent(level=0)
        debug(&#34;All features loaded / computed - for details use TF.isLoaded()&#34;)
        self.api = api
        setattr(self, &#34;isLoaded&#34;, self.api.isLoaded)
        return api

    def _updateApi(self):
        if not self.good:
            return None
        api = self.api
        tmObj = self.tmObj
        indent = tmObj.indent
        debug = tmObj.debug

        requestedSet = set(self.featuresRequested)

        for fName in self.features:
            fObj = self.features[fName]
            if fObj.dataLoaded and not fObj.isConfig:
                if not fObj.method:
                    if fName in requestedSet | self.textFeatures:
                        if fName in (OTYPE, OSLOTS, OTEXT):
                            continue
                        elif fObj.isEdge:
                            apiFobj = EdgeFeature(
                                api, fObj.metaData, fObj.data, fObj.edgeValues
                            )
                            setattr(api.E, fName, apiFobj)
                        else:
                            apiFobj = NodeFeature(api, fObj.metaData, fObj.data)
                            setattr(api.F, fName, apiFobj)
                    else:
                        if (
                            fName in (OTYPE, OSLOTS, OTEXT)
                            or fName in self.textFeatures
                        ):
                            continue
                        elif fObj.isEdge:
                            if hasattr(api.E, fName):
                                delattr(api.E, fName)
                        else:
                            if hasattr(api.F, fName):
                                delattr(api.F, fName)
                        fObj.unload()
        indent(level=0)
        debug(&#34;All additional features loaded - for details use TF.isLoaded()&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="tf.fabric.Fabric" href="../fabric.html#tf.fabric.Fabric">Fabric</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="tf.core.fabric.FabricCore.banner"><code class="name">var <span class="ident">banner</span></code></dt>
<dd>
<div class="desc"><p>The banner Text-Fabric.</p>
<p>Will be shown just after start up, if the silence is not <code>deep</code>.</p></div>
</dd>
<dt id="tf.core.fabric.FabricCore.features"><code class="name">var <span class="ident">features</span></code></dt>
<dd>
<div class="desc"><p>Dictionary of all features that TF has found, whether loaded or not.</p>
<p>Under each feature name is all info about that feature.</p>
<p>The best use of this is to get the metadata of features:</p>
<pre><code>TF.features['fff'].metaData
</code></pre>
<p>This works for all features <code>fff</code> that have been found,
whether the feature is loaded or not.</p>
<p>If a feature is loaded, you can also use</p>
<p><code>F.fff.meta</code> of <code>E.fff.meta</code> depending on whether <code>fff</code> is a node feature
or an edge feature.</p>
<div class="admonition caution">
<p class="admonition-title">Do not print!</p>
<p>If a feature is loaded, its data is also in the feature info.
This can be an enormous amount of information, and you can easily
overwhelm your notebook if you print it.</p>
</div></div>
</dd>
<dt id="tf.core.fabric.FabricCore.version"><code class="name">var <span class="ident">version</span></code></dt>
<dd>
<div class="desc"><p>The version number of the TF library.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tf.core.fabric.FabricCore.clearCache"><code class="name flex">
<span>def <span class="ident">clearCache</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Clears the cache of compiled TF data.</p>
<p>TF pre-computes data for you, so that it can be loaded faster.
If the original data is updated, TF detects it,
and will recompute that data.</p>
<p>But there are cases, when the algorithms of TF have changed,
without any changes in the data, where you might want to clear the cache
of pre-computed results.</p>
<p>Calling this function just does it, and it is equivalent with manually removing
all <code>.tfx</code> files inside the hidden <code>.<a title="tf" href="../index.html">tf</a></code> directory inside your dataset.</p>
<div class="admonition hint">
<p class="admonition-title">No need to load</p>
<p>It is not needed to execute a <code>TF.load()</code> first.</p>
</div>
<h2 id="see-also">See Also</h2>
<p><code><a title="tf.clean" href="../clean.html">tf.clean</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/5d2b5ddd19be981cf71dceb9798cd89b451058cd/tf/core/fabric.py#L537-L560" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def clearCache(self):
    &#34;&#34;&#34;Clears the cache of compiled TF data.

    TF pre-computes data for you, so that it can be loaded faster.
    If the original data is updated, TF detects it,
    and will recompute that data.

    But there are cases, when the algorithms of TF have changed,
    without any changes in the data, where you might want to clear the cache
    of pre-computed results.

    Calling this function just does it, and it is equivalent with manually removing
    all `.tfx` files inside the hidden `.tf` directory inside your dataset.

    !!! hint &#34;No need to load&#34;
        It is not needed to execute a `TF.load()` first.

    See Also
    --------
    tf.clean
    &#34;&#34;&#34;

    for (fName, fObj) in self.features.items():
        fObj.cleanDataBin()</code></pre>
</details>
</dd>
<dt id="tf.core.fabric.FabricCore.explore"><code class="name flex">
<span>def <span class="ident">explore</span></span>(<span>self, silent='auto', show=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Makes categorization of all features in the dataset.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>silent</code></strong> :&ensp;<code>string</code>, optional <code><a title="tf.core.timestamp.SILENT_D" href="timestamp.html#tf.core.timestamp.SILENT_D">SILENT_D</a></code></dt>
<dd>See <code><a title="tf.core.timestamp.Timestamp" href="timestamp.html#tf.core.timestamp.Timestamp">Timestamp</a></code></dd>
<dt><strong><code>show</code></strong> :&ensp;<code>boolean</code>, optional <code>True</code></dt>
<dd>If <code>False</code>, the resulting dictionary is delivered in <code>TF.featureSets</code>;
if <code>True</code>, the dictionary is returned as function result.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict | None</code></dt>
<dd>A dictionary
with keys <code>nodes</code>, <code>edges</code>, <code>configs</code>, <code>computeds</code>.
Under each key there is the set of feature names in that category.
How this dictionary is delivered, depends on the parameter <em>show</em>.</dd>
</dl>
<h2 id="notes">Notes</h2>
<div class="admonition explanation">
<p class="admonition-title"><code>configs</code></p>
<p>These are configuration features, with metadata only, no data. E.g. <code>otext</code>.</p>
</div>
<div class="admonition explanation">
<p class="admonition-title"><code>computeds</code></p>
<p>These are blocks of pre-computed data, available under the <code>C</code> API,
see <code><a title="tf.core.computed.Computeds" href="computed.html#tf.core.computed.Computeds">Computeds</a></code>.</p>
</div>
<p>The sets do not indicate whether a feature is loaded or not.
There are other functions that give you the loaded features:
<code><a title="tf.core.api.Api.Fall" href="api.html#tf.core.api.Api.Fall">Api.Fall()</a></code> for nodes and <code><a title="tf.core.api.Api.Eall" href="api.html#tf.core.api.Api.Eall">Api.Eall()</a></code> for edges.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/5d2b5ddd19be981cf71dceb9798cd89b451058cd/tf/core/fabric.py#L445-L519" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def explore(self, silent=SILENT_D, show=True):
    &#34;&#34;&#34;Makes categorization of all features in the dataset.

    Parameters
    ----------
    silent: string, optional tf.core.timestamp.SILENT_D
        See `tf.core.timestamp.Timestamp`
    show: boolean, optional True
        If `False`, the resulting dictionary is delivered in `TF.featureSets`;
        if `True`, the dictionary is returned as function result.

    Returns
    -------
    dict | None
        A dictionary  with keys `nodes`, `edges`, `configs`, `computeds`.
        Under each key there is the set of feature names in that category.
        How this dictionary is delivered, depends on the parameter *show*.

    Notes
    -----
    !!! explanation &#34;`configs`&#34;
        These are configuration features, with metadata only, no data. E.g. `otext`.

    !!! explanation &#34;`computeds`&#34;
        These are blocks of pre-computed data, available under the `C` API,
        see `tf.core.computed.Computeds`.

    The sets do not indicate whether a feature is loaded or not.
    There are other functions that give you the loaded features:
    `tf.core.api.Api.Fall` for nodes and `tf.core.api.Api.Eall` for edges.
    &#34;&#34;&#34;

    silent = silentConvert(silent)
    tmObj = self.tmObj
    isSilent = tmObj.isSilent
    setSilent = tmObj.setSilent
    info = tmObj.info

    wasSilent = isSilent()
    setSilent(silent)
    nodes = set()
    edges = set()
    configs = set()
    computeds = set()
    for (fName, fObj) in self.features.items():
        fObj.load(silent=silent, metaOnly=True)
        dest = None
        if fObj.method:
            dest = computeds
        elif fObj.isConfig:
            dest = configs
        elif fObj.isEdge:
            dest = edges
        else:
            dest = nodes
        dest.add(fName)
    info(
        &#34;Feature overview: {} for nodes; {} for edges; {} configs; {} computed&#34;.format(
            len(nodes),
            len(edges),
            len(configs),
            len(computeds),
        )
    )
    self.featureSets = dict(
        nodes=nodes, edges=edges, configs=configs, computeds=computeds
    )
    setSilent(wasSilent)
    if show:
        return dict(
            (kind, tuple(sorted(kindSet)))
            for (kind, kindSet) in sorted(
                self.featureSets.items(), key=lambda x: x[0]
            )
        )</code></pre>
</details>
</dd>
<dt id="tf.core.fabric.FabricCore.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>self, features, add=False, silent='auto')</span>
</code></dt>
<dd>
<div class="desc"><p>Loads features from disk into RAM memory.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>features</code></strong> :&ensp;<code>string | iterable</code></dt>
<dd>Either a string containing space separated feature names, or an
iterable of feature names.
The feature names are just the names of <code>.<a title="tf" href="../index.html">tf</a></code> files
without directory information and without extension.</dd>
<dt><strong><code>add</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>The features will be added to the same currently loaded features, managed
by the current API.
Meant to be able to dynamically load features without reloading lots
of features for nothing.</dd>
<dt><strong><code>silent</code></strong> :&ensp;<code>string</code>, optional <code><a title="tf.core.timestamp.SILENT_D" href="timestamp.html#tf.core.timestamp.SILENT_D">SILENT_D</a></code></dt>
<dd>See <code><a title="tf.core.timestamp.Timestamp" href="timestamp.html#tf.core.timestamp.Timestamp">Timestamp</a></code></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean | object</code></dt>
<dd>If <code>add</code> is <code>True</code> a boolean indicating success is returned.
Otherwise, the result is a new <code><a title="tf.core.api.Api" href="api.html#tf.core.api.Api">Api</a></code>
if the feature could be loaded, else <code>False</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/5d2b5ddd19be981cf71dceb9798cd89b451058cd/tf/core/fabric.py#L283-L443" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def load(self, features, add=False, silent=SILENT_D):
    &#34;&#34;&#34;Loads features from disk into RAM memory.

    Parameters
    ----------

    features: string | iterable
        Either a string containing space separated feature names, or an
        iterable of feature names.
        The feature names are just the names of `.tf` files
        without directory information and without extension.
    add: boolean, optional False
        The features will be added to the same currently loaded features, managed
        by the current API.
        Meant to be able to dynamically load features without reloading lots
        of features for nothing.
    silent: string, optional tf.core.timestamp.SILENT_D
        See `tf.core.timestamp.Timestamp`

    Returns
    -------
    boolean | object
        If `add` is `True` a boolean indicating success is returned.
        Otherwise, the result is a new `tf.core.api.Api`
        if the feature could be loaded, else `False`.
    &#34;&#34;&#34;

    silent = silentConvert(silent)
    tmObj = self.tmObj
    isSilent = tmObj.isSilent
    setSilent = tmObj.setSilent
    indent = tmObj.indent
    debug = tmObj.debug
    warning = tmObj.warning
    error = tmObj.error
    cache = tmObj.cache
    reset = tmObj.reset
    featuresOnly = self.featuresOnly

    wasSilent = isSilent()
    setSilent(silent)
    indent(level=0, reset=True)
    self.sectionsOK = True
    self.structureOK = True
    self.good = True

    if self.good:
        featuresRequested = sorted(fitemize(features))
        if add:
            self.featuresRequested += featuresRequested
        else:
            self.featuresRequested = featuresRequested
        for fName in (OTYPE, OSLOTS, OTEXT):
            self._loadFeature(fName, optional=fName == OTEXT or featuresOnly)

    self.textFeatures = set()

    if self.good and not featuresOnly:
        if OTEXT in self.features:
            otextMeta = self.features[OTEXT].metaData
            for otextMod in self.features:
                if otextMod.startswith(OTEXT + &#34;@&#34;):
                    self._loadFeature(otextMod)
                    otextMeta.update(self.features[otextMod].metaData)
            self.sectionFeats = itemize(otextMeta.get(&#34;sectionFeatures&#34;, &#34;&#34;), &#34;,&#34;)
            self.sectionTypes = itemize(otextMeta.get(&#34;sectionTypes&#34;, &#34;&#34;), &#34;,&#34;)
            self.structureFeats = itemize(
                otextMeta.get(&#34;structureFeatures&#34;, &#34;&#34;), &#34;,&#34;
            )
            self.structureTypes = itemize(otextMeta.get(&#34;structureTypes&#34;, &#34;&#34;), &#34;,&#34;)
            (self.cformats, self.formatFeats) = collectFormats(otextMeta)

            if not (0 &lt; len(self.sectionTypes) &lt;= 3) or not (
                0 &lt; len(self.sectionFeats) &lt;= 3
            ):
                if not add:
                    warning(
                        f&#34;Dataset without sections in {OTEXT}:&#34;
                        f&#34;no section functions in the T-API&#34;
                    )
                self.sectionsOK = False
            else:
                self.textFeatures |= set(self.sectionFeats)
                self.sectionFeatsWithLanguage = tuple(
                    f
                    for f in self.features
                    if f == self.sectionFeats[0]
                    or f.startswith(f&#34;{self.sectionFeats[0]}@&#34;)
                )
                self.textFeatures |= set(self.sectionFeatsWithLanguage)
            if not self.structureTypes or not self.structureFeats:
                if not add:
                    debug(
                        f&#34;Dataset without structure sections in {OTEXT}:&#34;
                        f&#34;no structure functions in the T-API&#34;
                    )
                self.structureOK = False
            else:
                self.textFeatures |= set(self.structureFeats)

            formatFeats = set(self.formatFeats)
            self.textFeatures |= formatFeats

            for fName in self.textFeatures:
                self._loadFeature(fName, optional=fName in formatFeats)

            dep1Feats = self.dep1Feats
            if dep1Feats:
                cformats = self.cformats
                tFormats = {}
                tFeats = set()
                for (fmt, (otpl, tpl, featData)) in cformats.items():
                    feats = set(chain.from_iterable(x[0] for x in featData))
                    tFormats[fmt] = tuple(sorted(feats))
                    tFeats |= feats
                tFeats = tuple(sorted(tFeats))
                extraDependencies = [tFormats]
                for tFeat in tFeats:
                    featData = self.features[tFeat].data
                    extraDependencies.append((tFeat, featData))
                for cFeat in dep1Feats:
                    self.features[cFeat].dependencies += extraDependencies

        else:
            self.sectionsOK = False
            self.structureOK = False

    if self.good and not featuresOnly:
        self._precompute()

    if self.good:
        reset()
        for fName in self.featuresRequested:
            self._loadFeature(fName)
            if not self.good:
                indent(level=0)
                cache()
                error(&#34;Not all features could be loaded / computed&#34;)
                result = False
                break
            reset()

    if self.good:
        if add:
            try:
                self._updateApi()
                result = True
            except MemoryError:
                console(MEM_MSG)
                result = False
        else:
            try:
                result = self._makeApi()
            except MemoryError:
                console(MEM_MSG)
                result = False
    else:
        result = False

    setSilent(wasSilent)
    return result</code></pre>
</details>
</dd>
<dt id="tf.core.fabric.FabricCore.loadAll"><code class="name flex">
<span>def <span class="ident">loadAll</span></span>(<span>self, silent='auto')</span>
</code></dt>
<dd>
<div class="desc"><p>Load all loadable features.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>silent</code></strong> :&ensp;<code>string</code>, optional <code><a title="tf.core.timestamp.SILENT_D" href="timestamp.html#tf.core.timestamp.SILENT_D">SILENT_D</a></code></dt>
<dd>See <code><a title="tf.core.timestamp.Timestamp" href="timestamp.html#tf.core.timestamp.Timestamp">Timestamp</a></code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/5d2b5ddd19be981cf71dceb9798cd89b451058cd/tf/core/fabric.py#L521-L535" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def loadAll(self, silent=SILENT_D):
    &#34;&#34;&#34;Load all loadable features.

    Parameters
    ----------
    silent: string, optional tf.core.timestamp.SILENT_D
        See `tf.core.timestamp.Timestamp`
    &#34;&#34;&#34;

    silent = silentConvert(silent)
    api = self.load(&#34;&#34;, silent=silent)
    allFeatures = self.explore(silent=silent, show=True)
    loadableFeatures = allFeatures[&#34;nodes&#34;] + allFeatures[&#34;edges&#34;]
    self.load(loadableFeatures, add=True, silent=silent)
    return api</code></pre>
</details>
</dd>
<dt id="tf.core.fabric.FabricCore.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, nodeFeatures:Â Dict[str,Â Dict[int,Â Union[str,Â int]]]Â =Â {}, edgeFeatures:Â Dict[str,Â Dict[int,Â Union[Set[int],Â Dict[int,Â Union[str,Â int]]]]]Â =Â {}, metaData:Â Dict[str,Â Dict[str,Â str]]Â =Â {}, location=None, module=None, silent='auto')</span>
</code></dt>
<dd>
<div class="desc"><p>Saves newly generated data to disk as TF features, nodes and / or edges.</p>
<p>If you have collected feature data in dictionaries, keyed by the
names of the features, and valued by their feature data,
then you can save that data to <code>.<a title="tf" href="../index.html">tf</a></code> feature files on disk.</p>
<p>It is this easy to export new data as features:
collect the data and metadata of the features and feed it in an orderly way
to <code>TF.save()</code> and there you go.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nodeFeatures</code></strong> :&ensp;<code>dict</code> of <code>dict</code></dt>
<dd>The data of a node feature is a dictionary with nodes as keys (integers!)
and strings or numbers as (feature) values.
This parameter holds all those dictionaries, keyed by feature name.</dd>
<dt><strong><code>edgeFeatures</code></strong> :&ensp;<code>dict</code> of <code>dict</code></dt>
<dd>The data of an edge feature is a dictionary with nodes as keys, and sets or
dictionaries as values. These sets should be sets of nodes (integers!),
and these dictionaries should have nodes as keys and strings or numbers
as values.
This parameter holds all those dictionaries, keyed by feature name.</dd>
<dt><strong><code>metaData</code></strong> :&ensp;<code>dict</code> of
<code>dict</code></dt>
<dd>
<p>The meta data for every feature to be saved is a key-value dictionary.
This parameter holds all those dictionaries, keyed by feature name.</p>
<div class="admonition explanation">
<p class="admonition-title">value types</p>
<p>The type of the feature values (<code>int</code> or <code>str</code>) should be specified
under key <code>valueType</code>.</p>
</div>
<div class="admonition explanation">
<p class="admonition-title">edge values</p>
<p>If you save an edge feature, and there are values in that edge feature,
you have to say so, by specifying <code>edgeValues=True</code>
in the metadata for that feature.</p>
</div>
<div class="admonition explanation">
<p class="admonition-title">generic metadata</p>
<p>This parameter may also contain fields under the empty name.
These fields will be added to all features in <code>nodeFeatures</code> and
<code>edgeFeatures</code>.</p>
</div>
<div class="admonition explanation">
<p class="admonition-title">configuration features</p>
<p>If you need to write the <em>configuration</em> feature <code>otext</code>,
which is a metadata-only feature, just
add the metadata under key <code>otext</code> in this parameter and make sure
that <code>otext</code> is not a key in <code>nodeFeatures</code> nor in
<code>edgeFeatures</code>.
These fields will be written into the separate configuration
feature <code>otext</code>, with no data associated.</p>
</div>
</dd>
<dt><strong><code>location</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>The (meta)data will be written to the very last directory that TF searched
when looking for features (this is determined by the
<code>locations</code> and <code>modules</code> parameters in <code><a title="tf.fabric.Fabric" href="../fabric.html#tf.fabric.Fabric">Fabric</a></code>.</p>
<p>If both <code>locations</code> and <code>modules</code> are empty, writing will take place
in the current directory.</p>
<p>But you can override it:</p>
<p>If you pass <code>location=something</code>, TF will save in <code>something/mod</code>,
where <code>mod</code> is the last member of the <code>modules</code> parameter of TF.</p>
</dd>
<dt><strong><code>module</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>This is an additional way of overriding the default location
where TF saves new features. See the <em>location</em> parameter.</p>
<p>If you pass <code>module=something</code>, TF will save in <code>loc/something</code>,
where <code>loc</code> is the last member of the <code>locations</code> parameter of TF.</p>
<p>If you pass <code>location=path1</code> and <code>module=path2</code>,
TF will save in <code>path1/path2</code>.</p>
</dd>
<dt><strong><code>silent</code></strong> :&ensp;<code>string</code>, optional <code><a title="tf.core.timestamp.SILENT_D" href="timestamp.html#tf.core.timestamp.SILENT_D">SILENT_D</a></code></dt>
<dd>See <code><a title="tf.core.timestamp.Timestamp" href="timestamp.html#tf.core.timestamp.Timestamp">Timestamp</a></code></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/5d2b5ddd19be981cf71dceb9798cd89b451058cd/tf/core/fabric.py#L562-L787" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def save(
    self,
    nodeFeatures: nodeFeatureDict = {},
    edgeFeatures: edgeFeatureDict = {},
    metaData: metaDataDict = {},
    location=None,
    module=None,
    silent=SILENT_D,
):
    &#34;&#34;&#34;Saves newly generated data to disk as TF features, nodes and / or edges.

    If you have collected feature data in dictionaries, keyed by the
    names of the features, and valued by their feature data,
    then you can save that data to `.tf` feature files on disk.

    It is this easy to export new data as features:
    collect the data and metadata of the features and feed it in an orderly way
    to `TF.save()` and there you go.

    Parameters
    ----------
    nodeFeatures: dict of dict
        The data of a node feature is a dictionary with nodes as keys (integers!)
        and strings or numbers as (feature) values.
        This parameter holds all those dictionaries, keyed by feature name.

    edgeFeatures: dict of dict
        The data of an edge feature is a dictionary with nodes as keys, and sets or
        dictionaries as values. These sets should be sets of nodes (integers!),
        and these dictionaries should have nodes as keys and strings or numbers
        as values.
        This parameter holds all those dictionaries, keyed by feature name.

    metaData: dict of  dict
        The meta data for every feature to be saved is a key-value dictionary.
        This parameter holds all those dictionaries, keyed by feature name.

        !!! explanation &#34;value types&#34;
            The type of the feature values (`int` or `str`) should be specified
            under key `valueType`.

        !!! explanation &#34;edge values&#34;
            If you save an edge feature, and there are values in that edge feature,
            you have to say so, by specifying `edgeValues=True`
            in the metadata for that feature.

        !!! explanation &#34;generic metadata&#34;
            This parameter may also contain fields under the empty name.
            These fields will be added to all features in `nodeFeatures` and
            `edgeFeatures`.

        !!! explanation &#34;configuration features&#34;
            If you need to write the *configuration* feature `otext`,
            which is a metadata-only feature, just
            add the metadata under key `otext` in this parameter and make sure
            that `otext` is not a key in `nodeFeatures` nor in
            `edgeFeatures`.
            These fields will be written into the separate configuration
            feature `otext`, with no data associated.

    location: dict
        The (meta)data will be written to the very last directory that TF searched
        when looking for features (this is determined by the
        `locations` and `modules` parameters in `tf.fabric.Fabric`.

        If both `locations` and `modules` are empty, writing will take place
        in the current directory.

        But you can override it:

        If you pass `location=something`, TF will save in `something/mod`,
        where `mod` is the last member of the `modules` parameter of TF.

    module: dict
        This is an additional way of overriding the default location
        where TF saves new features. See the *location* parameter.

        If you pass `module=something`, TF will save in `loc/something`,
        where `loc` is the last member of the `locations` parameter of TF.

        If you pass `location=path1` and `module=path2`,
        TF will save in `path1/path2`.

    silent: string, optional tf.core.timestamp.SILENT_D
        See `tf.core.timestamp.Timestamp`
    &#34;&#34;&#34;

    silent = silentConvert(silent)
    tmObj = self.tmObj
    isSilent = tmObj.isSilent
    setSilent = tmObj.setSilent
    indent = tmObj.indent
    info = tmObj.info
    error = tmObj.error

    good = True
    wasSilent = isSilent()
    setSilent(silent)
    indent(level=0, reset=True)
    self._getWriteLoc(location=location, module=module)
    configFeatures = dict(
        f
        for f in metaData.items()
        if f[0] != &#34;&#34; and f[0] not in nodeFeatures and f[0] not in edgeFeatures
    )
    info(
        &#34;Exporting {} node and {} edge and {} configuration features to {}:&#34;.format(
            len(nodeFeatures),
            len(edgeFeatures),
            len(configFeatures),
            self.writeDir,
        )
    )
    todo = []
    for fName in sorted(nodeFeatures):
        todo.append((fName, nodeFeatures[fName], False, False))
    for fName in sorted(edgeFeatures):
        todo.append((fName, edgeFeatures[fName], True, False))
    for fName in sorted(configFeatures):
        todo.append((fName, configFeatures[fName], None, True))
    total = collections.Counter()
    failed = collections.Counter()
    maxSlot = None
    maxNode = None
    slotType = None
    if OTYPE in nodeFeatures:
        info(f&#34;VALIDATING {OSLOTS} feature&#34;)
        otypeData = nodeFeatures[OTYPE]
        if type(otypeData) is tuple:
            (otypeData, slotType, maxSlot, maxNode) = otypeData
        elif 1 in otypeData:
            slotType = otypeData[1]
            maxSlot = max(n for n in otypeData if otypeData[n] == slotType)
            maxNode = max(otypeData)
    if OSLOTS in edgeFeatures:
        info(f&#34;VALIDATING {OSLOTS} feature&#34;)
        oslotsData = edgeFeatures[OSLOTS]
        if type(oslotsData) is tuple:
            (oslotsData, maxSlot, maxNode) = oslotsData
        if maxSlot is None or maxNode is None:
            error(f&#34;ERROR: cannot check validity of {OSLOTS} feature&#34;)
            good = False
        else:
            info(f&#34;maxSlot={maxSlot:&gt;11}&#34;)
            info(f&#34;maxNode={maxNode:&gt;11}&#34;)
            maxNodeInData = max(oslotsData)
            minNodeInData = min(oslotsData)

            mappedSlotNodes = []
            unmappedNodes = []
            fakeNodes = []

            start = min((maxSlot + 1, minNodeInData))
            end = max((maxNode, maxNodeInData))
            for n in range(start, end + 1):
                if n in oslotsData:
                    if n &lt;= maxSlot:
                        mappedSlotNodes.append(n)
                    elif n &gt; maxNode:
                        fakeNodes.append(n)
                else:
                    if maxSlot &lt; n &lt;= maxNode:
                        unmappedNodes.append(n)

            if mappedSlotNodes:
                error(f&#34;ERROR: {OSLOTS} maps slot nodes&#34;)
                error(makeExamples(mappedSlotNodes), tm=False)
                good = False
            if fakeNodes:
                error(f&#34;ERROR: {OSLOTS} maps nodes that are not in {OTYPE}&#34;)
                error(makeExamples(fakeNodes), tm=False)
                good = False
            if unmappedNodes:
                error(f&#34;ERROR: {OSLOTS} fails to map nodes:&#34;)
                unmappedByType = {}
                for n in unmappedNodes:
                    unmappedByType.setdefault(
                        otypeData.get(n, &#34;_UNKNOWN_&#34;), []
                    ).append(n)
                for (nType, nodes) in sorted(
                    unmappedByType.items(),
                    key=lambda x: (-len(x[1]), x[0]),
                ):
                    error(f&#34;--- unmapped {nType:&lt;10} : {makeExamples(nodes)}&#34;)
                good = False

        if good:
            info(f&#34;OK: {OSLOTS} is valid&#34;)

    for (fName, data, isEdge, isConfig) in todo:
        edgeValues = False
        fMeta = {}
        fMeta.update(metaData.get(&#34;&#34;, {}))
        fMeta.update(metaData.get(fName, {}))
        if fMeta.get(&#34;edgeValues&#34;, False):
            edgeValues = True
        if &#34;edgeValues&#34; in fMeta:
            del fMeta[&#34;edgeValues&#34;]
        fObj = Data(
            f&#34;{self.writeDir}/{fName}.tf&#34;,
            self.tmObj,
            data=data,
            metaData=fMeta,
            isEdge=isEdge,
            isConfig=isConfig,
            edgeValues=edgeValues,
        )
        tag = &#34;config&#34; if isConfig else &#34;edge&#34; if isEdge else &#34;node&#34;
        if fObj.save(nodeRanges=fName == OTYPE, overwrite=True, silent=silent):
            total[tag] += 1
        else:
            failed[tag] += 1
    indent(level=0)
    info(
        f&#34;&#34;&#34;Exported {total[&#34;node&#34;]} node features&#34;&#34;&#34;
        f&#34;&#34;&#34; and {total[&#34;edge&#34;]} edge features&#34;&#34;&#34;
        f&#34;&#34;&#34; and {total[&#34;config&#34;]} config features&#34;&#34;&#34;
        f&#34;&#34;&#34; to {self.writeDir}&#34;&#34;&#34;
    )
    if len(failed):
        for (tag, nf) in sorted(failed.items()):
            error(f&#34;Failed to export {nf} {tag} features&#34;)
        good = False

    setSilent(wasSilent)
    return good</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#fabriccore">FabricCore</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.core" href="index.html">tf.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="tf.core.fabric.PRECOMPUTE" href="#tf.core.fabric.PRECOMPUTE">PRECOMPUTE</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.core.fabric.FabricCore" href="#tf.core.fabric.FabricCore">FabricCore</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.core.fabric.FabricCore.banner" href="#tf.core.fabric.FabricCore.banner">banner</a></code></li>
<li><code><a title="tf.core.fabric.FabricCore.clearCache" href="#tf.core.fabric.FabricCore.clearCache">clearCache</a></code></li>
<li><code><a title="tf.core.fabric.FabricCore.explore" href="#tf.core.fabric.FabricCore.explore">explore</a></code></li>
<li><code><a title="tf.core.fabric.FabricCore.features" href="#tf.core.fabric.FabricCore.features">features</a></code></li>
<li><code><a title="tf.core.fabric.FabricCore.load" href="#tf.core.fabric.FabricCore.load">load</a></code></li>
<li><code><a title="tf.core.fabric.FabricCore.loadAll" href="#tf.core.fabric.FabricCore.loadAll">loadAll</a></code></li>
<li><code><a title="tf.core.fabric.FabricCore.save" href="#tf.core.fabric.FabricCore.save">save</a></code></li>
<li><code><a title="tf.core.fabric.FabricCore.version" href="#tf.core.fabric.FabricCore.version">version</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>