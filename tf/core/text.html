<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.1" />
<title>tf.core.text API documentation</title>
<meta name="description" content="Text API â€¦" />
<!-- integrity SRI from https://cdnjs.com/libraries/10up-sanitize.css/11.0.1 -->
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css"
integrity="sha512-kcbluZFacWN57NgWZ4aH6eUMBEaTyErFhIFD3y5qYZbKuuyImH0K/AKsBbfXlivh2z5C+3IDTIhI11YmKomzmA=="
crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css"
integrity="sha512-uVeAgzAmieLUTGba0qr9vXQgVD7fko2kcbYIKIraXUIDg9iJLxveTFUrg3DJhqn3cAf3HFDbgmhq0eGko5wEAA=="
crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tf.core.text</code></h1>
</header>
<section id="section-intro">
<h1 id="text-api">Text API</h1>
<p>Here are the functions that enable you to get the actual text in the dataset.
There are several things to accomplish here, such as</p>
<ul>
<li>support the structure of the corpus</li>
<li>support a rigid section system usable by the TF browser</li>
<li>handle multilingual section labels;</li>
<li>switch between various text representations.</li>
</ul>
<p>The details of the Text API are dependent on the <code><a title="tf.parameters.WARP" href="../parameters.html#tf.parameters.WARP">WARP</a></code> feature <code>otext</code>,
which is a configuration feature.</p>
<div class="admonition hint">
<p class="admonition-title">T</p>
<p>The Text API is exposed as <code>T</code> or <code><a title="tf.core.text.Text" href="#tf.core.text.Text">Text</a></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title"><code>otext</code> is optional</p>
<p>If your dataset does not have an <code>otext</code> feature,
the Text API will not be build.
If it exists, but does not specify structure or sections,
those parts of the Text API will not be built.
Likewise for text representations.</p>
</div>
<h2 id="structure">Structure</h2>
<p>If a corpus has sectional elements, such as
<code>series</code>, <code>volume</code>, <code>book</code>, <code>part</code>, <code>document</code>, <code>chapter</code>, <code>fragment</code>, <code>verse</code>,
<code>halfverse</code>, <code>line</code>, etc, then you can configure those elements as structural types.</p>
<p>If your TF dataset designer has done that, the <code>T.api</code> will provide a number
of handy functions to navigate your corpus along its structure, programmatically.</p>
<p>The
<a href="https://nbviewer.jupyter.org/github/annotation/banks/blob/master/programs/structure.ipynb">banks</a>
example corpus shows a full example.</p>
<p>Structure is defined in the <code>otext</code> feature, by means of the keys
<code>structureTypes</code> and <code>structureFeatures</code>.
These are comma-separated lists of equal length.</p>
<p><code>structureTypes</code> specifies the node types
that act as structural types, in the order from biggest to smallest.</p>
<p><code>structureFeatures</code> specifies a feature that corresponds to each
structural type. This feature must contain the label of the structural
element, e.g. the title of a book, the number of a verse, etc.</p>
<p>The order of the section types is significant.
Suppose you have a book with a single chapter. Is the chapter part of the book,
or is the book part of the chapter?
The order decides. If <code>book</code> is mentioned in <code>structureTypes</code> before <code>chapter</code>
then the chapter is part of the book, and not the other way around.</p>
<p>However, it is allowed to have nesting of elements of the same kind.</p>
<div class="admonition explanation">
<p class="admonition-title">Proper embedding not required</p>
<p>There are no assumptions on how exactly the structural elements lie
embedded in each other, and whether they consist of uninterrupted stretches
of material or not.</p>
<p>Suppose a we have a book with two disjoint chapters and there is a verse that
has material in both chapters. Then that verse is part of neither chapter,
but it is still part of the book.
If you go down from that book to its substructural elements, you find not only
its chapters, but also that verse.</p>
<p>So the great freedom with respect to structural elements also brings greater
responsibility when using that structure.</p>
</div>
<h2 id="sections">Sections</h2>
<p>In <code>otext</code> the main section levels (usually <code>book</code>, <code>chapter</code>, <code>verse</code>) can be
defined. It loads the features it needs (so you do not have to specify those
features, unless you want to use them via <code>F</code>). And finally, it makes some
functions available by which you can make handy use of that information.</p>
<div class="admonition explanation">
<p class="admonition-title">Section levels from a limited, rigid system</p>
<p>There are up to three section levels, and this is a hard coded boundary.
That makes this section system unsuitable to faithfully reflect the
rich sectioning that may be present in a corpus.</p>
<p>On the other hand, applications (such as TF apps) can access a predictable
sectioning system by which they can divide the material in practical portions.</p>
<p>The rule of thumb is:</p>
<p>Level 1 divides the corpus into top level units,
of which there might be (very) many. The TF browser has a control that
can deal with long lists.</p>
<p>Level 2 divides a level 1 section into a division that can be loaded into
a webpage, without overwhelming the browser.
Even better, it should be just one or a few screenfuls of text, when
represented in <code>plain</code> view.</p>
<p>Level 3 divides a level 2 section into divisions that roughly corresponds to lines.
Such lines typically take up one screenful if represented in <code>pretty</code> view.</p>
</div>
<div class="admonition explanation">
<p class="admonition-title">Section levels are generic</p>
<p>In this documentation, we call the main section level <code>book</code>, the second level
<code>chapter</code>, and the third level <code>verse</code>. TF, however, is completely
agnostic about how these levels are called. It is prepared to distinguish three
section levels, but how they are called, must be configured in the dataset. The
task of the <code>otext</code> feature is to declare which node type and feature correspond
with which section level. TF assumes that the first section level may
have multilingual headings, but that section levels two and three have single
language headings (numbers of some kind).</p>
</div>
<div class="admonition explanation">
<p class="admonition-title">String versus number</p>
<p>Chapter and verse numbers will be considered to be strings or
integers, depending on whether your dataset has declared the corresponding
feature with <code>valueType</code> as <code>str</code> or as <code>int</code>.</p>
<p>Conceivably, other works might have chapter and verse numbers
like <code>XIV</code>, '3A', '4.5', and in those cases these numbers are obviously not
<code>int</code>.</p>
</div>
<div class="admonition explanation">
<p class="admonition-title">levels of node types</p>
<p>Usually, TF computes the hierarchy of node types correctly, in the
sense that node types that act as containers have a lower level than node types
that act as containees. So books have the lowest level, words the highest. See
<a href="#levels">levels</a>. However, if this level assignment turns out to be wrong for
your dataset, you can configure the right order in the <code>otext</code> feature, by means
of a key <code>levels</code> with value a comma separated list of levels. Example:</p>
<pre><code>@levels=tablet,face,column,line,case,cluster,quad,comment,sign
</code></pre>
<p>If you only want to ensure that a certain type is smaller than other types,
you can add a key <code>levelConstraints</code> with a <code>;</code>-separated list of
constraints, where each constraint has the form</p>
<p><em>smaller</em> <code>&lt;</code> <em>bigger-1</em>, <em>bigger-2</em>, &hellip;</p>
<p>Example:</p>
<pre><code>@levelConstraints=note &lt; chunk, p ; opener &lt; chunk
</code></pre>
</div>
<h2 id="book-names-and-languages">Book names and languages</h2>
<p>The names of the books may be available in multiple languages. The book names
are stored in node features with names of the form <code>book@la</code>, where <code>la</code> is
the <a href="https://en.wikipedia.org/wiki/ISO_639">ISO 639</a> two-letter code for that
language. TF will always load these features.</p>
<h2 id="text-representation">Text representation</h2>
<p>Text can be represented in multiple ways. We provide a number of formats with
structured names.</p>
<p>A format name is a string of keywords separated by <code>-</code>:</p>
<p><em>what</em><code>-</code><em>how</em><code>-</code><em>fullness</em><code>-</code><em>modifier</em></p>
<p>For Hebrew any combination of the following could be useful formats:</p>
<table>
<thead>
<tr>
<th>keyword</th>
<th>value</th>
<th>meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>what</em></td>
<td><code>text</code></td>
<td>words as they belong to the text</td>
</tr>
<tr>
<td><em>what</em></td>
<td><code>lex</code></td>
<td>lexemes of the words</td>
</tr>
<tr>
<td><em>how</em></td>
<td><code>orig</code></td>
<td>in the original script (Hebrew, Greek, Syriac) (all UNICODE)</td>
</tr>
<tr>
<td><em>how</em></td>
<td><code>trans</code></td>
<td>in (latin) transliteration</td>
</tr>
<tr>
<td><em>how</em></td>
<td><code>phono</code></td>
<td>in phonetic / phonological transcription</td>
</tr>
<tr>
<td><em>fullness</em></td>
<td><code>full</code></td>
<td>complete with accents and all diacritical marks</td>
</tr>
<tr>
<td><em>fullness</em></td>
<td><code>plain</code></td>
<td>with accents and diacritical marks stripped, in Hebrew only the consonants are left</td>
</tr>
<tr>
<td><em>modifier</em></td>
<td><code>ketiv</code></td>
<td>(Hebrew): where there is ketiv / qere, follow ketiv instead of qere (default);</td>
</tr>
</tbody>
</table>
<p>The default format is <code>text-orig-full</code>, we assume that every TF dataset defines
this format.</p>
<p>A format is a template string, with fixed text and variable text.
The variable text comes from features.
You specify the interpolation of features by surrounding the feature name
by <code>{ }</code>.</p>
<p>For example, if <code>letters</code> and <code>after</code> are features, this is a text format:</p>
<pre><code>{letters}{after}
</code></pre>
<p>If you need tabs and newlines in a format, specify them by <code>\t</code> and <code>\n</code>.</p>
<p>You can also conditionally choose between features, to
substitute the value of another feature in case of empty values.</p>
<p>For example, if you want to use the <code>normal</code> feature to represent a word,
but if there is also a rare feature <code>special</code> that you want to use if it
is defined for that word, you can make a format</p>
<pre><code>{special/normal}
</code></pre>
<p>This tries the feature <code>special</code> first, and if that is undefined, it takes
<code>normal</code>.</p>
<div class="admonition caution">
<p class="admonition-title">undefined versus empty</p>
<p>The criterion to skip the value of feature <code>special</code> and use the value
of feature <code>normal</code> is that <code>special</code> either has no value, or its value is
<code>None</code> (TF essentially makes no difference between the two).
But if the value of <code>special</code> happens to be the empty string, it will be used!</p>
</div>
<div class="admonition hint">
<p class="admonition-title">longer chains</p>
<p>You can chain multiple features with <code>/</code>, as many as you want:</p>
<pre><code>{veryspecial/special/often/normal}
</code></pre>
</div>
<p>You can also add a fixed default. If you want to display a <code>.</code> if
neither <code>special</code> nor <code>normal</code> exist, you can say</p>
<pre><code>{special/normal:.}
</code></pre>
<p>You can also specify the empty string as the default:</p>
<pre><code>{special/normal:}
</code></pre>
<p>However, you do not need to do that, because the default is the empty string
by default!</p>
<p>TF datasets may also define formats of the form</p>
<p><code>nodeType-default</code></p>
<p>where <code>nodeType</code> is a valid type of node in the dataset.</p>
<p>These formats will be invoked in cases where no explicit format is specified as
a fall back for some kind of nodes. See <code>T.text()</code> below.</p>
<p>A node type may also be prepended to a format, with <code>#</code> as separator:</p>
<p><code>nodeType#textformat</code></p>
<p>In general, a format can be applied to any kind of node, and it will
lookup the features defined in its template for that node.
But some features have meaningful values for particular node types only.</p>
<p>So formats may indicate that they should be applied to nodes of a specific type.
See <code>T.text()</code> below.</p>
<p>Remember that the formats are defined in the <code>otext</code> warp configuration feature of your
set, not by TF.</p>
<div class="admonition note">
<p class="admonition-title">Freedom of names for formats</p>
<p>There is complete freedom of choosing names for text formats.
They do not have to complied with the above-mentioned scheme.</p>
</div>
<div class="admonition note">
<p class="admonition-title">layout in formats</p>
<p>So far, text formats only result in plain text.
A corpus app (<code><a title="tf.advanced.app" href="../advanced/app.html">tf.advanced.app</a></code>) may define and implement extra text
formats which may invoke all HTML+CSS styling that you can think of.</p>
</div>
<h3 id="the-ttext-function">The T.text() function</h3>
<p>The way <code><a title="tf.core.text.Text.text" href="#tf.core.text.Text.text">Text.text()</a></code> responds to its parameters may look complicated,
but the rationale is that the defaults should be sensible.</p>
<p>Consider the simplest call to this function: <code>T.text(node)</code>.
This will apply the default format to <code>node</code>.
If <code>node</code> is non-slot, then in most cases
the default format will be applied to the slots contained in <code>node</code>.</p>
<p>But for special node types, where the best representation
is not obtained by descending down
to the contained slot nodes, the dataset may define
special default types that use other
features to furnish a decent representation.</p>
<div class="admonition explanation">
<p class="admonition-title">lexemes</p>
<p>In some corpora case this happens for the type of lexemes: <code>lex</code>.
Lexemes contain their occurrences
as slots, but the representation of a lexeme
is not the string of its occurrences, but
resides in a feature such as <code>voc_lex_utf8</code>
(vocalized lexeme in UNICODE).</p>
<p>If the dataset defines the format <code>lex-default={lex}</code>,
this is the only thing needed to regulate
the representation of a lexeme.</p>
<p>Hence, <code>T.text(lx)</code> results in the lexeme representation of <code>lx</code>.</p>
<p>But if you really want to print out all occurrences of lexeme <code>lx</code>,
you can say <code>T.text(lx, descend=True)</code>.</p>
</div>
<div class="admonition explanation">
<p class="admonition-title">words and signs</p>
<p>In some corpora the characters or signs are the slot level, and there is
a non slot level of words.
Some text formats are best defined on signs, others best on words.</p>
<p>For example, if words are associated with lexemes, stored in a word
feature <code>lex</code>, we can define a text format</p>
<pre><code>lex-orig-full=word#{lex}
</code></pre>
<p>When you call <code>T.text(n)</code> for a non-slot, non-word node,
normally the node will be replaced by the slot nodes it contains,
before applying the template in the format.
But if you pass a format that specifies a different node type,
nodes will be replaced by contained nodes of that type. So</p>
<pre><code>T.text(n, fmt='lex-orig-full')
</code></pre>
<p>will lookup all word nodes under <code>n</code> and apply the template <code>{lex}</code>
to them.</p>
</div>
<div class="admonition caution">
<p class="admonition-title">same and different behaviours</p>
<p>The consequences of the rules might be unexpected in some cases.
Here are a few observations:</p>
<ul>
<li>formats like <code>phrase-default</code> can be implicitly invoked for phrase nodes,
but <code>descend=True</code> prevents that;</li>
<li>when a format targeted at phrases is invoked for phrase nodes,
<code>descend=True</code> will not cause the expansion of those nodes to slot nodes,
because the phrase node is already expanded
to the target type of the format;</li>
</ul>
</div>
<div class="admonition hint">
<p class="admonition-title">memory aid</p>
<ul>
<li>If <code>fmt</code> is explicitly passed, it will be the format used
no matter what, and it determines the level of the nodes to descend to;</li>
<li>Descending is the norm, it can only be prevented
by setting default formats for node types or
by passing <code>descend=False</code> to <code>T.text()</code>;</li>
<li><code>descend=True</code> is stronger than type-specific default formats,
but weaker than explicitly passed formats;</li>
<li><strong>Pass <code>explain=True</code> for a dynamic explanation.</strong></li>
</ul>
</div>
<div class="admonition note">
<p class="admonition-title">Non slot nodes allowed</p>
<p>In most cases, the nodes fed to <code>T.text()</code> are slots, and the formats are
templates that use features that are defined for slots.</p>
<p>But nothing prevents you to define a format
for non-slot nodes, and use features
defined for a non-slot node type.</p>
<p>If, for example, your slot type is <em>glyph</em>,
and you want a format that renders
lexemes, which are not defined for glyphs but for words,
you can just define a format in terms of word features.</p>
<p>It is your responsibility to take care to use the formats
for node types for which they make sense.</p>
</div>
<div class="admonition caution">
<p class="admonition-title">Escape white-space in formats</p>
<p>When defining formats in <code>otext.tf</code>,
if you need a newline or tab in the format,
specify it as <code>\n</code> and <code>\t</code>.
(i.e. a single backslash plus the character <code>n</code> or <code>t</code>.
In your editor you may have to type the backslash twice in order to put it
in the file once!)</p>
</div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/5ba750f09e755bca220c9fff221c3947f996aa09/tf/core/text.py#L1-L1281" class="git-link">Browse git</a>
</summary>
<pre><code class="python">&#34;&#34;&#34;
# Text API

Here are the functions that enable you to get the actual text in the dataset.
There are several things to accomplish here, such as

*   support the structure of the corpus
*   support a rigid section system usable by the TF browser
*   handle multilingual section labels;
*   switch between various text representations.

The details of the Text API are dependent on the `tf.parameters.WARP` feature `otext`,
which is a configuration feature.

!!! hint &#34;T&#34;
    The Text API is exposed as `T` or `Text`.

!!! note &#34;`otext` is optional&#34;
    If your dataset does not have an `otext` feature,
    the Text API will not be build.
    If it exists, but does not specify structure or sections,
    those parts of the Text API will not be built.
    Likewise for text representations.

## Structure

If a corpus has sectional elements, such as
`series`, `volume`, `book`, `part`, `document`, `chapter`, `fragment`, `verse`,
`halfverse`, `line`, etc, then you can configure those elements as structural types.

If your TF dataset designer has done that, the `T.api` will provide a number
of handy functions to navigate your corpus along its structure, programmatically.

The
[banks](https://nbviewer.jupyter.org/github/annotation/banks/blob/master/programs/structure.ipynb)
example corpus shows a full example.

Structure is defined in the `otext` feature, by means of the keys
`structureTypes` and `structureFeatures`.
These are comma-separated lists of equal length.

`structureTypes` specifies the node types
that act as structural types, in the order from biggest to smallest.

`structureFeatures` specifies a feature that corresponds to each
structural type. This feature must contain the label of the structural
element, e.g. the title of a book, the number of a verse, etc.

The order of the section types is significant.
Suppose you have a book with a single chapter. Is the chapter part of the book,
or is the book part of the chapter?
The order decides. If `book` is mentioned in `structureTypes` before `chapter`
then the chapter is part of the book, and not the other way around.

However, it is allowed to have nesting of elements of the same kind.

!!! explanation &#34;Proper embedding not required&#34;
    There are no assumptions on how exactly the structural elements lie
    embedded in each other, and whether they consist of uninterrupted stretches
    of material or not.

    Suppose a we have a book with two disjoint chapters and there is a verse that
    has material in both chapters. Then that verse is part of neither chapter,
    but it is still part of the book.
    If you go down from that book to its substructural elements, you find not only
    its chapters, but also that verse.

    So the great freedom with respect to structural elements also brings greater
    responsibility when using that structure.

## Sections

In `otext` the main section levels (usually `book`, `chapter`, `verse`) can be
defined. It loads the features it needs (so you do not have to specify those
features, unless you want to use them via `F`). And finally, it makes some
functions available by which you can make handy use of that information.

!!! explanation &#34;Section levels from a limited, rigid system&#34;
    There are up to three section levels, and this is a hard coded boundary.
    That makes this section system unsuitable to faithfully reflect the
    rich sectioning that may be present in a corpus.

    On the other hand, applications (such as TF apps) can access a predictable
    sectioning system by which they can divide the material in practical portions.

    The rule of thumb is:

    Level 1 divides the corpus into top level units,
    of which there might be (very) many. The TF browser has a control that
    can deal with long lists.

    Level 2 divides a level 1 section into a division that can be loaded into
    a webpage, without overwhelming the browser.
    Even better, it should be just one or a few screenfuls of text, when
    represented in `plain` view.

    Level 3 divides a level 2 section into divisions that roughly corresponds to lines.
    Such lines typically take up one screenful if represented in `pretty` view.

!!! explanation &#34;Section levels are generic&#34;
    In this documentation, we call the main section level `book`, the second level
    `chapter`, and the third level `verse`. TF, however, is completely
    agnostic about how these levels are called. It is prepared to distinguish three
    section levels, but how they are called, must be configured in the dataset. The
    task of the `otext` feature is to declare which node type and feature correspond
    with which section level. TF assumes that the first section level may
    have multilingual headings, but that section levels two and three have single
    language headings (numbers of some kind).

!!! explanation &#34;String versus number&#34;
    Chapter and verse numbers will be considered to be strings or
    integers, depending on whether your dataset has declared the corresponding
    feature with `valueType` as `str` or as `int`.

    Conceivably, other works might have chapter and verse numbers
    like `XIV`, &#39;3A&#39;, &#39;4.5&#39;, and in those cases these numbers are obviously not
    `int`.

!!! explanation &#34;levels of node types&#34;
    Usually, TF computes the hierarchy of node types correctly, in the
    sense that node types that act as containers have a lower level than node types
    that act as containees. So books have the lowest level, words the highest. See
    [levels](#levels). However, if this level assignment turns out to be wrong for
    your dataset, you can configure the right order in the `otext` feature, by means
    of a key `levels` with value a comma separated list of levels. Example:

        @levels=tablet,face,column,line,case,cluster,quad,comment,sign

    If you only want to ensure that a certain type is smaller than other types,
    you can add a key `levelConstraints` with a `;`-separated list of
    constraints, where each constraint has the form

    *smaller* `&lt;` *bigger-1*, *bigger-2*, ...

    Example:

        @levelConstraints=note &lt; chunk, p ; opener &lt; chunk

## Book names and languages

The names of the books may be available in multiple languages. The book names
are stored in node features with names of the form `book@la`, where `la` is
the [ISO 639](https://en.wikipedia.org/wiki/ISO_639) two-letter code for that
language. TF will always load these features.

## Text representation

Text can be represented in multiple ways. We provide a number of formats with
structured names.

A format name is a string of keywords separated by `-`:

*what*`-`*how*`-`*fullness*`-`*modifier*

For Hebrew any combination of the following could be useful formats:

keyword | value | meaning
------- | ----- | -------
*what* | `text` | words as they belong to the text
*what* | `lex` | lexemes of the words
*how* | `orig` | in the original script (Hebrew, Greek, Syriac) (all UNICODE)
*how* | `trans` | in (latin) transliteration
*how* | `phono` | in phonetic / phonological transcription
*fullness* | `full` | complete with accents and all diacritical marks
*fullness* | `plain` | with accents and diacritical marks stripped, in Hebrew only the consonants are left
*modifier* | `ketiv` | (Hebrew): where there is ketiv / qere, follow ketiv instead of qere (default);

The default format is `text-orig-full`, we assume that every TF dataset defines
this format.

A format is a template string, with fixed text and variable text.
The variable text comes from features.
You specify the interpolation of features by surrounding the feature name
by `{ }`.

For example, if `letters` and `after` are features, this is a text format:

```
{letters}{after}
```

If you need tabs and newlines in a format, specify them by `\\t` and `\\n`.

You can also conditionally choose between features, to
substitute the value of another feature in case of empty values.

For example, if you want to use the `normal` feature to represent a word,
but if there is also a rare feature `special` that you want to use if it
is defined for that word, you can make a format

```
{special/normal}
```

This tries the feature `special` first, and if that is undefined, it takes
`normal`.

!!! caution &#34;undefined versus empty&#34;
    The criterion to skip the value of feature `special` and use the value
    of feature `normal` is that `special` either has no value, or its value is
    `None` (TF essentially makes no difference between the two).
    But if the value of `special` happens to be the empty string, it will be used!

!!! hint &#34;longer chains&#34;
    You can chain multiple features with `/`, as many as you want:

        {veryspecial/special/often/normal}

You can also add a fixed default. If you want to display a `.` if
neither `special` nor `normal` exist, you can say

```
{special/normal:.}
```

You can also specify the empty string as the default:

```
{special/normal:}
```

However, you do not need to do that, because the default is the empty string
by default!

TF datasets may also define formats of the form

`nodeType-default`

where `nodeType` is a valid type of node in the dataset.

These formats will be invoked in cases where no explicit format is specified as
a fall back for some kind of nodes. See `T.text()` below.

A node type may also be prepended to a format, with `#` as separator:

`nodeType#textformat`

In general, a format can be applied to any kind of node, and it will
lookup the features defined in its template for that node.
But some features have meaningful values for particular node types only.

So formats may indicate that they should be applied to nodes of a specific type.
See `T.text()` below.

Remember that the formats are defined in the `otext` warp configuration feature of your
set, not by TF.

!!! note &#34;Freedom of names for formats&#34;
    There is complete freedom of choosing names for text formats.
    They do not have to complied with the above-mentioned scheme.

!!! note &#34;layout in formats&#34;
    So far, text formats only result in plain text.
    A corpus app (`tf.advanced.app`) may define and implement extra text
    formats which may invoke all HTML+CSS styling that you can think of.

### The T.text() function

The way `tf.core.text.Text.text` responds to its parameters may look complicated,
but the rationale is that the defaults should be sensible.

Consider the simplest call to this function: `T.text(node)`.
This will apply the default format to `node`.
If `node` is non-slot, then in most cases
the default format will be applied to the slots contained in `node`.

But for special node types, where the best representation
is not obtained by descending down
to the contained slot nodes, the dataset may define
special default types that use other
features to furnish a decent representation.

!!! explanation &#34;lexemes&#34;
    In some corpora case this happens for the type of lexemes: `lex`.
    Lexemes contain their occurrences
    as slots, but the representation of a lexeme
    is not the string of its occurrences, but
    resides in a feature such as `voc_lex_utf8`
    (vocalized lexeme in UNICODE).

    If the dataset defines the format `lex-default={lex} `,
    this is the only thing needed to regulate
    the representation of a lexeme.

    Hence, `T.text(lx)` results in the lexeme representation of `lx`.

    But if you really want to print out all occurrences of lexeme `lx`,
    you can say `T.text(lx, descend=True)`.

!!! explanation &#34;words and signs&#34;
    In some corpora the characters or signs are the slot level, and there is
    a non slot level of words.
    Some text formats are best defined on signs, others best on words.

    For example, if words are associated with lexemes, stored in a word
    feature `lex`, we can define a text format

        lex-orig-full=word#{lex}

    When you call `T.text(n)` for a non-slot, non-word node,
    normally the node will be replaced by the slot nodes it contains,
    before applying the template in the format.
    But if you pass a format that specifies a different node type,
    nodes will be replaced by contained nodes of that type. So

        T.text(n, fmt=&#39;lex-orig-full&#39;)

    will lookup all word nodes under `n` and apply the template `{lex}`
    to them.

!!! caution &#34;same and different behaviours&#34;
    The consequences of the rules might be unexpected in some cases.
    Here are a few observations:

    *   formats like `phrase-default` can be implicitly invoked for phrase nodes,
        but `descend=True` prevents that;
    *   when a format targeted at phrases is invoked for phrase nodes,
        `descend=True` will not cause the expansion of those nodes to slot nodes,
        because the phrase node is already expanded
        to the target type of the format;


!!! hint &#34;memory aid&#34;
    *   If `fmt` is explicitly passed, it will be the format used
        no matter what, and it determines the level of the nodes to descend to;
    *   Descending is the norm, it can only be prevented
        by setting default formats for node types or
        by passing `descend=False` to `T.text()`;
    *   `descend=True` is stronger than type-specific default formats,
        but weaker than explicitly passed formats;
    *   **Pass `explain=True` for a dynamic explanation.**

!!! note &#34;Non slot nodes allowed&#34;
    In most cases, the nodes fed to `T.text()` are slots, and the formats are
    templates that use features that are defined for slots.

    But nothing prevents you to define a format
    for non-slot nodes, and use features
    defined for a non-slot node type.

    If, for example, your slot type is *glyph*,
    and you want a format that renders
    lexemes, which are not defined for glyphs but for words,
    you can just define a format in terms of word features.

    It is your responsibility to take care to use the formats
    for node types for which they make sense.

!!! caution &#34;Escape white-space in formats&#34;
    When defining formats in `otext.tf`,
    if you need a newline or tab in the format,
    specify it as `\\n` and `\\t`.
    (i.e. a single backslash plus the character `n` or `t`.
    In your editor you may have to type the backslash twice in order to put it
    in the file once!)
&#34;&#34;&#34;

from ..parameters import OTEXT

DEFAULT_FORMAT = &#34;text-orig-full&#34;
DEFAULT_FORMAT_TYPE = &#34;{}-default&#34;
SEP = &#34;-&#34;
TYPE_FMT_SEP = &#34;#&#34;


class Text:
    &#34;&#34;&#34;Low level text representation, including section headings.

    In addition to the methods that are directly defined, there are also
    methods `xxxName()` and `xxxNode()` where `xxx` is whatever the node type of
    level 1 sections is.

    !!! note &#34;level 1 node types&#34;
        In the BHSA the `xxx` is `book`, in the DSS it is `scroll`,
        in Old Babylonian it is `document`, and in Uruk it is `tablet`.

        Here we take the BHSA as example: `bookName()` and `bookNode()`

            T.bookName(node, lang=&#39;en&#39;)
            T.bookNode(name, lang=&#39;en&#39;)

        with `node:int` the node in question, `name:str` the name in question,
        and `lang=&#39;en&#39;` the language of the book name.
    &#34;&#34;&#34;

    def __init__(self, api):
        self.api = api
        C = api.C
        Fs = api.Fs
        TF = api.TF
        self.languages = {}
        &#34;&#34;&#34;A dictionary of the languages that are available for book names.
        &#34;&#34;&#34;

        self.nameFromNode = {}
        self.nodeFromName = {}
        config = api.TF.features[OTEXT].metaData if OTEXT in api.TF.features else {}
        self.sectionTypes = TF.sectionTypes
        self.sectionTypeSet = set(TF.sectionTypes)
        self.sectionFeats = TF.sectionFeats
        self.sectionFeatsWithLanguage = getattr(TF, &#34;sectionFeatsWithLanguage&#34;, set())
        self.sectionFeatures = []
        self.sectionFeatureTypes = []
        self.structureTypes = TF.structureTypes
        self.structureFeats = TF.structureFeats
        self.structureTypeSet = set(self.structureTypes)
        self.config = config
        self.defaultFormat = DEFAULT_FORMAT
        self.defaultFormats = {}

        structure = getattr(C, &#34;structure&#34;, None)

        (
            self.hdFromNd,
            self.ndFromHd,
            self.hdMult,
            self.hdTop,
            self.hdUp,
            self.hdDown,
        ) = (
            structure.data if structure else (None, None, None, None, None, None)
        )
        self.headings = (
            ()
            if structure is None
            else tuple(zip(self.structureTypes, self.structureFeats))
        )
        otypeInfo = api.F.otype
        fOtype = otypeInfo.v

        good = True
        if len(self.sectionFeats) != 0 and len(self.sectionTypes) != 0:
            for fName in self.sectionFeatsWithLanguage:
                fObj = api.TF.features[fName]
                meta = fObj.metaData
                code = meta.get(&#34;languageCode&#34;, &#34;&#34;)
                self.languages[code] = {
                    k: meta.get(k, &#34;default&#34;) for k in (&#34;language&#34;, &#34;languageEnglish&#34;)
                }
                cData = Fs(fName).data
                self.nameFromNode[code] = cData
                self.nodeFromName[code] = dict(
                    ((fOtype(node), name), node) for (node, name) in cData.items()
                )
            for fName in self.sectionFeats:
                dataType = api.TF.features[fName].dataType
                self.sectionFeatures.append(api.Fs(fName).data)
                self.sectionFeatureTypes.append(dataType)

            sec0 = self.sectionTypes[0]
            setattr(self, f&#34;{sec0}Name&#34;, self._sec0Name)
            setattr(self, f&#34;{sec0}Node&#34;, self._sec0Node)

        self.formats = {}
        &#34;&#34;&#34;The text representation formats that have been defined in your dataset.
        &#34;&#34;&#34;

        self._compileFormats()
        self.good = good

    def sectionTuple(self, n, lastSlot=False, fillup=False):
        &#34;&#34;&#34;Gives a tuple of nodes that correspond to a section.

        More precisely, we retrieve the sections that contain a
        reference node, which is either the first slot or the last slot of the node
        in question.

        Parameters
        ----------
        n: integer
            The node whose containing section to retrieve.
        lastSlot: boolean, optional False
            Whether the reference node will be the last slot contained by `n`
            or the first slot.
        fillup: boolean, optional False
            Whether to fill up the tuple with missing section elements.
        Returns
        -------
        section: tuple of integer
            If `n` is not a section node, a reference node `r` will be taken
            according to the `lastSlot` parameter.

            If `fillup == False`:

            If `r` is a level 0 section node,
            `section` is the 1-element tuple `(r,)`.

            If `r` is a level 1 section node,
            *section* is a 2-element tuple, i.e.
            the enclosing level 0 section node and `r` itself.

            If `r` is a level 2 section node,
            `section` is a 3-element tuple, i.e.
            the enclosing level 0 and  1 section nodes and `r` itself.

            If `fillup == True`, always a complete 3-tuple of a level 0, 1, and 2
            section nodes is returned.
        &#34;&#34;&#34;

        sTypes = self.sectionTypes
        lsTypes = len(sTypes)
        if lsTypes == 0:
            return ()
        F = self.api.F
        E = self.api.E
        L = self.api.L
        fOtype = F.otype.v
        slotType = F.otype.slotType
        maxSlot = F.otype.maxSlot
        eoslots = E.oslots.data
        nType = fOtype(n)

        if nType == slotType:
            r = n
        else:
            slots = eoslots[n - maxSlot - 1]
            r = slots[-1 if lastSlot else 0]

        if nType == sTypes[0]:
            if fillup:
                r1 = L.u(r, otype=sTypes[1])
                r1 = r1[0] if r1 else &#34;&#34;
                if lsTypes &gt; 2:
                    r2 = L.u(r, otype=sTypes[2])
                    r2 = r2[0] if r2 else &#34;&#34;
                    return (n, r1, r2)
                return (n, r1)
            return (n,)

        r0s = L.u(r, sTypes[0])
        r0 = r0s[0] if r0s else None

        if nType == sTypes[1]:
            if fillup:
                if lsTypes &gt; 2:
                    r2 = L.u(r, otype=sTypes[2])
                    r2 = r2[0] if r2 else &#34;&#34;
                    return (r0, n, r2)
            return (r0, n)

        r1s = L.u(r, sTypes[1])
        r1 = r1s[0] if r1s else &#34;&#34;

        if lsTypes &lt; 3:
            return (r0, r1)

        if nType == sTypes[2]:
            return (r0, r1, n)

        r2s = L.u(r, sTypes[2])
        r2 = r2s[0] if r2s else &#34;&#34;

        return (r0, r1, r2)

    def sectionFromNode(self, n, lastSlot=False, lang=&#34;en&#34;, fillup=False, level=None):
        &#34;&#34;&#34;Gives the full heading of a section node.

        Parameters
        ----------
        n: integer
            The node whose heading to retrieve.
        lastSlot: boolean, optional False
            Whether the reference node will be the last slot contained by `n`
            or the first slot.
        lang: string, optional en
            The language assumed for the section parts,
            as far as they are language dependent.
            Must be a 2-letter language code.
        fillup: boolean, optional False
            Whether to fill up the tuple with missing section elements.
        level: integer, optional None
            If passed, only the first so many members of the tuple will be returned.

        Returns
        -------
        heading: tuple of pairs
            If `n` is not a section node, a reference node `r` will be taken
            according to the `lastSlot` parameter.

            It is the tuple of integer / string values for section ancestors
            of `r` and `r` itself,
            where the `fillup` parameter plays the same role as in
            `Text.sectionTuple`.

        Notes
        -----
        !!! hint &#34;crossing verse boundaries&#34;
            Sometimes a sentence or clause in a verse continue into the next verse.
            In those cases, this function will return different results for
            `lastSlot=False` and `lastSlot=True`.

        Warnings
        --------
        Nodes that lie outside any book, chapter, or verse
        will get a `None` in the corresponding members of the returned tuple.
        &#34;&#34;&#34;
        sTuple = self.sectionTuple(n, lastSlot=lastSlot, fillup=fillup)
        if len(sTuple) == 0:
            return ()

        sFs = self.sectionFeatures

        result = tuple(
            &#34;&#34;
            if n is None
            else self._sec0Name(n, lang=lang)
            if i == 0
            else sFs[i].get(n, None)
            for (i, n) in enumerate(sTuple)
        )
        if level is not None:
            result = result[0:level]

        return result

    def nodeFromSection(self, section, lang=&#34;en&#34;):
        &#34;&#34;&#34;Given a section tuple, return the node of it.

        Parameters
        ----------
        section: string
            `section` consists of a book name (in language `lang`),
            and a chapter number and a verse number
            (both as strings or number depending on the value type of the
            corresponding feature).
        lang: string, optional en
            The language assumed for the section parts,
            as far as they are language dependent.
            Must be a 2-letter language code.

        Returns
        -------
        section node: integer
            If section labels for all three levels is present,
            the result is a level 3 node.
            If the level 3 label has been left out, the result is a level 2 node.
            If both level 1 and level 2 labels have been left out,
            the result is a level 1 node.
        &#34;&#34;&#34;

        sTypes = self.sectionTypes
        if len(sTypes) == 0:
            return None
        cData = self.api.C.sections.data
        sec1 = cData[&#34;sec1&#34;]
        sec2 = cData[&#34;sec2&#34;]
        sec0node = self._sec0Node(section[0], lang=lang)
        if len(section) == 1:
            return sec0node
        elif len(section) == 2:
            return sec1.get(sec0node, {}).get(section[1], None)
        else:
            return sec2.get(sec0node, {}).get(section[1], {}).get(section[2], None)

    def structureInfo(self):
        &#34;&#34;&#34;Gives a summary of how structure has been configured in the dataset.

        If there are headings that are the same for multiple structural nodes,
        you&#39;ll get a warning here, and you are told how you can get all of those.

        It also shows a short description of all structure-related methods
        of the `T` API.
        &#34;&#34;&#34;

        api = self.api
        TF = api.TF
        info = TF.info
        error = TF.error
        hdMult = self.hdMult
        hdFromNd = self.hdFromNd
        headings = self.headings

        if hdFromNd is None:
            info(&#34;No structural elements configured&#34;, tm=False)
            return
        info(&#34;A heading is a tuple of pairs (node type, feature value)&#34;, tm=False)
        info(
            &#34;\tof node types and features that have been configured as structural elements&#34;,
            tm=False,
        )
        info(
            f&#34;These {len(headings)} structural elements have been configured&#34;, tm=False
        )
        for (tp, ft) in headings:
            info(f&#34;\tnode type {tp:&lt;10} with heading feature {ft}&#34;, tm=False)
        info(&#34;You can get them as a tuple with T.headings.&#34;, tm=False)
        info(
            f&#34;&#34;&#34;
Structure API:
\tT.structure(node=None)       gives the structure below node, or everything if node is None
\tT.structurePretty(node=None) prints the structure below node, or everything if node is None
\tT.top()                      gives all top-level nodes
\tT.up(node)                   gives the (immediate) parent node
\tT.down(node)                 gives the (immediate) children nodes
\tT.headingFromNode(node)      gives the heading of a node
\tT.nodeFromHeading(heading)   gives the node of a heading
\tT.ndFromHd                   complete mapping from headings to nodes
\tT.hdFromNd                   complete mapping from nodes to headings
\tT.hdMult are all headings    with their nodes that occur multiple times

There are {len(hdFromNd)} structural elements in the dataset.
&#34;&#34;&#34;,
            tm=False,
        )

        if hdMult:
            nMultiple = len(hdMult)
            tMultiple = sum(len(x) for x in hdMult.values())
            error(
                f&#34;WARNING: {nMultiple} structure headings with hdMult occurrences (total {tMultiple})&#34;,
                tm=False,
            )
            for (sKey, nodes) in sorted(hdMult.items())[0:10]:
                sKeyRep = &#34;-&#34;.join(&#34;:&#34;.join(str(p) for p in part) for part in sKey)
                nNodes = len(nodes)
                error(f&#34;\t{sKeyRep} has {nNodes} occurrences&#34;, tm=False)
                error(f&#39;\t\t{&#34;, &#34;.join(str(n) for n in nodes[0:5])}&#39;, tm=False)
                if nNodes &gt; 5:
                    error(f&#34;\t\tand {nNodes - 5} more&#34;, tm=False)
            if nMultiple &gt; 10:
                error(f&#34;\tand {nMultiple - 10} headings more&#34;)

    def structure(self, node=None):
        &#34;&#34;&#34;Gives the structure of node and everything below it as a tuple.

        Parameters
        ----------
        node: integer, optional None
            The node whose structure is asked for.
            If *node* is None, the complete structure of the whole dataset is returned.

        Returns
        -------
        structure: tuple
            Nested tuple of nodes involved in the structure below a node.
        &#34;&#34;&#34;

        api = self.api
        TF = api.TF
        error = TF.error
        F = api.F
        fOtype = F.otype.v
        hdTop = self.hdTop

        if hdTop is None:
            error(&#34;structure types are not configured&#34;, tm=False)
            return None
        if node is None:
            return tuple(self.structure(node=t) for t in self.top())

        nType = fOtype(node)
        if nType not in self.structureTypeSet:
            error(
                f&#34;{node} is an {nType} which is not configured as a structure type&#34;,
                tm=False,
            )
            return None

        return (node, tuple(self.structure(node=d) for d in self.down(node)))

    def structurePretty(self, node=None, fullHeading=False):
        &#34;&#34;&#34;Gives the structure of node and everything below it as a string.

        Parameters
        ----------
        node: integer, optional None
            The node whose structure is asked for.
            If *node* is None, the complete structure of the whole dataset is returned.
        fullHeading: boolean, optional False
            Normally, for each structural element, only its own subheading is added.
            But if you want to see the full heading, consisting of the headings of a
            node and all of its parents, pass `True` for this parameter.

        Returns
        -------
        structure: string
            Pretty representation as string with indentations of the structure
            below a node.
        &#34;&#34;&#34;

        structure = self.structure(node=node)
        if structure is None:
            return

        material = []

        def generate(struct, indent=&#34;&#34;):
            if type(struct) is int:
                sKey = self.headingFromNode(struct)
                if not fullHeading:
                    sKey = (sKey[-1],)
                sKeyRep = &#34;-&#34;.join(&#34;:&#34;.join(str(p) for p in part) for part in sKey)
                material.append(f&#34;{indent}{sKeyRep}&#34;)
            else:
                for item in struct:
                    generate(item, indent=indent + &#34;  &#34;)

        generate(structure)
        return &#34;\n&#34;.join(material)

    def top(self):
        &#34;&#34;&#34;Gives all top-level structural nodes in the dataset.
        These are the nodes that are not embedded in a structural node of the same
        or a higher level.
        &#34;&#34;&#34;

        api = self.api
        TF = api.TF
        error = TF.error
        hdTop = self.hdTop

        if hdTop is None:
            error(&#34;structure types are not configured&#34;, tm=False)
            return None
        return hdTop

    def up(self, n):
        &#34;&#34;&#34;Gives the parent of a structural node.

        Parameters
        ----------
        n: integer
            The node whose parent to retrieve.

        Returns
        -------
        parent: integer
            The parent is that structural node that whose heading you get from
            the heading of `n` minus its last element.

        Notes
        -----
        !!!hint &#34;Example&#34;
            The parent of `((book, Genesis), (chapter, 3), (verse, 16))`
            is the node that has heading `((book, Genesis), (chapter, 3))`.
        &#34;&#34;&#34;

        api = self.api
        F = api.F
        TF = api.TF
        error = TF.error
        fOtype = F.otype.v

        hdUp = self.hdUp
        if hdUp is None:
            error(&#34;structure types are not configured&#34;, tm=False)
            return None
        nType = fOtype(n)
        if nType not in self.structureTypeSet:
            error(
                f&#34;{n} is an {nType} which is not configured as a structure type&#34;,
                tm=False,
            )
            return None
        return hdUp.get(n, None)

    def down(self, n):
        &#34;&#34;&#34;Gives the children of a structural node.

        Parameters
        ----------
        n: integer
            The node whose children to retrieve.

        Returns
        -------
        children: tuple of integers
            The children are those structural nodes whose headings are one
            longer than the one from `n`.

        Notes
        -----
        !!!hint &#34;Example&#34;
            The children of `((book, Genesis), (chapter, 3))` are the nodes
            with heading `((book, Genesis), (chapter, 3), (verse, 1))`, etc.
        &#34;&#34;&#34;

        api = self.api
        F = api.F
        fOtype = F.otype.v
        TF = api.TF
        error = TF.error
        hdDown = self.hdDown
        if hdDown is None:
            error(&#34;structure types are not configured&#34;, tm=False)
            return None
        nType = fOtype(n)
        if nType not in self.structureTypeSet:
            error(
                f&#34;{n} is an {nType} which is not configured as a structure type&#34;,
                tm=False,
            )
            return None
        return hdDown.get(n, ())

    def headingFromNode(self, n):
        &#34;&#34;&#34;Gives the full heading of a structural node.

        Parameters
        ----------
        n: integer
            The node whose heading to retrieve.

        Returns
        -------
        heading: tuple of pairs
            It is the tuple of pairs (node type, feature value)
            for all ancestors of `n`.

        Notes
        -----
        !!!hint &#34;Example&#34;
            E.g., the heading of the verse node corresponding to Genesis 3:16
            is `((book, Genesis), (chapter, 3), (verse, 16))`.

        !!!hint &#34;Power tip&#34;
            If you are interested in the complete mapping: it is stored in
            the dictionary `hdFromNd`.
        &#34;&#34;&#34;

        api = self.api
        F = api.F
        TF = api.TF
        error = TF.error
        fOtype = F.otype.v
        hdFromNd = self.hdFromNd
        if hdFromNd is None:
            error(&#34;structure types are not configured&#34;, tm=False)
            return None
        nType = fOtype(n)
        if nType not in self.structureTypeSet:
            error(
                f&#34;{n} is an {nType} which is not configured as a structure type&#34;,
                tm=False,
            )
            return None
        return hdFromNd.get(n, None)

    def nodeFromHeading(self, head):
        &#34;&#34;&#34;Gives the node corresponding to a heading, provided it exists.

        Parameters
        ----------
        head: tuple of pairs
            See the result of `headingFromNode`.

        Returns
        -------
        node: integer
            If there is more than one node that corresponds to the heading,
            only the last one in the corpus will be returned.
            `hdMult` contains all such cases.

        Notes
        -----
        !!!hint &#34;Power tip&#34;
            If you are interested in the complete mapping: it is stored in
            the dictionary `ndFromHd`.
        &#34;&#34;&#34;

        api = self.api
        TF = api.TF
        error = TF.error
        ndFromHd = self.ndFromHd
        if ndFromHd is None:
            error(&#34;structure types are not configured&#34;, tm=False)
        n = ndFromHd.get(head, None)
        if n is None:
            error(f&#34;no structure node with heading {head}&#34;, tm=False)
        return n

    def text(self, nodes, fmt=None, descend=None, func=None, explain=False, **kwargs):
        &#34;&#34;&#34;Gives the text that corresponds to a bunch of nodes.

        The
        [banks](https://nbviewer.jupyter.org/github/annotation/banks/blob/master/programs/formats.ipynb)
        example corpus shows examples.

        Parameters
        ----------

        nodes: dict
            *nodes* can be a single node or an arbitrary iterable of nodes
            of arbitrary types.
            No attempt will be made to sort the nodes.
            If you need order, it is better to sort the nodes first.

        fmt: boolean, optional None
            The text-format of the text representation.

            If it is not specified or `None`, each node will be formatted with
            a node type specific format, defined as `nodeType-default`, if it
            exists.

            If there is no node specific format, the default format
            `text-orig-full` will be used.

            If `text-orig-full` is not defined, an error message will be issued,
            and the nodes will be represented by their types and numbers.

            If a value for `fmt` is passed, but it is not a format defined in the
            `otext.tf` feature, there will be an error message and `None` is returned.

        descend: boolean, optional None
            Whether to descend to constituent nodes.

            If `True`, nodes will be replaced by a sequence of their constituent nodes,
            which have a type specified by the format chosen, or, if the format does
            not specify such a type, the node will be replaced
            by the slots contained in it.

            If `False`, nodes will not be replaced.

            If *descend* is not specified or None,
            a node will be replaced by its constituent nodes,
            unless its type is associated with the given format or,
            if no format is given, by the default format of its type, or,
            if there is no such format, by its slots.

            !!! caution &#34;no nodes to descend to&#34;
                If you call `T.text(n, fmt=myfmt)`
                and `myfmt` is targeted to a node type that is
                bigger than the node type of `n`,
                then the so-called descending leads to an empty
                sequence of nodes and hence to an empty string.

        explain: boolean, optional False
            The logic of this function is subtle.
            If you call it and the results baffles you, pass `explain=True`
            and it will explain what it is doing.
        &#34;&#34;&#34;

        api = self.api
        E = api.E
        F = api.F
        L = api.L
        TF = api.TF
        error = TF.error

        fOtype = F.otype.v
        slotType = F.otype.slotType
        maxSlot = F.otype.maxSlot
        eoslots = E.oslots.data

        defaultFormats = self.defaultFormats
        xformats = self._xformats
        xdTypes = self._xdTypes

        if fmt and fmt not in xformats:
            error(f&#39;Undefined format &#34;{fmt}&#34;&#39;, tm=False)
            return &#34;&#34;

        def rescue(n, **kwargs):
            return f&#34;{fOtype(n)}{n}&#34;

        single = type(nodes) is int
        material = []
        good = True

        if single:
            nodes = [nodes]
        else:
            nodes = list(nodes) if explain else nodes
        if explain:
            fmttStr = &#34;format target type&#34;
            ntStr = &#34;node type&#34;

            nRep = &#34;single node&#34; if single else f&#34;iterable of {len(nodes)} nodes&#34;
            fmtRep = &#34;implicit&#34; if not fmt else f&#34;{fmt} targeted at {xdTypes[fmt]}&#34;
            descendRep = (
                &#34;implicit&#34; if descend is None else &#34;True&#34; if descend else &#34;False&#34;
            )
            funcRep = f&#39;{&#34;&#34; if func else &#34;no &#34;}custom format implementation&#39;
            error(
                f&#34;&#34;&#34;
EXPLANATION: T.text() called with parameters:
\tnodes  : {nRep}
\tfmt    : {fmtRep}
\tdescend: {descendRep}
\tfunc   : {funcRep}
&#34;&#34;&#34;,
                tm=False,
            )

        for node in nodes:
            nType = fOtype(node)
            if explain:
                error(f&#34;\tNODE: {nType} {node}&#34;, tm=False)
            if descend:
                if explain:
                    downRep = fmttStr
                if fmt:
                    repf = xformats[fmt]
                    downType = xdTypes[fmt]
                    if explain:
                        fmtRep = f&#34;explicit {fmt} does {repf}&#34;
                        expandRep = f&#34;{downType} {{}} (descend=True) ({downRep})&#34;
                else:
                    repf = xformats[DEFAULT_FORMAT]
                    downType = xdTypes[DEFAULT_FORMAT]
                    if explain:
                        fmtRep = f&#34;implicit {DEFAULT_FORMAT} does {repf}&#34;
                        expandRep = f&#34;{downType} {{}} (descend=True) ({downRep})&#34;
            else:
                downType = nType
                if explain:
                    downRep = ntStr
                if fmt:
                    repf = xformats[fmt]
                    if descend is None:
                        downType = xdTypes[fmt]
                        if explain:
                            downRep = fmttStr
                    if explain:
                        fmtRep = f&#34;explicit {fmt} does {repf}&#34;
                        expandRep = f&#34;{downType} {{}} (descend=None) ({downRep})&#34;
                elif nType in defaultFormats:
                    dfmt = defaultFormats[nType]
                    repf = xformats[dfmt]
                    if descend is None:
                        downType = nType
                        if explain:
                            downRep = fmttStr
                    if explain:
                        fmtRep = f&#34;implicit {dfmt} does {repf}&#34;
                        expandRep = f&#34;{downType} {{}} (descend=None) ({downRep})&#34;
                else:
                    repf = xformats[DEFAULT_FORMAT]
                    if descend is None:
                        downType = xdTypes[DEFAULT_FORMAT]
                        if explain:
                            downRep = fmttStr
                    if explain:
                        fmtRep = f&#34;implicit {DEFAULT_FORMAT} does {repf}&#34;
                        expandRep = f&#34;{downType} {{}} (descend=None) ({downRep})&#34;

            if explain:
                expandRep2 = &#34;&#34;
            if downType == nType:
                if explain:
                    expandRep2 = &#34;(no expansion needed)&#34;
                downType = None

            if explain:
                error(f&#34;\t\tTARGET LEVEL: {expandRep.format(expandRep2)}&#34;, tm=False)

            if explain:
                plural = &#34;s&#34;
            if downType == slotType:
                xnodes = eoslots[node - maxSlot - 1]
            elif downType:
                xnodes = L.d(node, otype=downType)
            else:
                xnodes = [node]
                if explain:
                    plural = &#34;&#34;
            if explain:
                nodeRep = f&#39;{len(xnodes)} {downType or nType}{plural} {&#34;, &#34;.join(str(x) for x in xnodes)}&#39;
                error(f&#34;\t\tEXPANSION: {nodeRep}&#34;, tm=False)

            if func:
                repf = func
                if explain:
                    fmtRep += f&#34; (overridden with the explicit func argument {repf})&#34;
            if not repf:
                repf = rescue
                good = False
                if explain:
                    fmtRep += &#34;\n\t\t\twhich is not defined: formatting as node types and numbers&#34;

            if explain:
                error(f&#34;\t\tFORMATTING: {fmtRep}&#34;, tm=False)
                error(&#34;\t\tMATERIAL:&#34;, tm=False)
            for n in xnodes:
                rep = repf(n, **kwargs)
                material.append(rep)
                if explain:
                    error(f&#39;\t\t\t{fOtype(n)} {n} ADDS &#34;{rep}&#34;&#39;, tm=False)

        if not good:
            error(&#39;Text format &#34;{DEFAULT_FORMAT}&#34; not defined in otext.tf&#39;, tm=False)
        return &#34;&#34;.join(material)

    def _sec0Name(self, n, lang=&#34;en&#34;):
        sec0T = self.sectionTypes[0]
        fOtype = self.api.F.otype.v
        refNode = n if fOtype(n) == sec0T else self.api.L.u(n, sec0T)[0]
        lookup = self.nameFromNode[&#34;&#34; if lang not in self.languages else lang]
        return lookup.get(refNode, f&#34;not a {sec0T} node&#34;)

    def _sec0Node(self, name, lang=&#34;en&#34;):
        sec0T = self.sectionTypes[0]
        return self.nodeFromName[&#34;&#34; if lang not in self.languages else lang].get(
            (sec0T, name), None
        )

    def _compileFormats(self):
        api = self.api
        TF = api.TF
        cformats = TF.cformats

        self.formats = {}
        self._tformats = {}
        self._xformats = {}
        self._xdTypes = {}
        for (fmt, (otpl, rtpl, feats)) in sorted(cformats.items()):
            defaultType = self.splitDefaultFormat(fmt)
            if defaultType:
                self.defaultFormats[defaultType] = fmt
            (descendType, rtpl) = self.splitFormat(rtpl)
            (dummy, otpl) = self.splitFormat(otpl)
            tpl = rtpl.replace(&#34;\\n&#34;, &#34;\n&#34;).replace(&#34;\\t&#34;, &#34;\t&#34;)
            self._xdTypes[fmt] = descendType
            self._xformats[fmt] = self._compileFormat(tpl, feats)
            self.formats[fmt] = descendType
            self._tformats[fmt] = otpl

    def splitFormat(self, tpl):
        api = self.api
        F = api.F
        slotType = F.otype.slotType
        otypes = set(F.otype.all)

        descendType = slotType
        parts = tpl.split(TYPE_FMT_SEP, maxsplit=1)
        if len(parts) == 2 and parts[0] in otypes:
            (descendType, tpl) = parts
        return (descendType, tpl)

    def splitDefaultFormat(self, tpl):
        api = self.api
        F = api.F
        otypes = set(F.otype.all)

        parts = tpl.rsplit(SEP, maxsplit=1)
        return (
            parts[0]
            if len(parts) == 2 and parts[1] == &#34;default&#34; and parts[0] in otypes
            else None
        )

    def _compileFormat(self, rtpl, feats):
        replaceFuncs = []
        for feat in feats:
            (feat, default) = feat
            replaceFuncs.append(self._makeFunc(feat, default))

        def g(n, **kwargs):
            values = tuple(replaceFunc(n) for replaceFunc in replaceFuncs)
            return rtpl.format(*values)

        return g

    def _makeFunc(self, feat, default):
        api = self.api
        Fs = api.Fs
        if len(feat) == 1:
            ft = feat[0]
            fObj = Fs(ft)
            f = fObj.data if fObj else {}
            return lambda n: f.get(n, default)
        elif len(feat) == 2:
            (ft1, ft2) = feat
            f1Obj = Fs(ft1)
            f2Obj = Fs(ft2)
            f1 = f1Obj.data if f1Obj else {}
            f2 = f2Obj.data if f2Obj else {}
            return lambda n: (f1.get(n, f2.get(n, default)))
        else:

            def _getVal(n):
                v = None
                for ft in feat:
                    fObj = Fs(ft)
                    f = fObj.data if fObj else {}
                    v = f.get(n, None)
                    if v is not None:
                        break
                return v or default

            return _getVal</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tf.core.text.Text"><code class="flex name class">
<span>class <span class="ident">Text</span></span>
<span>(</span><span>api)</span>
</code></dt>
<dd>
<div class="desc"><p>Low level text representation, including section headings.</p>
<p>In addition to the methods that are directly defined, there are also
methods <code>xxxName()</code> and <code>xxxNode()</code> where <code>xxx</code> is whatever the node type of
level 1 sections is.</p>
<div class="admonition note">
<p class="admonition-title">level 1 node types</p>
<p>In the BHSA the <code>xxx</code> is <code>book</code>, in the DSS it is <code>scroll</code>,
in Old Babylonian it is <code>document</code>, and in Uruk it is <code>tablet</code>.</p>
<p>Here we take the BHSA as example: <code>bookName()</code> and <code>bookNode()</code></p>
<pre><code>T.bookName(node, lang='en')
T.bookNode(name, lang='en')
</code></pre>
<p>with <code>node:int</code> the node in question, <code>name:str</code> the name in question,
and <code>lang='en'</code> the language of the book name.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-fabric/blob/5ba750f09e755bca220c9fff221c3947f996aa09/tf/core/text.py#L366-L1281" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Text:
    &#34;&#34;&#34;Low level text representation, including section headings.

    In addition to the methods that are directly defined, there are also
    methods `xxxName()` and `xxxNode()` where `xxx` is whatever the node type of
    level 1 sections is.

    !!! note &#34;level 1 node types&#34;
        In the BHSA the `xxx` is `book`, in the DSS it is `scroll`,
        in Old Babylonian it is `document`, and in Uruk it is `tablet`.

        Here we take the BHSA as example: `bookName()` and `bookNode()`

            T.bookName(node, lang=&#39;en&#39;)
            T.bookNode(name, lang=&#39;en&#39;)

        with `node:int` the node in question, `name:str` the name in question,
        and `lang=&#39;en&#39;` the language of the book name.
    &#34;&#34;&#34;

    def __init__(self, api):
        self.api = api
        C = api.C
        Fs = api.Fs
        TF = api.TF
        self.languages = {}
        &#34;&#34;&#34;A dictionary of the languages that are available for book names.
        &#34;&#34;&#34;

        self.nameFromNode = {}
        self.nodeFromName = {}
        config = api.TF.features[OTEXT].metaData if OTEXT in api.TF.features else {}
        self.sectionTypes = TF.sectionTypes
        self.sectionTypeSet = set(TF.sectionTypes)
        self.sectionFeats = TF.sectionFeats
        self.sectionFeatsWithLanguage = getattr(TF, &#34;sectionFeatsWithLanguage&#34;, set())
        self.sectionFeatures = []
        self.sectionFeatureTypes = []
        self.structureTypes = TF.structureTypes
        self.structureFeats = TF.structureFeats
        self.structureTypeSet = set(self.structureTypes)
        self.config = config
        self.defaultFormat = DEFAULT_FORMAT
        self.defaultFormats = {}

        structure = getattr(C, &#34;structure&#34;, None)

        (
            self.hdFromNd,
            self.ndFromHd,
            self.hdMult,
            self.hdTop,
            self.hdUp,
            self.hdDown,
        ) = (
            structure.data if structure else (None, None, None, None, None, None)
        )
        self.headings = (
            ()
            if structure is None
            else tuple(zip(self.structureTypes, self.structureFeats))
        )
        otypeInfo = api.F.otype
        fOtype = otypeInfo.v

        good = True
        if len(self.sectionFeats) != 0 and len(self.sectionTypes) != 0:
            for fName in self.sectionFeatsWithLanguage:
                fObj = api.TF.features[fName]
                meta = fObj.metaData
                code = meta.get(&#34;languageCode&#34;, &#34;&#34;)
                self.languages[code] = {
                    k: meta.get(k, &#34;default&#34;) for k in (&#34;language&#34;, &#34;languageEnglish&#34;)
                }
                cData = Fs(fName).data
                self.nameFromNode[code] = cData
                self.nodeFromName[code] = dict(
                    ((fOtype(node), name), node) for (node, name) in cData.items()
                )
            for fName in self.sectionFeats:
                dataType = api.TF.features[fName].dataType
                self.sectionFeatures.append(api.Fs(fName).data)
                self.sectionFeatureTypes.append(dataType)

            sec0 = self.sectionTypes[0]
            setattr(self, f&#34;{sec0}Name&#34;, self._sec0Name)
            setattr(self, f&#34;{sec0}Node&#34;, self._sec0Node)

        self.formats = {}
        &#34;&#34;&#34;The text representation formats that have been defined in your dataset.
        &#34;&#34;&#34;

        self._compileFormats()
        self.good = good

    def sectionTuple(self, n, lastSlot=False, fillup=False):
        &#34;&#34;&#34;Gives a tuple of nodes that correspond to a section.

        More precisely, we retrieve the sections that contain a
        reference node, which is either the first slot or the last slot of the node
        in question.

        Parameters
        ----------
        n: integer
            The node whose containing section to retrieve.
        lastSlot: boolean, optional False
            Whether the reference node will be the last slot contained by `n`
            or the first slot.
        fillup: boolean, optional False
            Whether to fill up the tuple with missing section elements.
        Returns
        -------
        section: tuple of integer
            If `n` is not a section node, a reference node `r` will be taken
            according to the `lastSlot` parameter.

            If `fillup == False`:

            If `r` is a level 0 section node,
            `section` is the 1-element tuple `(r,)`.

            If `r` is a level 1 section node,
            *section* is a 2-element tuple, i.e.
            the enclosing level 0 section node and `r` itself.

            If `r` is a level 2 section node,
            `section` is a 3-element tuple, i.e.
            the enclosing level 0 and  1 section nodes and `r` itself.

            If `fillup == True`, always a complete 3-tuple of a level 0, 1, and 2
            section nodes is returned.
        &#34;&#34;&#34;

        sTypes = self.sectionTypes
        lsTypes = len(sTypes)
        if lsTypes == 0:
            return ()
        F = self.api.F
        E = self.api.E
        L = self.api.L
        fOtype = F.otype.v
        slotType = F.otype.slotType
        maxSlot = F.otype.maxSlot
        eoslots = E.oslots.data
        nType = fOtype(n)

        if nType == slotType:
            r = n
        else:
            slots = eoslots[n - maxSlot - 1]
            r = slots[-1 if lastSlot else 0]

        if nType == sTypes[0]:
            if fillup:
                r1 = L.u(r, otype=sTypes[1])
                r1 = r1[0] if r1 else &#34;&#34;
                if lsTypes &gt; 2:
                    r2 = L.u(r, otype=sTypes[2])
                    r2 = r2[0] if r2 else &#34;&#34;
                    return (n, r1, r2)
                return (n, r1)
            return (n,)

        r0s = L.u(r, sTypes[0])
        r0 = r0s[0] if r0s else None

        if nType == sTypes[1]:
            if fillup:
                if lsTypes &gt; 2:
                    r2 = L.u(r, otype=sTypes[2])
                    r2 = r2[0] if r2 else &#34;&#34;
                    return (r0, n, r2)
            return (r0, n)

        r1s = L.u(r, sTypes[1])
        r1 = r1s[0] if r1s else &#34;&#34;

        if lsTypes &lt; 3:
            return (r0, r1)

        if nType == sTypes[2]:
            return (r0, r1, n)

        r2s = L.u(r, sTypes[2])
        r2 = r2s[0] if r2s else &#34;&#34;

        return (r0, r1, r2)

    def sectionFromNode(self, n, lastSlot=False, lang=&#34;en&#34;, fillup=False, level=None):
        &#34;&#34;&#34;Gives the full heading of a section node.

        Parameters
        ----------
        n: integer
            The node whose heading to retrieve.
        lastSlot: boolean, optional False
            Whether the reference node will be the last slot contained by `n`
            or the first slot.
        lang: string, optional en
            The language assumed for the section parts,
            as far as they are language dependent.
            Must be a 2-letter language code.
        fillup: boolean, optional False
            Whether to fill up the tuple with missing section elements.
        level: integer, optional None
            If passed, only the first so many members of the tuple will be returned.

        Returns
        -------
        heading: tuple of pairs
            If `n` is not a section node, a reference node `r` will be taken
            according to the `lastSlot` parameter.

            It is the tuple of integer / string values for section ancestors
            of `r` and `r` itself,
            where the `fillup` parameter plays the same role as in
            `Text.sectionTuple`.

        Notes
        -----
        !!! hint &#34;crossing verse boundaries&#34;
            Sometimes a sentence or clause in a verse continue into the next verse.
            In those cases, this function will return different results for
            `lastSlot=False` and `lastSlot=True`.

        Warnings
        --------
        Nodes that lie outside any book, chapter, or verse
        will get a `None` in the corresponding members of the returned tuple.
        &#34;&#34;&#34;
        sTuple = self.sectionTuple(n, lastSlot=lastSlot, fillup=fillup)
        if len(sTuple) == 0:
            return ()

        sFs = self.sectionFeatures

        result = tuple(
            &#34;&#34;
            if n is None
            else self._sec0Name(n, lang=lang)
            if i == 0
            else sFs[i].get(n, None)
            for (i, n) in enumerate(sTuple)
        )
        if level is not None:
            result = result[0:level]

        return result

    def nodeFromSection(self, section, lang=&#34;en&#34;):
        &#34;&#34;&#34;Given a section tuple, return the node of it.

        Parameters
        ----------
        section: string
            `section` consists of a book name (in language `lang`),
            and a chapter number and a verse number
            (both as strings or number depending on the value type of the
            corresponding feature).
        lang: string, optional en
            The language assumed for the section parts,
            as far as they are language dependent.
            Must be a 2-letter language code.

        Returns
        -------
        section node: integer
            If section labels for all three levels is present,
            the result is a level 3 node.
            If the level 3 label has been left out, the result is a level 2 node.
            If both level 1 and level 2 labels have been left out,
            the result is a level 1 node.
        &#34;&#34;&#34;

        sTypes = self.sectionTypes
        if len(sTypes) == 0:
            return None
        cData = self.api.C.sections.data
        sec1 = cData[&#34;sec1&#34;]
        sec2 = cData[&#34;sec2&#34;]
        sec0node = self._sec0Node(section[0], lang=lang)
        if len(section) == 1:
            return sec0node
        elif len(section) == 2:
            return sec1.get(sec0node, {}).get(section[1], None)
        else:
            return sec2.get(sec0node, {}).get(section[1], {}).get(section[2], None)

    def structureInfo(self):
        &#34;&#34;&#34;Gives a summary of how structure has been configured in the dataset.

        If there are headings that are the same for multiple structural nodes,
        you&#39;ll get a warning here, and you are told how you can get all of those.

        It also shows a short description of all structure-related methods
        of the `T` API.
        &#34;&#34;&#34;

        api = self.api
        TF = api.TF
        info = TF.info
        error = TF.error
        hdMult = self.hdMult
        hdFromNd = self.hdFromNd
        headings = self.headings

        if hdFromNd is None:
            info(&#34;No structural elements configured&#34;, tm=False)
            return
        info(&#34;A heading is a tuple of pairs (node type, feature value)&#34;, tm=False)
        info(
            &#34;\tof node types and features that have been configured as structural elements&#34;,
            tm=False,
        )
        info(
            f&#34;These {len(headings)} structural elements have been configured&#34;, tm=False
        )
        for (tp, ft) in headings:
            info(f&#34;\tnode type {tp:&lt;10} with heading feature {ft}&#34;, tm=False)
        info(&#34;You can get them as a tuple with T.headings.&#34;, tm=False)
        info(
            f&#34;&#34;&#34;
Structure API:
\tT.structure(node=None)       gives the structure below node, or everything if node is None
\tT.structurePretty(node=None) prints the structure below node, or everything if node is None
\tT.top()                      gives all top-level nodes
\tT.up(node)                   gives the (immediate) parent node
\tT.down(node)                 gives the (immediate) children nodes
\tT.headingFromNode(node)      gives the heading of a node
\tT.nodeFromHeading(heading)   gives the node of a heading
\tT.ndFromHd                   complete mapping from headings to nodes
\tT.hdFromNd                   complete mapping from nodes to headings
\tT.hdMult are all headings    with their nodes that occur multiple times

There are {len(hdFromNd)} structural elements in the dataset.
&#34;&#34;&#34;,
            tm=False,
        )

        if hdMult:
            nMultiple = len(hdMult)
            tMultiple = sum(len(x) for x in hdMult.values())
            error(
                f&#34;WARNING: {nMultiple} structure headings with hdMult occurrences (total {tMultiple})&#34;,
                tm=False,
            )
            for (sKey, nodes) in sorted(hdMult.items())[0:10]:
                sKeyRep = &#34;-&#34;.join(&#34;:&#34;.join(str(p) for p in part) for part in sKey)
                nNodes = len(nodes)
                error(f&#34;\t{sKeyRep} has {nNodes} occurrences&#34;, tm=False)
                error(f&#39;\t\t{&#34;, &#34;.join(str(n) for n in nodes[0:5])}&#39;, tm=False)
                if nNodes &gt; 5:
                    error(f&#34;\t\tand {nNodes - 5} more&#34;, tm=False)
            if nMultiple &gt; 10:
                error(f&#34;\tand {nMultiple - 10} headings more&#34;)

    def structure(self, node=None):
        &#34;&#34;&#34;Gives the structure of node and everything below it as a tuple.

        Parameters
        ----------
        node: integer, optional None
            The node whose structure is asked for.
            If *node* is None, the complete structure of the whole dataset is returned.

        Returns
        -------
        structure: tuple
            Nested tuple of nodes involved in the structure below a node.
        &#34;&#34;&#34;

        api = self.api
        TF = api.TF
        error = TF.error
        F = api.F
        fOtype = F.otype.v
        hdTop = self.hdTop

        if hdTop is None:
            error(&#34;structure types are not configured&#34;, tm=False)
            return None
        if node is None:
            return tuple(self.structure(node=t) for t in self.top())

        nType = fOtype(node)
        if nType not in self.structureTypeSet:
            error(
                f&#34;{node} is an {nType} which is not configured as a structure type&#34;,
                tm=False,
            )
            return None

        return (node, tuple(self.structure(node=d) for d in self.down(node)))

    def structurePretty(self, node=None, fullHeading=False):
        &#34;&#34;&#34;Gives the structure of node and everything below it as a string.

        Parameters
        ----------
        node: integer, optional None
            The node whose structure is asked for.
            If *node* is None, the complete structure of the whole dataset is returned.
        fullHeading: boolean, optional False
            Normally, for each structural element, only its own subheading is added.
            But if you want to see the full heading, consisting of the headings of a
            node and all of its parents, pass `True` for this parameter.

        Returns
        -------
        structure: string
            Pretty representation as string with indentations of the structure
            below a node.
        &#34;&#34;&#34;

        structure = self.structure(node=node)
        if structure is None:
            return

        material = []

        def generate(struct, indent=&#34;&#34;):
            if type(struct) is int:
                sKey = self.headingFromNode(struct)
                if not fullHeading:
                    sKey = (sKey[-1],)
                sKeyRep = &#34;-&#34;.join(&#34;:&#34;.join(str(p) for p in part) for part in sKey)
                material.append(f&#34;{indent}{sKeyRep}&#34;)
            else:
                for item in struct:
                    generate(item, indent=indent + &#34;  &#34;)

        generate(structure)
        return &#34;\n&#34;.join(material)

    def top(self):
        &#34;&#34;&#34;Gives all top-level structural nodes in the dataset.
        These are the nodes that are not embedded in a structural node of the same
        or a higher level.
        &#34;&#34;&#34;

        api = self.api
        TF = api.TF
        error = TF.error
        hdTop = self.hdTop

        if hdTop is None:
            error(&#34;structure types are not configured&#34;, tm=False)
            return None
        return hdTop

    def up(self, n):
        &#34;&#34;&#34;Gives the parent of a structural node.

        Parameters
        ----------
        n: integer
            The node whose parent to retrieve.

        Returns
        -------
        parent: integer
            The parent is that structural node that whose heading you get from
            the heading of `n` minus its last element.

        Notes
        -----
        !!!hint &#34;Example&#34;
            The parent of `((book, Genesis), (chapter, 3), (verse, 16))`
            is the node that has heading `((book, Genesis), (chapter, 3))`.
        &#34;&#34;&#34;

        api = self.api
        F = api.F
        TF = api.TF
        error = TF.error
        fOtype = F.otype.v

        hdUp = self.hdUp
        if hdUp is None:
            error(&#34;structure types are not configured&#34;, tm=False)
            return None
        nType = fOtype(n)
        if nType not in self.structureTypeSet:
            error(
                f&#34;{n} is an {nType} which is not configured as a structure type&#34;,
                tm=False,
            )
            return None
        return hdUp.get(n, None)

    def down(self, n):
        &#34;&#34;&#34;Gives the children of a structural node.

        Parameters
        ----------
        n: integer
            The node whose children to retrieve.

        Returns
        -------
        children: tuple of integers
            The children are those structural nodes whose headings are one
            longer than the one from `n`.

        Notes
        -----
        !!!hint &#34;Example&#34;
            The children of `((book, Genesis), (chapter, 3))` are the nodes
            with heading `((book, Genesis), (chapter, 3), (verse, 1))`, etc.
        &#34;&#34;&#34;

        api = self.api
        F = api.F
        fOtype = F.otype.v
        TF = api.TF
        error = TF.error
        hdDown = self.hdDown
        if hdDown is None:
            error(&#34;structure types are not configured&#34;, tm=False)
            return None
        nType = fOtype(n)
        if nType not in self.structureTypeSet:
            error(
                f&#34;{n} is an {nType} which is not configured as a structure type&#34;,
                tm=False,
            )
            return None
        return hdDown.get(n, ())

    def headingFromNode(self, n):
        &#34;&#34;&#34;Gives the full heading of a structural node.

        Parameters
        ----------
        n: integer
            The node whose heading to retrieve.

        Returns
        -------
        heading: tuple of pairs
            It is the tuple of pairs (node type, feature value)
            for all ancestors of `n`.

        Notes
        -----
        !!!hint &#34;Example&#34;
            E.g., the heading of the verse node corresponding to Genesis 3:16
            is `((book, Genesis), (chapter, 3), (verse, 16))`.

        !!!hint &#34;Power tip&#34;
            If you are interested in the complete mapping: it is stored in
            the dictionary `hdFromNd`.
        &#34;&#34;&#34;

        api = self.api
        F = api.F
        TF = api.TF
        error = TF.error
        fOtype = F.otype.v
        hdFromNd = self.hdFromNd
        if hdFromNd is None:
            error(&#34;structure types are not configured&#34;, tm=False)
            return None
        nType = fOtype(n)
        if nType not in self.structureTypeSet:
            error(
                f&#34;{n} is an {nType} which is not configured as a structure type&#34;,
                tm=False,
            )
            return None
        return hdFromNd.get(n, None)

    def nodeFromHeading(self, head):
        &#34;&#34;&#34;Gives the node corresponding to a heading, provided it exists.

        Parameters
        ----------
        head: tuple of pairs
            See the result of `headingFromNode`.

        Returns
        -------
        node: integer
            If there is more than one node that corresponds to the heading,
            only the last one in the corpus will be returned.
            `hdMult` contains all such cases.

        Notes
        -----
        !!!hint &#34;Power tip&#34;
            If you are interested in the complete mapping: it is stored in
            the dictionary `ndFromHd`.
        &#34;&#34;&#34;

        api = self.api
        TF = api.TF
        error = TF.error
        ndFromHd = self.ndFromHd
        if ndFromHd is None:
            error(&#34;structure types are not configured&#34;, tm=False)
        n = ndFromHd.get(head, None)
        if n is None:
            error(f&#34;no structure node with heading {head}&#34;, tm=False)
        return n

    def text(self, nodes, fmt=None, descend=None, func=None, explain=False, **kwargs):
        &#34;&#34;&#34;Gives the text that corresponds to a bunch of nodes.

        The
        [banks](https://nbviewer.jupyter.org/github/annotation/banks/blob/master/programs/formats.ipynb)
        example corpus shows examples.

        Parameters
        ----------

        nodes: dict
            *nodes* can be a single node or an arbitrary iterable of nodes
            of arbitrary types.
            No attempt will be made to sort the nodes.
            If you need order, it is better to sort the nodes first.

        fmt: boolean, optional None
            The text-format of the text representation.

            If it is not specified or `None`, each node will be formatted with
            a node type specific format, defined as `nodeType-default`, if it
            exists.

            If there is no node specific format, the default format
            `text-orig-full` will be used.

            If `text-orig-full` is not defined, an error message will be issued,
            and the nodes will be represented by their types and numbers.

            If a value for `fmt` is passed, but it is not a format defined in the
            `otext.tf` feature, there will be an error message and `None` is returned.

        descend: boolean, optional None
            Whether to descend to constituent nodes.

            If `True`, nodes will be replaced by a sequence of their constituent nodes,
            which have a type specified by the format chosen, or, if the format does
            not specify such a type, the node will be replaced
            by the slots contained in it.

            If `False`, nodes will not be replaced.

            If *descend* is not specified or None,
            a node will be replaced by its constituent nodes,
            unless its type is associated with the given format or,
            if no format is given, by the default format of its type, or,
            if there is no such format, by its slots.

            !!! caution &#34;no nodes to descend to&#34;
                If you call `T.text(n, fmt=myfmt)`
                and `myfmt` is targeted to a node type that is
                bigger than the node type of `n`,
                then the so-called descending leads to an empty
                sequence of nodes and hence to an empty string.

        explain: boolean, optional False
            The logic of this function is subtle.
            If you call it and the results baffles you, pass `explain=True`
            and it will explain what it is doing.
        &#34;&#34;&#34;

        api = self.api
        E = api.E
        F = api.F
        L = api.L
        TF = api.TF
        error = TF.error

        fOtype = F.otype.v
        slotType = F.otype.slotType
        maxSlot = F.otype.maxSlot
        eoslots = E.oslots.data

        defaultFormats = self.defaultFormats
        xformats = self._xformats
        xdTypes = self._xdTypes

        if fmt and fmt not in xformats:
            error(f&#39;Undefined format &#34;{fmt}&#34;&#39;, tm=False)
            return &#34;&#34;

        def rescue(n, **kwargs):
            return f&#34;{fOtype(n)}{n}&#34;

        single = type(nodes) is int
        material = []
        good = True

        if single:
            nodes = [nodes]
        else:
            nodes = list(nodes) if explain else nodes
        if explain:
            fmttStr = &#34;format target type&#34;
            ntStr = &#34;node type&#34;

            nRep = &#34;single node&#34; if single else f&#34;iterable of {len(nodes)} nodes&#34;
            fmtRep = &#34;implicit&#34; if not fmt else f&#34;{fmt} targeted at {xdTypes[fmt]}&#34;
            descendRep = (
                &#34;implicit&#34; if descend is None else &#34;True&#34; if descend else &#34;False&#34;
            )
            funcRep = f&#39;{&#34;&#34; if func else &#34;no &#34;}custom format implementation&#39;
            error(
                f&#34;&#34;&#34;
EXPLANATION: T.text() called with parameters:
\tnodes  : {nRep}
\tfmt    : {fmtRep}
\tdescend: {descendRep}
\tfunc   : {funcRep}
&#34;&#34;&#34;,
                tm=False,
            )

        for node in nodes:
            nType = fOtype(node)
            if explain:
                error(f&#34;\tNODE: {nType} {node}&#34;, tm=False)
            if descend:
                if explain:
                    downRep = fmttStr
                if fmt:
                    repf = xformats[fmt]
                    downType = xdTypes[fmt]
                    if explain:
                        fmtRep = f&#34;explicit {fmt} does {repf}&#34;
                        expandRep = f&#34;{downType} {{}} (descend=True) ({downRep})&#34;
                else:
                    repf = xformats[DEFAULT_FORMAT]
                    downType = xdTypes[DEFAULT_FORMAT]
                    if explain:
                        fmtRep = f&#34;implicit {DEFAULT_FORMAT} does {repf}&#34;
                        expandRep = f&#34;{downType} {{}} (descend=True) ({downRep})&#34;
            else:
                downType = nType
                if explain:
                    downRep = ntStr
                if fmt:
                    repf = xformats[fmt]
                    if descend is None:
                        downType = xdTypes[fmt]
                        if explain:
                            downRep = fmttStr
                    if explain:
                        fmtRep = f&#34;explicit {fmt} does {repf}&#34;
                        expandRep = f&#34;{downType} {{}} (descend=None) ({downRep})&#34;
                elif nType in defaultFormats:
                    dfmt = defaultFormats[nType]
                    repf = xformats[dfmt]
                    if descend is None:
                        downType = nType
                        if explain:
                            downRep = fmttStr
                    if explain:
                        fmtRep = f&#34;implicit {dfmt} does {repf}&#34;
                        expandRep = f&#34;{downType} {{}} (descend=None) ({downRep})&#34;
                else:
                    repf = xformats[DEFAULT_FORMAT]
                    if descend is None:
                        downType = xdTypes[DEFAULT_FORMAT]
                        if explain:
                            downRep = fmttStr
                    if explain:
                        fmtRep = f&#34;implicit {DEFAULT_FORMAT} does {repf}&#34;
                        expandRep = f&#34;{downType} {{}} (descend=None) ({downRep})&#34;

            if explain:
                expandRep2 = &#34;&#34;
            if downType == nType:
                if explain:
                    expandRep2 = &#34;(no expansion needed)&#34;
                downType = None

            if explain:
                error(f&#34;\t\tTARGET LEVEL: {expandRep.format(expandRep2)}&#34;, tm=False)

            if explain:
                plural = &#34;s&#34;
            if downType == slotType:
                xnodes = eoslots[node - maxSlot - 1]
            elif downType:
                xnodes = L.d(node, otype=downType)
            else:
                xnodes = [node]
                if explain:
                    plural = &#34;&#34;
            if explain:
                nodeRep = f&#39;{len(xnodes)} {downType or nType}{plural} {&#34;, &#34;.join(str(x) for x in xnodes)}&#39;
                error(f&#34;\t\tEXPANSION: {nodeRep}&#34;, tm=False)

            if func:
                repf = func
                if explain:
                    fmtRep += f&#34; (overridden with the explicit func argument {repf})&#34;
            if not repf:
                repf = rescue
                good = False
                if explain:
                    fmtRep += &#34;\n\t\t\twhich is not defined: formatting as node types and numbers&#34;

            if explain:
                error(f&#34;\t\tFORMATTING: {fmtRep}&#34;, tm=False)
                error(&#34;\t\tMATERIAL:&#34;, tm=False)
            for n in xnodes:
                rep = repf(n, **kwargs)
                material.append(rep)
                if explain:
                    error(f&#39;\t\t\t{fOtype(n)} {n} ADDS &#34;{rep}&#34;&#39;, tm=False)

        if not good:
            error(&#39;Text format &#34;{DEFAULT_FORMAT}&#34; not defined in otext.tf&#39;, tm=False)
        return &#34;&#34;.join(material)

    def _sec0Name(self, n, lang=&#34;en&#34;):
        sec0T = self.sectionTypes[0]
        fOtype = self.api.F.otype.v
        refNode = n if fOtype(n) == sec0T else self.api.L.u(n, sec0T)[0]
        lookup = self.nameFromNode[&#34;&#34; if lang not in self.languages else lang]
        return lookup.get(refNode, f&#34;not a {sec0T} node&#34;)

    def _sec0Node(self, name, lang=&#34;en&#34;):
        sec0T = self.sectionTypes[0]
        return self.nodeFromName[&#34;&#34; if lang not in self.languages else lang].get(
            (sec0T, name), None
        )

    def _compileFormats(self):
        api = self.api
        TF = api.TF
        cformats = TF.cformats

        self.formats = {}
        self._tformats = {}
        self._xformats = {}
        self._xdTypes = {}
        for (fmt, (otpl, rtpl, feats)) in sorted(cformats.items()):
            defaultType = self.splitDefaultFormat(fmt)
            if defaultType:
                self.defaultFormats[defaultType] = fmt
            (descendType, rtpl) = self.splitFormat(rtpl)
            (dummy, otpl) = self.splitFormat(otpl)
            tpl = rtpl.replace(&#34;\\n&#34;, &#34;\n&#34;).replace(&#34;\\t&#34;, &#34;\t&#34;)
            self._xdTypes[fmt] = descendType
            self._xformats[fmt] = self._compileFormat(tpl, feats)
            self.formats[fmt] = descendType
            self._tformats[fmt] = otpl

    def splitFormat(self, tpl):
        api = self.api
        F = api.F
        slotType = F.otype.slotType
        otypes = set(F.otype.all)

        descendType = slotType
        parts = tpl.split(TYPE_FMT_SEP, maxsplit=1)
        if len(parts) == 2 and parts[0] in otypes:
            (descendType, tpl) = parts
        return (descendType, tpl)

    def splitDefaultFormat(self, tpl):
        api = self.api
        F = api.F
        otypes = set(F.otype.all)

        parts = tpl.rsplit(SEP, maxsplit=1)
        return (
            parts[0]
            if len(parts) == 2 and parts[1] == &#34;default&#34; and parts[0] in otypes
            else None
        )

    def _compileFormat(self, rtpl, feats):
        replaceFuncs = []
        for feat in feats:
            (feat, default) = feat
            replaceFuncs.append(self._makeFunc(feat, default))

        def g(n, **kwargs):
            values = tuple(replaceFunc(n) for replaceFunc in replaceFuncs)
            return rtpl.format(*values)

        return g

    def _makeFunc(self, feat, default):
        api = self.api
        Fs = api.Fs
        if len(feat) == 1:
            ft = feat[0]
            fObj = Fs(ft)
            f = fObj.data if fObj else {}
            return lambda n: f.get(n, default)
        elif len(feat) == 2:
            (ft1, ft2) = feat
            f1Obj = Fs(ft1)
            f2Obj = Fs(ft2)
            f1 = f1Obj.data if f1Obj else {}
            f2 = f2Obj.data if f2Obj else {}
            return lambda n: (f1.get(n, f2.get(n, default)))
        else:

            def _getVal(n):
                v = None
                for ft in feat:
                    fObj = Fs(ft)
                    f = fObj.data if fObj else {}
                    v = f.get(n, None)
                    if v is not None:
                        break
                return v or default

            return _getVal</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tf.core.text.Text.formats"><code class="name">var <span class="ident">formats</span></code></dt>
<dd>
<div class="desc"><p>The text representation formats that have been defined in your dataset.</p></div>
</dd>
<dt id="tf.core.text.Text.languages"><code class="name">var <span class="ident">languages</span></code></dt>
<dd>
<div class="desc"><p>A dictionary of the languages that are available for book names.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tf.core.text.Text.down"><code class="name flex">
<span>def <span class="ident">down</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Gives the children of a structural node.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>integer</code></dt>
<dd>The node whose children to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>children</code></strong> :&ensp;<code>tuple</code> of <code>integers</code></dt>
<dd>The children are those structural nodes whose headings are one
longer than the one from <code>n</code>.</dd>
</dl>
<h2 id="notes">Notes</h2>
<div class="admonition hint">
<p class="admonition-title">Example</p>
<p>The children of <code>((book, Genesis), (chapter, 3))</code> are the nodes
with heading <code>((book, Genesis), (chapter, 3), (verse, 1))</code>, etc.</p>
</div></div>
</dd>
<dt id="tf.core.text.Text.headingFromNode"><code class="name flex">
<span>def <span class="ident">headingFromNode</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Gives the full heading of a structural node.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>integer</code></dt>
<dd>The node whose heading to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>heading</code></strong> :&ensp;<code>tuple</code> of <code>pairs</code></dt>
<dd>It is the tuple of pairs (node type, feature value)
for all ancestors of <code>n</code>.</dd>
</dl>
<h2 id="notes">Notes</h2>
<div class="admonition hint">
<p class="admonition-title">Example</p>
<p>E.g., the heading of the verse node corresponding to Genesis 3:16
is <code>((book, Genesis), (chapter, 3), (verse, 16))</code>.</p>
</div>
<div class="admonition hint">
<p class="admonition-title">Power tip</p>
<p>If you are interested in the complete mapping: it is stored in
the dictionary <code>hdFromNd</code>.</p>
</div></div>
</dd>
<dt id="tf.core.text.Text.nodeFromHeading"><code class="name flex">
<span>def <span class="ident">nodeFromHeading</span></span>(<span>self, head)</span>
</code></dt>
<dd>
<div class="desc"><p>Gives the node corresponding to a heading, provided it exists.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>head</code></strong> :&ensp;<code>tuple</code> of <code>pairs</code></dt>
<dd>See the result of <code>headingFromNode</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>integer</code></dt>
<dd>If there is more than one node that corresponds to the heading,
only the last one in the corpus will be returned.
<code>hdMult</code> contains all such cases.</dd>
</dl>
<h2 id="notes">Notes</h2>
<div class="admonition hint">
<p class="admonition-title">Power tip</p>
<p>If you are interested in the complete mapping: it is stored in
the dictionary <code>ndFromHd</code>.</p>
</div></div>
</dd>
<dt id="tf.core.text.Text.nodeFromSection"><code class="name flex">
<span>def <span class="ident">nodeFromSection</span></span>(<span>self, section, lang='en')</span>
</code></dt>
<dd>
<div class="desc"><p>Given a section tuple, return the node of it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>section</code></strong> :&ensp;<code>string</code></dt>
<dd><code>section</code> consists of a book name (in language <code>lang</code>),
and a chapter number and a verse number
(both as strings or number depending on the value type of the
corresponding feature).</dd>
<dt><strong><code>lang</code></strong> :&ensp;<code>string</code>, optional <code>en</code></dt>
<dd>The language assumed for the section parts,
as far as they are language dependent.
Must be a 2-letter language code.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>section node: integer</code></dt>
<dd>If section labels for all three levels is present,
the result is a level 3 node.
If the level 3 label has been left out, the result is a level 2 node.
If both level 1 and level 2 labels have been left out,
the result is a level 1 node.</dd>
</dl></div>
</dd>
<dt id="tf.core.text.Text.sectionFromNode"><code class="name flex">
<span>def <span class="ident">sectionFromNode</span></span>(<span>self, n, lastSlot=False, lang='en', fillup=False, level=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Gives the full heading of a section node.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>integer</code></dt>
<dd>The node whose heading to retrieve.</dd>
<dt><strong><code>lastSlot</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether the reference node will be the last slot contained by <code>n</code>
or the first slot.</dd>
<dt><strong><code>lang</code></strong> :&ensp;<code>string</code>, optional <code>en</code></dt>
<dd>The language assumed for the section parts,
as far as they are language dependent.
Must be a 2-letter language code.</dd>
<dt><strong><code>fillup</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to fill up the tuple with missing section elements.</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>integer</code>, optional <code>None</code></dt>
<dd>If passed, only the first so many members of the tuple will be returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>heading</code></strong> :&ensp;<code>tuple</code> of <code>pairs</code></dt>
<dd>
<p>If <code>n</code> is not a section node, a reference node <code>r</code> will be taken
according to the <code>lastSlot</code> parameter.</p>
<p>It is the tuple of integer / string values for section ancestors
of <code>r</code> and <code>r</code> itself,
where the <code>fillup</code> parameter plays the same role as in
<code><a title="tf.core.text.Text.sectionTuple" href="#tf.core.text.Text.sectionTuple">Text.sectionTuple()</a></code>.</p>
</dd>
</dl>
<h2 id="notes">Notes</h2>
<div class="admonition hint">
<p class="admonition-title">crossing verse boundaries</p>
<p>Sometimes a sentence or clause in a verse continue into the next verse.
In those cases, this function will return different results for
<code>lastSlot=False</code> and <code>lastSlot=True</code>.</p>
</div>
<h2 id="warnings">Warnings</h2>
<p>Nodes that lie outside any book, chapter, or verse
will get a <code>None</code> in the corresponding members of the returned tuple.</p></div>
</dd>
<dt id="tf.core.text.Text.sectionTuple"><code class="name flex">
<span>def <span class="ident">sectionTuple</span></span>(<span>self, n, lastSlot=False, fillup=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Gives a tuple of nodes that correspond to a section.</p>
<p>More precisely, we retrieve the sections that contain a
reference node, which is either the first slot or the last slot of the node
in question.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>integer</code></dt>
<dd>The node whose containing section to retrieve.</dd>
<dt><strong><code>lastSlot</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether the reference node will be the last slot contained by <code>n</code>
or the first slot.</dd>
<dt><strong><code>fillup</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to fill up the tuple with missing section elements.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>section</code></strong> :&ensp;<code>tuple</code> of <code>integer</code></dt>
<dd>
<p>If <code>n</code> is not a section node, a reference node <code>r</code> will be taken
according to the <code>lastSlot</code> parameter.</p>
<p>If <code>fillup == False</code>:</p>
<p>If <code>r</code> is a level 0 section node,
<code>section</code> is the 1-element tuple <code>(r,)</code>.</p>
<p>If <code>r</code> is a level 1 section node,
<em>section</em> is a 2-element tuple, i.e.
the enclosing level 0 section node and <code>r</code> itself.</p>
<p>If <code>r</code> is a level 2 section node,
<code>section</code> is a 3-element tuple, i.e.
the enclosing level 0 and
1 section nodes and <code>r</code> itself.</p>
<p>If <code>fillup == True</code>, always a complete 3-tuple of a level 0, 1, and 2
section nodes is returned.</p>
</dd>
</dl></div>
</dd>
<dt id="tf.core.text.Text.splitDefaultFormat"><code class="name flex">
<span>def <span class="ident">splitDefaultFormat</span></span>(<span>self, tpl)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tf.core.text.Text.splitFormat"><code class="name flex">
<span>def <span class="ident">splitFormat</span></span>(<span>self, tpl)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="tf.core.text.Text.structure"><code class="name flex">
<span>def <span class="ident">structure</span></span>(<span>self, node=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Gives the structure of node and everything below it as a tuple.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>integer</code>, optional <code>None</code></dt>
<dd>The node whose structure is asked for.
If <em>node</em> is None, the complete structure of the whole dataset is returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>structure</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Nested tuple of nodes involved in the structure below a node.</dd>
</dl></div>
</dd>
<dt id="tf.core.text.Text.structureInfo"><code class="name flex">
<span>def <span class="ident">structureInfo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gives a summary of how structure has been configured in the dataset.</p>
<p>If there are headings that are the same for multiple structural nodes,
you'll get a warning here, and you are told how you can get all of those.</p>
<p>It also shows a short description of all structure-related methods
of the <code>T</code> API.</p></div>
</dd>
<dt id="tf.core.text.Text.structurePretty"><code class="name flex">
<span>def <span class="ident">structurePretty</span></span>(<span>self, node=None, fullHeading=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Gives the structure of node and everything below it as a string.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>node</code></strong> :&ensp;<code>integer</code>, optional <code>None</code></dt>
<dd>The node whose structure is asked for.
If <em>node</em> is None, the complete structure of the whole dataset is returned.</dd>
<dt><strong><code>fullHeading</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Normally, for each structural element, only its own subheading is added.
But if you want to see the full heading, consisting of the headings of a
node and all of its parents, pass <code>True</code> for this parameter.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>structure</code></strong> :&ensp;<code>string</code></dt>
<dd>Pretty representation as string with indentations of the structure
below a node.</dd>
</dl></div>
</dd>
<dt id="tf.core.text.Text.text"><code class="name flex">
<span>def <span class="ident">text</span></span>(<span>self, nodes, fmt=None, descend=None, func=None, explain=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Gives the text that corresponds to a bunch of nodes.</p>
<p>The
<a href="https://nbviewer.jupyter.org/github/annotation/banks/blob/master/programs/formats.ipynb">banks</a>
example corpus shows examples.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nodes</code></strong> :&ensp;<code>dict</code></dt>
<dd><em>nodes</em> can be a single node or an arbitrary iterable of nodes
of arbitrary types.
No attempt will be made to sort the nodes.
If you need order, it is better to sort the nodes first.</dd>
<dt><strong><code>fmt</code></strong> :&ensp;<code>boolean</code>, optional <code>None</code></dt>
<dd>
<p>The text-format of the text representation.</p>
<p>If it is not specified or <code>None</code>, each node will be formatted with
a node type specific format, defined as <code>nodeType-default</code>, if it
exists.</p>
<p>If there is no node specific format, the default format
<code>text-orig-full</code> will be used.</p>
<p>If <code>text-orig-full</code> is not defined, an error message will be issued,
and the nodes will be represented by their types and numbers.</p>
<p>If a value for <code>fmt</code> is passed, but it is not a format defined in the
<code>otext.tf</code> feature, there will be an error message and <code>None</code> is returned.</p>
</dd>
<dt><strong><code>descend</code></strong> :&ensp;<code>boolean</code>, optional <code>None</code></dt>
<dd>
<p>Whether to descend to constituent nodes.</p>
<p>If <code>True</code>, nodes will be replaced by a sequence of their constituent nodes,
which have a type specified by the format chosen, or, if the format does
not specify such a type, the node will be replaced
by the slots contained in it.</p>
<p>If <code>False</code>, nodes will not be replaced.</p>
<p>If <em>descend</em> is not specified or None,
a node will be replaced by its constituent nodes,
unless its type is associated with the given format or,
if no format is given, by the default format of its type, or,
if there is no such format, by its slots.</p>
<div class="admonition caution">
<p class="admonition-title">no nodes to descend to</p>
<p>If you call <code>T.text(n, fmt=myfmt)</code>
and <code>myfmt</code> is targeted to a node type that is
bigger than the node type of <code>n</code>,
then the so-called descending leads to an empty
sequence of nodes and hence to an empty string.</p>
</div>
</dd>
<dt><strong><code>explain</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>The logic of this function is subtle.
If you call it and the results baffles you, pass <code>explain=True</code>
and it will explain what it is doing.</dd>
</dl></div>
</dd>
<dt id="tf.core.text.Text.top"><code class="name flex">
<span>def <span class="ident">top</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gives all top-level structural nodes in the dataset.
These are the nodes that are not embedded in a structural node of the same
or a higher level.</p></div>
</dd>
<dt id="tf.core.text.Text.up"><code class="name flex">
<span>def <span class="ident">up</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Gives the parent of a structural node.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n</code></strong> :&ensp;<code>integer</code></dt>
<dd>The node whose parent to retrieve.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>parent</code></strong> :&ensp;<code>integer</code></dt>
<dd>The parent is that structural node that whose heading you get from
the heading of <code>n</code> minus its last element.</dd>
</dl>
<h2 id="notes">Notes</h2>
<div class="admonition hint">
<p class="admonition-title">Example</p>
<p>The parent of <code>((book, Genesis), (chapter, 3), (verse, 16))</code>
is the node that has heading <code>((book, Genesis), (chapter, 3))</code>.</p>
</div></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../tf/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../tf/index.html">tf home</a> -
<a href="../../tf/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-fabric" title="GitHub repo"><img src="../../tf/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#text-api">Text API</a><ul>
<li><a href="#structure">Structure</a></li>
<li><a href="#sections">Sections</a></li>
<li><a href="#book-names-and-languages">Book names and languages</a></li>
<li><a href="#text-representation">Text representation</a><ul>
<li><a href="#the-ttext-function">The T.text() function</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tf.core" href="index.html">tf.core</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tf.core.text.Text" href="#tf.core.text.Text">Text</a></code></h4>
<ul class="two-column">
<li><code><a title="tf.core.text.Text.down" href="#tf.core.text.Text.down">down</a></code></li>
<li><code><a title="tf.core.text.Text.formats" href="#tf.core.text.Text.formats">formats</a></code></li>
<li><code><a title="tf.core.text.Text.headingFromNode" href="#tf.core.text.Text.headingFromNode">headingFromNode</a></code></li>
<li><code><a title="tf.core.text.Text.languages" href="#tf.core.text.Text.languages">languages</a></code></li>
<li><code><a title="tf.core.text.Text.nodeFromHeading" href="#tf.core.text.Text.nodeFromHeading">nodeFromHeading</a></code></li>
<li><code><a title="tf.core.text.Text.nodeFromSection" href="#tf.core.text.Text.nodeFromSection">nodeFromSection</a></code></li>
<li><code><a title="tf.core.text.Text.sectionFromNode" href="#tf.core.text.Text.sectionFromNode">sectionFromNode</a></code></li>
<li><code><a title="tf.core.text.Text.sectionTuple" href="#tf.core.text.Text.sectionTuple">sectionTuple</a></code></li>
<li><code><a title="tf.core.text.Text.splitDefaultFormat" href="#tf.core.text.Text.splitDefaultFormat">splitDefaultFormat</a></code></li>
<li><code><a title="tf.core.text.Text.splitFormat" href="#tf.core.text.Text.splitFormat">splitFormat</a></code></li>
<li><code><a title="tf.core.text.Text.structure" href="#tf.core.text.Text.structure">structure</a></code></li>
<li><code><a title="tf.core.text.Text.structureInfo" href="#tf.core.text.Text.structureInfo">structureInfo</a></code></li>
<li><code><a title="tf.core.text.Text.structurePretty" href="#tf.core.text.Text.structurePretty">structurePretty</a></code></li>
<li><code><a title="tf.core.text.Text.text" href="#tf.core.text.Text.text">text</a></code></li>
<li><code><a title="tf.core.text.Text.top" href="#tf.core.text.Text.top">top</a></code></li>
<li><code><a title="tf.core.text.Text.up" href="#tf.core.text.Text.up">up</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../tf/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
